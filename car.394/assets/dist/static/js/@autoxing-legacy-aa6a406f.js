System.register(["./axios-legacy-4567e38a.js", "./websocket-legacy-74864391.js"], (function (e, t) { "use strict"; var r, n; return { setters: [e => { r = e.r }, e => { n = e.r }], execute: function () { e({ a: function (e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e }, g: function (e) { var t = e.default; if ("function" == typeof t) { var r = function () { return t.apply(this, arguments) }; r.prototype = t.prototype } else r = {}; return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach((function (t) { var n = Object.getOwnPropertyDescriptor(e, t); Object.defineProperty(r, t, n.get ? n : { enumerable: !0, get: function () { return e[t] } }) })), r } }); var t = e("c", "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}), i = e("r", { exports: {} }); !function (e, r) { function i(e) { return e && "object" == typeof e && "default" in e ? e : { default: e } } var o = i(r), s = function (e, t) { return s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]) }, s(e, t) }, a = function () { return a = Object.assign || function (e) { for (var t, r = 1, n = arguments.length; r < n; r++)for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]); return e }, a.apply(this, arguments) }; function c(e, t, r, n) { return new (r || (r = Promise))((function (i, o) { function s(e) { try { c(n.next(e)) } catch (e) { o(e) } } function a(e) { try { c(n.throw(e)) } catch (e) { o(e) } } function c(e) { var t; e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function (e) { e(t) }))).then(s, a) } c((n = n.apply(e, t || [])).next()) })) } function l(e, t) { var r, n, i, o, s = { label: 0, sent: function () { if (1 & i[0]) throw i[1]; return i[1] }, trys: [], ops: [] }; return o = { next: a(0), throw: a(1), return: a(2) }, "function" == typeof Symbol && (o[Symbol.iterator] = function () { return this }), o; function a(o) { return function (a) { return function (o) { if (r) throw new TypeError("Generator is already executing."); for (; s;)try { if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i; switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) { case 0: case 1: i = o; break; case 4: return s.label++, { value: o[1], done: !1 }; case 5: s.label++, n = o[1], o = [0]; continue; case 7: o = s.ops.pop(), s.trys.pop(); continue; default: if (!((i = (i = s.trys).length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) { s = 0; continue } if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) { s.label = o[1]; break } if (6 === o[0] && s.label < i[1]) { s.label = i[1], i = o; break } if (i && s.label < i[2]) { s.label = i[2], s.ops.push(o); break } i[2] && s.ops.pop(), s.trys.pop(); continue }o = t.call(e, s) } catch (e) { o = [6, e], n = 0 } finally { r = i = 0 } if (5 & o[0]) throw o[1]; return { value: o[0] ? o[1] : void 0, done: !0 } }([o, a]) } } } const u = { Success: { errCode: 0, errText: "连接成功。", robotId: "" }, Point_Empty: { errCode: 35e3, errText: "任务点不能为空。", robotId: void 0 }, No_State: { errCode: 35001, errText: "获取状态失败，机器人已离线。", robotId: void 0 }, XY_Is_Not_Number: { errCode: 35002, errText: "（x,y）不是数字。", robotId: void 0 }, No_TaskId: { errCode: 35003, errText: "taskId未找到，请求失败", robotId: void 0 }, Only_Support_WanApp: { errCode: 35004, errText: "SDK仅支持WAP_APP模式", robotId: void 0 }, TaskId_Is_Unavail: { errCode: 35005, errText: "taskId不可用", robotId: void 0 }, Index_Is_Not_Number: { errCode: 35006, errText: "点的索引不是数字", robotId: void 0 }, Update_Value_Is_Error: { errCode: 35007, errText: "更新任务需要包含“isPass”和“stepActs”两个字段", robotId: void 0 }, Api_Is_Error: { errCode: 35008, errText: "Task api错误", robotId: void 0 }, Sys_UnAvailable: { errCode: 35009, errText: "系统异常", robotId: void 0 }, Task_Is_Null: { errCode: 35010, errText: "任务不存在", robotId: void 0 }, Task_AreaId_Is_Null: { errCode: 35011, errText: "任务点没有areaId", robotId: void 0 }, Task_Execute_Failed_By_Network: { errCode: 35012, errText: "任务执行失败，网络异常", robotId: void 0 }, Task_Execute_Failed_By_Not_link: { errCode: 35013, errText: "任务执行失败，当前地图缺少link", robotId: void 0 }, Task_Execute_Failed_By_Lose_Data: { errCode: 35014, errText: "任务执行失败，数据丢失", robotId: void 0 }, Task_Execute_Failed_By_Route_Calculation_Failed: { errCode: 35015, errText: "区域算路失败", robotId: void 0 }, Task_Execute_Failed_By_Cancel_Task_Failed: { errCode: 35016, errText: "取消任务失败", robotId: void 0 }, Task_Execute_Failed_By_ERROR_TASKPT_LESS: { errCode: 35017, errText: "任务执行失败，任务点少于两个", robotId: void 0 }, Task_Execute_Failed_By_Finish_Task_Failed: { errCode: 35018, errText: "结束任务失败", robotId: void 0 }, Task_Execute_Failed_By_Move_Failed: { errCode: 35019, errText: "移动失败", robotId: void 0 }, Task_Is_Error: { errCode: 35020, errText: "获取当前任务失败", robotId: void 0 }, Task_Execute_Failed_By_Cross_layer_charging_pile: { errCode: 35021, errText: "任务执行失败，选择的充电桩不在当前地图内，请在设置内重新选择", robotId: void 0 }, Task_Execute_Failed_By_Cross_layer_stand_by: { errCode: 35022, errText: "任务执行失败，选择的待命点不在当前地图内，请在设置内重新选择", robotId: void 0 }, Task_Execute_Failed_By_Cross_layer_destination: { errCode: 35023, errText: "任务执行失败，选择的目的地不在当前地图内，请选择当前地图内的点", robotId: void 0 }, Task_Execute_Failed_By_Switching_map: { errCode: 35024, errText: "任务执行失败，正在切换地图", robotId: void 0 }, Task_Execute_Failed_By_No_Command_Feedback: { errCode: 35025, errText: "任务执行失败，30s未收到指令反馈", robotId: void 0 }, Task_Create_Failed_By_No_Elevator_Control_Status: { errCode: 35026, errText: "机器人不在线，请检查网络连接", robotId: void 0 }, Task_Create_Failed_By_No_Effective_Elevator: { errCode: 35027, errText: "无可用的电梯!", robotId: void 0 }, Task_Create_Failed_By_No_Bind_Elevator_Control: { errCode: 35028, errText: "创建任务失败，梯控未绑定", robotId: void 0 }, Task_Create_Failed_By_No_Robot_State: { errCode: 35029, errText: "创建任务失败，梯控未绑定", robotId: void 0 }, Task_Create_Failed_By_Get_Task_Point_Failed: { errCode: 35030, errText: "创建任务失败，任务点位缺失，areaId为空或无效", robotId: void 0 }, Task_Create_Failed_RCS_No_Deploy: { errCode: 35031, errText: "RCS系统未部署", robotId: void 0 }, Task_Create_Failed_RCS_Task_Failed: { errCode: 35032, errText: " 创建RCS任务失败", robotId: void 0 }, Task_Create_Failed_Jack_up_Task_Failed: { errCode: 35033, errText: "创建任务失败，机器人处于顶起状态.", robotId: void 0 } }, h = { Business_Execute_Failed_By_Network: { errCode: 35012, errText: "失败，网络异常", robotId: void 0 } }, d = { Success: { errCode: 0, errText: "连接成功", robotId: "" }, No_Onlines: { errCode: 34e3, errText: "无在线机器人", robotId: void 0 }, Wrong_ID: { errCode: 34001, errText: "Robot ID错误", robotId: void 0 }, Is_Offline: { errCode: 34002, errText: "机器人已离线", robotId: void 0 }, No_Available: { errCode: 34003, errText: "无可用机器人", robotId: void 0 }, Sys_UnAvailable: { errCode: 34004, errText: "系统异常", robotId: void 0 }, Ip_UnAvailable: { errCode: 34005, errText: "LAN_APP模式需要Robot IP", robotId: void 0 }, Ws_Timeout: { errCode: 34006, errText: "websocket连接超时，正在重连...", robotId: void 0 }, Network_Timeout: { errCode: 34007, errText: "网络异常，请检查网络状态", robotId: void 0 }, Ws_Message_Not_Received: { errCode: 34008, errText: "ws已连接，但1分钟时间未收到信息上报", robotId: void 0 }, Chassis_Network_Timeout: { errCode: 34009, errText: "检测到和底盘连接断开，请检查网线...", robotId: void 0 }, Robot_Not_Connect: { errCode: 34010, errText: "机器人未连接" } }, p = { Success: { errCode: 0, errText: "初始化成功", robotId: "" }, Init_Error: { errCode: 33e3, errText: "初始化失败，请检查app id和app secret", robotId: void 0 }, AppId_Secret_Null: { errCode: 3e4, errText: "ppId或secret为空" }, Token_401: { errCode: 30401, errText: "登录超时或者当前登录失效，请重新登录！" } }, f = { Get_RobotList_Fail: { errCode: 38e3, errText: "获取机器人列表失败", robotId: void 0 }, Get_RobotDeploy_Fail: { errCode: 38001, errText: "机器人没有部署信息", robotId: void 0 }, Get_Token_Fail: { errCode: 38002, errText: "鉴权失败，请检查网络或参数", robotId: void 0 }, Get_Token_Fail_408: { errCode: 38003, errText: "鉴权失败请检查网络状态", robotId: void 0 }, Get_Token_Fail_404: { errCode: 38004, errText: "鉴权失败，请检查请求的url是否正确", robotId: void 0 }, Get_Token_APPID_NULL: { errCode: 380021, errText: "应用信息为空", robotId: void 0 }, Create_Task_Fail: { errCode: 38005, errText: "创建任务失败，请检查网络或参数", robotId: void 0 }, Create_Task_Fail_408: { errCode: 38006, errText: "创建任务失败请检查网络状态", robotId: void 0 }, Create_Task_Fail_404: { errCode: 38007, errText: "创建任务失败，请检查请求的url是否正确", robotId: void 0 }, Cancel_Task_Fail: { errCode: 38008, errText: "取消任务失败，请检查网络或参数", robotId: void 0 }, Cancel_Task_Fail_408: { errCode: 38009, errText: "取消任务失败，请检查网络状态", robotId: void 0 }, Cancel_Task_Fail_404: { errCode: 38010, errText: "取消任务失败，请检查请求的url是否正确", robotId: void 0 }, Finish_Task_Fail: { errCode: 38011, errText: "结束任务失败，请检查网络或参数", robotId: void 0 }, Finish_Task_Fail_408: { errCode: 38012, errText: "结束任务失败，请检查网络状态", robotId: void 0 }, Finish_Task_Fail_404: { errCode: 38013, errText: "更新任务失败，请检查网络或参数", robotId: void 0 }, Update_Task_Fail: { errCode: 38014, errText: "更新任务失败，请检查网络或参数", robotId: void 0 }, Update_Task_Fail_408: { errCode: 38015, errText: "更新任务失败，请检查网络状态", robotId: void 0 }, Update_Task_Fail_404: { errCode: 38016, errText: "更新任务失败，请检查请求的url是否正确", robotId: void 0 }, Execute_Task_Fail: { errCode: 38017, errText: "执行任务失败，请检查网络或参数", robotId: void 0 }, Execute_Task_Fail_408: { errCode: 38018, errText: "执行任务失败，请检查网络状态", robotId: void 0 }, Execute_Task_Fail_404: { errCode: 38019, errText: "执行任务失败，请检查请求的url是否正确", robotId: void 0 }, Get_State_Fail: { errCode: 38020, errText: "获取任务状态失败，请检查网络或参数", robotId: void 0 }, Get_State_Fail_408: { errCode: 38021, errText: "获取任务状态失败，请检查网络或参数", robotId: void 0 }, Get_State_Fail_404: { errCode: 38022, errText: "获取任务状态失败，请检查请求的url是否正确", robotId: void 0 }, Get_Deploy_Fail: { errCode: 38023, errText: "获取部署信息失败，请检查网络或参数", robotId: void 0 }, Get_Deploy_Fail_408: { errCode: 38024, errText: "获取部署信息失败，请检查网络或参数", robotId: void 0 }, Get_Deploy_Fail_404: { errCode: 38025, errText: "获取部署信息失败，请检查请求的url是否正确", robotId: void 0 }, Get_Cloud_Base_Map_Fail: { errCode: 38026, errText: "获取云端基础底图失败，请检查网络或参数", robotId: void 0 }, Get_Cloud_Base_Map_Fail_408: { errCode: 38027, errText: "获取云端基础底图失败，请检查网络或参数", robotId: void 0 }, Get_Cloud_Base_Map_Fail_404: { errCode: 38028, errText: "获取云端基础底图失败，请检查请求的url是否正确", robotId: void 0 }, Map_Not_Exist: { errCode: 38404, errText: "地图不存在，请检查参数", robotId: void 0 }, Get_Cloud_Features_Fail: { errCode: 38029, errText: "获取地图叠加物失败，请检查网络或参数", robotId: void 0 }, Get_Cloud_Features_Fail_408: { errCode: 38030, errText: "获取地图叠加物失败，请检查网络或参数", robotId: void 0 }, Get_Cloud_Features_Fail_404: { errCode: 38031, errText: "获取地图叠加物失败，请检查请求的url是否正确", robotId: void 0 }, Get_Cloud_Map_Meta_Fail: { errCode: 38032, errText: "获取地图元数据失败，请检查网络或参数", robotId: void 0 }, Get_Cloud_Map_Meta_Fail_408: { errCode: 38033, errText: "获取地图元数据失败，请检查网络或参数", robotId: void 0 }, Get_Cloud_Map_Meta_Fail_404: { errCode: 38034, errText: "获取地图元数据失败，请检查请求的url是否正确", robotId: void 0 }, Search_Area_Fail: { errCode: 38035, errText: "搜索区域失败，请检查网络或参数.", robotId: void 0 }, Search_Area_Fail_408: { errCode: 38036, errText: "搜索区域失败，请检查网络或参数.", robotId: void 0 }, Search_Area_Fail_404: { errCode: 38037, errText: "搜索区域失败，请检查请求的url是否正确", robotId: void 0 }, Get_Area_Picture_Fail: { errCode: 38038, errText: "获取区域图片失败，请检查网络或参数", robotId: void 0 }, Get_Area_Picture_Fail_408: { errCode: 38039, errText: "获取区域图片失败，请检查网络或参数", robotId: void 0 }, Get_Area_Picture_Fail_404: { errCode: 38040, errText: "获取区域图片失败，请检查请求的url是否正确", robotId: void 0 }, Get_Search_Poi_By_Id_Fail: { errCode: 38041, errText: "获取poi详情失败，请检查网络或参数", robotId: void 0 }, Get_Search_Poi_By_Id_Fail_408: { errCode: 38042, errText: "获取poi详情失败，请检查网络或参数", robotId: void 0 }, Get_Search_Poi_By_Id_Fail_404: { errCode: 38043, errText: "获取poi详情失败，请检查请求的url是否正确", robotId: void 0 }, Save_Cruise_Fail: { errCode: 38044, errText: "保存巡游信息失败，请检查网络或参数", robotId: void 0 }, Save_Cruise_Fail_408: { errCode: 38045, errText: "保存巡游信息失败，请检查网络或参数", robotId: void 0 }, Save_Cruise_Fail_404: { errCode: 38046, errText: "保存巡游信息失败，请检查请求的url是否正确", robotId: void 0 }, Get_Cruise_By_businessId_Fail: { errCode: 38047, errText: "获取巡游列表失败，请检查网络或参数", robotId: void 0 }, Get_Cruise_By_businessId_Fail_408: { errCode: 38048, errText: "获取巡游列表失败，请检查网络或参数", robotId: void 0 }, Get_Cruise_By_businessId_Fail_404: { errCode: 38049, errText: "获取巡游列表失败，请检查请求的url是否正确", robotId: void 0 }, Delete_Cruise_By_Id_Fail: { errCode: 38050, errText: "删除巡游信息失败，请检查网络或参数", robotId: void 0 }, Delete_Cruise_By_Id_Fail_408: { errCode: 38051, errText: "删除巡游信息失败，请检查网络或参数", robotId: void 0 }, Delete_Cruise_By_Id_Fail_404: { errCode: 38052, errText: "删除巡游信息失败，请检查请求的url是否正确", robotId: void 0 }, Post_Language_By_Id_Fail: { errCode: 38053, errText: "更新语言信息失败，请检查网络或参数", robotId: void 0 }, Post_Language_By_Id_Fail_408: { errCode: 38054, errText: "更新语言信息失败，请检查网络或参数", robotId: void 0 }, Post_Language_By_Id_Fail_404: { errCode: 38055, errText: "更新语言信息失败，请检查请求的url是否正确", robotId: void 0 }, Get_Wifi_State_Fail: { errCode: 38056, errText: "获取wifi状态信息失败，请检查网络或参数", robotId: void 0 }, Get_Wifi_State_Fail_408: { errCode: 38057, errText: "获取wifi状态信息失败，请检查网络或参数", robotId: void 0 }, Get_Wifi_State_Fail_404: { errCode: 38058, errText: "获取wifi状态信息失败，请检查请求的url是否正确", robotId: void 0 }, Get_Statis_Total_Fail: { errCode: 38059, errText: "获取机器人相关统计总数据失败，请检查网络或参数", robotId: void 0 }, Get_Statis_Total_Fail_408: { errCode: 38060, errText: "获取机器人相关统计总数据失败，请检查网络或参数", robotId: void 0 }, Get_Statis_Total_Fail_404: { errCode: 38061, errText: "获取机器人相关统计总数据失败，请检查请求的url是否正确", robotId: void 0 }, Get_Single_Task_Statis_Fail: { errCode: 38062, errText: "获取任务相关统计总数据失败，请检查网络或参数", robotId: void 0 }, Get_Single_Task_Statis_Fail_408: { errCode: 38063, errText: "获取任务相关统计总数据失败，请检查网络或参数", robotId: void 0 }, Get_Single_Task_Statis_Fail_404: { errCode: 38064, errText: "获取任务相关统计总数据失败，请检查请求的url是否正确", robotId: void 0 }, Get_Task_Statis_Fail: { errCode: 38065, errText: "获取任务相关统计总数据失败，请检查网络或参数", robotId: void 0 }, Get_Task_Statis_Fail_408: { errCode: 38066, errText: "获取任务相关统计总数据失败，请检查网络或参数", robotId: void 0 }, Get_Task_Statis_Fail_404: { errCode: 38067, errText: "获取任务相关统计总数据失败，请检查请求的url是否正确", robotId: void 0 }, Get_Area_By_Id_Fail: { errCode: 38068, errText: "根据id获取区域信息失败，请检查网络或参数", robotId: void 0 }, Get_Area_By_Id_Fail_408: { errCode: 38069, errText: "根据id获取区域信息失败，请检查网络或参数", robotId: void 0 }, Get_Area_By_Id_Fail_404: { errCode: 38070, errText: "根据id获取区域信息失败，请检查请求的url是否正确", robotId: void 0 }, Get_Area_Compare_List_Fail: { errCode: 38071, errText: "获取云端和本地区域对比列表失败，请检查网络或参数", robotId: void 0 }, Get_Area_Compare_List_Fail_408: { errCode: 38072, errText: "获取云端和本地区域对比列表失败，请检查网络或参数", robotId: void 0 }, Get_Area_Compare_List_Fail_404: { errCode: 38073, errText: "获取云端和本地区域对比列表失败，请检查请求的url是否正确", robotId: void 0 }, Get_Area_Features_Fail: { errCode: 38074, errText: "获取区域下所有feature失败，请检查网络或参数", robotId: void 0 }, Get_Area_Features_Fail_408: { errCode: 38075, errText: "获取区域下所有feature失败，请检查网络或参数", robotId: void 0 }, Get_Area_Features_Fail_404: { errCode: 38076, errText: "获取区域下所有feature失败，请检查请求的url是否正确", robotId: void 0 }, Get_Area_Thumbnail_Fail: { errCode: 38077, errText: "获取区域缩略图失败，请检查网络或参数", robotId: void 0 }, Get_Area_Thumbnail_Fail_408: { errCode: 38078, errText: "获取区域缩略图失败，请检查网络或参数", robotId: void 0 }, Get_Area_Thumbnail_Fail_404: { errCode: 38079, errText: "获取区域缩略图失败，请检查请求的url是否正确", robotId: void 0 }, Get_Area_Medium_Thumbnail_Fail: { errCode: 38080, errText: "获取区域缩略图失败，请检查网络或参数", robotId: void 0 }, Get_Area_Medium_Thumbnail_Fail_408: { errCode: 38081, errText: "获取区域缩略图失败，请检查网络或参数", robotId: void 0 }, Get_Area_Medium_Thumbnail_Fail_404: { errCode: 38082, errText: "获取区域缩略图失败，请检查请求的url是否正确", robotId: void 0 }, Add_Time_Task_Fail: { errCode: 38083, errText: "添加定时任务失败，请检查网络或参数", robotId: void 0 }, Add_Time_Task_Fail_408: { errCode: 38084, errText: "添加定时任务失败，请检查网络或参数", robotId: void 0 }, Add_Time_Task_Fail_404: { errCode: 38085, errText: "添加定时任务失败，请检查请求的url是否正确", robotId: void 0 }, Get_Time_Task_List_Fail: { errCode: 38086, errText: "获取定时任务失败，请检查网络或参数", robotId: void 0 }, Get_Time_Task_List_Fail_408: { errCode: 38087, errText: "获取定时任务失败，请检查网络或参数", robotId: void 0 }, Get_Time_Task_List_Fail_404: { errCode: 38088, errText: "获取定时任务失败，请检查请求的url是否正确", robotId: void 0 }, Delete_Time_Task_Fail: { errCode: 38089, errText: "删除定时任务失败，请检查网络或参数", robotId: void 0 }, Delete_Time_Task_Fail_408: { errCode: 38090, errText: "删除定时任务失败，请检查网络或参数", robotId: void 0 }, Delete_Time_Task_Fail_404: { errCode: 38091, errText: "删除定时任务失败，请检查请求的url是否正确", robotId: void 0 }, Get_Point_Cloud_Data_Fail: { errCode: 38092, errText: "获取点云数据失败，请检查网络或参数", robotId: void 0 }, Get_Point_Cloud_Data_Fail_408: { errCode: 38093, errText: "获取点云数据失败，请检查网络或参数", robotId: void 0 }, Get_Point_Cloud_Data_Fail_404: { errCode: 38094, errText: "获取点云数据失败，请检查请求的url是否正确", robotId: void 0 }, Save_Robot_Setting_Data_Fail: { errCode: 38095, errText: "保存机器人设置失败，请检查网络或参数", robotId: void 0 }, Save_Robot_Setting_Data_404: { errCode: 38096, errText: "保存机器人设置失败，请检查请求的url是否正确", robotId: void 0 }, Get_Robot_Setting_Data_Fail: { errCode: 38097, errText: "获取机器人设置失败，请检查网络或参数", robotId: void 0 }, Get_Robot_Setting_Data_404: { errCode: 38098, errText: "获取机器人设置失败，请检查请求的url是否正确", robotId: void 0 }, Get_Task_List_Fail: { errCode: 38086, errText: "获取任务列表失败，请检查网络或参数", robotId: void 0 }, Get_Task_List_Fail_408: { errCode: 38087, errText: "获取任务列表失败，请检查网络或参数", robotId: void 0 }, Get_Task_List_Fail_404: { errCode: 38088, errText: "获取任务列表失败，请检查请求的url是否正确", robotId: void 0 }, Get_Task_Detail_Fail: { errCode: 38086, errText: "获取任务详情失败，请检查网络或参数", robotId: void 0 }, Get_Log_Data_Params_Fail: { errCode: 38086, errText: "获取日志参数数据失败，请检查网络或参数", robotId: void 0 }, Get_Robot_Rack_Size_Fail: { errCode: 38099, errText: "获取点机器货架尺寸数据失败，请检查网络或参数", robotId: void 0 }, Get_Robot_Rack_Size_404: { errCode: 38100, errText: "获取点机器货架尺寸数据失败，请检查请求的url是否正确", robotId: void 0 }, set_serial_port_light_Fail: { errCode: 38101, errText: "获取点机器货架尺寸数据失败，请检查网络或参数", robotId: void 0 }, set_serial_port_light_404: { errCode: 38102, errText: "设置串口灯数据失败，请检查请求的url是否正确", robotId: void 0 }, Network_Error: { errCode: -1, errText: "网络异常，请检查网络" }, Get_Bind_Edge_Intelligence_Fail: { errCode: 38103, errText: "获场端智能设备失败，请检查网络或参数", robotId: void 0 }, Get_Bind_Edge_Intelligence_404: { errCode: 38104, errText: "获场端智能设备失败，请检查请求的url是否正确", robotId: void 0 }, Set_RCS_Active_Fail: { errCode: 38201, errText: "设置机器人RCS禁用状态失败，请检查网络或参数", robotId: void 0 }, Set_RCS_Active_404: { errCode: 38202, errText: "设置机器人RCS禁用状态失败，请检查请求的url是否正确", robotId: void 0 }, Get_RCS_Path_Fail: { errCode: 38203, errText: "获取RCS区对区路线失败，请检查网络或参数", robotId: void 0 }, Get_RCS_Path_404: { errCode: 38204, errText: "获取RCS区对区路线失败，请检查请求的url是否正确", robotId: void 0 }, Add_RCS_Area_Task_Fail: { errCode: 38205, errText: "发起RCS区对区任务失败，请检查网络或参数", robotId: void 0 }, Add_RCS_Area_Task_404: { errCode: 38206, errText: "发起RCS区对区任务失败，请检查请求的url是否正确", robotId: void 0 }, Get_Group_List_Fail: { errCode: 381101, errText: "获取分组列表失败，请检查网络或参数" }, Get_Group_List_404: { errCode: 381102, errText: "获取分组列表失败，请检查请求的url是否正确" }, Add_Group_Fail: { errCode: 381103, errText: "添加分组失败，请检查网络或参数" }, Add_Group_404: { errCode: 381104, errText: "添加分组失败，请检查请求的url是否正确" }, Edit_Group_Fail: { errCode: 381105, errText: "编辑分组失败，请检查网络或参数" }, Edit_Group_404: { errCode: 381106, errText: "编辑分组失败，请检查请求的url是否正确" }, Del_Group_Fail: { errCode: 381107, errText: "删除分组失败，请检查网络或参数" }, Del_Group_404: { errCode: 381108, errText: "删除分组失败，请检查请求的url是否正确" }, Get_Group_Detail_Fail: { errCode: 381109, errText: "获取分组详情失败，请检查网络或参数" }, Get_Group_Detail_404: { errCode: 381110, errText: "获取分组详情失败，请检查请求的url是否正确" }, Get_Group_Task_List_Fail: { errCode: 381111, errText: "获取分组任务列表失败，请检查网络或参数" }, Get_Group_Task_List_404: { errCode: 381112, errText: "获取分组任务列表失败，请检查请求的url是否正确" }, Add_Group_Task_Fail: { errCode: 381113, errText: "添加分组任务失败，请检查网络或参数" }, Add_Group_Task_404: { errCode: 381114, errText: "添加分组任务失败，请检查请求的url是否正确" }, Del_Group_Task_Fail: { errCode: 381115, errText: "删除分组任务失败，请检查网络或参数" }, Del_Group_Task_404: { errCode: 381116, errText: "删除分组任务失败，请检查请求的url是否正确" }, Edit_Group_Task_Fail: { errCode: 381117, errText: "编辑分组任务失败，请检查网络或参数" }, Edit_Group_Task_404: { errCode: 381118, errText: "编辑分组任务失败，请检查请求的url是否正确" }, Get_Group_Task_Detail_Fail: { errCode: 381119, errText: "获取分组任务详情失败，请检查网络或参数" }, Get_Group_Task_Detail_404: { errCode: 38120, errText: "获取分组任务详情失败，请检查请求的url是否正确" }, Del_Group_Fail_bound: { errCode: 38121, errText: "删除分组失败，分组已绑定任务！" }, Add_Group_Fail_NameExit: { errCode: 38122, errText: "添加分组失败，分组名称已存在！" }, Add_Group_Task_Fail_NameExit: { errCode: 38123, errText: "添加分组失败，分组任务名称已存在！" } }, m = { Success: { errCode: 0, errText: "初始化地图成功", robotId: "" }, Init_Error: { errCode: 36e3, errText: "初始化地图失败，请检查container是否存在", robotId: void 0 }, Un_Init_Error: { errCode: 36001, errText: "未初始化地图", robotId: void 0 } }, g = { Update_Map_Error: { errCode: 37e3, errText: "更新地图失败，请检查网络或参数", robotId: void 0 }, Go_Home_Error: { errCode: 37001, errText: "回桩失败，请检查网络或参数", robotId: void 0 }, Motion_For_Error: { errCode: 37002, errText: "运动控制失败，请检查网络或参数", robotId: void 0 }, Update_Map_Failed_By_Updating: { errCode: 37003, errText: "更新地图失败, 已有更新操作", robotId: void 0 }, Update_Map_Failed_By_Tasking: { errCode: 37004, errText: "更新地图失败, 任务中不允许更新", robotId: void 0 }, Update_Map_Failed_By_Mapping: { errCode: 37005, errText: "新地图失败, 建图中不允许更新", robotId: void 0 }, Update_Map_Failed_By_Timeout: { errCode: 37006, errText: "更新地图失败, 更新地图超时", robotId: void 0 }, Update_CMD_By_Timeout: { errCode: 37006, errText: "指令发送超时", robotId: void 0 } }, _ = { Param_type_is_number: { errCode: 39e3, errText: "参数要求为数字" }, Param_type_is_string: { errCode: 39001, errText: "参数要求为字符串" }, Param_type_is_object: { errCode: 39002, errText: "参数要求为对象" }, Param_type_is_null: { errCode: 39003, errText: "参数不能为空" } }, y = { Add_Queue_Task_404: { errCode: 31e3, errText: "添加任务失败，请检查请求的url是否正确" }, Add_Queue_Task_Fail: { errCode: 31001, errText: "添加任务失败，请检查网络或参数" }, Get_Queue_Task_List_Data_404: { errCode: 31002, errText: "获取任务记录列表失败，请检查请求的url是否正确" }, Get_Queue_Task_List_Data_Fail: { errCode: 31003, errText: "获取任务记录列表失败，请检查网络或参数" }, Get_Task_Queue_404: { errCode: 31004, errText: "获取指定业务的任务队列（等待分配的任务)失败，请检查请求的url是否正确" }, Get_Task_Queue_Fail: { errCode: 31005, errText: "获取指定业务的任务队列（等待分配的任务)失败，请检查网络或参数" }, Get_Task_Queue_Robot_404: { errCode: 31006, errText: "获取指定机器人的专属任务队列失败，请检查请求的url是否正确" }, Get_Task_Queue_Robot_Fail: { errCode: 31007, errText: "获取指定机器人的专属任务队列失败，请检查网络或参数" }, Set_Task_Order_404: { errCode: 31006, errText: "设置单个任务在队列中的顺序失败，请检查请求的url是否正确" }, Set_Task_Order_Fail: { errCode: 31007, errText: "设置单个任务在队列中的顺序失败，请检查网络或参数" }, Pause_Queue_404: { errCode: 31008, errText: "暂停指定队列分配任务失败，请检查请求的url是否正确" }, Pause_Queue_Fail: { errCode: 31009, errText: "暂停指定队列分配任务失败，请检查网络或参数" }, Continue_Queue_404: { errCode: 31010, errText: "继续任务列表分配任务失败，请检查请求的url是否正确" }, Continue_Queue_Fail: { errCode: 31011, errText: "继续任务列表分配任务失败，请检查网络或参数" }, Set_Queue_Order_404: { errCode: 31012, errText: "设置整个任务队列排序失败，请检查请求的url是否正确" }, Set_Queue_Order_Fail: { errCode: 31013, errText: "设置整个任务队列排序失败，请检查网络或参数" }, Delete_Queue_Task_404: { errCode: 31014, errText: "删除指定任务失败，请检查请求的url是否正确" }, Delete_Queue_Task_Fail: { errCode: 31015, errText: "删除指定任务失败，请检查网络或参数" }, Get_Queue_Task_Detail_404: { errCode: 31016, errText: "获取任务详情失败，请检查请求的url是否正确" }, Get_Queue_Task_Detail_Fail: { errCode: 31017, errText: "获取任务详情失败，请检查网络或参数" }, Cancel_All_Queue_404: { errCode: 31018, errText: "取消多有队列任务失败，请检查请求的url是否正确" }, Cancel_All_Queue_Fail: { errCode: 31019, errText: "取消多有队列任务失败，请检查网络或参数" } }, v = { Add_Custom_Task_404: { errCode: 32e3, errText: "添加任务失败，请检查请求的url是否正确" }, Add_Custom_Task_Fail: { errCode: 32001, errText: "添加任务失败，请检查网络或参数" }, Edit_Custom_Task_404: { errCode: 32006, errText: "编辑任务失败，请检查请求的url是否正确" }, Edit_Custom_Task_Fail: { errCode: 32007, errText: "编辑任务失败，请检查网络或参数" }, Get_Custom_Task_List_Data_404: { errCode: 32002, errText: "获取任务列表失败，请检查请求的url是否正确" }, Get_Custom_Task_List_Data_Fail: { errCode: 32003, errText: "获取任务列表失败，请检查网络或参数" }, Get_Custom_Task_404: { errCode: 32004, errText: "获取任务详情失败，请检查请求的url是否正确" }, Get_Custom_Task_Fail: { errCode: 32005, errText: "获取任务详情失败，请检查网络或参数" }, Delete_Custom_Task_404: { errCode: 32014, errText: "删除指定任务失败，请检查请求的url是否正确" }, Delete_Custom_Task_Fail: { errCode: 32015, errText: "删除指定任务失败，请检查网络或参数" } }, x = { DB_Error: { errCode: -1, errText: "数据库错误" }, DB_Add_Error: { errCode: 39100, errText: "数据添加失败" }, DB_Update_Error: { errCode: 39101, errText: "数据更新失败" }, DB_Delete_Error: { errCode: 39102, errText: "数据删除失败" }, DB_Get_Error: { errCode: 39103, errText: "数据获取失败" } }, b = { Map_UpDate_Failed: { errCode: 37100, errText: "地图更新失败" }, Map_UpDate_Conflict_Failed: { errCode: 37101, errText: "地图更新失败 - 地图冲突检测失败" }, Map_UpDate_Conflict_Timeout: { errCode: 37102, errText: "地图更新失败 - 地图冲突检测超时" }, 1405: { errCode: 37105, errText: "地图更新失败 - 下载地图失败" }, 1406: { errCode: 37106, errText: "地图更新失败 - 更新地图失败" } }, w = { Mode_Error: { errCode: 38220, errText: "当前连接不是离线模式，统计该统计数据查询" }, Sever_Error: { errCode: 38221, errText: "服务异常" }, Search_Overview_Fail: { errCode: 38210, errText: "获取概览统计数据失败" }, Search_Overview_404: { errCode: 38211, errText: "获取概览统计数据失败，请检查参数是否正确" }, Search_Tasks_Fail: { errCode: 38212, errText: "获取任务列表失败" }, Search_Tasks_404: { errCode: 38213, errText: "获取任务列表失败，请检查参数是否正确" }, Search_Hourly_Robot_Fail: { errCode: 38214, errText: "获取小时维度的车辆统计信息失败" }, Search_Hourly_Robot_404: { errCode: 38215, errText: "获取小时维度的车辆统计信息失败，请检查参数是否正确" }, Search_HourlyTasks_Fail: { errCode: 38216, errText: "获取小时维度的任务数据失败" }, Search_HourlyTasks_404: { errCode: 38217, errText: "获取小时维度的任务数据失败，请检查参数是否正确" }, Search_TaskCountByDay_Fail: { errCode: 38218, errText: "获取任务统计数据失败" }, Search_TaskCountByDay_404: { errCode: 38219, errText: "获取任务统计数据失败，请检查参数是否正确" } }, T = { 80400: "算路失败 - 不可到达", 80401: "算路失败 - 禁行点位", 80402: "算路失败 - 指定车辆不存在", 80403: "车辆不支持当前任务类型", 80404: "不存在的资源(点位、路线等)", 80405: "车辆当前位置节点为空", 80406: "区域内无停靠点", 80407: "区域无效停靠点" }, k = { 1: "其他原因", 2: "获取地图失败（WorldMap）", 3: "起点在地图之外", 4: "终点在地图之外", 5: "起点不在地图可通行区域", 6: "终点不在地图可通行区域", 7: "起点和终点相同", 8: "计算全局路线扩展信息失败", 9: "道路不连通", 10: "算路超时", 11: "没有全局路线", 12: "在全局路线上抓取起点失败", 13: "在全局路线上抓取终点失败", 14: "路径规划长时间不成功", 15: "路径规划成功，但避让长时间过不去", 16: "局部避障地图数据出现错误，当前避障传感器数据异常", 500: "无效的货架检测点", 501: "未识别到货架", 502: "超过对接重试次数", 503: "货架位置被别的机器人占用", 504: "无法到达卸货点", 505: "货架发生明显滑动", 506: "顶升处于升起状态", 507: "无效的货架区域 ID", 508: "货架区域里没有货架", 510: "当前区域未识别到货架，请确认后重试", 511: "货架区域里有货架，但对接失败", 512: "货架区域里货架位都被占用", 513: "货架区域里有空闲货架位，但放货失败", 1001: "planning 节点未运行", 1002: "occupancy_grid_server 节点未运行", 1003: "map_server 节点未运行", 1004: "cartographer_occupancy_grid_node 节点未运行", 1005: "超过1s没有避障图 /maps/5cm 消息", 1008: "机器人卡住，请检查是否有障碍物", 1012: "检测前方坠落风险，纠正机器人位置或绘制必要的虚拟墙", 2002: "请检查轮子是否有异物缠绕导致过载，检查后请点击继续任务按钮", 2006: "轮子过载", 2008: "检测到机器人轮子打滑，检查后请点击继续任务按钮", 3001: "odom 节点未运行", 3002: "odom 消息频率异常", 4001: "imu 节点未运行", 4002: "imu 消息频率异常", 4003: "imu 角速度异常", 4008: "检测到机器人倾倒，请手动清除故障码", 5001: "lidar 节点未运行", 5002: "激光雷达信息频率异常", 5007: "点云为空数据", 5008: "激光雷达在图示位置被异物遮挡，请检查并清理异物", 6010: "检测到系统异常关机", 7002: "位姿信息极不可靠", 7004: "位姿信息不可靠", 8004: "电池通讯断开，读取电量失败", 20020: "底盘链接断开", 12005: "检测到货架偏移，请摆正货架后重试，或再次执行举放动作", 20009: "自动门、闸机异常", 20012: "没有可用的电梯", 20015: "顶起超时，重试中…", 20021: "电梯被占用，正在重新预约电梯...", 20022: "电梯被占用，正在重新预约电梯...", 35021: "任务执行失败，选择的充电桩不在当前地图内 <br>请在设置内重新选择", 35022: "任务执行失败，选择的待命点不在当前地图内 <br>请在设置内重新选择", 35023: "任务执行失败，选择的目的地不在当前地图内 <br>请选择当前地图内的点", 51e3: "区域无link,无法按最短距离算路", 51001: "地图数据不完整(缺少侯梯点，连接点，电梯点位)，区域不连通", 51002: "区域算路失败，一般link不连通导致", 51003: "任务点数量太少，无法算路(循环任务任务点少于2个，非循环任务任务点少于1个)", 51004: "充电桩跨层", 51005: "待命点跨层", 51006: "目的地跨层", 51007: "跨层任务获取在线电梯失败", 51008: "跨层任务没有在线电梯", 51009: "跨层任务在线电梯被其他机器人占用", 51010: "其他错误", 51011: "任务点位缺失", 51012: "返航点位缺失", 51013: "巡游路线缺失", 51014: "机器人位置丢失", 51015: "任务指令创建失败", 51016: "取消任务", 51017: "在充电中，定时回桩执行失败", 51018: "急停模式，不执行任务", 51019: "手动模式，不执行任务", 51020: "远控模式，不执行任务", 51021: "建图模式，不执行任务", 51022: "未获取到机器人状态，不执行任务", 51023: "电量低于15%，不执行任务", 51024: "底盘未设置地图，不执行任务", 51032: "在充电中，定时回桩执行失败" }, C = { Success: { errCode: 0, errText: "Connection success.", robotId: "" }, Point_Empty: { errCode: 35e3, errText: "Task point can not be void.", robotId: void 0 }, No_State: { errCode: 35001, errText: "Robot offline, failed to obtain robot state.", robotId: void 0 }, XY_Is_Not_Number: { errCode: 35002, errText: "Point (x,y) is not numeric.", robotId: void 0 }, No_TaskId: { errCode: 35003, errText: "Task ID unfounded, request failed.", robotId: void 0 }, Only_Support_WanApp: { errCode: 35004, errText: "SDK only support WAP_APP mode.", robotId: void 0 }, TaskId_Is_Unavail: { errCode: 35005, errText: "Task ID unavailable.", robotId: void 0 }, Index_Is_Not_Number: { errCode: 35006, errText: "The point index is not numeric.", robotId: void 0 }, Update_Value_Is_Error: { errCode: 35007, errText: "Task update must include isPass and stepActs fields.", robotId: void 0 }, Api_Is_Error: { errCode: 35008, errText: "Task api error.", robotId: void 0 }, Sys_UnAvailable: { errCode: 35009, errText: "System error.", robotId: void 0 }, Task_Is_Null: { errCode: 35010, errText: "Task does not exist.", robotId: void 0 }, Task_AreaId_Is_Null: { errCode: 35011, errText: "Task point has no area ID.", robotId: void 0 }, Task_Execute_Failed_By_Network: { errCode: 35012, errText: "Task failed, network error.", robotId: void 0 }, Task_Execute_Failed_By_Not_link: { errCode: 35013, errText: "Task failed, map link absent.", robotId: void 0 }, Task_Execute_Failed_By_Lose_Data: { errCode: 35014, errText: "Task failed, data lost.", robotId: void 0 }, Task_Execute_Failed_By_Route_Calculation_Failed: { errCode: 35015, errText: "Route failed.", robotId: void 0 }, Task_Execute_Failed_By_Cancel_Task_Failed: { errCode: 35016, errText: "Task cancelling failed.", robotId: void 0 }, Task_Execute_Failed_By_ERROR_TASKPT_LESS: { errCode: 35017, errText: "Task failed, task point is less than 2.", robotId: void 0 }, Task_Execute_Failed_By_Finish_Task_Failed: { errCode: 35018, errText: "End task failed.", robotId: void 0 }, Task_Execute_Failed_By_Move_Failed: { errCode: 35019, errText: "Movement failed.", robotId: void 0 }, Task_Is_Error: { errCode: 35020, errText: "Failed to get current task.", robotId: void 0 }, Task_Execute_Failed_By_Cross_layer_charging_pile: { errCode: 35021, errText: "Task failed, charging pile is not in the current map, please select again in the Settings.", robotId: void 0 }, Task_Execute_Failed_By_Cross_layer_stand_by: { errCode: 35022, errText: "Task failed, standby point is not in the current map, please select again in the Settings.", robotId: void 0 }, Task_Execute_Failed_By_Cross_layer_destination: { errCode: 35023, errText: "Task failed.  destination is not in the current map. please select again.", robotId: void 0 }, Task_Execute_Failed_By_Switching_map: { errCode: 35024, errText: "Task failed. Chassis is switching maps.", robotId: void 0 }, Task_Execute_Failed_By_No_Command_Feedback: { errCode: 35025, errText: "Task failed. No command feedback received for 30 seconds.", robotId: void 0 }, Task_Create_Failed_By_No_Elevator_Control_Status: { errCode: 35026, errText: "The robot is not online, please check the network connection.", robotId: void 0 }, Task_Create_Failed_By_No_Effective_Elevator: { errCode: 35027, errText: "No elevator available  ", robotId: void 0 }, Task_Create_Failed_By_No_Bind_Elevator_Control: { errCode: 35028, errText: "Elevator not bound, task creation failed.", robotId: void 0 }, Task_Create_Failed_By_No_Robot_State: { errCode: 35029, errText: "Failed to get robot status.", robotId: void 0 }, Task_Create_Failed_By_Get_Task_Point_Failed: { errCode: 35030, errText: "Missing task waypoints, areaId is empty or invalid.", robotId: void 0 }, Task_Create_Failed_RCS_No_Deploy: { errCode: 35031, errText: "RCS system not deployed.", robotId: void 0 }, Task_Create_Failed_RCS_Task_Failed: { errCode: 35032, errText: "Failed to create RCS task.", robotId: void 0 }, Task_Create_Failed_Jack_up_Task_Failed: { errCode: 35033, errText: "Task creation failed, robot is in jacking up state.", robotId: void 0 } }, E = { Business_Execute_Failed_By_Network: { errCode: 35012, errText: "Business failed, network error.", robotId: void 0 } }, S = { Success: { errCode: 0, errText: "Connection success.", robotId: "" }, No_Onlines: { errCode: 34e3, errText: "No online robots.", robotId: void 0 }, Wrong_ID: { errCode: 34001, errText: "Robot ID error.", robotId: void 0 }, Is_Offline: { errCode: 34002, errText: "Robot offline.", robotId: void 0 }, No_Available: { errCode: 34003, errText: "No robot available.", robotId: void 0 }, Sys_UnAvailable: { errCode: 34004, errText: "System error.", robotId: void 0 }, Ip_UnAvailable: { errCode: 34005, errText: "Robot IP is needed in LAN_APP mode.", robotId: void 0 }, Ws_Timeout: { errCode: 34006, errText: "Robot websocket connection  timeout, reconnecting...", robotId: void 0 }, Network_Timeout: { errCode: 34007, errText: "Network error, please check network status.", robotId: void 0 }, Ws_Message_Not_Received: { errCode: 34008, errText: "Robot websocket connection abnormal, message not received.", robotId: void 0 }, Chassis_Network_Timeout: { errCode: 34009, errText: "Detected disconnection from the chassis connection, please check the network cable...", robotId: void 0 }, Robot_Not_Connect: { errCode: 34010, errText: "Robot not connected" } }, P = { Success: { errCode: 0, errText: "Initialization success.", robotId: "" }, Init_Error: { errCode: 33e3, errText: "Initialization failed. Please check app id and app secret.", robotId: void 0 }, AppId_Secret_Null: { errCode: 404001, errText: "appId or secret is empty." }, Token_401: { errCode: 30401, errText: "Login timeout or current login failure, please log in again!" } }, I = { Get_RobotList_Fail: { errCode: 38e3, errText: "Robot list retrieve failed.", robotId: void 0 }, Get_RobotDeploy_Fail: { errCode: 38001, errText: "No robot deployment info.", robotId: void 0 }, Get_Token_Fail: { errCode: 38002, errText: "Authorization failed. Please check network or authorization parameters.", robotId: void 0 }, Get_Token_Fail_408: { errCode: 38003, errText: "Authorization failed. Please check network state.", robotId: void 0 }, Get_Token_Fail_404: { errCode: 38004, errText: "Authorization failed. Please check request url.", robotId: void 0 }, Get_Token_APPID_NULL: { errCode: 380021, errText: "APPID is null", robotId: void 0 }, Create_Task_Fail: { errCode: 38005, errText: "Task creation failed. Please check network or parameters.", robotId: void 0 }, Create_Task_Fail_408: { errCode: 38006, errText: "Task creation failed. Please check network state.", robotId: void 0 }, Create_Task_Fail_404: { errCode: 38007, errText: "Task creation failed. Please check request url.", robotId: void 0 }, Cancel_Task_Fail: { errCode: 38008, errText: "Task cancelling failed. Please check network or parameters.", robotId: void 0 }, Cancel_Task_Fail_408: { errCode: 38009, errText: "Task cancelling failed. Please check network state.", robotId: void 0 }, Cancel_Task_Fail_404: { errCode: 38010, errText: "Task cancelling failed. Please check request url.", robotId: void 0 }, Finish_Task_Fail: { errCode: 38011, errText: "End task failed. Please check network or parameters.", robotId: void 0 }, Finish_Task_Fail_408: { errCode: 38012, errText: "End task failed. Please check network state.", robotId: void 0 }, Finish_Task_Fail_404: { errCode: 38013, errText: "End task failed. Please check request url.", robotId: void 0 }, Update_Task_Fail: { errCode: 38014, errText: "Task update failed. Please check network or parameters.", robotId: void 0 }, Update_Task_Fail_408: { errCode: 38015, errText: "Task update failed. Please check network state.", robotId: void 0 }, Update_Task_Fail_404: { errCode: 38016, errText: "Task update failed. Please check request url.", robotId: void 0 }, Execute_Task_Fail: { errCode: 38017, errText: "Task failed. Please check network or parameters.", robotId: void 0 }, Execute_Task_Fail_408: { errCode: 38018, errText: "Task failed. Please check network state.", robotId: void 0 }, Execute_Task_Fail_404: { errCode: 38019, errText: "Task failed. Please check request url.", robotId: void 0 }, Get_State_Fail: { errCode: 38020, errText: "Failed to get status. Please check network or parameters.", robotId: void 0 }, Get_State_Fail_408: { errCode: 38021, errText: "Failed to get status. Please check network or parameters.", robotId: void 0 }, Get_State_Fail_404: { errCode: 38022, errText: "Failed to get status. Please check request url.", robotId: void 0 }, Get_Deploy_Fail: { errCode: 38023, errText: "Failed to get deploy info. Please check network or parameters.", robotId: void 0 }, Get_Deploy_Fail_408: { errCode: 38024, errText: "Failed to get deploy info. Please check network or parameters.", robotId: void 0 }, Get_Deploy_Fail_404: { errCode: 38025, errText: "Failed to get deploy info. Please check request url.", robotId: void 0 }, Get_Cloud_Base_Map_Fail: { errCode: 38026, errText: "Failed to get base map. Please check network or parameters.", robotId: void 0 }, Get_Cloud_Base_Map_Fail_408: { errCode: 38027, errText: "Failed to get base map. Please check network or parameters.", robotId: void 0 }, Get_Cloud_Base_Map_Fail_404: { errCode: 38028, errText: "Failed to get base map. Please check request url.", robotId: void 0 }, Map_Not_Exist: { errCode: 38404, errText: "Map does not exist. Please check parameters.", robotId: void 0 }, Get_Cloud_Features_Fail: { errCode: 38029, errText: "Failed to get features. Please check network or parameters.", robotId: void 0 }, Get_Cloud_Features_Fail_408: { errCode: 38030, errText: "Failed to get features. Please check network or parameters.", robotId: void 0 }, Get_Cloud_Features_Fail_404: { errCode: 38031, errText: "Failed to get features. Please check request url.", robotId: void 0 }, Get_Cloud_Map_Meta_Fail: { errCode: 38032, errText: "Failed to get map metadata. Please check network or parameters.", robotId: void 0 }, Get_Cloud_Map_Meta_Fail_408: { errCode: 38033, errText: "Failed to get map metadata. Please check network or parameters.", robotId: void 0 }, Get_Cloud_Map_Meta_Fail_404: { errCode: 38034, errText: "Failed to get map metadata. Please check request url.", robotId: void 0 }, Search_Area_Fail: { errCode: 38035, errText: "Failed to search area. Please check network or parameters.", robotId: void 0 }, Search_Area_Fail_408: { errCode: 38036, errText: "Failed to search area. Please check network or parameters.", robotId: void 0 }, Search_Area_Fail_404: { errCode: 38037, errText: "Failed to search area. Please check request url.", robotId: void 0 }, Get_Area_Picture_Fail: { errCode: 38038, errText: "Failed to get area picture. Please check network or parameters.", robotId: void 0 }, Get_Area_Picture_Fail_408: { errCode: 38039, errText: "Failed to get area picture. Please check network or parameters.", robotId: void 0 }, Get_Area_Picture_Fail_404: { errCode: 38040, errText: "Failed to get area picture. Please check request url.", robotId: void 0 }, Get_Search_Poi_By_Id_Fail: { errCode: 38041, errText: "Failed to get poi info. Please check network or parameters.", robotId: void 0 }, Get_Search_Poi_By_Id_Fail_408: { errCode: 38042, errText: "Failed to get poi info. Please check network or parameters.", robotId: void 0 }, Get_Search_Poi_By_Id_Fail_404: { errCode: 38043, errText: "Failed to get poi info. Please check request url.", robotId: void 0 }, Save_Cruise_Fail: { errCode: 38044, errText: "Failed to save cruise info. Please check network or parameters.", robotId: void 0 }, Save_Cruise_Fail_408: { errCode: 38045, errText: "Failed to save cruise info. Please check network or parameters.", robotId: void 0 }, Save_Cruise_Fail_404: { errCode: 38046, errText: "Failed to save cruise info. Please check request url.", robotId: void 0 }, Get_Cruise_By_businessId_Fail: { errCode: 38047, errText: "Failed to get cruise info. Please check network or parameters.", robotId: void 0 }, Get_Cruise_By_businessId_Fail_408: { errCode: 38048, errText: "Failed to get cruise info. Please check network or parameters.", robotId: void 0 }, Get_Cruise_By_businessId_Fail_404: { errCode: 38049, errText: "Failed to get cruise info. Please check request url.", robotId: void 0 }, Delete_Cruise_By_Id_Fail: { errCode: 38050, errText: "Failed to delete cruise info. Please check network or parameters.", robotId: void 0 }, Delete_Cruise_By_Id_Fail_408: { errCode: 38051, errText: "Failed to delete cruise info. Please check network or parameters.", robotId: void 0 }, Delete_Cruise_By_Id_Fail_404: { errCode: 38052, errText: "Failed to delete cruise info. Please check request url.", robotId: void 0 }, Post_Language_By_Id_Fail: { errCode: 38053, errText: "Failed to update language. Please check network or parameters.", robotId: void 0 }, Post_Language_By_Id_Fail_408: { errCode: 38054, errText: "Failed to update language. Please check network or parameters.", robotId: void 0 }, Post_Language_By_Id_Fail_404: { errCode: 38055, errText: "Failed to update language. Please check request url.", robotId: void 0 }, Get_Wifi_State_Fail: { errCode: 38056, errText: "Failed to get wifi state. Please check network or parameters.", robotId: void 0 }, Get_Wifi_State_Fail_408: { errCode: 38057, errText: "Failed to get wifi state. Please check network or parameters.", robotId: void 0 }, Get_Wifi_State_Fail_404: { errCode: 38058, errText: "Failed to get wifi state. Please check request url.", robotId: void 0 }, Get_Statis_Total_Fail: { errCode: 38059, errText: "Failed to get statistics total. Please check network or parameters.", robotId: void 0 }, Get_Statis_Total_Fail_408: { errCode: 38060, errText: "Failed to get statistics total. Please check network or parameters.", robotId: void 0 }, Get_Statis_Total_Fail_404: { errCode: 38061, errText: "Failed to get statistics total. Please check request url.", robotId: void 0 }, Get_Single_Task_Statis_Fail: { errCode: 38062, errText: "Failed to get single task statistics. Please check network or parameters.", robotId: void 0 }, Get_Single_Task_Statis_Fail_408: { errCode: 38063, errText: "Failed to get single task  statistics. Please check network or parameters.", robotId: void 0 }, Get_Single_Task_Statis_Fail_404: { errCode: 38064, errText: "Failed to get single task  statistics. Please check request url.", robotId: void 0 }, Get_Task_Statis_Fail: { errCode: 38065, errText: "Failed to get task statistics. Please check network or parameters.", robotId: void 0 }, Get_Task_Statis_Fail_408: { errCode: 38066, errText: "Failed to get task statistics. Please check network or parameters.", robotId: void 0 }, Get_Task_Statis_Fail_404: { errCode: 38067, errText: "Failed to get task statistics. Please check request url.", robotId: void 0 }, Get_Area_By_Id_Fail: { errCode: 38068, errText: "Failed to get area. Please check network or parameters.", robotId: void 0 }, Get_Area_By_Id_Fail_408: { errCode: 38069, errText: "Failed to get area. Please check network or parameters.", robotId: void 0 }, Get_Area_By_Id_Fail_404: { errCode: 38070, errText: "Failed to get area. Please check request url.", robotId: void 0 }, Get_Area_Compare_List_Fail: { errCode: 38071, errText: "Failed to get area  compare list. Please check network or parameters.", robotId: void 0 }, Get_Area_Compare_List_Fail_408: { errCode: 38072, errText: "Failed to get area compare list. Please check network or parameters.", robotId: void 0 }, Get_Area_Compare_List_Fail_404: { errCode: 38073, errText: "Failed to get area compare list. Please check request url.", robotId: void 0 }, Get_Area_Features_Fail: { errCode: 38074, errText: "Failed to get area features. Please check network or parameters.", robotId: void 0 }, Get_Area_Features_Fail_408: { errCode: 38075, errText: "Failed to get area features. Please check network or parameters.", robotId: void 0 }, Get_Area_Features_Fail_404: { errCode: 38076, errText: "Failed to get area features. Please check request url.", robotId: void 0 }, Get_Area_Thumbnail_Fail: { errCode: 38077, errText: "Failed to get area thumbnail. Please check network or parameters.", robotId: void 0 }, Get_Area_Thumbnail_Fail_408: { errCode: 38078, errText: "Failed to get area thumbnail. Please check network or parameters.", robotId: void 0 }, Get_Area_Thumbnail_Fail_404: { errCode: 38079, errText: "Failed to get area thumbnail. Please check request url.", robotId: void 0 }, Get_Area_Medium_Thumbnail_Fail: { errCode: 38080, errText: "Failed to get area medium thumbnail. Please check network or parameters.", robotId: void 0 }, Get_Area_Medium_Thumbnail_Fail_408: { errCode: 38081, errText: "Failed to get area medium thumbnail. Please check network or parameters.", robotId: void 0 }, Get_Area_Medium_Thumbnail_Fail_404: { errCode: 38082, errText: "Failed to get area medium thumbnail. Please check request url.", robotId: void 0 }, Add_Time_Task_Fail: { errCode: 38083, errText: "Failed to add time task. Please check network or parameters.", robotId: void 0 }, Add_Time_Task_Fail_408: { errCode: 38084, errText: "Failed to add time task. Please check network or parameters.", robotId: void 0 }, Add_Time_Task_Fail_404: { errCode: 38085, errText: "Failed to add time task. Please check request url.", robotId: void 0 }, Get_Time_Task_List_Fail: { errCode: 38086, errText: "Failed to get time task list. Please check network or parameters.", robotId: void 0 }, Get_Time_Task_List_Fail_408: { errCode: 38087, errText: "Failed to get time task list. Please check network or parameters.", robotId: void 0 }, Get_Time_Task_List_Fail_404: { errCode: 38088, errText: "Failed to get time task list. Please check request url.", robotId: void 0 }, Delete_Time_Task_Fail: { errCode: 38089, errText: "Failed to delete time task. Please check network or parameters.", robotId: void 0 }, Delete_Time_Task_Fail_408: { errCode: 38090, errText: "Failed to delete time task. Please check network or parameters.", robotId: void 0 }, Delete_Time_Task_Fail_404: { errCode: 38091, errText: "Failed to delete time task. Please check request url.", robotId: void 0 }, Get_Point_Cloud_Data_Fail: { errCode: 38092, errText: "Failed to get point cloud data. Please check network or parameters.", robotId: void 0 }, Get_Point_Cloud_Data_Fail_408: { errCode: 38093, errText: "Failed to get point cloud data. Please check network or parameters.", robotId: void 0 }, Get_Point_Cloud_Data_Fail_404: { errCode: 38094, errText: "Failed to get point cloud data. Please check request url.", robotId: void 0 }, Save_Robot_Setting_Data_Fail: { errCode: 38095, errText: "Failed to save robot setting data. Please check network or parameters.", robotId: void 0 }, Save_Robot_Setting_Data_404: { errCode: 38096, errText: "Failed to save robot setting data. Please check request url.", robotId: void 0 }, Get_Robot_Setting_Data_Fail: { errCode: 38097, errText: "Failed to get robot setting data. Please check network or parameters.", robotId: void 0 }, Get_Robot_Setting_Data_404: { errCode: 38098, errText: "Failed to get robot setting data. Please check request url.", robotId: void 0 }, Get_Task_List_Fail: { errCode: 38086, errText: "Failed to get task list. Please check network or parameters.", robotId: void 0 }, Get_Task_List_Fail_408: { errCode: 38087, errText: "Failed to get task list. Please check network or parameters.", robotId: void 0 }, Get_Task_List_Fail_404: { errCode: 38088, errText: "Failed to get task list. Please check request url.", robotId: void 0 }, Get_Task_Detail_Fail: { errCode: 38086, errText: "Failed to get task Detail. Please check network or parameters.", robotId: void 0 }, Get_Log_Data_Params_Fail: { errCode: 38086, errText: "Failed to get Params. Please check network or parameters.", robotId: void 0 }, Get_Robot_Rack_Size_Fail: { errCode: 38099, errText: "Failed to get robot rack size data. Please check network or parameters.", robotId: void 0 }, Get_Robot_Rack_Size_404: { errCode: 38100, errText: "Failed to get robot ack size data. Please check request url.", robotId: void 0 }, set_serial_port_light_Fail: { errCode: 38101, errText: "Failed to set serial port light data. Please check network or parameters.", robotId: void 0 }, set_serial_port_light_404: { errCode: 38102, errText: "Failed to set serial port light data. Please check request url.", robotId: void 0 }, get_battery_life_Fail: { errCode: 38103, errText: "Failed to get battery life. Please check network or  parameters", robotId: void 0 }, Network_Error: { errCode: -1, errText: "Network error. Please check network." }, Get_Bind_Edge_Intelligence_Fail: { errCode: 38103, errText: "Get edge intelligence failed. Please check network or parameters.", robotId: void 0 }, Get_Bind_Edge_Intelligence_404: { errCode: 38104, errText: "Get edge intelligence failed. Please check request url.", robotId: void 0 }, Set_RCS_Active_Fail: { errCode: 38201, errText: "Failed to disable the RCS status of the robot. Please check network or parameters.", robotId: void 0 }, Set_RCS_Active_404: { errCode: 38202, errText: "Failed to disable the RCS status of the robot. Please check request url.", robotId: void 0 }, Get_RCS_Path_Fail: { errCode: 38203, errText: "Failed to obtain RCS zone to zone route.Please check network or parameters.", robotId: void 0 }, Get_RCS_Path_404: { errCode: 38204, errText: "Failed to obtain RCS zone to zone route. Please check request url.", robotId: void 0 }, Add_RCS_Area_Task_Fail: { errCode: 38205, errText: "Failed to initiate RCS task. Please check network or parameters.", robotId: void 0 }, Add_RCS_Area_Task_404: { errCode: 38206, errText: "Failed to initiate RCS task. Please check request url.", robotId: void 0 }, Get_Group_List_Fail: { errCode: 381101, errText: "Failed to get group list. Please check network or parameters." }, Get_Group_List_404: { errCode: 381102, errText: "Failed to get group list. Please check request url." }, Add_Group_Fail: { errCode: 381103, errText: "Failed to add group. Please check network or parameters." }, Add_Group_404: { errCode: 381104, errText: "Failed to add group. Please check request url." }, Edit_Group_Fail: { errCode: 381105, errText: "Failed to edit group. Please check network or parameters." }, Edit_Group_404: { errCode: 381106, errText: "Failed to edit group. Please check request url." }, Del_Group_Fail: { errCode: 381107, errText: "Failed to delete group. Please check network or parameters." }, Del_Group_404: { errCode: 381108, errText: "Failed to delete group. Please check request url." }, Get_Group_Detail_Fail: { errCode: 381109, errText: "Failed to get group detail. Please check network or parameters." }, Get_Group_Detail_404: { errCode: 381110, errText: "Failed to get group detail. Please check request url." }, Get_Group_Task_List_Fail: { errCode: 381111, errText: "Failed to get group task list. Please check network or parameters." }, Get_Group_Task_List_404: { errCode: 381112, errText: "Failed to get group task list. Please check request url." }, Add_Group_Task_Fail: { errCode: 381113, errText: "Failed to add group task. Please check network or parameters." }, Add_Group_Task_404: { errCode: 381114, errText: "Failed to add group task. Please check request url." }, Del_Group_Task_Fail: { errCode: 381115, errText: "Failed to delete group task. Please check network or parameters." }, Del_Group_Task_404: { errCode: 381116, errText: "Failed to delete group task. Please check request url." }, Edit_Group_Task_Fail: { errCode: 381117, errText: "Failed to edit group task. Please check network or parameters." }, Edit_Group_Task_404: { errCode: 381118, errText: "Failed to edit group task. Please check request url." }, Get_Group_Task_Detail_Fail: { errCode: 381119, errText: "Failed to get group task detail. Please check network or parameters." }, Get_Group_Task_Detail_404: { errCode: 38120, errText: "Failed to get group task detail. Please check request url." }, Del_Group_Fail_bound: { errCode: 38121, errText: "Group has associated tasks." }, Add_Group_Fail_NameExit: { errCode: 38122, errText: "Group name already exists." }, Add_Group_Task_Fail_NameExit: { errCode: 38123, errText: "Group task name already exists." }, cruise_route_sort_Fail: { errCode: 38124, errText: "Failed to cruise route sort. Please check network or parameters.", robotId: void 0 }, cruise_route_sort_Fail_408: { errCode: 38125, errText: "Failed to cruise route sort. Please check network or parameters.", robotId: void 0 }, cruise_route_sort_Fail_404: { errCode: 38126, errText: "Failed to cruise route sort. Please check request url.", robotId: void 0 } }, A = { Success: { errCode: 0, errText: "Map initialization success.", robotId: "" }, Init_Error: { errCode: 36e3, errText: "Map initialization failed. Please check whether container exists.", robotId: void 0 }, Un_Init_Error: { errCode: 36001, errText: "Uninitialized map.", robotId: void 0 } }, L = { Update_Map_Error: { errCode: 37e3, errText: "Map update failed, please check network or command parameters.", robotId: void 0 }, Go_Home_Error: { errCode: 37001, errText: "Go to charging station failed, please check network or command parameters.", robotId: void 0 }, Motion_For_Error: { errCode: 37002, errText: "Motion control failed, please check network or command parameters.", robotId: void 0 }, Update_Map_Failed_By_Updating: { errCode: 37003, errText: "Map update failed, Already updated.", robotId: void 0 }, Update_Map_Failed_By_Tasking: { errCode: 37004, errText: "Map update failed, In the task, update not allowed.", robotId: void 0 }, Update_Map_Failed_By_Mapping: { errCode: 37005, errText: "Map update failed, In the create map, update not allowed.", robotId: void 0 }, Update_Map_Failed_By_Timeout: { errCode: 37006, errText: "Map update failed, Update map timed out.", robotId: void 0 }, Update_CMD_By_Timeout: { errCode: 37006, errText: "Send cmd to robot timed out.", robotId: void 0 } }, M = { Param_type_is_number: { errCode: 39e3, errText: "param require is number." }, Param_type_is_string: { errCode: 39001, errText: "param require is string." }, Param_type_is_object: { errCode: 39002, errText: "param require is object." }, Param_type_is_null: { errCode: 39003, errText: "param is null." } }, B = { Add_Queue_Task_404: { errCode: 31e3, errText: "Failed to get task list data. Please check request url." }, Add_Queue_Task_Fail: { errCode: 31001, errText: "Failed to get task list data. Please check network or parameters." }, Get_Queue_Task_List_Data_404: { errCode: 31002, errText: "Failed to get task list data. Please check request url." }, Get_Queue_Task_List_Data_Fail: { errCode: 31003, errText: "Failed to get task list data. Please check network or parameters." }, Get_Task_Queue_404: { errCode: 31004, errText: "Failed to get task queue. Please check request url." }, Get_Task_Queue_Fail: { errCode: 31005, errText: "Failed to get task queue. Please check network or parameters." }, Get_Task_Queue_Robot_404: { errCode: 31006, errText: "Failed to get task queue to robot. Please check request url." }, Get_Task_Queue_Robot_Fail: { errCode: 31007, errText: "Failed to get task queue to robot. Please check network or parameters." }, Set_Task_Order_404: { errCode: 31006, errText: "Failed to set task order. Please check request url." }, Set_Task_Order_Fail: { errCode: 31007, errText: "Failed to set task order. Please check network or parameters." }, Pause_Queue_404: { errCode: 31008, errText: "Failed to pause queue. Please check request url." }, Pause_Queue_Fail: { errCode: 31009, errText: "Failed to pause queue. Please check network or parameters." }, Continue_Queue_404: { errCode: 31010, errText: "Failed to continue queue. Please check request url." }, Continue_Queue_Fail: { errCode: 31011, errText: "Failed to continue queue. Please check network or parameters." }, Set_Queue_Order_404: { errCode: 31012, errText: "Failed to set queue order. Please check request url." }, Set_Queue_Order_Fail: { errCode: 31013, errText: "Failed to set queue order. Please check network or parameters." }, Delete_Queue_Task_404: { errCode: 31014, errText: "Failed to delete task. Please check request url." }, Delete_Queue_Task_Fail: { errCode: 31015, errText: "Failed to delete task. Please check network or parameters." }, Get_Queue_Task_Detail_404: { errCode: 31016, errText: "Failed to get task info data. Please check request url." }, Get_Queue_Task_Detail_Fail: { errCode: 31017, errText: "Failed to get task info data. Please check request url." }, Cancel_All_Queue_404: { errCode: 31018, errText: "Failed to cancel tasks. Please check network or parameters." }, Cancel_All_Queue_Fail: { errCode: 31019, errText: "Failed to cancel tasks. Please check request url." } }, R = { Add_Custom_Task_404: { errCode: 32e3, errText: "Failed to add task. Please check request url." }, Add_Custom_Task_Fail: { errCode: 32001, errText: "Failed to add task. Please check network or parameters." }, Edit_Custom_Task_404: { errCode: 32006, errText: "Failed to edit task. Please check request url." }, Edit_Custom_Task_Fail: { errCode: 32007, errText: "Failed to edit task. Please check network or parameters." }, Get_Custom_Task_List_Data_404: { errCode: 32002, errText: "Failed to get task list data. Please check request url." }, Get_Custom_Task_List_Data_Fail: { errCode: 32003, errText: "Failed to get task list data. Please check network or parameters." }, Get_Custom_Task_404: { errCode: 32004, errText: "Failed to get task info. Please check request url." }, Get_Custom_Task_Fail: { errCode: 32005, errText: "Failed to get task info. Please check network or parameters." }, Delete_Custom_Task_404: { errCode: 32014, errText: "Failed to delete task. Please check request url." }, Delete_Custom_Task_Fail: { errCode: 32015, errText: "Failed to delete task. Please check network or parameters." } }, D = { DB_Error: { errCode: -1, errText: "database error" }, DB_Add_Error: { errCode: 39100, errText: "Data addition failed" }, DB_Update_Error: { errCode: 39101, errText: "Data update failed" }, DB_Delete_Error: { errCode: 39102, errText: "Data deletion failed" }, DB_Get_Error: { errCode: 39103, errText: "Data acquisition failed" } }, F = { Map_UpDate_Failed: { errCode: 37100, errText: "Map update failed" }, Map_UpDate_Conflict_Failed: { errCode: 37100, errText: "Map update failed - Map conflict detection failed" }, Map_UpDate_Conflict_Timeout: { errCode: 37102, errText: "Map update failed - Map conflict detection timeout" }, 1405: { errCode: 37105, errText: "Map update failed - Download map failed" }, 1406: { errCode: 37106, errText: "Map update failed - Update map failed" } }, O = { Mode_Error: { errCode: 38220, errText: "This is not in the offline mode" }, Sever_Error: { errCode: 38221, errText: "Server error" }, Search_Overview_Fail: { errCode: 38210, errText: "Get overview statistics data failed" }, Search_Overview_404: { errCode: 38211, errText: "GET overview statistics data failed, please check params" }, Search_Tasks_Fail: { errCode: 38212, errText: "Get tasks statistics data failed" }, Search_Tasks_404: { errCode: 38213, errText: "Get tasks statistics data failed, please check params" }, Search_Hourly_Robot_Fail: { errCode: 38214, errText: "Get hourly robot statistics data failed" }, Search_Hourly_Robot_404: { errCode: 38215, errText: "Get hourly robot statistics data failed, please check params" }, Search_HourlyTasks_Fail: { errCode: 38216, errText: "Get hourly tasks statistics data failed" }, Search_HourlyTasks_404: { errCode: 38217, errText: "Get hourly tasks statistics data failed, please check params" }, Search_TaskCountByDay_Fail: { errCode: 38218, errText: "Get task count by day statistics data failed" }, Search_TaskCountByDay_404: { errCode: 38219, errText: "Get task count by day statistics data failed, please check params" } }, z = { 80400: "Road calculation failed - unreachable", 80401: "Road calculation failed - no entry point", 80402: "Road calculation failed - specified vehicle does not exist", 80403: "The vehicle does not support the current task type", 80404: "non-existent resources (points, routes, etc.)", 80405: "The current location node of the vehicle is empt", 80406: "There are no stops within the area", 80407: "Invalid docking point in the area" }, U = { 1: "Other reasons", 2: "Failed to obtain map (WorldMap)", 3: "Starting point is outside the map", 4: "Destination is outside the map", 5: "Starting point is not in a passable area", 6: "Destination is not in a passable area", 7: "Starting point and destination are the same", 8: "Failed to c alculate global route", 9: "Road not connected", 10: "Route calculation timed out", 11: "No global route", 12: "Failed to grab starting point on global route", 13: "Failed to grab destination on global route", 14: "Path planning unsuccessful for too long", 15: "Path planning success, but obstacles avoidance takes too long", 16: "Error in local obstacle avoidance, sensor data abnormal", 500: "Invalid shelf detection points", 501: "Unrecognized shelves", 502: "Exceeded docking retry attempts", 503: "The shelf position is occupied by another robot", 504: "Unable to reach the unloading point", 505: "Significant sliding of the shelves", 506: "Jacking is in the raised state", 507: "Invalid shelf area ID", 508: "There are no shelves in the shelf area", 510: "The shelf was not recognized in the current area. Please confirm and try again", 511: "There are shelves in the shelf area, but the docking failed", 512: "All shelf positions in the shelf area are occupied", 513: "There is free shelf space in the shelf area, but the delivery failed", 1001: "planning node is not running", 1002: "occupancy_grid_server node is not running ", 1003: "map_server node is not running", 1004: "cartographer_occupancy_grid_node is not running", 1005: "No /maps/5cm message for more than 1s", 1008: "The robot is stuck, please check if there are any obstacles", 1012: "Fall risk ahead detected, correct robots position or draw necessary virtual walls", 2002: "Robot wheel overload detected. Please inspect and then click continue.", 2006: "Wheel overload", 2008: "Robot wheel slip detected.Please inspect and then click continue.", 3001: "odom node is not running", 3002: "odom message frequency abnormal", 4001: "imu node is not running", 4002: "imu message frequency abnormal", 4003: "imu angular velocity abnormal", 4008: "Detected robot tilting, please manually clear the fault code", 5001: "lidar node is not running", 5002: "lidar info frequency abnormal", 5007: "Point cloud is empty data", 5008: "The LiDAR is obstructed by foreign objects at the indicated location. Please check and clean up the foreign objects", 6010: "System down unexpectedly", 7002: "pose info extremely unreliable", 7004: "pose info unreliable", 8004: "Battery communication disconnected, reading battery level failed", 12005: "Shelf deviation detected, please straighten the shelf and try again, or perform the lifting and placing action again.", 20009: "Gate or auto-door abnormal", 20012: "No available elevators", 20015: "jacking up timeout, retrying…", 20020: "Chassis link disconnected", 20021: "The elevator is occupied and is being rescheduled...", 20022: "The elevator is occupied and is being rescheduled...", 35021: "Task failed, charging pile is not in the current map <br> please select again in the Settings;", 35022: "Task failed, standby point is not in the current map <br>please select again in the Settings;", 35023: "Task failed.  destination is not in the current map <br>please select again", 51e3: "There is no link in the area, and the shortest route cannot be calculated", 51001: "Map data is incomplete (missing waiting points, connection points, elevator points), the area is not connected", 51002: "The link is not connected", 51003: "The number of task points is too small to calculate the route (less than 2 task points for cyclic tasks and less than 1 task point for non-cyclic tasks)", 51004: "Charging station cross-layer", 51005: "Standby point cross-layer", 51006: "Destination cross-layer", 51007: "Failed to obtain an online elevator for a cross-layer task", 51008: "There is no online elevator for cross-layer tasks", 51009: "Cross-floor task The online elevator is occupied by another robot", 51010: "Other errors. Required parameters are missing and the robot is not deployed", 51011: "Task point missing", 51012: "Homing point missing", 51013: "Cruise route missing", 51014: "The robot position is lost", 51015: "Failed to create the task instruction", 51016: "Cancel task", 51017: "Failed to execute timed station return during charging", 51018: "Emergency stop mode, no task is executed", 51019: "Manual mode, no task is executed", 51020: "Remote mode, no task is executed", 51021: "Map creation mode, no task is executed", 51022: "The robot status is not obtained", 51023: "The battery is lower than 15%, the task will not be executed", 51024: " Chassis without map", 51032: "Failed to execute timed station return during charging" }; var N = "error", G = "warning", V = "info", q = { Forward: 0, Back: 1, TurnLeft: 2, TurnRight: 3, Cancel: 4, Auto: 5, Manual: 6 }, j = { Stop: 0, Start: 1 }, X = { WAN_APP: 0, LOCAL_APP: 1, LAN_APP: 2 }, W = C, Z = E, H = S, Q = P, $ = I, J = A, K = L, Y = M, ee = B, te = R, re = z, ne = U, ie = D, oe = F, se = O, ae = { notJump: -1, None: 0, CallElevator: 1, Changemap: 4, PlayAudio: 5, OpenDoor: 6, CallAutoDoor: 8, CallGate: 9, CheckInArea: 10, TryInElevator: 11, TryOutElevator: 12, CloseElevator: 13, GoTo: 14, Arrive: 16, Charge: 17, Pause: 18, CallExtNum: 24, CallIot: 25, DockPoint: 26, ApproachVmf: 27, CloseDoor: 28, GearOperation: 32, LogAction: 33, TakeElevator: 34, StopAudio: 36, OpenLight: 37, CloseLight: 38, InterAction: 40, SetSpeed: 41, Continue: 42, JackingUp: 47, JackingDown: 48, TaskBreakOff: 52, ActionStatus: 53, RollerLoad: 54, RollerUnLoad: 55, TaskCancal: 56, TaskFinish: 57, TaskChildFinish: 58, TaskStart: 1e3, TaskEnd: 1001, WheelOverload: 1002 }, ce = { Red: 1, Green: 3, Blue: 4, Yellow: 5 }, le = { none: [0, "无"], unknown: [1, "其它原因"], get_map_failed: [2, "获取地图失败（这里的地图是指 WorldMap）"], starting_point_out_of_map: [3, "起点在地图之外"], ending_point_out_of_map: [4, "终点在地图之外"], starting_point_not_in_ground: [5, "起点不在可通行区域"], ending_point_not_in_ground: [6, "终点不在可通行区域"], starting_equal_ending: [7, "起点和终点相同"], calculate_global_path_extended_data_error: [8, "计算全局路线扩展信息失败"], calculation_failed: [9, "算路失败"], calculation_timeout: [10, "算路超时"], no_global_path: [11, "没有全局路线"], not_grab_start_index_on_global_path: [12, "在全局路线上抓取起点失败"], not_grab_end_index_on_global_path: [13, "在全局路线上抓取终点失败"], planning_timeout: [14, " 路径规划长时间不成功"], move_timeout: [15, "路径规划成功，但是避让长时间过不去"], control_costmap_error: [16, "局部避障地图数据出现错误,当前避障传感器数据异常"], power_cable_connected: [17, "当前正在用线充电中"], rotate_timeout: [18, "旋转长时间无法完成"], charge_retry_count_exceeded: [100, "超过充电重试次数"], charge_dock_detection_error: [101, "未识别到充电桩"], charge_dock_signal_error: [102, "没有接收到充电桩对桩成功的信号"], invalid_charge_dock: [103, "无效的充电桩位姿"], already_in_charging: [104, "当前已经在充电中"], no_charge_current: [105, "touch后长时间没有收到电流"], invalid_cabinet_pos: [200, "无效的货柜点"], cabinet_detection_error: [201, "未识别到货柜"], no_dock_with_conveyer: [202, "当前没有在货物传送带对接点"], no_approach_conveyer: [203, "当前没有对接货物传送带"], elevator_point_occupied: [300, "乘梯点被占用"], elevator_closed: [301, "电梯已关闭"], invalid_track_points: [400, "无效的轨迹点（传入坐标数非偶数或者轨迹点数 < 2）"], too_far_from_start_of_track: [401, "离轨迹起点太远"], platform_alert_error: [1e3, "系统异常"], internal_error: [1002, "内部 ASSERT 引起的错误"] }, ue = function (e) { W = C, Z = E, H = S, Q = P, $ = I, J = A, K = L, Y = M, ee = B, te = R, re = z, ne = U, ie = D, oe = F, se = O, e.startsWith("zh") && (W = u, Z = h, H = d, Q = p, $ = f, J = m, K = g, Y = _, ee = y, te = v, re = T, ne = k, ie = x, oe = b, se = w) }, he = [{ name: "中文简体", value: "zh-cn", languageindex: 1 }, { name: "中文繁体", value: "zh-tw", languageindex: 3 }, { name: "English", value: "en", languageindex: 2 }, { name: "한국어", value: "ko", languageindex: 5 }, { name: "日本語", value: "jp", languageindex: 4 }, { name: "Deutsch", value: "de", languageindex: 6 }, { name: "ภาษาไทย", value: "th", languageindex: 7 }, { name: "España", value: "es", languageindex: 8 }, { name: "Polska", value: "pl", languageindex: 9 }, { name: "Русский", value: "ru", languageindex: 10 }, { name: "Français", value: "fr", languageindex: 11 }, { name: "Vietnamština", value: "vi", languageindex: 12 }, { name: "Čeština", value: "cs", languageindex: 13 }, { name: "Italiano", value: "it", languageindex: 14 }, { name: "Türkçe", value: "tr", languageindex: 15 }]; const de = {}, pe = "undefined" != typeof uni; "undefined" != typeof wx && wx.request; const fe = { baseURL: "", responseType: "json", timeout: 5e3, headers: { "Content-Type": "application/json" } }; de.request = e => new Promise(((t, r) => { const n = (e => Object.assign({}, fe, e))(e), { url: i, method: s, data: a, params: c, headers: l, timeout: u, responseType: h } = n; let d = i; if (c && Object.keys(c).length > 0) { const e = Object.keys(c).map((e => `${encodeURIComponent(e)}=${encodeURIComponent(c[e])}`)).join("&"); d += (i.includes("?") ? "&" : "?") + e } pe ? uni.request({ url: d, method: s || "GET", data: a || {}, header: l, timeout: u, responseType: h, success: e => { e.statusCode >= 200 && e.statusCode < 300 ? (e.status = e.statusCode, t(e)) : r(me(e)) }, fail: e => { r(me(e)) } }) : o.default.request({ url: d, data: a, method: s, headers: l, timeout: u, responseType: h }).then((e => { t(e) })).catch((e => { r(e) })) })); const me = e => { const t = JSON.parse(JSON.stringify(e)); return t.response = e.response || {}, t.response.status = e.statusCode || e.status, t.response.statusText = e.statusText || e.errMsg, t.response.data = e.data || null, t.name = "AxiosError", t }; de.get = (e, t = {}) => de.request({ url: e, method: "GET", ...t }), de.post = (e, t, r = {}) => de.request({ url: e, method: "POST", data: t, ...r }), de.put = (e, t, r = {}) => de.request({ url: e, method: "PUT", data: t, ...r }), de.delete = (e, t = {}) => de.request({ url: e, method: "DELETE", ...t }), de.patch = (e, t, r = {}) => de.request({ url: e, method: "PATCH", data: t, ...r }), de.interceptors = { request: [], response: [] }, de.useRequestInterceptor = (e, t) => { de.interceptors.request.push({ onFulfilled: e, onRejected: t }) }, de.useResponseInterceptor = (e, t) => { de.interceptors.response.push({ onFulfilled: e, onRejected: t }) }; const ge = "undefined" != typeof uni; function _e() { var e = null, t = null, r = null, i = null, o = null, s = !1, a = 1e4, c = null, l = 0; const u = () => { if (ge) return uni.connectSocket({ url: r, protocols: i ? [i] : [], complete: () => { } }); var e = n().w3cwebsocket; return i ? new e(r, i) : new e(r) }, h = e => { ge ? e.send({ data: '{"reqType":"onHeartBeat"}' }) : e.send('{"reqType":"onHeartBeat"}') }, d = (e, t) => { ge ? e.send({ data: t }) : e.send(t) }, p = (e, t) => { ge ? e.onOpen(t) : e.onopen = t }, f = (e, t) => { ge ? e.onError(t) : e.onerror = t }, m = (e, t) => { ge ? e.onClose(t) : e.onclose = t }, g = (e, t) => { ge ? e.onMessage(t) : e.onmessage = t }; function _(e) { if (null !== o && (clearTimeout(o), o = null), e) { var r = 5e3; l > 0 && (r = 1e3), e.readyState === e.OPEN && h(e), l > 0 && (new Date).getTime() - c > 5e3 ? (t && t(1), e.close()) : o = setTimeout((function () { _(e) }), r) } } this.start = function (n, h, d, y = 1e4, v = 0) { e = null, t = n, r = h, i = d, l = v, "number" == typeof y && (a = y), null !== (e = u()) && (s = !0, e.binaryType = "arraybuffer", c = (new Date).getTime(), _(e), g(e, (e => { if ("string" == typeof e.data) { var r = JSON.parse(e.data); "onHeartBeat" === r.reqType && (c = (new Date).getTime()), t && t(0, r) } else t && t(0, e.data) })), m(e, (e => { console.log(e, "close"), t && t(1), !1 !== s && (null !== o && (clearTimeout(o), o = null), setTimeout((() => { console.log(Date.parse(new Date), "start"), this.start(t, r, i, a, l) }), a)) })), p(e, (e => { t && t(2) })), f(e, (e => { t && t(3, e) }))) }, this.send = function (t) { e && (t.timestamp && (new Date).getTime() - t.timestamp > 1e4 ? console.log("online send ws cmd ---" + t.cmd + "---current time less than 10s") : d(e, JSON.stringify(t))) }, this.stop = function () { e && (s = !1, e.close(), e = null) }, this.close = function () { e.close() }, this.setProtocol = function (e) { i = e } } var ye = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== t ? t : "undefined" != typeof self ? self : {}; function ve(e, t) { return e(t = { exports: {} }, t.exports), t.exports } var xe, be = ve((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.Md5 = void 0; var r = function () { function e() { this._dataLength = 0, this._bufferLength = 0, this._state = new Int32Array(4), this._buffer = new ArrayBuffer(68), this._buffer8 = new Uint8Array(this._buffer, 0, 68), this._buffer32 = new Uint32Array(this._buffer, 0, 17), this.start() } return e.hashStr = function (e, t) { return void 0 === t && (t = !1), this.onePassHasher.start().appendStr(e).end(t) }, e.hashAsciiStr = function (e, t) { return void 0 === t && (t = !1), this.onePassHasher.start().appendAsciiStr(e).end(t) }, e._hex = function (t) { var r, n, i, o, s = e.hexChars, a = e.hexOut; for (o = 0; o < 4; o += 1)for (n = 8 * o, r = t[o], i = 0; i < 8; i += 2)a[n + 1 + i] = s.charAt(15 & r), r >>>= 4, a[n + 0 + i] = s.charAt(15 & r), r >>>= 4; return a.join("") }, e._md5cycle = function (e, t) { var r = e[0], n = e[1], i = e[2], o = e[3]; n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n & i | ~n & o) + t[0] - 680876936 | 0) << 7 | r >>> 25) + n | 0) & n | ~r & i) + t[1] - 389564586 | 0) << 12 | o >>> 20) + r | 0) & r | ~o & n) + t[2] + 606105819 | 0) << 17 | i >>> 15) + o | 0) & o | ~i & r) + t[3] - 1044525330 | 0) << 22 | n >>> 10) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n & i | ~n & o) + t[4] - 176418897 | 0) << 7 | r >>> 25) + n | 0) & n | ~r & i) + t[5] + 1200080426 | 0) << 12 | o >>> 20) + r | 0) & r | ~o & n) + t[6] - 1473231341 | 0) << 17 | i >>> 15) + o | 0) & o | ~i & r) + t[7] - 45705983 | 0) << 22 | n >>> 10) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n & i | ~n & o) + t[8] + 1770035416 | 0) << 7 | r >>> 25) + n | 0) & n | ~r & i) + t[9] - 1958414417 | 0) << 12 | o >>> 20) + r | 0) & r | ~o & n) + t[10] - 42063 | 0) << 17 | i >>> 15) + o | 0) & o | ~i & r) + t[11] - 1990404162 | 0) << 22 | n >>> 10) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n & i | ~n & o) + t[12] + 1804603682 | 0) << 7 | r >>> 25) + n | 0) & n | ~r & i) + t[13] - 40341101 | 0) << 12 | o >>> 20) + r | 0) & r | ~o & n) + t[14] - 1502002290 | 0) << 17 | i >>> 15) + o | 0) & o | ~i & r) + t[15] + 1236535329 | 0) << 22 | n >>> 10) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n & o | i & ~o) + t[1] - 165796510 | 0) << 5 | r >>> 27) + n | 0) & i | n & ~i) + t[6] - 1069501632 | 0) << 9 | o >>> 23) + r | 0) & n | r & ~n) + t[11] + 643717713 | 0) << 14 | i >>> 18) + o | 0) & r | o & ~r) + t[0] - 373897302 | 0) << 20 | n >>> 12) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n & o | i & ~o) + t[5] - 701558691 | 0) << 5 | r >>> 27) + n | 0) & i | n & ~i) + t[10] + 38016083 | 0) << 9 | o >>> 23) + r | 0) & n | r & ~n) + t[15] - 660478335 | 0) << 14 | i >>> 18) + o | 0) & r | o & ~r) + t[4] - 405537848 | 0) << 20 | n >>> 12) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n & o | i & ~o) + t[9] + 568446438 | 0) << 5 | r >>> 27) + n | 0) & i | n & ~i) + t[14] - 1019803690 | 0) << 9 | o >>> 23) + r | 0) & n | r & ~n) + t[3] - 187363961 | 0) << 14 | i >>> 18) + o | 0) & r | o & ~r) + t[8] + 1163531501 | 0) << 20 | n >>> 12) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n & o | i & ~o) + t[13] - 1444681467 | 0) << 5 | r >>> 27) + n | 0) & i | n & ~i) + t[2] - 51403784 | 0) << 9 | o >>> 23) + r | 0) & n | r & ~n) + t[7] + 1735328473 | 0) << 14 | i >>> 18) + o | 0) & r | o & ~r) + t[12] - 1926607734 | 0) << 20 | n >>> 12) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n ^ i ^ o) + t[5] - 378558 | 0) << 4 | r >>> 28) + n | 0) ^ n ^ i) + t[8] - 2022574463 | 0) << 11 | o >>> 21) + r | 0) ^ r ^ n) + t[11] + 1839030562 | 0) << 16 | i >>> 16) + o | 0) ^ o ^ r) + t[14] - 35309556 | 0) << 23 | n >>> 9) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n ^ i ^ o) + t[1] - 1530992060 | 0) << 4 | r >>> 28) + n | 0) ^ n ^ i) + t[4] + 1272893353 | 0) << 11 | o >>> 21) + r | 0) ^ r ^ n) + t[7] - 155497632 | 0) << 16 | i >>> 16) + o | 0) ^ o ^ r) + t[10] - 1094730640 | 0) << 23 | n >>> 9) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n ^ i ^ o) + t[13] + 681279174 | 0) << 4 | r >>> 28) + n | 0) ^ n ^ i) + t[0] - 358537222 | 0) << 11 | o >>> 21) + r | 0) ^ r ^ n) + t[3] - 722521979 | 0) << 16 | i >>> 16) + o | 0) ^ o ^ r) + t[6] + 76029189 | 0) << 23 | n >>> 9) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n ^ i ^ o) + t[9] - 640364487 | 0) << 4 | r >>> 28) + n | 0) ^ n ^ i) + t[12] - 421815835 | 0) << 11 | o >>> 21) + r | 0) ^ r ^ n) + t[15] + 530742520 | 0) << 16 | i >>> 16) + o | 0) ^ o ^ r) + t[2] - 995338651 | 0) << 23 | n >>> 9) + i | 0, n = ((n += ((o = ((o += (n ^ ((r = ((r += (i ^ (n | ~o)) + t[0] - 198630844 | 0) << 6 | r >>> 26) + n | 0) | ~i)) + t[7] + 1126891415 | 0) << 10 | o >>> 22) + r | 0) ^ ((i = ((i += (r ^ (o | ~n)) + t[14] - 1416354905 | 0) << 15 | i >>> 17) + o | 0) | ~r)) + t[5] - 57434055 | 0) << 21 | n >>> 11) + i | 0, n = ((n += ((o = ((o += (n ^ ((r = ((r += (i ^ (n | ~o)) + t[12] + 1700485571 | 0) << 6 | r >>> 26) + n | 0) | ~i)) + t[3] - 1894986606 | 0) << 10 | o >>> 22) + r | 0) ^ ((i = ((i += (r ^ (o | ~n)) + t[10] - 1051523 | 0) << 15 | i >>> 17) + o | 0) | ~r)) + t[1] - 2054922799 | 0) << 21 | n >>> 11) + i | 0, n = ((n += ((o = ((o += (n ^ ((r = ((r += (i ^ (n | ~o)) + t[8] + 1873313359 | 0) << 6 | r >>> 26) + n | 0) | ~i)) + t[15] - 30611744 | 0) << 10 | o >>> 22) + r | 0) ^ ((i = ((i += (r ^ (o | ~n)) + t[6] - 1560198380 | 0) << 15 | i >>> 17) + o | 0) | ~r)) + t[13] + 1309151649 | 0) << 21 | n >>> 11) + i | 0, n = ((n += ((o = ((o += (n ^ ((r = ((r += (i ^ (n | ~o)) + t[4] - 145523070 | 0) << 6 | r >>> 26) + n | 0) | ~i)) + t[11] - 1120210379 | 0) << 10 | o >>> 22) + r | 0) ^ ((i = ((i += (r ^ (o | ~n)) + t[2] + 718787259 | 0) << 15 | i >>> 17) + o | 0) | ~r)) + t[9] - 343485551 | 0) << 21 | n >>> 11) + i | 0, e[0] = r + e[0] | 0, e[1] = n + e[1] | 0, e[2] = i + e[2] | 0, e[3] = o + e[3] | 0 }, e.prototype.start = function () { return this._dataLength = 0, this._bufferLength = 0, this._state.set(e.stateIdentity), this }, e.prototype.appendStr = function (t) { var r, n, i = this._buffer8, o = this._buffer32, s = this._bufferLength; for (n = 0; n < t.length; n += 1) { if ((r = t.charCodeAt(n)) < 128) i[s++] = r; else if (r < 2048) i[s++] = 192 + (r >>> 6), i[s++] = 63 & r | 128; else if (r < 55296 || r > 56319) i[s++] = 224 + (r >>> 12), i[s++] = r >>> 6 & 63 | 128, i[s++] = 63 & r | 128; else { if ((r = 1024 * (r - 55296) + (t.charCodeAt(++n) - 56320) + 65536) > 1114111) throw new Error("Unicode standard supports code points up to U+10FFFF"); i[s++] = 240 + (r >>> 18), i[s++] = r >>> 12 & 63 | 128, i[s++] = r >>> 6 & 63 | 128, i[s++] = 63 & r | 128 } s >= 64 && (this._dataLength += 64, e._md5cycle(this._state, o), s -= 64, o[0] = o[16]) } return this._bufferLength = s, this }, e.prototype.appendAsciiStr = function (t) { for (var r, n = this._buffer8, i = this._buffer32, o = this._bufferLength, s = 0; ;) { for (r = Math.min(t.length - s, 64 - o); r--;)n[o++] = t.charCodeAt(s++); if (o < 64) break; this._dataLength += 64, e._md5cycle(this._state, i), o = 0 } return this._bufferLength = o, this }, e.prototype.appendByteArray = function (t) { for (var r, n = this._buffer8, i = this._buffer32, o = this._bufferLength, s = 0; ;) { for (r = Math.min(t.length - s, 64 - o); r--;)n[o++] = t[s++]; if (o < 64) break; this._dataLength += 64, e._md5cycle(this._state, i), o = 0 } return this._bufferLength = o, this }, e.prototype.getState = function () { var e = this._state; return { buffer: String.fromCharCode.apply(null, Array.from(this._buffer8)), buflen: this._bufferLength, length: this._dataLength, state: [e[0], e[1], e[2], e[3]] } }, e.prototype.setState = function (e) { var t, r = e.buffer, n = e.state, i = this._state; for (this._dataLength = e.length, this._bufferLength = e.buflen, i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], t = 0; t < r.length; t += 1)this._buffer8[t] = r.charCodeAt(t) }, e.prototype.end = function (t) { void 0 === t && (t = !1); var r = this._bufferLength, n = this._buffer8, i = this._buffer32, o = 1 + (r >> 2); this._dataLength += r; var s = 8 * this._dataLength; if (n[r] = 128, n[r + 1] = n[r + 2] = n[r + 3] = 0, i.set(e.buffer32Identity.subarray(o), o), r > 55 && (e._md5cycle(this._state, i), i.set(e.buffer32Identity)), s <= 4294967295) i[14] = s; else { var a = s.toString(16).match(/(.*?)(.{0,8})$/); if (null === a) return; var c = parseInt(a[2], 16), l = parseInt(a[1], 16) || 0; i[14] = c, i[15] = l } return e._md5cycle(this._state, i), t ? this._state : e._hex(this._state) }, e.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]), e.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), e.hexChars = "0123456789abcdef", e.hexOut = [], e.onePassHasher = new e, e }(); if (t.Md5 = r, "5d41402abc4b2a76b9719d911017c592" !== r.hashStr("hello")) throw new Error("Md5 self test failed.") })); (xe = be) && xe.__esModule && Object.prototype.hasOwnProperty.call(xe, "default") && xe.default; var we = be.Md5, Te = function () { function e() { } return e.generateUUID = function () { var e = (new Date).getTime(); return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function (t) { var r = (e + 16 * Math.random()) % 16 | 0; return e = Math.floor(e / 16), ("x" === t ? r : 3 & r | 8).toString(16) })) }, e.md5 = function (e) { return we.hashStr(e) }, e }(), ke = { serverUrl: "", baseHeader: { Authorization: "APPCODE 9f7297c52bbd42f082331ed620d50653" }, wsUrl: "", chassisUrl: "", queueTaskUrl: "", outlineStatisUrl: "", mapboxToken: "", server: "dev" }, Ce = function () { function e(e) { this.mCmds = new Map, this.isEnableTrackLine = !1, this.mMyWebsocketConnected = !1, this.mMyCmdConnected = !1, this.taskWsError = !1, this.sendRestartTask = !1, this.executeGoHome = !1, this.executeGoHomeCount = 0, this.isUpdateMap = !0, this.isAutoCharge = !0, this.retryCheckStateCount = 15, this.checkStateTimer = null, this.retryWsConnectTimer = null, this.retryRequestCount = 15, this.sendSerialdataTimer = null, this.wsMessageNotReceivedTimer = null, this.updateMapTimer = null, this.sendLaserDataTopicTimer = null, this.worker = null, this.workerConnected = !1, this.requestRetryTime = 1e3, this.bootProgressStateArr = [], this.checkOutChassisRequestResult = !1, this.checkOutChassisRequestTime = null, this.checkOutCloudRequestResult = !1, this.checkOutCloudRequestTime = null, this.mGetRobotSettingsCMD = "", this.checkOutChassisResolveReason = new Map, this.mBaseListener = e, this.retryCheckStateCount = 15, e.getMode() === X.WAN_APP ? this.requestRetryTime = 5e3 : this.requestRetryTime = 1e3 } return e.prototype.isRobotEstimate = function () { return !0 }, e.prototype.connectRobot = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return this.mBaseListener.setCurrentTaskProperty(null, null), [4, this.doConnectRobot(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getCurrentRobotSn = function () { return this.mCurrentRobotId }, e.prototype.destroy = function () { this.worker && (this.worker.postMessage({ type: "stopWS" }), this.worker.terminate(), this.worker = null), null !== this.retryTimer && (clearTimeout(this.retryTimer), this.retryTimer = null), null !== this.checkStateTimer && (clearTimeout(this.checkStateTimer), this.checkStateTimer = null), this.mMyWebsocket && (this.mMyWebsocket.stop(), this.mMyWebsocket = null), this.mMyCmd && (this.mMyCmd.stop(), this.mMyCmd = null), this.mMyWebsocketRetryInfo = null, this.mMyCmdRetryInfo = null, this.retryWsConnectTimer && (clearInterval(this.retryWsConnectTimer), this.retryWsConnectTimer = null), this.mMyDownloadMapState && (this.mMyDownloadMapState.stop(), this.mMyDownloadMapState = null) }, e.prototype.destroyRobotConnect = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { return this.mCurrentRobotId = "", this.worker && (this.worker.postMessage({ type: "stopWS" }), this.worker.terminate(), this.worker = null), null !== this.retryTimer && (clearTimeout(this.retryTimer), this.retryTimer = null), null !== this.checkStateTimer && (clearTimeout(this.checkStateTimer), this.checkStateTimer = null), this.mMyWebsocket && (this.mMyWebsocket.stop(), this.mMyWebsocket = null), this.mMyCmd && (this.mMyCmd.stop(), this.mMyCmd = null), this.mMyWebsocketRetryInfo = null, this.mMyCmdRetryInfo = null, this.retryWsConnectTimer && (clearInterval(this.retryWsConnectTimer), this.retryWsConnectTimer = null), [2, !0] })) })) }, e.prototype.setEnableTrack = function (e) { this.isEnableTrackLine = e }, e.prototype.doConnectRobot = function (e) { return c(this, void 0, Promise, (function () { var t, r, n, i, o, s, a, u, h, d, p, f, m, g, _, y, v, x, b, w, T, k, C = this; return l(this, (function (E) { switch (E.label) { case 0: return t = !1, r = null, n = H.No_Onlines, e && "string" == typeof e.robotId && (n = H.Wrong_ID), i = this.mBaseListener.getMode(), o = { mode: i, serverUrl: this.mBaseListener.getServerUrl(), wsUrl: this.mBaseListener.getWsUrl() }, this.mBaseListener.exportOperationLogger(V, e.robotId, "AXRobotEngin", o, "init-connect-robot"), i !== X.WAN_APP ? [3, 16] : (this.mBaseListener.exportOperationLogger(V, e.robotId, "AXRobotEngin", { mode: i }, "do-connect-robot"), [4, this.requestRobotList(e.robotId)]); case 1: if ((s = E.sent()) && 200 === s.status && s.data && s.data.list) if ((a = s.data.list.length) > 0) { for (u = 0; u < a; u++)if (h = s.data.list[u], e && "string" == typeof e.robotId) { if (h.robotId === e.robotId) { if (r = e.robotId, t = !0, !0 !== h.isOnLine) { if (this.retryCheckStateCount > 0) return this.retryCheckStateCount--, [2, new Promise((function (t, r) { C.checkStateTimer = setTimeout((function () { return c(C, void 0, void 0, (function () { var n, i; return l(this, (function (o) { switch (o.label) { case 0: return o.trys.push([0, 2, , 3]), [4, this.doConnectRobot(e)]; case 1: return n = o.sent(), t(n), [3, 3]; case 2: return i = o.sent(), r(i), [3, 3]; case 3: return [2] } })) })) }), 5e3) }))]; t = !1, n = H.Is_Offline } break } } else if (!0 === h.isOnLine) { t = !0, r = h.robotId; break } } else n = $.Get_RobotDeploy_Fail; else n = H.No_Available; if (this.retryCheckStateCount = 15, d = !1, p = null, !0 !== t) return [3, 15]; E.label = 2; case 2: return E.trys.push([2, 4, , 5]), [4, this.requestRobotDeploy(r)]; case 3: return E.sent(), [3, 5]; case 4: return f = E.sent(), [2, new Promise((function (e, t) { t(f) }))]; case 5: return this.mCurrentRobotId = r, [4, this.startWebSocket(e)]; case 6: return E.sent(), [4, this.startCmdWs()]; case 7: return E.sent(), [4, this.startDownloadMapStateWs()]; case 8: return E.sent(), x = 3e5, e.timeOut && (x = e.timeOut), b = !1, this.mMyWebsocketConnected ? (b = !0, [3, 11]) : [3, 9]; case 9: return [4, this.checkConnect(x)]; case 10: b = E.sent(), E.label = 11; case 11: return m = !1, this.mMyCmdConnected ? (m = !0, [3, 14]) : [3, 12]; case 12: return [4, this.checkControlConnect(x)]; case 13: m = E.sent(), E.label = 14; case 14: !0 === b && !0 === m ? ((n = H.Success).robotId = r, d = !0) : (this.mBaseListener.exportOperationLogger(N, e.robotId, "AXRobotEngin", { mode: i, controlResult: m, result: b }, "do-connect-robot-timeout"), n = H.Ws_Timeout), E.label = 15; case 15: return p = new Promise((function (e, t) { !0 === d ? e(n) : t(n) })), g = { mode: i, error: n }, this.mBaseListener.exportOperationLogger(V, e.robotId, "AXRobotEngin", g, "do-connect-robot"), [2, p]; case 16: return i !== X.LOCAL_APP && i !== X.LAN_APP ? [3, 23] : i !== X.LAN_APP ? [3, 18] : (e && e.robotId && (this.mCurrentRobotId = e.robotId), e && "string" == typeof e.robotIp && "" !== e.robotIp ? (ke.serverUrl = "http://" + e.robotIp + ":9002/", ke.wsUrl = "ws://" + e.robotIp + ":9000/", ke.queueTaskUrl = "http://" + e.robotIp + ":9003/", ke.outlineStatisUrl = "http://" + e.robotIp + ":9004/", _ = "http://" + e.robotIp + ":9001/", [4, this.mBaseListener.setLoggerExportUrl(_)]) : [3, 18]); case 17: E.sent(), e.robotId && delete e.robotId, E.label = 18; case 18: return this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { mode: i }, "do-connect-robot"), [4, this.startWebSocket(e)]; case 19: return E.sent(), y = !1, v = null, this.mCurrentRobotId || this.mMyWebsocketConnected ? ((n = H.Success).robotId = this.mCurrentRobotId, y = !0, [3, 22]) : [3, 20]; case 20: return x = 3e5, e.timeOut && (x = e.timeOut), [4, this.checkConnect(x)]; case 21: !0 === (b = E.sent()) ? ((n = H.Success).robotId = this.mCurrentRobotId, y = !0) : (this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", { mode: i }, "do-connect-robot-timeout"), n = H.Ws_Timeout), E.label = 22; case 22: return v = new Promise((function (e, t) { !0 === y ? e(n) : t(n) })), w = { mode: i, error: n }, this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", w, "do-connect-robot"), [2, v]; case 23: return T = new Promise((function (e, t) { t(H.Sys_UnAvailable) })), k = { mode: i, error: H.Sys_UnAvailable }, this.mBaseListener.exportOperationLogger(G, this.mCurrentRobotId, "AXRobotEngin", k, "do-connect-robot"), [2, T] } })) })) }, e.prototype.initUpdateMap = function () { return c(this, void 0, void 0, (function () { var e, t; return l(this, (function (r) { switch (r.label) { case 0: return this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "init-update-map"), [4, this.getState()]; case 1: return (e = r.sent()) && e.taskObj ? (this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { isTask: !0 }, "init-update-map"), [2]) : [4, this.updateMap()]; case 2: return t = r.sent(), this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { isOk: t }, "init-update-map"), [2] } })) })) }, e.prototype.startWebSocket = function (e) { return c(this, void 0, Promise, (function () { var e, t, r, n, i, o, s = this; return l(this, (function (u) { switch (u.label) { case 0: return this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "start-web-socket"), this.mMyWebsocket && (this.mMyWebsocket.stop(), this.mMyWebsocket = null), this.worker && (this.worker.postMessage({ type: "stopWS" }), this.worker.terminate(), this.worker = null), [4, this.mBaseListener.getTokenKey()]; case 1: if (e = u.sent(), t = this.mBaseListener.getWsUrl() + "robot-control/oversee/" + this.mCurrentRobotId, r = this.mBaseListener.getMode(), n = 1e4, r === X.LOCAL_APP || r === X.LAN_APP) e = void 0, t = this.mBaseListener.getWsUrl(), n = 5e3, "undefined" != typeof Worker && (this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "start-worker-socket"), i = new Blob(["onmessage = (event) => {\n\n    let data = event.data\n    if (data.type === 'initWS') {\n      initWS(data.wsUrl)\n    } else if (data.type === 'sendWS') {\n      sendWS(data.cmd, data.sendType)\n    } else if (data.type === 'stopWS') {\n      stopWS()\n    } else if (data.type === 'closeWS') {\n      closeWS()\n    }\n  }\n\n\n  var _ws = null\n  var _uri = null\n  var _protocol = null\n  var _isStarted = false\n  var _heartTimer = null\n  var _isKeepAlive = true\n  var _retryTimeout = 1000\n  var _heartBeatTime = null\n  var wsMap = new Map()\n\n  // // var _workerMsgTime = new Date().getTime()\n  // var _wsMsgTime = null\n\n  function generateUUID() {\n    var d = new Date().getTime()\n    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = (d + Math.random() * 16) % 16 | 0\n      d = Math.floor(d / 16)\n      return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16)\n    })\n    return uuid\n  }\n\n  function keepAlive(ws) {\n    if (_isKeepAlive === false) return\n    if (_heartTimer !== null) {\n      clearTimeout(_heartTimer)\n      _heartTimer = null\n    }\n    if (!ws) return\n    var timeout = 1000\n    if (ws.readyState === ws.OPEN) {\n      ws.send('{\"reqType\":\"onHeartBeat\"}')\n    }\n    // console.log(_heartBeatTime - new Date().getTime())\n    if(new Date().getTime() - _heartBeatTime > 5000){\n      console.log(\"---worker ws发送心跳检测，5s没有收到反馈，关闭ws，重新连接---\")\n      postMessage({ type: 1 })\n      ws.close()\n    }else{\n      _heartTimer = setTimeout(function () {\n        keepAlive(ws)\n      }, timeout)\n    }\n  }\n\n  function sendWS(cmd, sendType) {\n    if (_ws) {\n      if(sendType !== \"logger\"){\n        if(cmd.timestamp && new Date().getTime() - cmd.timestamp > 10000){\n          console.log(\"send ws cmd ---\" + cmd.cmd + \"---current time less than 10s\")\n          return\n        }\n      }\n      _ws.send(JSON.stringify(cmd))\n    }\n  }\n\n  function stopWS() {\n    if (!_ws) {\n      return\n    }\n    _isStarted = false\n    _ws.close()\n    _ws = null\n  }\n\n  function closeWS() {\n    console.log(\"----------外部调用发起ws关闭操作。-----------\")\n    _ws.close()\n  }\n\n  function initWS(wsUrl, protocol) {\n    _uri = wsUrl\n    _protocol = protocol\n    // console.log(\"init ----- ws\")\n    // 创建 WebSocket 连接\n    if (protocol) {\n      _ws = new WebSocket(wsUrl, protocol)\n    } else {\n      _ws = new WebSocket(wsUrl)\n    }\n    _isStarted = true\n    _ws.binaryType = 'arraybuffer'\n    _heartBeatTime = new Date().getTime()\n    keepAlive(_ws)\n    // 收到消息\n    _ws.onmessage = (evt) => {\n      // console.log(evt)\n      if (typeof (evt.data) === 'string') {\n        let data = JSON.parse(evt.data)\n        if (data.reqType === 'onHeartBeat') {\n          _heartBeatTime = new Date().getTime()\n        }\n        postMessage({ type: 0, data: data })\n      } else {\n        postMessage({ type: 0, data: evt.data })\n      }\n    }\n    // 断开连接\n    _ws.onclose = (evt) => {\n      console.log(evt, 'close')\n      // console.log(new Date().getTime(), 'close')\n      // console.log('------worker ws close------')\n      postMessage({ type: 1 })\n\n      if (_isStarted === false) {\n        return\n      }\n\n      if (_heartTimer !== null) {\n        clearTimeout(_heartTimer)\n        _heartTimer = null\n      }\n\n      setTimeout(() => {\n        // console.log(Date.parse(new Date()), 'retry-start')\n        // console.log('------worker ws retry-start------retryTime: -- ' + _retryTimeout)\n        initWS(_uri, _protocol)\n      }, _retryTimeout)\n    }\n\n    // 打开连接\n    _ws.onopen = (evt) => {\n      // console.log(evt, 'open')\n      // console.log('------worker ws open------')\n      postMessage({ type: 2 })\n    }\n\n    _ws.onerror = (evt) => {\n      console.log(evt, 'onerror')\n      console.log('------worker ws onerror------')\n      postMessage({ type: 3 })\n    }\n  }"]), o = URL.createObjectURL(i), this.worker = new Worker(o)); else if (!e) return [2]; return this.worker ? (this.worker.onmessage = function (e) { var t = e.data; 0 === t.type ? s.responseWs(0, t.data) : 1 === t.type ? (s.workerConnected = !1, s.mBaseListener.getState().then((function (e) { s.mBaseListener.onStateChanged(a(a({}, e), { isDisconnect: !0 })) })), s.mBaseListener.exportOperationLogger(N, s.mCurrentRobotId, "AXRobotEngin", {}, "start-worker-socket-close")) : 2 === t.type && (s.workerConnected = !0, s.worker.postMessage({ type: "sendWS", cmd: { enable_topic: "/robot_state" }, sendType: "enable_topic" }), s.worker.postMessage({ type: "sendWS", cmd: { enable_topic: "/download_map_state" }, sendType: "enable_topic" }), s.worker.postMessage({ type: "sendWS", cmd: { enable_topic: "/laser_state" }, sendType: "enable_topic" }), s.worker.postMessage({ type: "sendWS", cmd: { enable_topic: "/serialdata_state" }, sendType: "enable_topic" }), s.worker.postMessage({ type: "sendWS", cmd: { enable_topic: "/scan_matched_points2" }, sendType: "enable_topic" }), s.worker.postMessage({ type: "sendWS", cmd: { enable_topic: "/boot_progress_state" }, sendType: "enable_topic" }), s.mMyWebsocketRetryInfo && (s.worker.postMessage({ type: "sendWS", cmd: s.mMyWebsocketRetryInfo, sendType: "cmd" }), s.mMyWebsocketRetryInfo = null), s.mBaseListener.exportOperationLogger(V, s.mCurrentRobotId, "AXRobotEngin", {}, "start-worker-socket-success")) }, this.worker.postMessage({ type: "initWS", wsUrl: t }), [3, 4]) : [3, 2]; case 2: return this.mMyWebsocket = new _e, [4, this.mMyWebsocket.start((function (e, t) { return c(s, void 0, void 0, (function () { var n, i, o, s = this; return l(this, (function (a) { switch (a.label) { case 0: return 0 !== e ? [3, 1] : (this.wsMessageNotReceivedTimer && (clearTimeout(this.wsMessageNotReceivedTimer), this.wsMessageNotReceivedTimer = null), this.responseWs(e, t), [3, 6]); case 1: return 2 !== e ? [3, 2] : (this.mMyWebsocketConnected = !0, this.sendRestartTask = !0, (n = this.mBaseListener.getMode()) === X.WAN_APP && this.mCheckConnectFunc && (this.mCheckConnectFunc(), this.mCheckConnectFunc = null), n !== X.LOCAL_APP && n !== X.LAN_APP || (this.mMyWebsocket.send({ enable_topic: "/robot_state" }), this.mMyWebsocket.send({ enable_topic: "/task_state" }), this.mMyWebsocket.send({ enable_topic: "/download_map_state" }), this.mMyWebsocket.send({ enable_topic: "/laser_state" }), this.mMyWebsocket.send({ enable_topic: "/serialdata_state" }), this.mMyWebsocket.send({ enable_topic: "/scan_matched_points2" }), this.mMyWebsocket.send({ enable_topic: "/boot_progress_state" }), this.taskWsError = !1, this.taskWSTimeout && (clearTimeout(this.taskWSTimeout), this.taskWSTimeout = null), this.mMyWebsocketRetryInfo && (this.sendCmd(this.mMyWebsocketRetryInfo), this.mMyWebsocketRetryInfo = null)), this.wsMessageNotReceivedTimer = setTimeout((function () { s.mBaseListener.onStateError(H.Ws_Message_Not_Received) }), 6e4), this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "start-web-socket-success"), [3, 6]); case 2: return 1 !== e ? [3, 6] : (this.mMyWebsocketConnected = !1, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", {}, "start-web-socket-close"), r !== X.LOCAL_APP && r !== X.LAN_APP ? [3, 4] : [4, this.getState()]); case 3: return (i = a.sent()) && i.taskObj && !this.taskWsError && (this.taskWsError = !0, this.taskWSTimeout = setTimeout((function () { s.setTaskChannelFaild(!0, H.Network_Timeout) }), 12e4)), [3, 6]; case 4: return this.mMyWebsocket ? [4, this.mBaseListener.getTokenKey()] : [3, 6]; case 5: if (!(o = a.sent())) return [2]; this.mMyWebsocket.setProtocol(o), a.label = 6; case 6: return [2] } })) })) }), t, e, n, r)]; case 3: u.sent(), u.label = 4; case 4: return [2] } })) })) }, e.prototype.startLaserDataChannel = function () { var e = this; this.mMyWebsocket && this.mMyWebsocketConnected ? (clearInterval(this.sendLaserDataTopicTimer), this.sendLaserDataTopicTimer = null, this.mMyWebsocket.send({ enable_topic: "/laser_state" })) : this.sendLaserDataTopicTimer || (this.sendLaserDataTopicTimer = setInterval((function () { e.startLaserDataChannel() }), 5e3)) }, e.prototype.startSerialDataChannel = function () { var e = this; this.mMyWebsocket && this.mMyWebsocketConnected ? (clearInterval(this.sendSerialdataTimer), this.sendSerialdataTimer = null, this.mMyWebsocket.send({ enable_topic: "/serialdata_state" })) : this.sendSerialdataTimer || (this.sendSerialdataTimer = setInterval((function () { e.startSerialDataChannel() }), 5e3)) }, e.prototype.setTaskChannelFaild = function (e, t) { e && (t ? this.mBaseListener.onTaskError(t) : this.mBaseListener.onTaskError(W.Task_Execute_Failed_By_Network)), this.mBaseListener.exportOperationLogger(G, this.mCurrentRobotId, "AXRobotEngin", {}, "set-state-channel-faild") }, e.prototype.startCmdWs = function () { return c(this, void 0, Promise, (function () { var e, t = this; return l(this, (function (r) { switch (r.label) { case 0: return this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "start-cmd-ws"), this.mMyCmd && (this.mMyCmd.stop(), this.mMyCmd = null), [4, this.mBaseListener.getTokenKey()]; case 1: return (e = r.sent()) ? (this.mMyCmd = new _e, [4, this.mMyCmd.start((function (r, n) { return c(t, void 0, void 0, (function () { var t, i, o; return l(this, (function (s) { switch (s.label) { case 0: return 0 !== r ? [3, 1] : this.mCurrentRobotId && this.mCurrentRobotId === n.deviceId ? (this.mGetRobotSettingsCMD === n.commandId && (t = {}, n.commandData && n.commandData.data && (t = n.commandData.data), this.mBaseListener.onRobotSettingsStateChanged(t)), n.commandId && this.mCmds.has(n.commandId) && (0 === n.code || 1 === n.state ? this.mCmds.get(n.commandId)(n.commandData) : (n.rawConfirm && (i = JSON.parse(n.rawConfirm), n.code = i.code), 5 === n.code ? (K.Update_Map_Failed_By_Updating.robotId = this.mCurrentRobotId, this.mCmds.get(n.commandId + "_failed")(K.Update_Map_Failed_By_Updating)) : 6 === n.code ? (K.Update_Map_Failed_By_Tasking.robotId = this.mCurrentRobotId, this.mCmds.get(n.commandId + "_failed")(K.Update_Map_Failed_By_Tasking)) : 7 === n.code ? (K.Update_Map_Failed_By_Mapping.robotId = this.mCurrentRobotId, this.mCmds.get(n.commandId + "_failed")(K.Update_Map_Failed_By_Mapping)) : this.mCmds.get(n.commandId + "_failed")()), this.mCmds.delete(n.commandId), this.mCmds.delete(n.commandId + "_failed"), "function" == typeof this.mCmds.get(n.commandId + "_timer") && this.mCmds.delete(n.commandId + "_timer")), [3, 4]) : [2]; case 1: return 2 !== r ? [3, 2] : (this.mMyCmdConnected = !0, this.mCheckControlConnectFunc && (this.mCheckControlConnectFunc(), this.mCheckControlConnectFunc = null), this.mMyCmdRetryInfo && (this.sendCmd(this.mMyCmdRetryInfo), this.mMyCmdRetryInfo = null), this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { tokenKey: e }, "start-cmd-ws-success"), [3, 4]); case 2: return 1 !== r ? [3, 4] : (this.mMyCmdConnected = !1, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", { tokenKey: e }, "start-cmd-ws-close"), this.mMyCmd ? [4, this.mBaseListener.getTokenKey()] : [3, 4]); case 3: if (!(o = s.sent())) return [2]; this.mMyCmd.setProtocol(o), s.label = 4; case 4: return [2] } })) })) }), this.mBaseListener.getWsUrl() + "robot-control/control/" + this.mCurrentRobotId, e)]) : [2]; case 2: return r.sent(), [2] } })) })) }, e.prototype.startDownloadMapStateWs = function () { return c(this, void 0, Promise, (function () { var e, t = this; return l(this, (function (r) { switch (r.label) { case 0: return this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "start-download-map-state-ws"), this.mMyDownloadMapState && (this.mMyDownloadMapState.stop(), this.mMyDownloadMapState = null), [4, this.mBaseListener.getTokenKey()]; case 1: return (e = r.sent()) ? (this.mMyDownloadMapState = new _e, [4, this.mMyDownloadMapState.start((function (r, n) { return c(t, void 0, void 0, (function () { var t, i, o, s = this; return l(this, (function (a) { switch (a.label) { case 0: return 0 !== r ? [3, 1] : this.mCurrentRobotId && this.mCurrentRobotId === n.deviceId ? (-1 === n.state ? (this.updateMapTimer && clearTimeout(this.updateMapTimer), this.mBaseListener.onDownloadMapStateChanged(n), this.mOnUpdateMapListener && this.mOnUpdateMapListener.onUpdateStateError && (t = oe[n.errCode] ? oe[n.errCode] : oe[1406], this.mOnUpdateMapListener.onUpdateStateError(t))) : (this.updateMapTimer && (clearTimeout(this.updateMapTimer), this.updateMapTimer = setTimeout((function () { s.mCmds.get(n.commandId + "_timer")() }), 18e4)), this.mBaseListener.onDownloadMapStateChanged(n), this.mOnUpdateMapListener && this.mOnUpdateMapListener.onUpdateStateChanged && (i = { state: -1, topic: "download_map", progress: n.progress, deviceId: n.deviceId }, this.mOnUpdateMapListener.onUpdateStateChanged(i), 100 === n.progress && this.mOnUpdateMapListener.onUpdateStateChanged({ state: 0, topic: "updating_map", deviceId: n.deviceId }))), [3, 4]) : [2]; case 1: return 2 !== r ? [3, 2] : (this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { tokenKey: e }, "start-download-map-state-ws-success"), [3, 4]); case 2: return 1 !== r ? [3, 4] : (this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", { tokenKey: e }, "start-download-map-state-ws-close"), this.mMyDownloadMapState ? [4, this.mBaseListener.getTokenKey()] : [3, 4]); case 3: if (!(o = a.sent())) return [2]; this.mMyDownloadMapState.setProtocol(o), a.label = 4; case 4: return [2] } })) })) }), this.mBaseListener.getWsUrl() + "robot-control/download-map-state/" + this.mCurrentRobotId, e)]) : [2]; case 2: return r.sent(), [2] } })) })) }, e.prototype.checkConnect = function (e) { return c(this, void 0, Promise, (function () { var t = this; return l(this, (function (r) { return [2, new Promise((function (r, n) { var i = setTimeout((function () { r(!1) }), e); t.mCheckConnectFunc = function () { clearTimeout(i), r(!0) } }))] })) })) }, e.prototype.checkControlConnect = function (e) { return c(this, void 0, Promise, (function () { var t = this; return l(this, (function (r) { return [2, new Promise((function (r, n) { var i = setTimeout((function () { r(!1) }), e); t.mCheckControlConnectFunc = function () { clearTimeout(i), r(!0) } }))] })) })) }, e.prototype.checkCmd = function (e, t, r, n) { return c(this, void 0, Promise, (function () { var r = this; return l(this, (function (i) { return [2, new Promise((function (i, o) { var s = null; n ? r.mCmds.set(e + "_timer", (function () { r.mCmds.delete(e), r.mCmds.delete(e + "_failed"), r.mCmds.delete(e + "_timer"), r.mCmds.delete(e + "_timeOut"), r.updateMapTimer = null, K.Update_Map_Failed_By_Timeout.robotId = r.mCurrentRobotId, o(K.Update_Map_Failed_By_Timeout) })) : s = setTimeout((function () { r.mCmds.delete(e), r.mCmds.delete(e + "_failed"), r.mCmds.delete(e + "_timeOut"), i(!1) }), t), r.mCmds.set(e + "_timeOut", (function (n) { s && clearTimeout(s), s = setTimeout((function () { r.mCmds.delete(e), r.mCmds.delete(e + "_failed"), r.mCmds.delete(e + "_timeOut"), i(!1) }), t) })), r.mCmds.set(e, (function (t) { s && clearTimeout(s), r.updateMapTimer && (clearTimeout(r.updateMapTimer), r.updateMapTimer = null), r.mCmds.delete(e), r.mCmds.delete(e + "_failed"), r.mCmds.delete(e + "_timeOut"), t && t.data ? i(t.data) : i(!0) })), r.mCmds.set(e + "_failed", (function (t) { s && clearTimeout(s), r.updateMapTimer && (clearTimeout(r.updateMapTimer), r.updateMapTimer = null), r.mCmds.delete(e), r.mCmds.delete(e + "_failed"), r.mCmds.delete(e + "_timeOut"), t ? o(t) : i(!1) })) }))] })) })) }, e.prototype.sendInfo = function (e) { this.mBaseListener.getMode() !== X.WAN_APP && (this.worker ? this.workerConnected ? this.worker.postMessage({ type: "sendWS", cmd: e, sendType: "cmd" }) : this.mMyWebsocketRetryInfo = e : this.mMyWebsocket && this.mMyWebsocketConnected ? this.mMyWebsocket.send(e) : this.mMyWebsocketRetryInfo = e) }, e.prototype.sendCmd = function (e) { if (this.worker) this.workerConnected ? this.worker.postMessage({ type: "sendWS", cmd: e, sendType: "cmd" }) : this.mMyWebsocketRetryInfo = e; else { var t = this.mBaseListener.getMode(); t === X.WAN_APP ? this.mMyCmd && this.mMyCmdConnected ? this.mMyCmd.send(e) : this.mMyCmdRetryInfo = e : t !== X.LOCAL_APP && t !== X.LAN_APP || (this.mMyWebsocket && this.mMyWebsocketConnected ? this.mMyWebsocket.send(e) : this.mMyWebsocketRetryInfo = e) } }, e.prototype.responseWs = function (e, t, r) { return c(this, void 0, void 0, (function () { var e, n, i, o, s, a = this; return l(this, (function (c) { if (!t) return [2]; if (r || (r = Te.generateUUID()), t.topic) "/serialdata_state" === t.topic && this.mBaseListener.onSerialChanged(t), "/download_map_state" === t.topic && (-1 === t.state ? (this.updateMapTimer && clearTimeout(this.updateMapTimer), this.mBaseListener.onDownloadMapStateChanged(t), this.mOnUpdateMapListener && this.mOnUpdateMapListener.onUpdateStateError && (e = oe[t.errCode] ? oe[t.errCode] : oe[1406], this.mOnUpdateMapListener.onUpdateStateError(e))) : (this.updateMapTimer && (clearTimeout(this.updateMapTimer), this.updateMapTimer = setTimeout((function () { a.mCmds.get(t.commandId + "_timer")() }), 18e4)), this.mCmds && this.mCmds.has(t.commandId + "_timeOut") && this.mCmds.get(t.commandId + "_timeOut")(t), this.mBaseListener.onDownloadMapStateChanged(t), this.mOnUpdateMapListener && this.mOnUpdateMapListener.onUpdateStateChanged && (n = { state: -1, topic: "download_map", progress: t.progress, deviceId: t.deviceId }, this.mOnUpdateMapListener.onUpdateStateChanged(n), 100 === t.progress && this.mOnUpdateMapListener.onUpdateStateChanged({ state: 0, topic: "updating_map", deviceId: t.deviceId })))), "/laser_state" === t.topic && this.mBaseListener.onLaserDataChanged(t), "/scan_matched_points2" === t.topic && this.mBaseListener.onPointCloudDataChanged(t), "/boot_progress_state" === t.topic && (0 === t.progress && (this.bootProgressStateArr = []), this.bootProgressStateArr.push(t), this.mBaseListener.onChassisStartProgressChanged(t)); else if (t.state) { if (this.setMapPose(t.state), i = this.formatStateInfo(t)) { if ((o = this.mBaseListener.getMode()) !== X.LOCAL_APP && o !== X.LAN_APP || !this.mCheckConnectFunc || (this.mCurrentRobotId = i.robotId, this.mCheckConnectFunc(), this.mCheckConnectFunc = null), t.deviceId !== this.mCurrentRobotId) return [2]; this.mCurStateInfo = i, this.mBaseListener.onStateChanged(i) } } else if (t.commandId) { if (!this.mCurrentRobotId || this.mCurrentRobotId !== t.deviceId) return [2]; this.mCmds && this.mCmds.has(t.commandId) && (0 === t.code || 1 === t.state ? this.mCmds.get(t.commandId)(t) : (t.rawConfirm && (s = JSON.parse(t.rawConfirm), t.code = s.code), 5 === t.code ? (K.Update_Map_Failed_By_Updating.robotId = this.mCurrentRobotId, this.mCmds.get(t.commandId + "_failed")(K.Update_Map_Failed_By_Updating)) : 6 === t.code ? (K.Update_Map_Failed_By_Tasking.robotId = this.mCurrentRobotId, this.mCmds.get(t.commandId + "_failed")(K.Update_Map_Failed_By_Tasking)) : 7 === t.code ? (K.Update_Map_Failed_By_Mapping.robotId = this.mCurrentRobotId, this.mCmds.get(t.commandId + "_failed")(K.Update_Map_Failed_By_Mapping)) : this.mCmds.get(t.commandId + "_failed")()), this.mCmds.delete(t.commandId), this.mCmds.delete(t.commandId + "_failed"), "function" == typeof this.mCmds.get(t.commandId + "_timer") && this.mCmds.delete(t.commandId + "_timer")) } else "number" == typeof t.actType && (this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXRobotEngin", t, "response-ws"), this.mBaseListener.receiveTaskState(t)); return [2] })) })) }, e.prototype.formatStateInfo = function (e) { try { var t = [], r = []; if (e.state.errors) { for (var n = e.state.errors.length, i = 0; i < n; i++) { var o = e.state.errors[i]; o.code ? (ne[o.code] && (o.priority = !0), t.push(o.code)) : t.push(o) } n > 0 && (r = r.concat(e.state.errors)) } !0 === this.isEnableTrackLine && e.state.path && "object" == typeof e.state.path && "object" == typeof e.state.path.positions ? (this.mTrackLineId || (this.mTrackLineId = Te.generateUUID()), this.mBaseListener.trackLine(this.mTrackLineId, e.state.path.positions, { color: "#ff0000" })) : this.mTrackLineId && (this.mBaseListener.deleteFeature(this.mTrackLineId), this.mTrackLineId = null); var s = !1; e.state && "object" == typeof e.state.taskObj && (s = !0); var a = ""; "string" == typeof e.moveState ? a = e.moveState : "string" == typeof e.state.moveState && (a = e.state.moveState), e.state && e.state.taskObj && e.state.taskObj.taskId && this.mBaseListener.setCurrentTaskProperty(e.state.taskObj.taskId, e.state.taskObj.taskType); var c = ""; "string" == typeof e.state.moveCreator && (c = e.state.moveCreator); var l = ""; "string" == typeof e.state.stuckState && (l = e.state.stuckState); var u = { isManualMode: e.state.isManualMode, isTasking: s, isCharging: e.state.isCharging, isRemoteMode: e.state.isRemoteMode, battery: e.state.battery, robotId: e.deviceId, speed: e.state.speed, yaw: e.state.yaw, areaId: e.state.floorId, x: e.state.x, isEmergencyStop: e.state.isEmergencyStop, y: e.state.y, locQuality: e.state.locQuality, hasObstruction: e.state.hasObstruction, errors: t, chassisErrors: r, isGoHome: e.state.isGoHome, vers: e.state.vers, moveState: a, timestamp: e.timestamp, taskObj: e.state.taskObj, cancelTaskId: e.state.cancelTaskId, dispatch: e.state.dispatch, moveCreator: c, stuckState: l, jackProgress: e.state.jackProgress || 0, isOnLine: this.mBaseListener.getMode() !== X.WAN_APP || !e.isHttpGet || e.state.isOnline, path: e.state.path, isWheelsReleased: e.state.isWheelsReleased, isFrontBumperPressed: e.state.isFrontBumperPressed || !1, isRearBumperPressed: e.state.isRearBumperPressed || !1, isWaitingForDest: e.state.isWaitingForDest || !1, businessId: e.state.businessId, enableRcs: e.state.enableRcs, pushHandleMode: e.state.pushHandleMode, robotSignal: e.state.robotSignal, followData: e.state.followData, isDeviceLocked: e.state.isDeviceLocked || !1 }; return void 0 !== e.state.voicePercent && (u.voicePercent = e.state.voicePercent), u } catch (e) { } return null }, e.prototype.setMapPose = function (e) { "number" == typeof e.x && (this.mCurrentMapPose = { x: e.x, y: e.y, yaw: e.yaw, areaId: e.areaId || e.floorId }) }, e.prototype.getStateToStateChanged = function () { return c(this, void 0, void 0, (function () { var e, t, r; return l(this, (function (n) { switch (n.label) { case 0: return n.trys.push([0, 2, , 3]), [4, this.getState()]; case 1: return (e = n.sent()).floorId = e.areaId, t = this.formatStateInfo({ state: e, isHttpGet: !0, deviceId: e.robotId }), this.mCurStateInfo = t, this.mBaseListener.onStateChanged(t), [3, 3]; case 2: return r = n.sent(), console.log("e", r), [3, 3]; case 3: return [2] } })) })) }, e.prototype.getState = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: if (this.mCurStateInfo && this.mCurrentRobotId === e) return [2, this.mCurStateInfo]; r = null, u.label = 1; case 1: if (u.trys.push([1, 8, , 16]), this.mBaseListener.getMode() === X.WAN_APP) { if (e || (e = this.mCurrentRobotId), !e) return [2, null] } else e || (e = this.mCurrentRobotId), e || (e = "88888888"), console.log("------------robotId-", e); return [4, this.checkChassisNetWork()]; case 2: return u.sent() ? (this.mBaseListener.exportOperationLogger(V, e, "AXRobotEngin", {}, "request-get-state"), [4, this.mBaseListener.getHeader()]) : [2, new Promise((function (e, t) { t($.Get_State_Fail) }))]; case 3: return n = u.sent(), this.mBaseListener.getMode() !== X.WAN_APP ? [3, 5] : [4, de.get("".concat(this.mBaseListener.getServerUrl(), "robot/v2.0/").concat(e, "/state?realTime=true"), { headers: n })]; case 4: return r = u.sent(), [3, 7]; case 5: return [4, de.get("".concat(this.mBaseListener.getServerUrl(), "robot/v1.1/").concat(e, "/state"), { headers: n })]; case 6: r = u.sent(), u.label = 7; case 7: return this.mBaseListener.exportOperationLogger(V, e, "AXRobotEngin", { resData: r ? r.data : null }, "response-get-state-end"), [3, 16]; case 8: return i = u.sent(), this.mBaseListener.exportOperationLogger(N, e, "AXRobotEngin", { error: i }, "request-get-state-error"), o = null, i.response && 404 === i.response.status ? (o = new Promise((function (e, t) { t($.Get_State_Fail_404) })), [3, 15]) : [3, 9]; case 9: return i.response && 401 === i.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 14]; case 10: if (u.sent()) return [2, o = new Promise((function (e, t) { t(Q.Token_401) }))]; u.label = 11; case 11: return u.trys.push([11, 13, , 14]), [4, this.mBaseListener.requestAuth()]; case 12: return u.sent(), [3, 14]; case 13: return u.sent(), [2, o = new Promise((function (e, t) { t($.Get_State_Fail) }))]; case 14: if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getState(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; o = new Promise((function (e, t) { t($.Get_State_Fail) })), u.label = 15; case 15: return [2, o]; case 16: return r && r.data && 200 === r.data.status ? (this.setMapPose(r.data.data), s = !1, "object" == typeof r.data.data.taskObj && (s = !0), r.data.data.isTasking = s, [2, r.data.data]) : (this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", { resData: r ? r.data : null }, "request-get-state-error"), [2, null]) } })) })) }, e.prototype.getRobotList = function (e, t) { return c(this, void 0, Promise, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.requestRobotList("", e, t)]; case 1: return (r = n.sent()) && 200 === r.status && r.data ? [2, r.data.list] : [2, $.Get_RobotList_Fail] } })) })) }, e.prototype.requestRobotList = function (e, t, r) { return c(this, void 0, Promise, (function () { var n, i, o, s, a; return l(this, (function (c) { switch (c.label) { case 0: n = null, i = {}, c.label = 1; case 1: return c.trys.push([1, 4, , 7]), "string" == typeof e && "" !== e && (i.keyWord = e), "string" == typeof t && "" !== t && (i.busiIds = [t]), "string" == typeof r && "" !== r && (i.areaId = r), this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { params: i }, "request-robot-list"), [4, this.mBaseListener.getHeader()]; case 2: return o = c.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "robot/v1.1/list?robotSn=").concat(this.mCurrentRobotId), i, { headers: o })]; case 3: return n = c.sent(), this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { resData: n ? n.data : null }, "response-robot-list-end"), [3, 7]; case 4: return (s = c.sent()) && s.response && 401 === s.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 6]; case 5: if (c.sent()) return [2, new Promise((function (e, t) { t(Q.Token_401) }))]; c.label = 6; case 6: return a = { params: i, error: s }, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", a, "request-robot-list-error"), [3, 7]; case 7: return n && n.data ? [2, new Promise((function (e) { e(n.data) }))] : [2, null] } })) })) }, e.prototype.resetPose = function (e, t, r) { return void 0 === t && (t = !0), void 0 === r && (r = 15), c(this, void 0, Promise, (function () { var n, i, o, s; return l(this, (function (a) { switch (a.label) { case 0: return "object" != typeof e ? [2, new Promise((function (e, t) { Y.Param_type_is_object.errText = "mapPose " + Y.Param_type_is_object.errText, t(Y.Param_type_is_object) }))] : "number" != typeof e.x ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "x " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : "number" != typeof e.y ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "y " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : "number" != typeof e.yaw ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "yaw " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : (n = null, e.areaId && "" !== e.areaId && (n = e.areaId), n ? ((i = { x: 0, y: 0, yaw: 0, mapId: n, type: 0 }).x = e.x, i.y = e.y, i.yaw = e.yaw, "number" == typeof e.angle && (i.yaw = e.angle), !1 === t && (i.type = 1), o = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "resetMap", args: i, needConfirm: !0, timeoutSec: r, timestamp: (new Date).getTime() }, this.sendCmd(o), [4, this.checkCmd(o.id, 1e3 * r)]) : [2, !1]); case 1: return s = a.sent(), this.setLogger(o.id, s, "reset-pose"), [2, s] } })) })) }, e.prototype.setEmergency = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return "number" != typeof e ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "type " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : e !== j.Start && e !== j.Stop ? [2, !1] : (r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "setEmergency", args: { type: e }, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]); case 1: return n = i.sent(), this.setLogger(r.id, n, "set-emergency"), [2, n] } })) })) }, e.prototype.updateMap = function (e, t, r) { return void 0 === r && (r = 90), c(this, void 0, Promise, (function () { var n, i, o, s = this; return l(this, (function (a) { switch (a.label) { case 0: return n = {}, "boolean" == typeof e ? !1 === e ? n = { syncCloud: !1 } : !0 === e && (n = { syncCloud: !0 }) : n = void 0 === e ? {} : e, n || (n = {}), i = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "updateMap", args: n, needConfirm: !0, timeoutSec: r, timestamp: (new Date).getTime() }, this.sendCmd(i), t && (this.updateMapTimer = setTimeout((function () { s.mCmds.get(i.id + "_timer")() }), 1e3 * r)), [4, this.checkCmd(i.id, 1e3 * r, null, t)]; case 1: return o = a.sent(), this.setLogger(i.id, o, "update-map"), [2, o] } })) })) }, e.prototype.restartRobot = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r; return l(this, (function (n) { switch (n.label) { case 0: return t = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "restartRobot", args: {}, timeoutSec: e, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(t), [4, this.checkCmd(t.id, 1e3 * e)]; case 1: return r = n.sent(), this.setLogger(t.id, r, "restart-robot"), [2, r] } })) })) }, e.prototype.goHome = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return "object" != typeof e ? [2, new Promise((function (e, t) { Y.Param_type_is_object.errText = "pose " + Y.Param_type_is_object.errText, t(Y.Param_type_is_object) }))] : "number" != typeof e.x ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "x " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : "number" != typeof e.y ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "y " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : "number" != typeof e.yaw ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "yaw " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : (r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "goHome", args: { x: e.x, y: e.y, yaw: e.yaw, tryNum: 10 }, needConfirm: !0, timeoutSec: t, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]); case 1: return n = i.sent(), this.setLogger(r.id, n, "go-home"), [2, n] } })) })) }, e.prototype.openSprayer = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return "number" != typeof e || e < 1 || e > 5 ? [2, !1] : [4, this.setGearType(parseInt(e.toFixed(0)), t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.closeSprayer = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.setGearType(0, e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.setGearType = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return "number" != typeof e ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "gear " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : (r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "setGearType", args: { type: e }, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]); case 1: return n = i.sent(), this.setLogger(r.id, n, "set-gear-type"), [2, n] } })) })) }, e.prototype.openBoxDoor = function (e, t, r) { return c(this, void 0, Promise, (function () { var n, i; return l(this, (function (o) { switch (o.label) { case 0: return [4, this.operationBoxDoor(e, t, "openBoxDoor", r)]; case 1: return n = o.sent(), this.mBaseListener.getCurrentTaskProperty().taskId && (i = this.mBaseListener.getCurrentTaskProperty().taskType, this.mBaseListener.exportTaskLogger(1, i, { deviceId: this.mCurrentRobotId }, "openBoxDoor")), [2, n] } })) })) }, e.prototype.closeBoxDoor = function (e, t, r) { return c(this, void 0, Promise, (function () { var n, i; return l(this, (function (o) { switch (o.label) { case 0: return [4, this.operationBoxDoor(e, t, "closeBoxDoor", r)]; case 1: return n = o.sent(), this.mBaseListener.getCurrentTaskProperty().taskId && (i = this.mBaseListener.getCurrentTaskProperty().taskType, this.mBaseListener.exportTaskLogger(1, i, { deviceId: this.mCurrentRobotId }, "openBoxDoor")), [2, n] } })) })) }, e.prototype.openLightBelt = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.operationLightBelt(e, "openLightBelt", t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.closeLightBelt = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.operationLightBelt(e, "closeLightBelt", t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.operationBoxDoor = function (e, t, r, n) { return void 0 === n && (n = 15), c(this, void 0, Promise, (function () { var i, o, s; return l(this, (function (a) { switch (a.label) { case 0: return i = 1, "number" == typeof t && (i = parseInt(t.toFixed(0)), -1 === [1, 2, 3].indexOf(i)) ? [2, !1] : (i = this.mBaseListener.getActionMode(i), o = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: r, args: { mode: i, doorIds: e }, timeoutSec: n, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(o), [4, this.checkCmd(o.id, 1e3 * n)]); case 1: return s = a.sent(), this.setLogger(o.id, s, "operation-box-door"), [2, s] } })) })) }, e.prototype.operationLightBelt = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, Promise, (function () { var n, i; return l(this, (function (o) { switch (o.label) { case 0: return "number" != typeof e.mode && (e.mode = 1), -1 === [1, 2, 3].indexOf(e.mode) ? [2, !1] : (e.mode = this.mBaseListener.getActionMode(e.mode), n = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: t, args: e, timeoutSec: r, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(n), [4, this.checkCmd(n.id, 1e3 * r)]); case 1: return i = o.sent(), this.setLogger(n.id, i, "operation-light-belt"), [2, i] } })) })) }, e.prototype.setVolume = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, Promise, (function () { var n, i, o; return l(this, (function (s) { switch (s.label) { case 0: return "number" != typeof e ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "volume " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : (n = 1, "number" == typeof t && -1 !== [1, 2, 3].indexOf(t) && (n = t), n = this.mBaseListener.getActionMode(n), i = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "setVoice", args: { type: e, mode: n }, timeoutSec: r, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(i), [4, this.checkCmd(i.id, 1e3 * r)]); case 1: return o = s.sent(), this.setLogger(i.id, o, "set-volume"), [2, o] } })) })) }, e.prototype.setSpeed = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return "number" != typeof e ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "speed " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : (r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "setSpeed", args: { type: "set", speed: e }, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]); case 1: return n = i.sent(), this.setLogger(r.id, n, "set-speed"), [2, n] } })) })) }, e.prototype.stopPlayAudio = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return "number" != typeof e ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "mode " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : (r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "stopPlayAudio", args: { mode: e }, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]); case 1: return n = i.sent(), this.setLogger(r.id, n, "stop-play-audio"), [2, n] } })) })) }, e.prototype.removeWheelOverload = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r; return l(this, (function (n) { switch (n.label) { case 0: return t = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "removeWheelOverload", args: {}, timeoutSec: e, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(t), [4, this.checkCmd(t.id, 1e3 * e)]; case 1: return r = n.sent(), this.setLogger(t.id, r, "set-move-mode"), [2, r] } })) })) }, e.prototype.setLanguage = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i; return l(this, (function (o) { switch (o.label) { case 0: return r = { language: 1 }, 1 == e.length ? r.language = e : r = e, n = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "setLanguage", args: r, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(n), [4, this.checkCmd(n.id, 1e3 * t)]; case 1: return i = o.sent(), this.setLogger(n.id, i, "set-language"), [2, i] } })) })) }, e.prototype.setWifi = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, Promise, (function () { var n, i; return l(this, (function (o) { switch (o.label) { case 0: return "string" != typeof e ? [2, new Promise((function (e, t) { Y.Param_type_is_string.errText = "ssid " + Y.Param_type_is_string.errText, t(Y.Param_type_is_string) }))] : "string" != typeof t ? [2, new Promise((function (e, t) { Y.Param_type_is_string.errText = "password " + Y.Param_type_is_string.errText, t(Y.Param_type_is_string) }))] : (n = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "setWifi", args: { ssid: e, password: t }, timeoutSec: r, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(n), [4, this.checkCmd(n.id, 1e3 * r)]); case 1: return i = o.sent(), this.setLogger(n.id, i, "set-wifi"), [2, i] } })) })) }, e.prototype.switchUpdateMap = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { return this.isUpdateMap = e, [2, !0] })) })) }, e.prototype.switchAutoCharge = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { return this.isAutoCharge = e, [2, !0] })) })) }, e.prototype.setServerInfo = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return "string" != typeof e ? [2, new Promise((function (e, t) { Y.Param_type_is_string.errText = "ip " + Y.Param_type_is_string.errText, t(Y.Param_type_is_string) }))] : "number" != typeof t ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "type " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : [4, this.setServerMsg(e, t, 0, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.setServerInfos = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return "object" != typeof e ? [2, new Promise((function (e, t) { Y.Param_type_is_object.errText = "serverInfo " + Y.Param_type_is_object.errText, t(Y.Param_type_is_object) }))] : "string" != typeof e.ip ? [2, new Promise((function (e, t) { Y.Param_type_is_string.errText = "ip " + Y.Param_type_is_string.errText, t(Y.Param_type_is_string) }))] : "number" != typeof e.type ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "type " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : "number" != typeof e.offline ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "offline " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : [4, this.setServerMsg(e.ip, e.type, e.offline, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.setServerMsg = function (e, t, r, n) { return void 0 === n && (n = 90), c(this, void 0, Promise, (function () { var i, o; return l(this, (function (s) { switch (s.label) { case 0: return i = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "setServerInfo", args: { ip: e, type: t, offline: r }, timeoutSec: n, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(i), [4, this.checkCmd(i.id, 1e3 * n)]; case 1: return o = s.sent(), this.setLogger(i.id, o, "set-server-info"), [2, new Promise((function (e, t) { setTimeout((function () { e(o) }), 1e3) }))] } })) })) }, e.prototype.setPlayAudio = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "startPlayAudio", args: e, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]; case 1: return n = i.sent(), this.setLogger(r.id, n, "set-play-audio"), [2, n] } })) })) }, e.prototype.setGlobalPosition = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r; return l(this, (function (n) { switch (n.label) { case 0: return t = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "startGlobalPos", args: {}, timeoutSec: e, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(t), [4, this.checkCmd(t.id, 1e3 * e)]; case 1: return r = n.sent(), this.setLogger(t.id, r, "set-global-position"), [2, r] } })) })) }, e.prototype.setRouteMode = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return "number" != typeof e ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "mode " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : (r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "setRouteMode", args: { mode: e }, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]); case 1: return n = i.sent(), this.setLogger(r.id, n, "set-route-mode"), [2, n] } })) })) }, e.prototype.getRouteMode = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r, n, i, o, s = this; return l(this, (function (a) { switch (a.label) { case 0: return [4, this.checkChassisNetWork()]; case 1: if (!a.sent()) return [2, new Promise((function (e, t) { t($.Get_Wifi_State_Fail) }))]; if (this.mBaseListener.getMode() === X.WAN_APP) return [2, new Promise((function (e, t) { t($.Get_Wifi_State_Fail) }))]; t = null, a.label = 2; case 2: return a.trys.push([2, 4, , 5]), r = ke.chassisUrl + "wifi_state", this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "request-get-robot-mode"), [4, de.get(r)]; case 3: return t = a.sent(), this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { resData: t ? t.data : null }, "response-get-robot-mode-end"), [3, 5]; case 4: if (n = a.sent(), i = { error: n }, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", i, "request-get-robot-mode-error"), o = null, n.response && 404 === n.response.status) o = new Promise((function (e, t) { t($.Get_Wifi_State_Fail_404) })); else { if (e > 0) return e--, [2, new Promise((function (t, r) { s.retryTimer = setTimeout((function () { return c(s, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.getRouteMode(e)]; case 1: return r = n.sent(), t(r), [2] } })) })) }), s.requestRetryTime) }))]; o = new Promise((function (e, t) { t($.Get_Wifi_State_Fail) })) } return [2, o]; case 5: return t && t.data && t.data.data && 0 === t.data.code ? [2, t.data.data.wifi_info.route_mode] : [2, o = new Promise((function (e, t) { t($.Get_Wifi_State_Fail) }))] } })) })) }, e.prototype.setLogger = function (e, t, r) { var n = { cmdId: e, isOk: t }; this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", n, r) }, e.prototype.requestRobotDeploy = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.checkCloudNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Deploy_Fail) }))]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 13]), e || (e = this.mCurrentRobotId), this.mBaseListener.exportOperationLogger(V, e, "AXRobotEngin", {}, "request-robot-deploy"), [4, this.mBaseListener.getToken(X.WAN_APP)]; case 3: return n = u.sent(), [4, de.get("".concat(this.mBaseListener.getWANServerUrl(), "map/v1.1/robot/").concat(e, "/deploy?robotSn=").concat(e), { headers: { "X-Token": n } })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, e, "AXRobotEngin", { resData: r ? r.data : null }, "response-robot-deploy-end"), [3, 13]; case 5: return i = u.sent(), o = { error: i }, this.mBaseListener.exportOperationLogger(N, e, "AXRobotEngin", o, "request-robot-deploy-error"), s = null, i.response && 404 === i.response.status ? (s = new Promise((function (e, t) { t($.Get_Deploy_Fail_404) })), [3, 12]) : [3, 6]; case 6: return i.response && 401 === i.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (u.sent()) return [2, s = new Promise((function (e, t) { t(Q.Token_401) }))]; u.label = 8; case 8: return u.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return u.sent(), [3, 11]; case 10: return u.sent(), [2, s = new Promise((function (e, t) { t($.Get_Deploy_Fail) }))]; case 11: if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.requestRobotDeploy(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Deploy_Fail) })), u.label = 12; case 12: return [2, s]; case 13: return r && r.data && r.data.data && "-1" !== r.data.data.deployState ? [2, r.data.data.businessId] : [2, s = new Promise((function (e, t) { t($.Get_RobotDeploy_Fail) }))] } })) })) }, e.prototype.checkCloudNetWork = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r, n, i, o; return l(this, (function (s) { switch (s.label) { case 0: return s.trys.push([0, 3, , 9]), this.checkOutCloudRequestResult && this.checkOutCloudRequestTime && (new Date).getTime() - this.checkOutCloudRequestTime <= 15e3 ? [2, new Promise((function (e, t) { e(!0) }))] : (this.checkOutCloudRequestTime = (new Date).getTime(), [4, this.mBaseListener.getToken(X.WAN_APP)]); case 1: return t = s.sent(), r = {}, t && (r = { "X-Token": t }), [4, de.get("".concat(this.mBaseListener.getWANServerUrl(), "map/v1.1/area/888888"), { timeout: 1e3, headers: r })]; case 2: return s.sent(), this.checkOutCloudRequestResult = !0, [2, new Promise((function (e, t) { e(!0) }))]; case 3: return n = s.sent(), i = { error: n, getWANServerUrl: this.mBaseListener.getWANServerUrl() }, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", i, "request-check-cloud-network-error"), o = null, n.response && 404 === n.response.status ? (this.checkOutCloudRequestResult = !0, o = new Promise((function (e, t) { e(!0) })), [3, 8]) : [3, 4]; case 4: return n.response && 401 === n.response.status ? (this.checkOutCloudRequestResult = !0, o = new Promise((function (e, t) { e(!0) })), [3, 8]) : [3, 5]; case 5: return e > 0 ? (--e, this.checkOutCloudRequestResult = !1, [4, this.checkCloudNetWork(e)]) : [3, 7]; case 6: return [2, s.sent()]; case 7: this.checkOutCloudRequestResult = !1, o = new Promise((function (e, t) { e(!1) })), s.label = 8; case 8: return [2, o]; case 9: return [2] } })) })) }, e.prototype.clearSystemDownAlert = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r; return l(this, (function (n) { switch (n.label) { case 0: return t = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "clearSystemDownAlert", args: {}, timeoutSec: e, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(t), [4, this.checkCmd(t.id, 1e3 * e)]; case 1: return r = n.sent(), this.setLogger(t.id, r, "clear-system-down-alert"), [2, r] } })) })) }, e.prototype.getRouteInfo = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r, n, i, o, s = this; return l(this, (function (a) { switch (a.label) { case 0: return [4, this.checkChassisNetWork()]; case 1: if (!a.sent()) return [2, new Promise((function (e, t) { t($.Get_Wifi_State_Fail) }))]; if (this.mBaseListener.getMode() === X.WAN_APP) return [2, new Promise((function (e, t) { t($.Get_Wifi_State_Fail) }))]; t = null, a.label = 2; case 2: return a.trys.push([2, 4, , 5]), r = ke.chassisUrl + "wifi_state", this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "request-get-robot-info"), [4, de.get(r)]; case 3: return t = a.sent(), this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { resData: t ? t.data : null }, "response-get-robot-info-end"), [3, 5]; case 4: if (n = a.sent(), i = { error: n }, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", i, "request-get-robot-info-error"), o = null, n.response && 404 === n.response.status) o = new Promise((function (e, t) { t($.Get_Wifi_State_Fail_404) })); else { if (e > 0) return e--, [2, new Promise((function (t, r) { s.retryTimer = setTimeout((function () { return c(s, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.getRouteMode(e)]; case 1: return r = n.sent(), t(r), [2] } })) })) }), s.requestRetryTime) }))]; o = new Promise((function (e, t) { t($.Get_Wifi_State_Fail) })) } return [2, o]; case 5: return t && t.data && t.data.data && 0 === t.data.code ? [2, t.data.data] : [2, o = new Promise((function (e, t) { t($.Get_Wifi_State_Fail) }))] } })) })) }, e.prototype.checkOutChassisRequest = function (e) { return void 0 === e && (e = 15), c(this, void 0, void 0, (function () { var t, r, n, i = this; return l(this, (function (o) { switch (o.label) { case 0: return o.trys.push([0, 2, , 3]), this.checkOutChassisResolveReason.set((new Date).getTime(), (function (e) { return e })), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "robot/v1.1/robot_state"), { timeout: 1e3 })]; case 1: return o.sent(), this.checkOutChassisRequestResult = !0, [2, new Promise((function (e, t) { e(!0) }))]; case 2: if (t = o.sent(), r = { error: t }, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", r, "request-check-chassis-network-error"), n = null, t.response && 404 === t.response.status) this.checkOutChassisRequestResult = !0, n = new Promise((function (e, t) { e(!0) })); else { if (e > 0) return --e, [2, new Promise((function (t) { return c(i, void 0, void 0, (function () { var r = this; return l(this, (function (n) { return setTimeout((function () { r.checkOutChassisRequest(e).then(t) }), 1e3), [2] })) })) }))]; this.checkOutChassisRequestResult = !1, this.mBaseListener.onStateError(H.Chassis_Network_Timeout), n = new Promise((function (e, t) { e(!1) })) } return [2, n]; case 3: return [2] } })) })) }, e.prototype.checkChassisNetWork = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r, n, i, o, s = this; return l(this, (function (a) { switch (a.label) { case 0: return this.mBaseListener.getMode() === X.WAN_APP || this.checkOutChassisRequestResult && this.checkOutChassisRequestTime && (new Date).getTime() - this.checkOutChassisRequestTime <= 15e3 ? [2, new Promise((function (e, t) { e(!0) }))] : (this.checkOutChassisRequestTime = (new Date).getTime(), this.checkOutChassisResolveReason.size ? [2, new Promise((function (e, t) { s.checkOutChassisResolveReason.set((new Date).getTime(), e) }))] : [3, 1]); case 1: return [4, this.checkOutChassisRequest(e)]; case 2: for (t = a.sent(), r = 0, n = this.checkOutChassisResolveReason.entries(); r < n.length; r++)i = n[r], o = i[0], (0, i[1])(t), this.checkOutChassisResolveReason.delete(o); return this.checkOutChassisResolveReason.clear(), [2, t] } })) })) }, e.prototype.checkChassisNetWorkOld = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r, n; return l(this, (function (i) { switch (i.label) { case 0: return i.trys.push([0, 2, , 7]), this.mBaseListener.getMode() === X.WAN_APP || (this.checkOutChassisRequestResult || this.checkOutChassisRequestTime) && (new Date).getTime() - this.checkOutChassisRequestTime <= 15 ? [2, new Promise((function (e, t) { e(!0) }))] : (this.checkOutChassisRequestTime = (new Date).getTime(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "robot/v1.1/robot_state"), { timeout: 1e3 })]); case 1: return i.sent(), this.checkOutChassisRequestResult = !0, [2, new Promise((function (e, t) { e(!0) }))]; case 2: return t = i.sent(), r = { error: t }, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", r, "request-check-chassis-network-error"), n = null, t.response && 404 === t.response.status ? (this.checkOutChassisRequestResult = !0, n = new Promise((function (e, t) { e(!0) })), [3, 6]) : [3, 3]; case 3: return e > 0 ? (--e, [4, this.checkChassisNetWork(e)]) : [3, 5]; case 4: return [2, i.sent()]; case 5: this.checkOutChassisRequestResult = !1, this.mBaseListener.onStateError(H.Chassis_Network_Timeout), n = new Promise((function (e, t) { e(!1) })), i.label = 6; case 6: return [2, n]; case 7: return [2] } })) })) }, e.prototype.getAreaCompareList = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r, n, i, o = this; return l(this, (function (s) { switch (s.label) { case 0: return this.mBaseListener.getMode() === X.WAN_APP ? [2, null] : [4, this.checkChassisNetWork()]; case 1: if (!s.sent()) return [2, new Promise((function (e, t) { t($.Get_Area_Compare_List_Fail) }))]; t = null, s.label = 2; case 2: return s.trys.push([2, 4, , 5]), this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "request-get-area-compare-list"), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "robot-api/axApi/compare/area/list?robotSn=").concat(this.mCurrentRobotId))]; case 3: return t = s.sent(), this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { resData: t ? t.data : null }, "response-get-area-compare-list-end"), [3, 5]; case 4: if (r = s.sent(), n = { error: r }, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", n, "request-get-area-compare-list-error"), i = null, r.response && 404 === r.response.status) i = new Promise((function (e, t) { t($.Get_Area_Compare_List_Fail_404) })); else { if (e > 0) return e--, [2, new Promise((function (t, r) { o.retryTimer = setTimeout((function () { return c(o, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.getAreaCompareList(e)]; case 1: return r = n.sent(), t(r), [2] } })) })) }), o.requestRetryTime) }))]; i = new Promise((function (e, t) { t($.Get_Area_Compare_List_Fail) })) } return [2, i]; case 5: return t && t.data && t.data.data && 200 === t.data.status ? [2, t.data.data] : (n = { error: t }, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", n, "request-get-area-compare-list-error"), t && t.data && t.data.message && ($.Get_Area_Compare_List_Fail_408.errText = t.data.message), [2, i = new Promise((function (e, t) { t($.Get_Area_Compare_List_Fail_408) }))]) } })) })) }, e.prototype.sendSyncMapData = function (e, t) { return void 0 === t && (t = 90), c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "syncMapData", args: { syncMaps: e.syncMaps, delCloudIds: e.delCloudIds, delLocalIds: e.delLocalIds, recoverLocalIds: e.recoverLocalIds, recoverCloudIds: e.recoverCloudIds }, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]; case 1: return n = i.sent(), this.setLogger(r.id, n, "send-sync-map-data"), [2, n] } })) })) }, e.prototype.shutdownRobot = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r; return l(this, (function (n) { switch (n.label) { case 0: return t = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "shutdownRobot", args: {}, timeoutSec: e, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(t), [4, this.checkCmd(t.id, 1e3 * e)]; case 1: return r = n.sent(), this.setLogger(t.id, r, "shutdown-robot"), [2, r] } })) })) }, e.prototype.recordBag = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r; return l(this, (function (n) { switch (n.label) { case 0: return t = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "recordBag", args: {}, timeoutSec: e, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(t), [4, this.checkCmd(t.id, 1e3 * e)]; case 1: return r = n.sent(), this.setLogger(t.id, r, "record-bag"), [2, r] } })) })) }, e.prototype.setJackAction = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return "number" != typeof e ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "action " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : (r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "startJacking", args: { type: e }, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]); case 1: return n = i.sent(), this.setLogger(r.id, n, "set-jack-action"), [2, n] } })) })) }, e.prototype.getChassisStartProgress = function () { return this.bootProgressStateArr }, e.prototype.setSmoothLevel = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return "number" != typeof e ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "type " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : (r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "setSmoothLevel", args: { type: e }, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]); case 1: return n = i.sent(), this.setLogger(r.id, n, "set-smooth-level"), [2, n] } })) })) }, e.prototype.setBumpTolerance = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return "number" != typeof e ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "tolerance " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : (r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "setBumpTolerance", args: { tolerance: e }, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]); case 1: return n = i.sent(), this.setLogger(r.id, n, "set-bump-tolerance"), [2, n] } })) })) }, e.prototype.saveRobotSetting = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h, d, p = this; return l(this, (function (f) { switch (f.label) { case 0: return [4, this.checkChassisNetWork()]; case 1: if (!f.sent()) return [2, new Promise((function (e, t) { t($.Save_Robot_Setting_Data_Fail) }))]; r = null, f.label = 2; case 2: return f.trys.push([2, 9, , 10]), this.mBaseListener.getMode() !== X.WAN_APP ? [3, 6] : [4, this.mBaseListener.getToken(X.WAN_APP)]; case 3: return n = f.sent(), (i = e.settings).carId = this.mCurrentRobotId, o = { token: n, reqType: "onSaveCustomSettings", data: i }, this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "request-get-robot-setting"), [4, this.mBaseListener.getHeader()]; case 4: return s = f.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "robot/v2.0/save/setting"), o, { headers: s })]; case 5: return r = f.sent(), [3, 8]; case 6: return a = ke.serverUrl + "robot/v1.1/robot/setting/save", this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "request-save-robot-setting"), [4, de.put(a, e)]; case 7: r = f.sent(), f.label = 8; case 8: return this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { resData: r ? r.data : null }, "request-save-robot-setting-end"), [3, 10]; case 9: if (u = f.sent(), h = { error: u }, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", h, "request-save-robot-setting-error"), d = null, u.response && 404 === u.response.status) d = new Promise((function (e, t) { t($.Save_Robot_Setting_Data_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { p.retryTimer = setTimeout((function () { return c(p, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.saveRobotSetting(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), p.requestRetryTime) }))]; d = new Promise((function (e, t) { t($.Save_Robot_Setting_Data_Fail) })) } return [2, d]; case 10: return r && r.data && 200 === r.data.status ? [2, !0] : [2, d = new Promise((function (e, t) { t($.Save_Robot_Setting_Data_Fail) }))] } })) })) }, e.prototype.getRobotSetting = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r, n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: return [4, this.checkChassisNetWork()]; case 1: if (!d.sent()) return [2, new Promise((function (e, t) { t($.Get_Robot_Setting_Data_Fail) }))]; t = null, d.label = 2; case 2: return d.trys.push([2, 9, , 10]), this.mBaseListener.getMode() !== X.WAN_APP ? [3, 6] : [4, this.mBaseListener.getToken(X.WAN_APP)]; case 3: return r = d.sent(), n = { token: r, reqType: "onGetGlobalSettings", data: { isGetPageSetting: !1, carId: this.mCurrentRobotId, isGetCustomSetting: !0 } }, this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "request-get-robot-setting"), [4, this.mBaseListener.getHeader()]; case 4: return i = d.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "robot/v2.0/setting"), n, { headers: i })]; case 5: return t = d.sent(), [3, 8]; case 6: return o = ke.serverUrl + "robot/v1.1/robot/setting", this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "request-get-robot-setting"), [4, de.get(o)]; case 7: t = d.sent(), d.label = 8; case 8: return this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { resData: t ? t.data : null }, "request-get-robot-setting-end"), [3, 10]; case 9: if (s = d.sent(), a = { error: s }, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", a, "request-get-robot-setting-error"), u = null, s.response && 404 === s.response.status) u = new Promise((function (e, t) { t($.Get_Robot_Setting_Data_404) })); else { if (e > 0) return e--, [2, new Promise((function (t, r) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.getRobotSetting(e)]; case 1: return r = n.sent(), t(r), [2] } })) })) }), h.requestRetryTime) }))]; u = new Promise((function (e, t) { t($.Get_Robot_Setting_Data_Fail) })) } return [2, u]; case 10: return t && t.data && 200 === t.data.status ? [2, t.data.data] : [2, u = new Promise((function (e, t) { t($.Get_Robot_Setting_Data_Fail) }))] } })) })) }, e.prototype.getRobotSettingById = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h, d = this; return l(this, (function (p) { switch (p.label) { case 0: return [4, this.checkChassisNetWork()]; case 1: if (!p.sent()) return [2, new Promise((function (e, t) { t($.Get_Robot_Setting_Data_Fail) }))]; r = null, p.label = 2; case 2: return p.trys.push([2, 9, , 10]), this.mBaseListener.getMode() !== X.WAN_APP ? [3, 6] : [4, this.mBaseListener.getToken(X.WAN_APP)]; case 3: return n = p.sent(), i = { token: n, reqType: "onGetGlobalSettings", data: { isGetPageSetting: !1, carId: e, isGetCustomSetting: !0 } }, this.mBaseListener.exportOperationLogger(V, e, "AXRobotEngin", {}, "request-get-robot-setting"), [4, this.mBaseListener.getHeader()]; case 4: return o = p.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "robot/v2.0/setting"), i, { headers: o })]; case 5: return r = p.sent(), [3, 8]; case 6: return s = ke.serverUrl + "robot/v1.1/robot/setting", this.mBaseListener.exportOperationLogger(V, e, "AXRobotEngin", {}, "request-get-robot-setting"), [4, de.get(s)]; case 7: r = p.sent(), p.label = 8; case 8: return this.mBaseListener.exportOperationLogger(V, e, "AXRobotEngin", { resData: r ? r.data : null }, "request-get-robot-setting-end"), [3, 10]; case 9: if (a = p.sent(), u = { error: a }, this.mBaseListener.exportOperationLogger(N, e, "AXRobotEngin", u, "request-get-robot-setting-error"), h = null, a.response && 404 === a.response.status) h = new Promise((function (e, t) { t($.Get_Robot_Setting_Data_404) })); else { if (t > 0) return t--, [2, new Promise((function (e, r) { d.retryTimer = setTimeout((function () { return c(d, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.getRobotSetting(t)]; case 1: return r = n.sent(), e(r), [2] } })) })) }), d.requestRetryTime) }))]; h = new Promise((function (e, t) { t($.Get_Robot_Setting_Data_Fail) })) } return [2, h]; case 10: return r && r.data && 200 === r.data.status ? [2, r.data.data] : [2, h = new Promise((function (e, t) { t($.Get_Robot_Setting_Data_Fail) }))] } })) })) }, e.prototype.setPlayObstacle = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return null != e && e || (e = {}), r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "setPlayObstacle", args: e, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]; case 1: return n = i.sent(), this.setLogger(r.id, n, "set-play-obstacle"), [2, n] } })) })) }, e.prototype.sendCommand = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return "number" == typeof e.timeoutSec && (t = e.timeoutSec), this.sendCmd(e), [4, this.checkCmd(e.id, 1e3 * t)]; case 1: return r = n.sent(), this.setLogger(e.id, r, "set-command"), [2, r] } })) })) }, e.prototype.getRobotFootprint = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r, n, i, o, s = this; return l(this, (function (a) { switch (a.label) { case 0: return [4, this.checkChassisNetWork()]; case 1: if (!a.sent()) return [2, new Promise((function (e, t) { t($.Get_Robot_Setting_Data_Fail) }))]; t = null, a.label = 2; case 2: return a.trys.push([2, 4, , 5]), this.mBaseListener.getMode() === X.WAN_APP ? [2, new Promise((function (e, t) { t($.Get_Robot_Setting_Data_Fail) }))] : (r = ke.chassisUrl + "robot_footprint", this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "request-get-robot-footprint"), [4, de.get(r)]); case 3: return t = a.sent(), this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { resData: t ? t.data : null }, "request-get-robot-footprint-end"), [3, 5]; case 4: if (n = a.sent(), i = { error: n }, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", i, "request-get-robot-footprint-error"), o = null, n.response && 404 === n.response.status) o = new Promise((function (e, t) { t($.Get_Robot_Setting_Data_404) })); else { if (e > 0) return e--, [2, new Promise((function (t, r) { s.retryTimer = setTimeout((function () { return c(s, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.getRobotFootprint(e)]; case 1: return r = n.sent(), t(r), [2] } })) })) }), s.requestRetryTime) }))]; o = new Promise((function (e, t) { t($.Get_Robot_Setting_Data_Fail) })) } return [2, o]; case 5: return t && t.data && 200 === t.status ? [2, t.data.data] : [2, o = new Promise((function (e, t) { t($.Get_Robot_Setting_Data_Fail) }))] } })) })) }, e.prototype.saveRobotFootprint = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return null != e && e || (e = {}), r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "setFootprint", args: e, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]; case 1: return n = i.sent(), this.setLogger(r.id, n, "set-foot-print"), [2, n] } })) })) }, e.prototype.setFootprintDefault = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var e, r; return l(this, (function (n) { switch (n.label) { case 0: return e = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "setFootprintDefault", args: {}, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(e), [4, this.checkCmd(e.id, 1e3 * t)]; case 1: return r = n.sent(), this.setLogger(e.id, r, "set-foot-print-default"), [2, r] } })) })) }, e.prototype.fixIMU = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r; return l(this, (function (n) { switch (n.label) { case 0: return t = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "fixImu", args: {}, timeoutSec: e, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(t), [4, this.checkCmd(t.id, 1e3 * e)]; case 1: return r = n.sent(), this.setLogger(t.id, r, "fix-IMU"), [2, r] } })) })) }, e.prototype.getShelvesAreaList = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Task_List_Fail) }))]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { data: e }, "request-get-shelvesArea-list"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "map/v2.0/features?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), e, { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { result: r }, "request-get-shelvesArea-list-end"), [3, 6]; case 5: if (i = u.sent(), o = { data: e, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", o, "request-get-shelvesArea-list-error"), s = null, i.response && 404 === i.response.status) s = new Promise((function (e, t) { t($.Get_Task_List_Fail_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getShelvesAreaList(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Task_List_Fail) })) } return [2, s]; case 6: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.clearWheelControlErrors = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return null != e && e || (e = {}), r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "clearErrors", args: e, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]; case 1: return n = i.sent(), this.setLogger(r.id, n, "set-clear-error"), [2, n] } })) })) }, e.prototype.getRobotService = function (e) { return c(this, void 0, Promise, (function () { var t, r, n, i; return l(this, (function (o) { switch (o.label) { case 0: t = null, o.label = 1; case 1: return o.trys.push([1, 3, , 4]), r = "http://" + e + ":9001/server_state", this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "request-get-robot-server"), [4, de.get(r)]; case 2: return t = o.sent(), this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { resData: t ? t.data : null }, "request-get-robot-server-end"), [3, 4]; case 3: return n = o.sent(), i = { error: n }, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", i, "request-get-robot-server-error"), [2, new Promise((function (e, t) { t($.Get_Robot_Setting_Data_Fail) }))]; case 4: return t && t.data && t.data.data ? [2, t.data.data] : [2, new Promise((function (e, t) { t($.Get_Robot_Setting_Data_Fail) }))] } })) })) }, e.prototype.getDeviceInfo = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r, n, i, o, s = this; return l(this, (function (a) { switch (a.label) { case 0: return [4, this.checkChassisNetWork()]; case 1: if (!a.sent()) return [2, new Promise((function (e, t) { t($.Get_Wifi_State_Fail) }))]; if (this.mBaseListener.getMode() === X.WAN_APP) return [2, new Promise((function (e, t) { t($.Get_Wifi_State_Fail) }))]; t = null, a.label = 2; case 2: return a.trys.push([2, 4, , 5]), r = ke.chassisUrl + "device_info", this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "request-get-device-info"), [4, de.get(r)]; case 3: return t = a.sent(), this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { resData: t ? t.data : null }, "response-get-device-info-end"), [3, 5]; case 4: if (n = a.sent(), i = { error: n }, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", i, "request-get-robot-device-error"), o = null, n.response && 404 === n.response.status) o = new Promise((function (e, t) { t($.Get_Wifi_State_Fail_404) })); else { if (e > 0) return e--, [2, new Promise((function (t, r) { s.retryTimer = setTimeout((function () { return c(s, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.getDeviceInfo(e)]; case 1: return r = n.sent(), t(r), [2] } })) })) }), s.requestRetryTime) }))]; o = new Promise((function (e, t) { t($.Get_Wifi_State_Fail) })) } return [2, o]; case 5: return t && t.data && t.data.data && 0 === t.data.code ? [2, t.data.data] : [2, o = new Promise((function (e, t) { t($.Get_Wifi_State_Fail) }))] } })) })) }, e.prototype.setWeightSpeedLimit = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return null != e && e || (e = {}), r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "setWeightSpeedLimit", args: e, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]; case 1: return n = i.sent(), this.setLogger(r.id, n, "set-clear-error"), [2, n] } })) })) }, e.prototype.startRollerAction = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i = this; return l(this, (function (o) { switch (o.label) { case 0: return "number" != typeof e ? [2, new Promise((function (e, t) { var r = i.deepClone(Y.Param_type_is_number); r.errText = "action " + r.errText, t(r) }))] : (r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "startRoller", args: { type: e }, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]); case 1: return n = o.sent(), this.setLogger(r.id, n, "start-roller"), [2, n] } })) })) }, e.prototype.detectRackSize = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return null != e && e || (e = {}), r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "detectRackSize", args: e, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]; case 1: return n = i.sent(), this.setLogger(r.id, n, "start-rack-size-detection"), [2, n] } })) })) }, e.prototype.getRackSize = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r, n, i, o, s = this; return l(this, (function (a) { switch (a.label) { case 0: return [4, this.checkChassisNetWork()]; case 1: if (!a.sent()) return [2, new Promise((function (e, t) { t($.Get_Robot_Rack_Size_Fail) }))]; t = null, a.label = 2; case 2: return a.trys.push([2, 4, , 5]), this.mBaseListener.getMode() === X.WAN_APP ? [2, new Promise((function (e, t) { t($.Get_Robot_Rack_Size_Fail) }))] : (r = ke.chassisUrl + "detected_rack", this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "request-get-robot-rack-size"), [4, de.get(r)]); case 3: return t = a.sent(), this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { resData: t ? t.data : null }, "request-get-robot-rack-size-end"), [3, 5]; case 4: if (n = a.sent(), i = { error: n }, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", i, "request-get-robot--rack-size-error"), o = null, n.response && 404 === n.response.status) o = new Promise((function (e, t) { t($.Get_Robot_Rack_Size_404) })); else { if (e > 0) return e--, [2, new Promise((function (t, r) { s.retryTimer = setTimeout((function () { return c(s, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.getRobotFootprint(e)]; case 1: return r = n.sent(), t(r), [2] } })) })) }), s.requestRetryTime) }))]; o = new Promise((function (e, t) { t($.Get_Robot_Rack_Size_Fail) })) } return [2, o]; case 5: return t && t.data && 200 === t.status ? [2, t.data.data] : [2, o = new Promise((function (e, t) { t($.Get_Robot_Rack_Size_Fail) }))] } })) })) }, e.prototype.setRackSize = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return null != e && e || (e = {}), r = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "setRackSize", args: e, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(r), [4, this.checkCmd(r.id, 1e3 * t)]; case 1: return n = i.sent(), this.setLogger(r.id, n, "set-rack-size"), [2, n] } })) })) }, e.prototype.setSerialPortLight = function (e, t) { return void 0 === t && (t = 0), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u = this; return l(this, (function (h) { switch (h.label) { case 0: if (r = null, this.mBaseListener.getMode() === X.WAN_APP) return [2, new Promise((function (e, t) { e(!0) }))]; h.label = 1; case 1: return h.trys.push([1, 4, , 5]), n = "http://127.0.0.1:8080/serialport/light", this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "set-serial-port-light"), [4, this.mBaseListener.getHeader()]; case 2: return i = h.sent(), [4, de.post(n, e, { headers: i })]; case 3: return r = h.sent(), this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { resData: r ? r.data : null }, "request-set-serial-port-light-end"), [3, 5]; case 4: if (o = h.sent(), s = { error: o }, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", s, "request-set-serial-port-light-error"), a = null, o.response && 404 === o.response.status) a = new Promise((function (e, t) { t($.set_serial_port_light_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { u.retryTimer = setTimeout((function () { return c(u, void 0, void 0, (function () { var n; return l(this, (function (i) { return n = this.setSerialPortLight(e, t), r(n), [2] })) })) }), u.requestRetryTime) }))]; a = new Promise((function (e, t) { t($.set_serial_port_light_Fail) })) } return [2, a]; case 5: return r && r.data && r.data.data && 0 === r.data.code ? [2, r.data.data] : [2, a = new Promise((function (e, t) { $.set_serial_port_light_Fail.errText = (r.data && r.data.code + "-") + (r.data && r.data.errText), t($.set_serial_port_light_Fail) }))] } })) })) }, e.prototype.sendPyCommand = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, void 0, (function () { var n, i; return l(this, (function (o) { switch (o.label) { case 0: return null != t && t || (t = {}), e ? (n = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: e, args: t, timeoutSec: r, needConfirm: !0, timestamp: (new Date).getTime() }, this.sendCmd(n), [4, this.checkCmd(n.id, 1e3 * r)]) : [2, !1]; case 1: return i = o.sent(), this.setLogger(n.id, i, e), [2, i] } })) })) }, e.prototype.getBatteryLife = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o; return l(this, (function (s) { switch (s.label) { case 0: return r = function (e) { return ["88", "89"].includes(e.slice(0, 2)) ? 40.276 : ["23"].includes(e.slice(0, 2)) ? 47.101 : ["61"].includes(e.slice(0, 2)) ? 36.341 : ["81"].includes(e.slice(0, 2)) ? 37.151 : ["B6"].includes(e.slice(0, 2)) ? 39.814 : ["B7"].includes(e.slice(0, 2)) ? 35.786 : void 0 }, e && "number" == typeof e.battery && "number" == typeof e.lowBattery ? [4, this.getDeviceInfo(t)] : [3, 2]; case 1: return (n = s.sent()) && n.battery && n.battery.capacity ? (i = parseInt(n.battery.capacity), (o = r(this.mCurrentRobotId)) ? [2, (i * (e.battery - e.lowBattery) / 100 * 25.6 / o).toFixed(1)] : [2, "--"]) : [2, new Promise((function (e, t) { t($.get_battery_life_Fail) }))]; case 2: return [2, new Promise((function (e, t) { t($.get_battery_life_Fail) }))]; case 3: return [2] } })) })) }, e.prototype.getRobotCustomSettings = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, void 0, (function () { var n, i; return l(this, (function (o) { switch (o.label) { case 0: return null != t && t || (t = {}), n = { deviceId: e, id: Te.generateUUID(), cmd: "getCustomSettings", args: t, timeoutSec: r, needConfirm: !0, timestamp: (new Date).getTime() }, this.mGetRobotSettingsCMD = n.id, this.sendCmd(n), [4, this.checkCmd(n.id, 1e3 * r)]; case 1: return i = o.sent(), this.setLogger(n.id, i, "get-custom-settings"), [2, i] } })) })) }, e.prototype.deepClone = function (e) { return JSON.parse(JSON.stringify(e)) }, e.prototype.oneKeyPrivateConfig = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, void 0, (function () { var n, i, o = this; return l(this, (function (s) { switch (s.label) { case 0: return e ? t ? (n = { id: Te.generateUUID(), deviceId: t, cmd: "executeFactoryCheck", needConfirm: !0, args: { ip: e, hosts: ["apilocal.autoxing.com", "mqttlocal.autoxing.com", "servicelocal.autoxing.com", "mobileapplocal.autoxing.com"], cmd: "setPrivateConfigs" }, timestamp: (new Date).getTime() }, this.sendCmd(n), [4, this.checkCmd(n.id, 1e3 * r)]) : [2, new Promise((function (e, t) { var r = o.deepClone(Y.Param_type_is_null); r.errText = "deviceId " + r.errText, t(r) }))] : [2, new Promise((function (e, t) { var r = o.deepClone(Y.Param_type_is_null); r.errText = "ip " + r.errText, t(r) }))]; case 1: return i = s.sent(), this.setLogger(n.id, i, "set-private-configs"), [2, i] } })) })) }, e.prototype.getCustomSetting = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r, n, i, o, s = this; return l(this, (function (a) { switch (a.label) { case 0: return [4, this.checkChassisNetWork()]; case 1: if (!a.sent()) return [2, new Promise((function (e, t) { t($.Get_Wifi_State_Fail) }))]; if (this.mBaseListener.getMode() === X.WAN_APP) return [2, new Promise((function (e, t) { t($.Get_Wifi_State_Fail) }))]; t = null, a.label = 2; case 2: return a.trys.push([2, 4, , 5]), r = ke.chassisUrl + "custom_settings", this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", {}, "request-get-custom-setting"), [4, de.get(r)]; case 3: return t = a.sent(), this.mBaseListener.exportOperationLogger(V, this.mCurrentRobotId, "AXRobotEngin", { resData: t ? t.data : null }, "response-get-custom-setting-end"), [3, 5]; case 4: if (n = a.sent(), i = { error: n }, this.mBaseListener.exportOperationLogger(N, this.mCurrentRobotId, "AXRobotEngin", i, "request-get-custom-setting-error"), o = null, n.response && 404 === n.response.status) o = new Promise((function (e, t) { t($.Get_Wifi_State_Fail_404) })); else { if (e > 0) return e--, [2, new Promise((function (t, r) { s.retryTimer = setTimeout((function () { return c(s, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.getCustomSetting(e)]; case 1: return r = n.sent(), t(r), [2] } })) })) }), s.requestRetryTime) }))]; o = new Promise((function (e, t) { t($.Get_Wifi_State_Fail) })) } return [2, o]; case 5: return t && t.data && t.data.data && 0 === t.data.code ? [2, t.data.data] : [2, o = new Promise((function (e, t) { t($.Get_Wifi_State_Fail) }))] } })) })) }, e.prototype.requestMapService = function (e, t, r, n) { return void 0 === n && (n = 15), c(this, void 0, Promise, (function () { var i, o, s; return l(this, (function (a) { switch (a.label) { case 0: return i = { method: e, url: t, params: r }, o = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "requestMapService", args: i, needConfirm: !0, timeoutSec: n, timestamp: (new Date).getTime() }, this.sendCmd(o), [4, this.checkCmd(o.id, 1e3 * n)]; case 1: return s = a.sent(), this.setLogger(o.id, s, "request-map-service"), [2, s] } })) })) }, e.prototype.requestTaskScheduling = function (e, t, r, n) { return void 0 === n && (n = 15), c(this, void 0, Promise, (function () { var i, o, s; return l(this, (function (a) { switch (a.label) { case 0: return i = { method: e, url: t, params: r }, this.newVar = { deviceId: this.mCurrentRobotId, id: Te.generateUUID(), cmd: "requestTaskScheduling", args: i, needConfirm: !0, timeoutSec: n, timestamp: (new Date).getTime() }, o = this.newVar, this.sendCmd(o), [4, this.checkCmd(o.id, 1e3 * n)]; case 1: return s = a.sent(), this.setLogger(o.id, s, "request-task-Scheduling"), [2, s] } })) })) }, e.prototype.setRCSActive = function (e, t, r, n) { return void 0 === r && (r = !1), void 0 === n && (n = 15), c(this, void 0, Promise, (function () { var i, o, s, a, u, h, d = this; return l(this, (function (p) { switch (p.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!p.sent()) return [2, new Promise((function (e, t) { t($.Set_RCS_Active_Fail) }))]; if (this.mBaseListener.getMode() !== X.WAN_APP) return [2, null]; i = null, p.label = 2; case 2: return p.trys.push([2, 5, , 6]), o = { active: t, cleanTask: r }, this.mBaseListener.exportOperationLogger(V, e, "AXRobotEngin", {}, "set-rcs-active"), [4, this.mBaseListener.getHeader()]; case 3: return s = p.sent(), [4, de.put("".concat(this.mBaseListener.getServerUrl(), "robot/v2.0/opentcs/").concat(e, "/active"), o, { headers: s })]; case 4: return i = p.sent(), this.mBaseListener.exportOperationLogger(V, e, "AXRobotEngin", { resData: i ? i.data : null }, "response-get-lidar-state-end"), [3, 6]; case 5: if (a = p.sent(), u = { error: a }, this.mBaseListener.exportOperationLogger(N, e, "AXRobotEngin", u, "set-rcs-active-error"), h = null, a.response && 404 === a.response.status) h = new Promise((function (e, t) { a.response.data && re[a.response.data.status] && ($.Set_RCS_Active_404.errText = re[a.response.data.status], $.Set_RCS_Active_404.errCode = a.response.data.status, $.Set_RCS_Active_404.data = a.response.data.data), t($.Set_RCS_Active_404) })); else if (a.response && 400 === a.response.status) h = new Promise((function (e, t) { if (a.response.data) { var r = { errText: null, errCode: null, data: null }; re[a.response.data.status] ? (r.errText = re[a.response.data.status], r.errCode = a.response.data.status, r.data = a.response.data.data, t(r)) : e(a.response.data) } })); else { if (n > 0) return n--, [2, new Promise((function (i, o) { d.retryTimer = setTimeout((function () { return c(d, void 0, void 0, (function () { var o; return l(this, (function (s) { switch (s.label) { case 0: return [4, this.setRCSActive(e, t, r, n)]; case 1: return o = s.sent(), i(o), [2] } })) })) }), d.requestRetryTime) }))]; h = new Promise((function (e, t) { t($.Set_RCS_Active_Fail) })) } return [2, h]; case 6: return i ? [2, new Promise((function (e) { e(i.data) }))] : [2, null] } })) })) }, e.prototype.getRCSPathList = function (e, t, r, n) { return void 0 === n && (n = 15), c(this, void 0, Promise, (function () { var i, o, s, a, u, h, d = this; return l(this, (function (p) { switch (p.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!p.sent()) return [2, new Promise((function (e, t) { t($.Get_RCS_Path_Fail) }))]; if (this.mBaseListener.getMode() !== X.WAN_APP) return [2, null]; i = null, p.label = 2; case 2: return p.trys.push([2, 5, , 6]), o = r.res, this.mBaseListener.exportOperationLogger(V, e, "AXRobotEngin", {}, "request-get-rcs-path"), [4, this.mBaseListener.getHeader()]; case 3: return s = p.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "robot/v2.0/opentcs/wms/path?sn=").concat(e, "&area=").concat(t, "&res=").concat(o), { headers: s })]; case 4: return i = p.sent(), this.mBaseListener.exportOperationLogger(V, e, "AXRobotEngin", { resData: i ? i.data : null }, "response-get-rcs-path-end"), [3, 6]; case 5: if (a = p.sent(), u = { error: a }, this.mBaseListener.exportOperationLogger(N, e, "AXRobotEngin", u, "request-get-rcs-path-error"), h = null, a.response && 404 === a.response.status) h = new Promise((function (e, t) { a.response.data && re[a.response.data.status] && ($.Get_RCS_Path_404.errText = re[a.response.data.status], $.Get_RCS_Path_404.errCode = a.response.data.status, $.Get_RCS_Path_404.data = a.response.data.data), t($.Get_RCS_Path_404) })); else { if (a.response && 400 === a.response.status) return [2, h = new Promise((function (e, t) { if (a.response.data) { var r = { errText: null, errCode: null, data: null }; re[a.response.data.status] ? (r.errText = re[a.response.data.status], r.errCode = a.response.data.status, r.data = a.response.data.data, t(r)) : e(a.response.data) } }))]; if (n > 0) return n--, [2, new Promise((function (i, o) { d.retryTimer = setTimeout((function () { return c(d, void 0, void 0, (function () { var o; return l(this, (function (s) { switch (s.label) { case 0: return [4, this.getRCSPathList(e, t, r, n)]; case 1: return o = s.sent(), i(o), [2] } })) })) }), d.requestRetryTime) }))]; h = new Promise((function (e, t) { t($.Get_RCS_Path_Fail) })) } return [2, h]; case 6: return i ? [2, new Promise((function (e) { e(i.data) }))] : [2, null] } })) })) }, e.prototype.addTimerTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.requestMapService("PUT", "/time/task/v2.0", e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.delTimerTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.requestMapService("DELETE", "/time/task/v1.1/" + e, {}, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.editTimerTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.requestMapService("POST", "/time/task/v2.0", e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getTimerTaskList = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.requestMapService("POST", "/time/task/v1.1/list", e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.cancelChassisAllQueueTasks = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.requestTaskScheduling("PATCH", "/task/queue/cancel/" + e, {}, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getChassisTaskQueueRobot = function (e, t, r) { return c(this, void 0, void 0, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.requestTaskScheduling("GET", "/task/queue/" + e + "/" + t, {}, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.setChassisQueueOrder = function (e, t, r) { return c(this, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return e ? (n = { key: e, newOrder: t }, [4, this.requestTaskScheduling("PATCH", "/task/set-queue-order", n, r)]) : [2, !1]; case 1: return [2, i.sent()] } })) })) }, e.prototype.pauseChassisQueue = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return e ? [4, this.requestTaskScheduling("PATCH", "/task/pause/queue/" + e, {}, t)] : [2, !1]; case 1: return [2, r.sent()] } })) })) }, e.prototype.continueChassisQueue = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return e ? [4, this.requestTaskScheduling("PATCH", "/task/continue/queue/" + e, {}, t)] : [2, !1]; case 1: return [2, r.sent()] } })) })) }, e.prototype.deleteChassisQueueTask = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return e ? [4, this.requestTaskScheduling("DELETE", "/task/" + e, {}, t)] : [2, !1]; case 1: return [2, r.sent()] } })) })) }, e.prototype.cancelChassisQueueTask = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return this.mCurrentRobotId && e ? [4, this.requestTaskScheduling("PATCH", "/task/queue/cancel/" + this.mCurrentRobotId + "?taskSn=" + e, {}, t)] : [2, !1]; case 1: return [2, r.sent()] } })) })) }, e.prototype.updateMapUpgrade = function (e, t) { return c(this, void 0, void 0, (function () { var t, r; return l(this, (function (n) { switch (n.label) { case 0: return this.mOnUpdateMapListener = e, (t = this.mCurrentRobotId) ? (this.mOnUpdateMapListener.onUpdateStateChanged({ state: -3, topic: "check_map_conflict", deviceId: t }), [4, this.checkMapConflict(t, 20)]) : (this.mOnUpdateMapListener.onUpdateStateError(H.Robot_Not_Connect), [2]); case 1: return (r = n.sent()) && 200 === r.status ? this.toCompareDetail(r) : this.updateMap() ? this.mOnUpdateMapListener.onUpdateStateChanged({ state: 1, topic: "update_success", data: "Update success", deviceId: this.mCurrentRobotId }) : this.mOnUpdateMapListener.onUpdateStateError(oe.Map_UpDate_Failed), [2] } })) })) }, e.prototype.toCompareDetail = function (e) { return c(this, void 0, void 0, (function () { var t, r, n, i, o, s, a; return l(this, (function (c) { switch (c.label) { case 0: if (!e || !e.data) return [3, 4]; if (t = e.data, r = t.conflictData, n = t.noConflictData, i = [], r && r.length > 0) for (o = 0; o < r.length; o++)4 === (s = r[o]).conflictType || 6 === s.conflictType ? i.push(s) : 5 === s.conflictType || 7 === s.conflictType || i.push(s); return [4, this.checkNeedSkipToSync(n, i)]; case 1: return (a = c.sent()) && a.length > 0 ? [4, this.syncMapToRobot(a)] : [3, 3]; case 2: return c.sent(), [3, 4]; case 3: this.mOnUpdateMapListener.onUpdateStateChanged({ state: 1, topic: "update_success", data: "Update success - No need to update", deviceId: this.mCurrentRobotId }), c.label = 4; case 4: return [2] } })) })) }, e.prototype.checkNeedSkipToSync = function (e, t) { return c(this, void 0, void 0, (function () { var r, n; return l(this, (function (i) { if (e && e.length > 0) for (r = 0; r < e.length; r++)(n = e[r]).cloudDelete === n.localDelete && n.cloudFloorName === n.localFloorName && n.cloudId === n.localId && n.cloudMapVersion === n.localMapVersion && n.cloudName === n.localName && n.cloudOverLayVersion === n.localOverLayVersion || t.push(n); return [2, t] })) })) }, e.prototype.syncMapToRobot = function (e) { return c(this, void 0, void 0, (function () { var t, r, n = this; return l(this, (function (i) { return t = this, r = new Promise((function (r, i) { return c(n, void 0, void 0, (function () { var n, i, o, s, a, c, u, h, d, p; return l(this, (function (l) { switch (l.label) { case 0: for (n = [], i = [], o = 0; o < e.length; o++)1 !== (s = e[o]).conflictType && 2 !== s.conflictType && 3 !== s.conflictType || i.push(s.localId), a = s.cloudMapVersion, s.cloudMapVersion === s.localMapVersion && (a = 0), c = s.cloudOverLayVersion, s.cloudOverLayVersion === s.localOverLayVersion && (c = 0), n.push({ areaId: s.cloudId, mapVersion: a, overLayVersion: c, syncCloud: !1 }); return n && 0 !== n.length ? (u = { syncMaps: n }, i && i.length > 0 && (u.delLocalIds = i), [4, t.getSyncMapDataParams(u)]) : [2]; case 1: h = l.sent(), d = null, l.label = 2; case 2: return l.trys.push([2, 4, , 5]), this.mOnUpdateMapListener.onUpdateStateChanged({ state: -2, topic: "update_map_send", data: u, deviceId: this.mCurrentRobotId }), [4, t.updateMap(h, !0, 90)]; case 3: return d = l.sent(), [3, 5]; case 4: return p = l.sent(), t.mOnUpdateMapListener.onUpdateStateError(p), [2]; case 5: return d && t.mOnUpdateMapListener.onUpdateStateChanged({ state: 1, topic: "update_success", data: u, deviceId: this.mCurrentRobotId }), r(!0), [2] } })) })) })), [2, r] })) })) }, e.prototype.getSyncMapDataParams = function (e) { return c(this, void 0, Promise, (function () { var t; return l(this, (function (r) { return t = {}, e.syncMaps && (t.syncMaps = e.syncMaps), e.delCloudIds && (t.delCloudIds = e.delCloudIds), e.delLocalIds && (t.delLocalIds = e.delLocalIds), e.recoverLocalIds && (t.recoverLocalIds = e.recoverLocalIds), e.recoverCloudIds && (t.recoverCloudIds = e.recoverCloudIds), [2, t] })) })) }, e.prototype.checkMapConflict = function (e, t) { return void 0 === t && (t = 20), c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: e || (e = this.mCurrentRobotId), r.label = 1; case 1: return r.trys.push([1, 3, , 4]), [4, this.requestMapService("GET", "/robot-api/axApi/compare/area/list", {}, t)]; case 2: return [2, r.sent()]; case 3: return r.sent(), [2, !1]; case 4: return [2] } })) })) }, e }(), Ee = function () { function e(e, t, r, n) { void 0 === e && (e = {}), this.token = null, this.tokenKey = null, this.expireTime = 20, this.tokenTime = 0, this.tokenParamInit = !1, e && e.token ? (this.token = e.token, this.tokenKey = e.tokenKey, this.tokenTime = e.tokenTime, this.expireTime = e.expireTime, this.tokenParamInit = !0) : this.tokenParamInit = !1, this.axAppId = t, this.axSecret = r, this.mBaseListener = n } return e.prototype.destroy = function () { null !== this.authRetryTimer && (clearTimeout(this.authRetryTimer), this.authRetryTimer = null) }, e.prototype.verifyApplication = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return this.axAppId && this.axSecret ? [4, this.mBaseListener.checkCloudNetWork()] : [2, new Promise((function (e, t) { t(Q.AppId_Secret_Null) }))]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Token_Fail) }))]; t = null, u.label = 2; case 2: return u.trys.push([2, 4, , 5]), r = (new Date).getTime(), n = Te.md5(this.axAppId + r + this.axSecret), i = { appId: this.axAppId, timestamp: r, sign: n }, [4, de.post("".concat(this.mBaseListener.getWANServerUrl(), "auth/v1.1/token?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), i, { headers: this.mBaseListener.getBaseHeader() })]; case 3: return t = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXAuth", { resData: t ? t.data : null }, "verify-application-end"), [3, 5]; case 4: return o = u.sent(), s = { error: o }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXAuth", s, "verify-application-error"), o.response && 404 === o.response.status ? [2, new Promise((function (e, t) { t($.Get_Token_Fail_404) }))] : e > 0 ? (e--, [2, new Promise((function (t, r) { a.authRetryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.verifyApplication(e)]; case 1: return r = n.sent(), t(r), [2] } })) })) }), 5e3) }))]) : [2, new Promise((function (e, t) { t($.Get_Token_Fail) }))]; case 5: return t && t.data && 200 === t.data.status && t.data.data && t.data.data.token ? [2, !0] : (this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXAuth", { resData: t ? t.data : null }, "verify-application-error"), [2, new Promise((function (e, r) { r({ errCode: t.data.status, errText: t.data.message }) }))]) } })) })) }, e.prototype.requestAuth = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r, n, i, o, s = this; return l(this, (function (a) { switch (a.label) { case 0: console.log("###request-auth:   " + this.mBaseListener.getCurrentRobotSn()), this.token && this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXAuth", {}, "request-auth"), t = null, a.label = 1; case 1: return a.trys.push([1, 5, , 6]), r = (new Date).getTime(), n = Te.md5(this.axAppId + r + this.axSecret), this.tokenParamInit ? [3, 3] : (i = { appId: this.axAppId, timestamp: r, sign: n }, [4, de.post("".concat(this.mBaseListener.getWANServerUrl(), "auth/v1.1/token?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), i, { headers: this.mBaseListener.getBaseHeader() })]); case 2: return t = a.sent(), [3, 4]; case 3: return [2]; case 4: return [3, 6]; case 5: return (o = a.sent()).toString().indexOf("Network") >= 0 ? [2, this.mBaseListener.getMode() !== X.WAN_APP ? new Promise((function (e, t) { e(null) })) : new Promise((function (e, t) { t($.Network_Error) }))] : o.response && 404 === o.response.status ? [2, new Promise((function (e, t) { t($.Get_Token_Fail_404) }))] : e > 0 ? (e--, [2, new Promise((function (t, r) { s.authRetryTimer = setTimeout((function () { return c(s, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return i.trys.push([0, 2, , 3]), [4, this.requestAuth(e)]; case 1: return n = i.sent(), t(n), [3, 3]; case 2: return i.sent(), r($.Get_Token_Fail), [3, 3]; case 3: return [2] } })) })) }), 5e3) }))]) : [2, new Promise((function (e, t) { t($.Get_Token_Fail) }))]; case 6: return "request:fail" === t.errMsg ? [2, this.mBaseListener.getMode() !== X.WAN_APP ? new Promise((function (e, t) { e(null) })) : new Promise((function (e, t) { t($.Network_Error) }))] : t && t.data && 200 === t.data.status && t.data.data && t.data.data.token && "number" == typeof t.data.data.expireTime && t.data.data.expireTime > 0 ? (this.tokenKey = t.data.data.key, this.token = t.data.data.token, this.expireTime = t.data.data.expireTime, this.tokenTime = (new Date).getTime(), [2, !0]) : [2, new Promise((function (e, t) { t(Q.Init_Error) }))] } })) })) }, e.prototype.isTokenAvail = function () { var e = ((new Date).getTime() - this.tokenTime) / 1e3; return !!(this.token && e < this.expireTime) }, e.prototype.getTokenKey = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return this.mBaseListener.getMode() !== X.WAN_APP ? [3, 2] : this.isTokenAvail() ? [2, this.tokenKey] : [4, this.requestAuth()]; case 1: if (!0 === e.sent()) return [2, this.tokenKey]; e.label = 2; case 2: return [2, null] } })) })) }, e.prototype.getToken = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return void 0 === e && (e = this.mBaseListener.getMode()), e !== X.WAN_APP ? [3, 2] : this.tokenParamInit || this.isTokenAvail() ? [2, this.token] : [4, this.requestAuth()]; case 1: return !0 === t.sent() ? [2, this.token] : [3, 3]; case 2: if (e === X.LOCAL_APP) return [2, ""]; t.label = 3; case 3: return [2, null] } })) })) }, e.prototype.getTokenByOpenId = function (e) { return c(this, void 0, Promise, (function () { var t, r, n, i, o, s; return l(this, (function (a) { switch (a.label) { case 0: t = null, a.label = 1; case 1: return a.trys.push([1, 3, , 4]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXAuth", {}, "request-token-by-openid-start"), e ? (r = (new Date).getTime(), Te.md5(this.axAppId + r + this.axSecret), n = { openId: e }, [4, de.post("".concat(this.mBaseListener.getWANServerUrl(), "auth/v1.1/token"), n, { headers: this.mBaseListener.getBaseHeader() })]) : [2, new Promise((function (e, t) { t($.Get_Token_Fail) }))]; case 2: return t = a.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXAuth", { resData: t ? t.data : null }, "request-token-by-openid-end"), [3, 4]; case 3: return i = a.sent(), o = { error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXAuth", o, "request-token-by-openid-error"), i.toString().indexOf("Network") >= 0 ? [2, this.mBaseListener.getMode() !== X.WAN_APP ? new Promise((function (e, t) { e(null) })) : new Promise((function (e, t) { t($.Network_Error) }))] : i.response && 404 === i.response.status ? [2, new Promise((function (e, t) { t($.Get_Token_Fail_404) }))] : [2, new Promise((function (e, t) { t($.Get_Token_Fail) }))]; case 4: return s = null, "request:fail" === t.errMsg ? s = this.mBaseListener.getMode() !== X.WAN_APP ? new Promise((function (e, t) { e(null) })) : new Promise((function (e, t) { t($.Network_Error) })) : t && t.data && (s = new Promise((function (e, r) { e(t.data) }))), [2, s] } })) })) }, e }(), Se = function () { function e(e) { this.mBaseListener = e, this.mLastMotionTime = -1, this.isMotionControl = !1, this.canMotionControl = !1, this.maxLinearVelocity = .5, this.maxAngularVelocity = 1.5 } return e.prototype.destroy = function () { this.isMotionControl = !1 }, e.prototype.motionFor = function (e, t, r) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var n, i, o; return l(this, (function (s) { switch (s.label) { case 0: switch (n = -1, e) { case q.Forward: n = 1; break; case q.Back: n = 2; break; case q.TurnLeft: n = 3; break; case q.TurnRight: n = 4; break; case q.Cancel: n = 0; break; case q.Auto: n = 5; break; case q.Manual: n = 6 }return -1 === n ? [3, 3] : (i = { type: n, duration: 100, val: 1 }, o = { deviceId: r || this.mBaseListener.getCurrentRobotSn(), id: Te.generateUUID(), cmd: "move", args: i, needConfirm: !0, timeoutSec: t, timestamp: (new Date).getTime() }, this.mBaseListener.sendCmd(o), e !== q.Auto && e !== q.Manual ? [3, 2] : [4, this.mBaseListener.checkCmd(o.id, 1e3 * t)]); case 1: return [2, s.sent()]; case 2: return [2, !0]; case 3: return [2, !1] } })) })) }, e.prototype.cleanMotionTimer = function () { this.motionTimer && (clearInterval(this.motionTimer), this.motionTimer = null) }, e.prototype.startMotionTimer = function () { this.cleanMotionTimer(); var e = this; this.motionTimer = setInterval((function () { e.doMotionControl() }), 100) }, e.prototype.beginControl = function () { this.isMotionControl = !0 }, e.prototype.endControl = function () { this.mLastMotionTime = -1, this.isMotionControl = !1, this.canMotionControl = !1 }, e.prototype.motionControl = function (e, t) { !1 !== this.isMotionControl && (this.linearVelocity = e, this.angularVelocity = t, !1 === this.canMotionControl && (this.canMotionControl = !0, this.startMotionTimer()), this.doMotionControl()) }, e.prototype.doMotionControl = function (e) { if (void 0 === e && (e = 15), !1 !== this.isMotionControl && !1 !== this.canMotionControl) { var t = (new Date).getTime(); if (!(t - this.mLastMotionTime < 100)) { this.mLastMotionTime = t, this.linearVelocity > this.maxLinearVelocity ? this.linearVelocity = this.maxLinearVelocity : this.linearVelocity < -.2 && (this.linearVelocity = -.2), this.angularVelocity > this.maxAngularVelocity ? this.angularVelocity = this.maxAngularVelocity : this.angularVelocity < -this.maxAngularVelocity && (this.angularVelocity = -this.maxAngularVelocity); var r = { type: 7, linearVelocity: this.linearVelocity, angularVelocity: this.angularVelocity }, n = { deviceId: this.mBaseListener.getCurrentRobotSn(), id: Te.generateUUID(), cmd: "move", args: r, needConfirm: !1, timeoutSec: e, timestamp: (new Date).getTime() }; this.mBaseListener.sendCmd(n) } } else this.cleanMotionTimer() }, e.prototype.moveTo = function (e, t) { if (void 0 === t && (t = 15), "number" == typeof e.x && "number" == typeof e.y) { var r = {}; r = "number" == typeof e.yaw ? { x: e.x, y: e.y, yaw: e.yaw } : { x: e.x, y: e.y }; var n = { deviceId: this.mBaseListener.getCurrentRobotSn(), id: Te.generateUUID(), cmd: "moveTo", args: r, timeoutSec: t, needConfirm: !1, timestamp: (new Date).getTime() }; this.mBaseListener.sendCmd(n) } }, e }(), Pe = function () { function e(e) { this.requestRetryTime = 1e3, this.isFinishEdgeAiSub = !1, this.mBaseListener = e, e.getMode() !== X.WAN_APP ? (this.requestRetryTime = 1e3, this.destroy()) : this.requestRetryTime = 5e3 } return e.prototype.destroy = function () { null !== this.retryTimer && (clearTimeout(this.retryTimer), this.retryTimer = null) }, e.prototype.searchBusiness = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: t = null, u.label = 1; case 1: return u.trys.push([1, 5, , 14]), r = "".concat(this.mBaseListener.getServerUrl(), "business/v1.1/list"), [4, this.mBaseListener.checkChassisNetWork()]; case 2: return u.sent() ? (o = { url: r }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", o, "request-search-business"), [4, this.mBaseListener.getHeader()]) : [2, new Promise((function (e, t) { t($.Search_Area_Fail) }))]; case 3: return n = u.sent(), [4, de.get(r, { headers: n })]; case 4: return t = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { resData: t ? t.data : null }, "response-search-business-end"), [3, 14]; case 5: return i = u.sent(), o = { effective: !1, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", o, "request-search-business-error"), s = null, i.toString().indexOf("Network") >= 0 ? (s = new Promise((function (e, t) { t($.Network_Error) })), [3, 13]) : [3, 6]; case 6: return i.response && 404 === i.response.status ? (s = new Promise((function (e, t) { })), [3, 13]) : [3, 7]; case 7: return i.response && 401 === i.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 12]; case 8: if (u.sent()) return [2, s = new Promise((function (e, t) { t(Q.Token_401) }))]; u.label = 9; case 9: return u.trys.push([9, 11, , 12]), [4, this.mBaseListener.requestAuth()]; case 10: return u.sent(), [3, 12]; case 11: return u.sent(), [2, s = new Promise((function (e, t) { t($.Search_Area_Fail) }))]; case 12: if (e > 0) return e--, [2, new Promise((function (t, r) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.searchBusiness(e)]; case 1: return r = n.sent(), t(r), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Search_Area_Fail) })), u.label = 13; case 13: return [2, s]; case 14: return t ? (s = null, [2, s = "request:fail" === t.errMsg ? new Promise((function (e, t) { t($.Network_Error) })) : new Promise((function (e) { e(t.data) }))]) : [2, null] } })) })) }, e.prototype.searchAreaByBus = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: r = null, d.label = 1; case 1: return d.trys.push([1, 5, , 14]), [4, this.mBaseListener.getHeader()]; case 2: return n = d.sent(), i = { businessId: e }, o = "".concat(this.mBaseListener.getServerUrl(), "map/v1.1/area/list"), [4, this.mBaseListener.checkChassisNetWork()]; case 3: return d.sent() ? (a = { url: o, params: i }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", a, "request-search-area-by-bussiness"), [4, de.post(o, i, { headers: n })]) : [2, new Promise((function (e, t) { t($.Search_Area_Fail) }))]; case 4: return r = d.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { resData: r ? r.data : null }, "response-search-area-by-bussiness-end"), [3, 14]; case 5: return s = d.sent(), a = { effective: !1, error: s }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", a, "request-search-area-by-bussiness-error"), u = null, s.toString().indexOf("Network") >= 0 ? (u = new Promise((function (e, t) { t($.Network_Error) })), [3, 13]) : [3, 6]; case 6: return s.response && 404 === s.response.status ? (u = new Promise((function (e, t) { t($.Search_Area_Fail_404) })), [3, 13]) : [3, 7]; case 7: return s.response && 401 === s.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 12]; case 8: if (d.sent()) return [2, u = new Promise((function (e, t) { t(Q.Token_401) }))]; d.label = 9; case 9: return d.trys.push([9, 11, , 12]), [4, this.mBaseListener.requestAuth()]; case 10: return d.sent(), [3, 12]; case 11: return d.sent(), [2, u = new Promise((function (e, t) { t($.Search_Area_Fail) }))]; case 12: if (t > 0) return t--, [2, new Promise((function (r, n) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.searchAreaByBus(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), h.requestRetryTime) }))]; u = new Promise((function (e, t) { t($.Search_Area_Fail) })), d.label = 13; case 13: return [2, u]; case 14: return r ? (u = null, [2, u = "request:fail" === r.errMsg ? new Promise((function (e, t) { t($.Network_Error) })) : new Promise((function (e) { e(r.data) }))]) : [2, null] } })) })) }, e.prototype.searchArea = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: r = null, d.label = 1; case 1: return d.trys.push([1, 5, , 13]), [4, this.mBaseListener.getHeader()]; case 2: return n = d.sent(), i = { robotId: this.mBaseListener.getCurrentRobotSn() }, o = "".concat(this.mBaseListener.getServerUrl(), "map/v1.1/area/list?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), "boolean" == typeof e && (o = "".concat(this.mBaseListener.getServerUrl(), "map/v1.1/building/floors?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), i.effectiveArea = e), [4, this.mBaseListener.checkChassisNetWork()]; case 3: return d.sent() ? (a = { url: o, params: i }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", a, "request-search-area"), [4, de.post(o, i, { headers: n })]) : [2, new Promise((function (e, t) { t($.Search_Area_Fail) }))]; case 4: return r = d.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { resData: r ? r.data : null, logData: a }, "response-search-area-end"), [3, 13]; case 5: return s = d.sent(), a = { effective: !1, error: s }, "boolean" == typeof e && (a.effective = e), this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", a, "request-search-area-error"), u = null, s.response && 404 === s.response.status ? (u = new Promise((function (e, t) { t($.Search_Area_Fail_404) })), [3, 12]) : [3, 6]; case 6: return s.response && 401 === s.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (d.sent()) return [2, u = new Promise((function (e, t) { t(Q.Token_401) }))]; d.label = 8; case 8: return d.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return d.sent(), [3, 11]; case 10: return d.sent(), [2, u = new Promise((function (e, t) { t($.Search_Area_Fail) }))]; case 11: if (t > 0) return t--, [2, new Promise((function (r, n) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.searchArea(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), h.requestRetryTime) }))]; u = new Promise((function (e, t) { t($.Search_Area_Fail) })), d.label = 12; case 12: return [2, u]; case 13: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.getAreaPic = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Area_Picture_Fail) }))]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 13]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { areaId: e }, "request-get-area-pic"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "map/v1.1/area/").concat(e, "/base-map?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), { responseType: "arraybuffer", headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { resData: r ? r.data : null }, "response-get-area-pic-end"), [3, 13]; case 5: return i = u.sent(), o = { areaId: e, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", o, "request-get-area-pic-error"), s = null, i.response && 404 === i.response.status ? (s = new Promise((function (e, t) { t($.Get_Area_Picture_Fail_404) })), [3, 12]) : [3, 6]; case 6: return i.response && 401 === i.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (u.sent()) return [2, s = new Promise((function (e, t) { t(Q.Token_401) }))]; u.label = 8; case 8: return u.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return u.sent(), [3, 11]; case 10: return u.sent(), [2, s = new Promise((function (e, t) { t($.Get_Area_Picture_Fail) }))]; case 11: if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getAreaPic(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Area_Picture_Fail) })), u.label = 12; case 12: return [2, s]; case 13: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.searchPoi = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: r = null, n = {}, d.label = 1; case 1: return d.trys.push([1, 4, , 12]), i = this.mBaseListener.getCurrentRobotSn(), n.robotId = i, "object" == typeof e && ("string" == typeof e.robotId && (n.robotId = e.robotId, i || (i = e.robotId)), "number" == typeof e.type && (n.type = e.type), "string" == typeof e.areaId && (n.areaId = e.areaId), "string" == typeof e.businessId && (n.businessId = e.businessId), "object" == typeof e.page && "number" == typeof e.page.pageNum && "number" == typeof e.page.pageSize && (n.page = {}, n.page.pageNum = e.page.pageNum, n.page.pageSize = e.page.pageSize), "object" == typeof e.properties && "string" == typeof e.properties.deviceIds && (n.properties = { deviceIds: e.properties.deviceIds })), a = { params: n }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", a, "request-search-poi"), [4, this.mBaseListener.getHeader()]; case 2: return o = d.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "map/v1.1/poi/list?robotSn=").concat(i), n, { headers: o })]; case 3: return r = d.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { resData: r ? r.data : null }, "response-search-poi-end"), [3, 12]; case 4: return s = d.sent(), a = { params: n, error: s }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", a, "request-search-poi-error"), u = null, s.response && 404 === s.response.status ? (u = new Promise((function (e, t) { t($.Get_Search_Poi_By_Id_Fail_404) })), [3, 11]) : [3, 5]; case 5: return s.response && 401 === s.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 10]; case 6: if (d.sent()) return [2, u = new Promise((function (e, t) { t(Q.Token_401) }))]; d.label = 7; case 7: return d.trys.push([7, 9, , 10]), [4, this.mBaseListener.requestAuth()]; case 8: return d.sent(), [3, 10]; case 9: return d.sent(), [2, u = new Promise((function (e, t) { t($.Get_Search_Poi_By_Id_Fail) }))]; case 10: if (t > 0) return t--, [2, new Promise((function (r, n) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.searchPoi(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), h.requestRetryTime) }))]; u = new Promise((function (e, t) { t($.Get_Search_Poi_By_Id_Fail) })), d.label = 11; case 11: return [2, u]; case 12: return r && r.data && 200 === r.data.status ? [2, r.data.data] : [2, null] } })) })) }, e.prototype.searchPoiExtend = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u = this; return l(this, (function (h) { switch (h.label) { case 0: r = null, n = {}, h.label = 1; case 1: return h.trys.push([1, 5, , 13]), "object" == typeof e && ("string" == typeof e.robotId && (n.robotId = e.robotId), "number" == typeof e.type && (n.type = e.type), "string" == typeof e.areaId && (n.areaId = e.areaId), "string" == typeof e.businessId && (n.businessId = e.businessId), "object" == typeof e.page && "number" == typeof e.page.pageNum && "number" == typeof e.page.pageSize && (n.page = {}, n.page.pageNum = e.page.pageNum, n.page.pageSize = e.page.pageSize), "object" == typeof e.properties && "string" == typeof e.properties.deviceIds && (n.properties = { deviceIds: e.properties.deviceIds })), [4, this.mBaseListener.checkChassisNetWork()]; case 2: return h.sent() ? (s = { params: n }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", s, "request-search-poi"), [4, this.mBaseListener.getHeader()]) : [2, new Promise((function (e, t) { t($.Get_Search_Poi_By_Id_Fail) }))]; case 3: return i = h.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "map/v1.1/poi/list"), n, { headers: i })]; case 4: return r = h.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { resData: r ? r.data : null }, "response-search-poi-end"), [3, 13]; case 5: return o = h.sent(), s = { params: n, error: o }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", s, "request-search-poi-error"), a = null, o.response && 404 === o.response.status ? (a = new Promise((function (e, t) { t($.Get_Search_Poi_By_Id_Fail_404) })), [3, 12]) : [3, 6]; case 6: return o.response && 401 === o.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (h.sent()) return [2, a = new Promise((function (e, t) { t(Q.Token_401) }))]; h.label = 8; case 8: return h.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return h.sent(), [3, 11]; case 10: return h.sent(), [2, a = new Promise((function (e, t) { t($.Get_Search_Poi_By_Id_Fail) }))]; case 11: if (t > 0) return t--, [2, new Promise((function (r, n) { u.retryTimer = setTimeout((function () { return c(u, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.searchPoi(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), u.requestRetryTime) }))]; a = new Promise((function (e, t) { t($.Get_Search_Poi_By_Id_Fail) })), h.label = 12; case 12: return [2, a]; case 13: return r && r.data && 200 === r.data.status ? [2, r.data.data] : [2, null] } })) })) }, e.prototype.searchPoiById = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, Promise, (function () { var n, i, o, s, a, u = this; return l(this, (function (h) { switch (h.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!h.sent()) return [2, new Promise((function (e, t) { t($.Get_Search_Poi_By_Id_Fail) }))]; t || (t = this.mBaseListener.getCurrentRobotSn()), n = null, h.label = 2; case 2: return h.trys.push([2, 5, , 13]), this.mBaseListener.exportOperationLogger(V, t, "AXSearchEngin", { poiId: e }, "request-search-poi-by-id"), [4, this.mBaseListener.getHeader()]; case 3: return i = h.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "map/v1.1/poi/").concat(e, "?robotSn=").concat(t), { headers: i })]; case 4: return n = h.sent(), this.mBaseListener.exportOperationLogger(V, t, "AXSearchEngin", { resData: n ? n.data : null }, "response-search-poi-by-id-end"), [3, 13]; case 5: return o = h.sent(), s = { poiId: e, error: o }, this.mBaseListener.exportOperationLogger(N, t, "AXSearchEngin", s, "request-search-poi-by-id-error"), a = null, o.response && 404 === o.response.status ? (a = new Promise((function (e, t) { t($.Get_Search_Poi_By_Id_Fail_404) })), [3, 12]) : [3, 6]; case 6: return o.response && 401 === o.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (h.sent()) return [2, a = new Promise((function (e, t) { t(Q.Token_401) }))]; h.label = 8; case 8: return h.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return h.sent(), [3, 11]; case 10: return h.sent(), [2, a = new Promise((function (e, t) { t($.Get_Search_Poi_By_Id_Fail) }))]; case 11: if (r > 0) return r--, [2, new Promise((function (n, i) { u.retryTimer = setTimeout((function () { return c(u, void 0, void 0, (function () { var i; return l(this, (function (o) { switch (o.label) { case 0: return [4, this.searchPoiById(e, t, r)]; case 1: return i = o.sent(), n(i), [2] } })) })) }), u.requestRetryTime) }))]; a = new Promise((function (e, t) { t($.Get_Search_Poi_By_Id_Fail) })), h.label = 12; case 12: return [2, a]; case 13: return n && n.data && 200 === n.data.status ? [2, n.data.data] : [2, null] } })) })) }, e.prototype.getAreaById = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Area_By_Id_Fail) }))]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 13]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { areaId: e }, "request-get-area"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "map/v1.1/area/").concat(e, "?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { resData: r ? r.data : null }, "response-get-area-end"), [3, 13]; case 5: return i = u.sent(), o = { areaId: e, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", o, "request-get-area-error"), s = null, i.response && 404 === i.response.status ? (s = new Promise((function (e, t) { t($.Get_Area_By_Id_Fail_404) })), [3, 12]) : [3, 6]; case 6: return i.response && 401 === i.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (u.sent()) return [2, s = new Promise((function (e, t) { t(Q.Token_401) }))]; u.label = 8; case 8: return u.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return u.sent(), [3, 11]; case 10: return u.sent(), [2, s = new Promise((function (e, t) { t($.Get_Area_By_Id_Fail) }))]; case 11: if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getAreaById(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Area_By_Id_Fail) })), u.label = 12; case 12: return [2, s]; case 13: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.getAreaFeatures = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Area_Features_Fail) }))]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 13]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { areaId: e }, "request-get-area-features"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "map/v1.1/area/").concat(e, "/features?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { resData: r ? r.data : null }, "response-get-area-features-end"), [3, 13]; case 5: return i = u.sent(), o = { areaId: e, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", o, "request-get-area-features-error"), s = null, i.response && 404 === i.response.status ? (s = new Promise((function (e, t) { t($.Get_Area_Features_Fail_404) })), [3, 12]) : [3, 6]; case 6: return i.response && 401 === i.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (u.sent()) return [2, s = new Promise((function (e, t) { t(Q.Token_401) }))]; u.label = 8; case 8: return u.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return u.sent(), [3, 11]; case 10: return u.sent(), [2, s = new Promise((function (e, t) { t($.Get_Area_Features_Fail) }))]; case 11: if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getAreaFeatures(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Area_Features_Fail) })), u.label = 12; case 12: return [2, s]; case 13: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.getAreaThumbnail = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Area_Thumbnail_Fail) }))]; if (this.mBaseListener.getMode() == X.WAN_APP) return [2, null]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { areaId: e }, "request-get-area-thumbnail"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "map/v1.1/area/").concat(e, "/thumbnail?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), { responseType: "arraybuffer", headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", {}, "response-get-area-thumbnail-end"), [3, 6]; case 5: if (i = u.sent(), o = { areaId: e, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", o, "request-get-area-thumbnail-error"), s = null, i.response && 404 === i.response.status) s = new Promise((function (e, t) { t($.Get_Area_Thumbnail_Fail_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getAreaThumbnail(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Area_Thumbnail_Fail) })) } return [2, s]; case 6: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.getCloudAreaThumbnail = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s = this; return l(this, (function (a) { switch (a.label) { case 0: return [4, this.mBaseListener.checkCloudNetWork()]; case 1: if (!a.sent()) return [2, new Promise((function (e, t) { t($.Get_Deploy_Fail) }))]; if (this.mBaseListener.getMode() !== X.WAN_APP) return [2, null]; r = null, a.label = 2; case 2: return a.trys.push([2, 4, , 5]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { areaId: e }, "request-get-cloud-area-thumbnail"), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "geo/area/").concat(e, "/mediumThumbnail?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), { responseType: "arraybuffer", headers: this.mBaseListener.getBaseHeader() })]; case 3: return r = a.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { resData: r ? r.data : null }, "response-get-cloud-area-thumbnail-end"), [3, 5]; case 4: if (n = a.sent(), i = { areaId: e, error: n }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", i, "request-get-cloud-area-thumbnail-error"), o = null, n.response && 404 === n.response.status) o = new Promise((function (e, t) { t($.Get_Area_Thumbnail_Fail_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { s.retryTimer = setTimeout((function () { return c(s, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getAreaThumbnail(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), s.requestRetryTime) }))]; o = new Promise((function (e, t) { t($.Get_Area_Thumbnail_Fail) })) } return [2, o]; case 5: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.getAreaMediumThumbnail = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Area_Thumbnail_Fail) }))]; if (this.mBaseListener.getMode() == X.WAN_APP) return [2, new Promise((function (e, t) { t($.Get_Area_Thumbnail_Fail) }))]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { areaId: e }, "request-get-area-mediumThumbnail"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "map/v1.1/area/").concat(e, "/mediumThumbnail?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), { responseType: "arraybuffer", headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", {}, "response-get-area-mediumThumbnail-end"), [3, 6]; case 5: if (i = u.sent(), o = { areaId: e, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", o, "request-get-area-mediumThumbnail-error"), s = null, i.response && 404 === i.response.status) s = new Promise((function (e, t) { t($.Get_Area_Thumbnail_Fail_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getAreaMediumThumbnail(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Area_Thumbnail_Fail) })) } return [2, s]; case 6: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.addTimeTask = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Add_Time_Task_Fail) }))]; if (this.mBaseListener.getMode() == X.WAN_APP) return [2, null]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { param: e }, "request-add-time-task"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.put("".concat(this.mBaseListener.getServerUrl(), "time/task/v1.1?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), e, { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { resData: r ? r.data : null }, "request-add-time-task-end"), [3, 6]; case 5: if (i = u.sent(), o = { param: e, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", o, "request-add-time-task-error"), s = null, i.response && 404 === i.response.status) s = new Promise((function (e, t) { t($.Add_Time_Task_Fail_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.addTimeTask(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Add_Time_Task_Fail) })) } return [2, s]; case 6: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.getTimeTaskList = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Time_Task_List_Fail) }))]; if (this.mBaseListener.getMode() == X.WAN_APP) return [2, null]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { param: e }, "request-get-time-task-list"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "time/task/v1.1/list?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), e, { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { resData: r ? r.data : null }, "request-get-time-task-list-end"), [3, 6]; case 5: if (i = u.sent(), o = { param: e, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", o, "request-get-time-task-list-error"), s = null, i.response && 404 === i.response.status) s = new Promise((function (e, t) { t($.Get_Time_Task_List_Fail_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getTimeTaskList(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Time_Task_List_Fail) })) } return [2, s]; case 6: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.deleteTimeTask = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Delete_Time_Task_Fail) }))]; if (this.mBaseListener.getMode() == X.WAN_APP) return [2, null]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { id: e }, "request-delete-time-task"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.delete("".concat(this.mBaseListener.getServerUrl(), "time/task/v1.1/").concat(e, "?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { resData: r ? r.data : null }, "request-delete-time-task-end"), [3, 6]; case 5: if (i = u.sent(), o = { id: e, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", o, "request-delete-time-task-error"), s = null, i.response && 404 === i.response.status) s = new Promise((function (e, t) { t($.Delete_Time_Task_Fail_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.deleteTimeTask(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Delete_Time_Task_Fail) })) } return [2, s]; case 6: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.getPointCloudData = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r, n, i, o, s = this; return l(this, (function (a) { switch (a.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!a.sent()) return [2, new Promise((function (e, t) { t($.Get_Point_Cloud_Data_Fail) }))]; if (this.mBaseListener.getMode() == X.WAN_APP) return [2, null]; t = null, a.label = 2; case 2: return a.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", {}, "request-get-lidar-state"), [4, this.mBaseListener.getHeader()]; case 3: return r = a.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "robot/v1.1/lidar/state?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), { headers: r })]; case 4: return t = a.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { resData: t ? t.data : null }, "response-get-lidar-state-end"), [3, 6]; case 5: if (n = a.sent(), i = { error: n }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", i, "request-get-lidar-state-error"), o = null, n.response && 404 === n.response.status) o = new Promise((function (e, t) { t($.Get_Point_Cloud_Data_Fail_404) })); else { if (e > 0) return e--, [2, new Promise((function (t, r) { s.retryTimer = setTimeout((function () { return c(s, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.getPointCloudData(e)]; case 1: return r = n.sent(), t(r), [2] } })) })) }), s.requestRetryTime) }))]; o = new Promise((function (e, t) { t($.Get_Point_Cloud_Data_Fail) })) } return [2, o]; case 6: return t ? [2, new Promise((function (e) { e(t.data) }))] : [2, null] } })) })) }, e.prototype.getBindEdgeIntelligence = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Bind_Edge_Intelligence_Fail) }))]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 6]), e || (e = {}), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", e, "request-bind-edge-intelligence"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "iot/v2.0/edge/intelligence/list"), e, { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { resData: r ? r.data : null }, "response-bind-edge-intelligence-end"), [3, 6]; case 5: if (i = u.sent(), o = { error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", o, "request-bind-edge-intelligence-error"), s = null, i.response && 404 === i.response.status) s = new Promise((function (e, t) { t($.Get_Bind_Edge_Intelligence_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getBindEdgeIntelligence(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Bind_Edge_Intelligence_Fail) })) } return [2, s]; case 6: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.startEdgeAiWebSocket = function (e) { return c(this, void 0, Promise, (function () { var t, r, n = this; return l(this, (function (i) { switch (i.label) { case 0: return "string" != typeof e ? [2, null] : (t = this.mBaseListener.getWsUrl() + "iot-state/edgeai/" + e, this.mBaseListener.exportOperationLogger(V, e, "AXRobotsEngin", { isFinishEdgeAiSub: this.isFinishEdgeAiSub }, "start-subscribe-edge-ai"), !0 === this.isFinishEdgeAiSub ? [2] : (this.mMyChannelWs && (this.mMyChannelWs.stop(), this.mMyChannelWs = null), [4, this.mBaseListener.getTokenKey()])); case 1: return (r = i.sent()) ? (this.mBaseListener.exportOperationLogger(V, e, "AXRobotsEngin", { isFinishEdgeAiSub: this.isFinishEdgeAiSub, tokenKey: r }, "start-subscribe-edge-ai"), this.mMyChannelWs = new _e, [4, this.mMyChannelWs.start((function (e, t) { return c(n, void 0, void 0, (function () { return l(this, (function (r) { return 0 === e && t && this.mBaseListener.onEdgeAiChanged(t), [2] })) })) }), t, r)]) : [2]; case 2: return i.sent(), [2] } })) })) }, e.prototype.stopEdgeAiWebSocket = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { return this.mMyChannelWs && (this.mMyChannelWs.stop(), this.mMyChannelWs = null), [2] })) })) }, e.prototype.cruiseRouteSort = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.cruise_route_sort_Fail) }))]; if (this.mBaseListener.getMode() == X.WAN_APP) return [2, null]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { data: e }, "cruise-route-sort"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.put("".concat(this.mBaseListener.getServerUrl(), "mobileapp/v1.1/cruise/updates?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), e, { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", { resData: r ? r.data : null }, "request-cruise-route-sort-end"), [3, 6]; case 5: if (i = u.sent(), o = { data: e, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXSearchEngin", o, "request-cruise-route-sort-error"), s = null, i.response && 404 === i.response.status) s = new Promise((function (e, t) { t($.Delete_Time_Task_Fail_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.cruiseRouteSort(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Task_Statis_Fail_408) })) } return [2, s]; case 6: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e }(), Ie = function () { function e() { } return e.prototype.createDB = function (e) { return c(this, void 0, Promise, (function () { var t, r; return l(this, (function (n) { return t = this, r = indexedDB.open(e, 1), [2, new Promise((function (n, i) { r.onerror = function (e) { var t = ie.DB_Error; t.errCode = e.target.errorCode, i(t) }, r.onsuccess = function (e) { t.db = e.target.result, n(!0) }, r.onupgradeneeded = function (r) { t.db = r.target.result, t.db.objectStoreNames.contains(e) || t.db.createObjectStore(e, { keyPath: "id" }) } }))] })) })) }, e.prototype.addData = function (e, t) { return c(this, void 0, Promise, (function () { var r; return l(this, (function (n) { return (r = this.db.transaction([e], "readwrite")).objectStore(e).add(t), [2, new Promise((function (e, t) { r.oncomplete = function () { e(!0) }, r.onerror = function () { t(ie.DB_Add_Error) } }))] })) })) }, e.prototype.getData = function (e, t) { return c(this, void 0, Promise, (function () { var r, n, i; return l(this, (function (o) { return r = this.db.transaction([e], "readwrite"), n = r.objectStore(e), i = n.get(t), [2, new Promise((function (e, t) { i.onsuccess = function () { i.result ? e(i.result) : e(null) } }))] })) })) }, e.prototype.updateData = function (e, t) { return c(this, void 0, Promise, (function () { var r; return l(this, (function (n) { return (r = this.db.transaction([e], "readwrite")).objectStore(e).put(t), [2, new Promise((function (e, t) { r.oncomplete = function () { e(!0) }, r.onerror = function () { t(ie.DB_Update_Error) } }))] })) })) }, e.prototype.deleteData = function (e, t) { return c(this, void 0, Promise, (function () { var r; return l(this, (function (n) { return (r = this.db.transaction([e], "readwrite")).objectStore(e).delete(t), [2, new Promise((function (e, t) { r.oncomplete = function () { e(!0) }, r.onerror = function () { t(ie.DB_Delete_Error) } }))] })) })) }, e.prototype.getAllData = function (e) { return c(this, void 0, Promise, (function () { var t, r, n, i; return l(this, (function (o) { return t = this.db.transaction([e], "readwrite"), r = t.objectStore(e), n = r.openCursor(), i = [], [2, new Promise((function (e, t) { n.onsuccess = function (t) { var r = t.target.result; r ? (i.push(r.value), r.continue()) : e({ list: i }) } }))] })) })) }, e }(), Ae = function () { function e(e) { this.isFinishTaskChannel = !1, this.taskWsError = !1, this.requestRetryTime = 1e3, this.indexedDBName = "taskInfo", this.mBaseListener = e, e.getMode() !== X.WAN_APP ? (this.requestRetryTime = 1e3, this.destroy()) : this.requestRetryTime = 5e3, this.createDB() } return e.prototype.createDB = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return e.trys.push([0, 2, , 3]), this.indexedDB = new Ie, [4, this.indexedDB.createDB(this.indexedDBName)]; case 1: case 2: return e.sent(), [3, 3]; case 3: return [2] } })) })) }, e.prototype.getDB = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { return [2, this.indexedDB] })) })) }, e.prototype.destroy = function () { this.isFinishTaskChannel = !1, this.mCurTaskId = null, this.mCurTaskType = null, null !== this.retryTimer && (clearTimeout(this.retryTimer), this.retryTimer = null), this.mMyTaskWs && (this.mMyTaskWs.stop(), this.mMyTaskWs = null), this.taskHearBeatTimeout && (clearTimeout(this.taskHearBeatTimeout), this.taskHearBeatTimeout = null) }, e.prototype.start = function () { this.startTaskChannel() }, e.prototype.startTaskChannel = function () { return c(this, void 0, Promise, (function () { var e, t = this; return l(this, (function (r) { switch (r.label) { case 0: return this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { isFinishTaskChannel: this.isFinishTaskChannel }, "start-task-channel"), !0 === this.isFinishTaskChannel ? [2] : (this.mMyTaskWs && (this.mMyTaskWs.stop(), this.mMyTaskWs = null), [4, this.mBaseListener.getTokenKey()]); case 1: return (e = r.sent()) ? (this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { isFinishTaskChannel: this.isFinishTaskChannel, tokenKey: e }, "start-task-channel"), this.mMyTaskWs = new _e, [4, this.mMyTaskWs.start((function (r, n) { return c(t, void 0, void 0, (function () { var t, i, o, s, a, u, h, d = this; return l(this, (function (p) { switch (p.label) { case 0: return 0 !== r ? [3, 4] : this.mBaseListener.getMode() !== X.WAN_APP ? [3, 3] : n ? "number" != typeof n.actType ? [3, 2] : [4, this.mBaseListener.getState()] : [3, 3]; case 1: return u = p.sent(), t = u && u.taskObj || {}, i = t.duration, o = void 0 === i ? 0 : i, s = t.mileage, a = void 0 === s ? 0 : s, n.data = Object.assign({}, n.data, { duration: o, mileage: a }), this.dealTaskState(n), [3, 3]; case 2: "onHeartBeat" === n.reqType && (this.taskHearBeatTimeout && clearTimeout(this.taskHearBeatTimeout), this.taskHearBeatTimeout = setTimeout((function () { return c(d, void 0, void 0, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.setTaskChannelFaild(!1)]; case 1: return e.sent(), [2] } })) })) }), 1e4)), p.label = 3; case 3: return [3, 9]; case 4: return 2 !== r ? [3, 6] : (this.taskWsError = !1, this.taskWSTimeout && (clearTimeout(this.taskWSTimeout), this.taskWSTimeout = null), [4, this.sendStartTaskChannelCmd()]); case 5: return p.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { tokenKey: e }, "start-task-channel-success"), [3, 9]; case 6: return 1 !== r ? [3, 9] : (this.isFinishTaskChannel = !1, [4, this.mBaseListener.getState()]); case 7: return (u = p.sent()) && u.taskObj && !this.taskWsError && (this.taskWsError = !0, this.taskWSTimeout = setTimeout((function () { d.setTaskChannelFaild(!0, H.Network_Timeout) }), 12e4)), this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { tokenKey: e }, "start-task-channel-close"), this.mMyTaskWs ? [4, this.mBaseListener.getTokenKey()] : [3, 9]; case 8: if (!(h = p.sent())) return [2]; this.mMyTaskWs.setProtocol(h), p.label = 9; case 9: return [2] } })) })) }), this.mBaseListener.getWsUrl() + "robot-control/interact-client/" + this.mBaseListener.getCurrentRobotSn(), e)]) : [2]; case 2: return r.sent(), [2] } })) })) }, e.prototype.goRestartTask = function (e) { return c(this, void 0, void 0, (function () { var t; return l(this, (function (r) { switch (r.label) { case 0: if (!e) return [3, 5]; r.label = 1; case 1: return r.trys.push([1, 3, , 5]), [4, this.restartTask(e)]; case 2: return r.sent(), [3, 5]; case 3: return t = r.sent(), [4, this.setTaskChannelFaild(!0, t)]; case 4: return r.sent(), [3, 5]; case 5: return [2] } })) })) }, e.prototype.setTaskChannelFaild = function (e, t) { return c(this, void 0, void 0, (function () { return l(this, (function (r) { return e && (t ? this.mBaseListener.onTaskError(t) : this.mBaseListener.onTaskError(W.Task_Execute_Failed_By_Network)), this.mBaseListener.exportOperationLogger(G, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", {}, "set-task-channel-faild"), this.taskHearBeatTimeout && (clearTimeout(this.taskHearBeatTimeout), this.taskHearBeatTimeout = null), [2] })) })) }, e.prototype.dealTaskState = function (e) { switch (this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", e, "deal-task-state"), e.actType) { case ae.TaskStart: e.data && "string" == typeof e.data.taskId && (this.mCurTaskId = e.data.taskId, this.mCurTaskType = e.data.taskType); break; case ae.TaskEnd: this.mCurTaskId = null, this.mCurTaskType = null; break; case ae.Arrive: if (this.mCurTaskId && e.data && e.data.current && "number" == typeof e.data.current.index) { var t = [{ index: e.data.current.index, isPass: !0 }]; try { this.doUpdateTask(this.mCurTaskId, t) } catch (e) { } } }this.mBaseListener.onTaskChanged(e) }, e.prototype.sendStartTaskChannelCmd = function () { return c(this, void 0, Promise, (function () { var e, t, r, n, i = this; return l(this, (function (o) { switch (o.label) { case 0: return [4, this.mBaseListener.getTokenKey()]; case 1: return (e = o.sent()) ? (this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { tokenKey: e }, "send-start-task-channel-cmd"), t = this.mBaseListener.getWsUrl() + "robot-control/interact-robot/" + this.mBaseListener.getCurrentRobotSn(), r = Te.generateUUID(), n = { deviceId: this.mBaseListener.getCurrentRobotSn(), id: r, cmd: "startTaskChannel", args: { ws: t, subProtocol: e }, needConfirm: !0, timestamp: (new Date).getTime() }, this.mBaseListener.sendCmd(n), [4, this.mBaseListener.checkCmd(r, 15e3)]) : [2]; case 2: return o.sent() ? (this.taskChannelTimeout && (clearTimeout(this.taskChannelTimeout), this.taskChannelTimeout = null), this.isFinishTaskChannel = !0) : this.taskChannelTimeout = setTimeout((function () { return c(i, void 0, void 0, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.sendStartTaskChannelCmd()]; case 1: return e.sent(), [2] } })) })) }), 1e4), [2] } })) })) }, e.prototype.createTask = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, Promise, (function () { var n, i, o, s, a, u, h, d, p, f, m, g, _, y, v, x = this; return l(this, (function (b) { switch (b.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: return b.sent() ? e ? ((n = {}).name = "Unknown", "string" == typeof e.name && (n.name = e.name), t ? n.robotId = t : (t = this.mBaseListener.getCurrentRobotSn(), n.robotId = this.mBaseListener.getCurrentRobotSn()), n.runNum = 1, "number" == typeof e.runNum && (n.runNum = e.runNum), n.taskType = 2, "number" == typeof e.taskType && (n.taskType = e.taskType), n.runType = 20, "number" == typeof e.runType && (n.runType = e.runType), n.routeMode = 1, "number" == typeof e.routeMode && (n.routeMode = e.routeMode), n.runMode = 1, "number" == typeof e.runMode && (n.runMode = e.runMode), n.ignorePublicSite = !1, e.ignorePublicSite && (n.ignorePublicSite = !0), n.speed = -1, "number" == typeof e.speed && (n.speed = e.speed), n.sourceType = -1, "number" == typeof e.sourceType && (n.sourceType = e.sourceType), "number" == typeof e.detourRadius && (n.detourRadius = e.detourRadius), "number" == typeof e.returnDest && (n.returnDest = e.returnDest), "number" == typeof e.returnTime && (n.returnTime = e.returnTime), i = null, t ? [3, 3] : [4, this.mBaseListener.getState()]) : [2, new Promise((function (e, t) { t(W.Point_Empty) }))] : [2, new Promise((function (e, t) { t($.Create_Task_Fail) }))]; case 2: return i = b.sent(), [3, 5]; case 3: return [4, this.mBaseListener.getState(t)]; case 4: i = b.sent(), b.label = 5; case 5: if (!i) return [2, new Promise((function (e, t) { t(W.No_State) }))]; if (o = i.areaId, n.curPt = {}, n.curPt.x = i.x, n.curPt.y = i.y, "number" == typeof i.yaw && (n.curPt.yaw = i.yaw), n.curPt.areaId = o, n.curPt.type = -1, n.curPt.stopRadius = 1, e.curPt && "number" == typeof e.curPt.runMode && (n.curPt.runMode = e.curPt.runMode), e.curPt && "number" == typeof e.curPt.detourRadius && (n.curPt.detourRadius = e.curPt.detourRadius), e.curPt && e.curPt.stepActs && Array.isArray(e.curPt.stepActs) && e.curPt.stepActs.length > 0 && (n.curPt.stepActs = e.curPt.stepActs, s = this.parseTaskPoint(n.curPt, o), n.curPt = s), e.taskPts && e.taskPts.length > 0 && !e.pts && (e.pts = e.taskPts), [24, 25].includes(n.runType) && e.pts && e.pts[0] && 9 === e.pts[0].type && i.jackProgress > 0 && !e.isCheckForkliftStatusSwitch) return [2, new Promise((function (e, t) { t(W.Task_Create_Failed_Jack_up_Task_Failed) }))]; if (n.taskPts = [], Array.isArray(e.pts) && e.pts.length > 0) for (a = e.pts.length, u = 0; u < a; u++) { if ("number" != typeof (h = e.pts[u]).x || "number" != typeof h.y) return this.mBaseListener.exportOperationLogger(N, t, "AXTaskEngin", { xy: null, task: e }, "create-task-error"), [2, new Promise((function (e, t) { t(W.XY_Is_Not_Number) }))]; if (null === (d = this.parseTaskPoint(h, o))) return this.mBaseListener.exportOperationLogger(N, t, "AXTaskEngin", { taskPoint: null, task: e }, "create-task-error"), [2, new Promise((function (e, t) { t(W.Task_AreaId_Is_Null) }))]; n.taskPts.push(d) } if (e.backPt && "number" == typeof e.backPt.x && "number" == typeof e.backPt.y) { if (null === (p = this.parseTaskPoint(e.backPt, o))) return this.mBaseListener.exportOperationLogger(N, t, "AXTaskEngin", { backPt: null, task: e }, "create-task-error"), [2, new Promise((function (e, t) { t(W.Task_AreaId_Is_Null) }))]; n.backPt = p } e.ext && (n.ext = e.ext), f = null, b.label = 6; case 6: return b.trys.push([6, 9, , 17]), this.mBaseListener.exportOperationLogger(V, t, "AXTaskEngin", n, "create-task"), [4, this.mBaseListener.getHeader()]; case 7: return m = b.sent(), [4, de.put("".concat(this.mBaseListener.getServerUrl(), "task/v1.1?robotSn=").concat(t), n, { headers: m })]; case 8: return f = b.sent(), this.mBaseListener.exportOperationLogger(V, t, "AXTaskEngin", { resData: f ? f.data : null }, "create-task-end"), [3, 17]; case 9: return g = b.sent(), _ = { dataObj: n, error: g }, this.mBaseListener.exportOperationLogger(N, t, "AXTaskEngin", _, "create-task-error"), y = null, g.response && 404 === g.response.status ? (y = new Promise((function (e, t) { t($.Create_Task_Fail_404) })), [3, 16]) : [3, 10]; case 10: return g.response && 401 === g.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 15]; case 11: if (b.sent()) return [2, y = new Promise((function (e, t) { t(Q.Token_401) }))]; b.label = 12; case 12: return b.trys.push([12, 14, , 15]), [4, this.mBaseListener.requestAuth()]; case 13: return b.sent(), [3, 15]; case 14: return b.sent(), [2, y = new Promise((function (e, t) { t($.Create_Task_Fail) }))]; case 15: if (r > 0) return r--, [2, new Promise((function (n, i) { x.retryTimer = setTimeout((function () { return c(x, void 0, void 0, (function () { var o, s; return l(this, (function (a) { switch (a.label) { case 0: return a.trys.push([0, 2, , 3]), [4, this.createTask(e, t, r)]; case 1: return o = a.sent(), n(o), [3, 3]; case 2: return s = a.sent(), i(s), [3, 3]; case 3: return [2] } })) })) }), x.requestRetryTime) }))]; y = new Promise((function (e, t) { t($.Create_Task_Fail) })), b.label = 16; case 16: return [2, y]; case 17: return f && f.data && 200 === f.data.status ? "string" == typeof f.data.data.taskId ? [2, f.data.data.taskId] : [2, new Promise((function (e, t) { t(W.No_TaskId) }))] : (v = { dataObj: n, error: f }, this.mBaseListener.exportOperationLogger(N, t, "AXTaskEngin", v, "create-task-error"), f && f.data.data ? 1007 === f.data.data.errorCode ? f = W.Task_Create_Failed_By_No_Elevator_Control_Status : 1008 === f.data.data.errorCode ? f = W.Task_Create_Failed_By_No_Effective_Elevator : 1027 === f.data.data.errorCode ? f = W.Task_Create_Failed_By_No_Bind_Elevator_Control : 1022 === f.data.data.errorCode ? f = W.Task_Create_Failed_By_No_Robot_State : 1011 === f.data.data.errorCode ? f = W.Task_Create_Failed_By_Get_Task_Point_Failed : 1e3 === f.data.data.errorCode ? f = W.Task_Execute_Failed_By_Not_link : (W.Api_Is_Error.errText = f.data.message, f = W.Api_Is_Error) : f = f && f.data && f.data.message ? W.Api_Is_Error.errText = f.data.message : W.Api_Is_Error, [2, new Promise((function (e, t) { t(f) }))]) } })) })) }, e.prototype.executeTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { taskId: e }, "execute-task"), [4, this.performTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.startTask = function (e, t) { return c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { task: e }, "start-task"), i.label = 1; case 1: return i.trys.push([1, 5, , 6]), [4, this.createTask(e, t)]; case 2: return "string" != typeof (r = i.sent()) ? [3, 4] : [4, this.performTask(r)]; case 3: return [2, i.sent()]; case 4: return [3, 6]; case 5: return n = i.sent(), [2, new Promise((function (e, t) { t(n) }))]; case 6: return [2] } })) })) }, e.prototype.performTask = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h, d = this; return l(this, (function (p) { switch (p.label) { case 0: r = null, p.label = 1; case 1: return p.trys.push([1, 5, , 13]), [4, this.mBaseListener.checkChassisNetWork()]; case 2: return p.sent() ? (n = { taskId: e }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", n, "perform-task"), [4, this.mBaseListener.getHeader()]) : [2, new Promise((function (e, t) { t($.Execute_Task_Fail) }))]; case 3: return i = p.sent(), o = {}, [4, de.post("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/").concat(e, "/execute?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), o, { headers: i })]; case 4: return r = p.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resData: r ? r.data : null }, "perform-task-end"), [3, 13]; case 5: return s = p.sent(), a = { taskId: e, error: s }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", a, "perform-task-error"), u = null, s.response && 404 === s.response.status ? (u = new Promise((function (e, t) { t($.Execute_Task_Fail_404) })), [3, 12]) : [3, 6]; case 6: return s.response && 401 === s.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (p.sent()) return [2, u = new Promise((function (e, t) { t(Q.Token_401) }))]; p.label = 8; case 8: return p.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return p.sent(), [3, 11]; case 10: return p.sent(), [2, u = new Promise((function (e, t) { t($.Execute_Task_Fail) }))]; case 11: if (t > 0) return t--, [2, new Promise((function (r, n) { d.retryTimer = setTimeout((function () { return c(d, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.performTask(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), d.requestRetryTime) }))]; u = new Promise((function (e, t) { t($.Execute_Task_Fail) })), p.label = 12; case 12: return [2, u]; case 13: return r && r.data && 200 === r.data.status ? (this.mCurTaskId = e, [2, !0]) : (h = { taskId: e, error: r }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", h, "perform-task-error"), r.data && r.data.status && re[r.data.status] ? (W.Api_Is_Error.errText = re[r.data.status], W.Api_Is_Error.errCode = r.data.status, W.Api_Is_Error.data = r.data.data, r = W.Api_Is_Error) : r && r.data.data ? 1e3 === r.data.data.errorCode ? r = W.Task_Execute_Failed_By_Not_link : 1001 === r.data.data.errorCode ? (r.data.message && (W.Task_Execute_Failed_By_Lose_Data.errText = r.data.message), r = W.Task_Execute_Failed_By_Lose_Data) : 1002 === r.data.data.errorCode ? r = W.Task_Execute_Failed_By_Route_Calculation_Failed : 1003 === r.data.data.errorCode ? r = W.Task_Execute_Failed_By_ERROR_TASKPT_LESS : 1004 === r.data.data.errorCode ? r = W.Task_Execute_Failed_By_Cross_layer_charging_pile : 1005 === r.data.data.errorCode ? r = W.Task_Execute_Failed_By_Cross_layer_stand_by : 1006 === r.data.data.errorCode ? r = W.Task_Execute_Failed_By_Cross_layer_destination : 1007 === r.data.data.errorCode ? r = W.Task_Create_Failed_By_No_Elevator_Control_Status : 1008 === r.data.data.errorCode ? r = W.Task_Create_Failed_By_No_Effective_Elevator : 1025 === r.data.data.errorCode ? r = W.Task_Execute_Failed_By_Switching_map : 1026 === r.data.data.errorCode ? r = W.Task_Execute_Failed_By_No_Command_Feedback : 1029 === r.data.data.errorCode ? r = W.Task_Create_Failed_RCS_No_Deploy : 1030 === r.data.data.errorCode ? r = W.Task_Create_Failed_RCS_Task_Failed : (W.Api_Is_Error.errText = r.data.message, r = W.Api_Is_Error) : r && r.data ? (W.Api_Is_Error.errText = r.data.message, r = W.Api_Is_Error) : r = W.Api_Is_Error, [2, new Promise((function (e, t) { t(r) }))]) } })) })) }, e.prototype.parseTaskPoint = function (e, t) { var r = "", n = -1; if ("string" != typeof e.areaId) return null; r = e.areaId, "number" == typeof e.type && (n = e.type); var i = {}; if (i.x = e.x, i.y = e.y, "number" == typeof e.yaw && (i.yaw = e.yaw), "number" == typeof e.runMode && (i.runMode = e.runMode), "number" == typeof e.detourRadius && (i.detourRadius = e.detourRadius), "string" == typeof e.dockingRadius ? i.stopRadius = parseFloat(e.dockingRadius) : i.stopRadius = 1, i.areaId = r, i.type = n, "object" == typeof e.ext && (i.ext = e.ext), Array.isArray(e.stepActs) && e.stepActs.length > 0) { i.stepActs = []; for (var o = e.stepActs.length, s = 0; s < o; s++) { var a = e.stepActs[s], c = this.createAction(a); null !== c && i.stepActs.push(c) } } return i }, e.prototype.createAction = function (e) { var t = e.type; if ("number" != typeof t) return null; var r = {}; r.type = t, r.data = {}; var n = !1; return (t === ae.PlayAudio || t === ae.GearOperation || t === ae.OpenDoor || t === ae.StopAudio || t === ae.OpenLight || t === ae.CloseLight) && (n = !0), "object" == typeof e.data && (r.data = e.data), !0 === n && (r.data.mode = this.mBaseListener.getActionMode()), r }, e.prototype.pauseTask = function (e) { return c(this, void 0, Promise, (function () { var t; return l(this, (function (r) { switch (r.label) { case 0: return [4, this.sendTaskCmd("pauseTask", e)]; case 1: return t = r.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { pauseTask: t }, "pause-task"), [2, t] } })) })) }, e.prototype.resumeTask = function (e) { return c(this, void 0, Promise, (function () { var t; return l(this, (function (r) { switch (r.label) { case 0: return [4, this.sendTaskCmd("resumeTask", e)]; case 1: return t = r.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resumeTask: t }, "resume-task"), [2, t] } })) })) }, e.prototype.continueTask = function (e) { return c(this, void 0, Promise, (function () { var t; return l(this, (function (r) { switch (r.label) { case 0: return [4, this.sendTaskCmd("onContinueTask", e)]; case 1: return t = r.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { onContinueTask: t }, "continue-task"), [2, t] } })) })) }, e.prototype.cancelTask = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, Promise, (function () { var n, i, o, s, a, u, h, d, p, f = this; return l(this, (function (m) { switch (m.label) { case 0: if (n = null, i = null, !(i = t && "" !== t ? t : this.mCurTaskId)) return [2, new Promise((function (e, t) { e(!0) }))]; m.label = 1; case 1: return m.trys.push([1, 5, , 13]), [4, this.mBaseListener.checkChassisNetWork()]; case 2: return m.sent() ? (o = { taskId: i }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", o, "cancel-task"), [4, this.mBaseListener.getHeader()]) : [2, new Promise((function (e, t) { t($.Cancel_Task_Fail) }))]; case 3: return s = m.sent(), a = { type: 2, robotId: this.mBaseListener.getCurrentRobotSn() }, "number" == typeof e && (a.type = e), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/").concat(i, "/cancel?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), a, { headers: s })]; case 4: return n = m.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resData: n ? n.data : null }, "cancel-task-end"), [3, 13]; case 5: return u = m.sent(), h = { taskId: i, error: u }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", h, "cancel-task-error"), d = null, u.response && 404 === u.response.status ? (d = new Promise((function (e, t) { t($.Cancel_Task_Fail_404) })), [3, 12]) : [3, 6]; case 6: return u.response && 401 === u.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (m.sent()) return [2, d = new Promise((function (e, t) { t(Q.Token_401) }))]; m.label = 8; case 8: return m.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return m.sent(), [3, 11]; case 10: return m.sent(), [2, d = new Promise((function (e, t) { t($.Cancel_Task_Fail) }))]; case 11: if (r > 0) return r--, [2, new Promise((function (n, i) { f.retryTimer = setTimeout((function () { return c(f, void 0, void 0, (function () { var i; return l(this, (function (o) { switch (o.label) { case 0: return [4, this.cancelTask(e, t, r)]; case 1: return i = o.sent(), n(i), [2] } })) })) }), f.requestRetryTime) }))]; d = new Promise((function (e, t) { t($.Cancel_Task_Fail) })), m.label = 12; case 12: return [2, d]; case 13: return n && n.data && 200 === n.data.status ? (this.mCurTaskId = null, this.mCurTaskType = null, [2, !0]) : (p = { taskId: t, error: n }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", p, "cancel-task-error"), n = n && n.data && n.data.message ? W.Api_Is_Error.errText = n.data.message : W.Api_Is_Error, [2, new Promise((function (e, t) { t(n) }))]) } })) })) }, e.prototype.finishTask = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h, d = this; return l(this, (function (p) { switch (p.label) { case 0: e || (e = this.mCurTaskId), r = null, p.label = 1; case 1: return p.trys.push([1, 5, , 13]), [4, this.mBaseListener.checkChassisNetWork()]; case 2: return p.sent() ? (n = { taskId: e }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", n, "finish-task"), [4, this.mBaseListener.getHeader()]) : [2, new Promise((function (e, t) { t($.Finish_Task_Fail) }))]; case 3: return i = p.sent(), o = {}, [4, de.post("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/").concat(e, "/finish?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), o, { headers: i })]; case 4: return r = p.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resData: r ? r.data : null }, "finish-task-end"), [3, 13]; case 5: return s = p.sent(), a = { taskId: e, error: s }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", a, "finish-task-error"), u = null, s.response && 404 === s.response.status ? (u = new Promise((function (e, t) { t($.Finish_Task_Fail_404) })), [3, 12]) : [3, 6]; case 6: return s.response && 401 === s.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (p.sent()) return [2, u = new Promise((function (e, t) { t(Q.Token_401) }))]; p.label = 8; case 8: return p.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return p.sent(), [3, 11]; case 10: return p.sent(), [2, u = new Promise((function (e, t) { t($.Finish_Task_Fail) }))]; case 11: if (t > 0) return t--, [2, new Promise((function (r, n) { d.retryTimer = setTimeout((function () { return c(d, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.finishTask(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), d.requestRetryTime) }))]; u = new Promise((function (e, t) { t($.Finish_Task_Fail) })), p.label = 12; case 12: return [2, u]; case 13: return r && r.data && 200 === r.data.status ? (this.mCurTaskId = null, this.mCurTaskType = null, [2, !0]) : (h = { taskId: e, error: r }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", h, "finish-task-error"), r = r && r.data && r.data.message ? W.Api_Is_Error.errText = r.data.message : W.Api_Is_Error, [2, new Promise((function (e, t) { t(r) }))]) } })) })) }, e.prototype.cancelElevator = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r, n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: t = null, d.label = 1; case 1: return d.trys.push([1, 5, , 13]), [4, this.mBaseListener.checkChassisNetWork()]; case 2: return d.sent() ? (r = { robotId: this.mBaseListener.getCurrentRobotSn() }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", r, "cancel-elevator"), [4, this.mBaseListener.getHeader()]) : [2, new Promise((function (e, t) { t($.Finish_Task_Fail) }))]; case 3: return n = d.sent(), i = { robotId: this.mBaseListener.getCurrentRobotSn() }, [4, de.post("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/cancelElevator?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), i, { headers: n })]; case 4: return t = d.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resData: t ? t.data : null }, "cancel-elevator-end"), [3, 13]; case 5: return o = d.sent(), s = { robotId: this.mBaseListener.getCurrentRobotSn(), error: o }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", s, "cancel-elevator-error"), a = null, o.response && 404 === o.response.status ? (a = new Promise((function (e, t) { t($.Cancel_Task_Fail_404) })), [3, 12]) : [3, 6]; case 6: return o.response && 401 === o.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (d.sent()) return [2, a = new Promise((function (e, t) { t(Q.Token_401) }))]; d.label = 8; case 8: return d.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return d.sent(), [3, 11]; case 10: return d.sent(), [2, a = new Promise((function (e, t) { t($.Cancel_Task_Fail) }))]; case 11: if (e > 0) return e--, [2, new Promise((function (t, r) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.cancelElevator(e)]; case 1: return r = n.sent(), t(r), [2] } })) })) }), h.requestRetryTime) }))]; a = new Promise((function (e, t) { t($.Cancel_Task_Fail) })), d.label = 12; case 12: return [2, a]; case 13: return t && t.data && 200 === t.data.status ? [2, !0] : (u = { robotId: this.mBaseListener.getCurrentRobotSn(), error: t }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", u, "cancel-elevator-error"), t = t && t.data && t.data.message ? W.Api_Is_Error.errText = t.data.message : W.Api_Is_Error, [2, new Promise((function (e, r) { r(t) }))]) } })) })) }, e.prototype.sendTaskCmd = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return r = { deviceId: this.mBaseListener.getCurrentRobotSn(), id: Te.generateUUID(), cmd: e, args: {}, timeoutSec: t, needConfirm: !0, timestamp: (new Date).getTime() }, this.mBaseListener.sendCmd(r), [4, this.mBaseListener.checkCmd(r.id, 1e3 * t)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.getCurrentTask = function () { return c(this, void 0, Promise, (function () { var e, t, r, n; return l(this, (function (i) { switch (i.label) { case 0: if (!this.mCurTaskId) return [3, 6]; e = null, i.label = 1; case 1: return i.trys.push([1, 4, , 5]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { taskId: this.mCurTaskId }, "get-current-task"), [4, this.mBaseListener.getHeader()]; case 2: return t = i.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/").concat(this.mCurTaskId, "?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), { headers: t })]; case 3: return e = i.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resData: e ? e.data : null }, "get-current-task-end"), [3, 5]; case 4: return r = i.sent(), n = { taskId: this.mCurTaskId, error: r }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", n, "get-current-task-error"), [3, 5]; case 5: return e && e.data && 200 === e.data.status ? [2, e.data.data] : (n = { taskId: this.mCurTaskId, error: e }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", n, "get-current-task-error"), e = e && e.data && e.data.message ? W.Task_Is_Error.errText = e.data.message : W.Task_Is_Error, [2, new Promise((function (t, r) { r(e) }))]); case 6: this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { taskId: "" }, "get-current-task-error"), i.label = 7; case 7: return [2, new Promise((function (e, t) { t(W.Task_Is_Null) }))] } })) })) }, e.prototype.updateTask = function (e, t) { return c(this, void 0, Promise, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return r = { taskId: e, pts: t }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", r, "update-task"), [4, this.doUpdateTask(e, t)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.performRestartTask = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { return this.mCurTaskId && "" !== this.mCurTaskId ? [2, this.restartTask(this.mCurTaskId)] : [2, !1] })) })) }, e.prototype.restartTask = function (e) { return c(this, void 0, Promise, (function () { var t; return l(this, (function (r) { switch (r.label) { case 0: return t = { taskId: e }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", t, "restart-task"), [4, this.performTask(e)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.doUpdateTask = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, Promise, (function () { var n, i, o, s, a, u, h, d, p, f, m, g, _, y, v, x, b, w, T = this; return l(this, (function (k) { switch (k.label) { case 0: if (n = { taskId: e, pts: t }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", n, "do-update-task"), "string" != typeof e || "" === e) return [2, w = new Promise((function (e, t) { t(W.TaskId_Is_Unavail) }))]; if (!t || !Array.isArray(t) || 0 === t.length) return [2, w = new Promise((function (e, t) { t(W.Point_Empty) }))]; for (i = t.length, o = [], s = 0; s < i; s++) { if ("number" != typeof (a = t[s]).index) return [2, w = new Promise((function (e, t) { t(W.Index_Is_Not_Number) }))]; if (u = !1, (h = {}).index = a.index, "boolean" == typeof a.isPass && (h.isPass = a.isPass, u = !0), Array.isArray(a.stepActs) && a.stepActs.length > 0) for (h.stepActs = [], d = a.stepActs.length, p = 0; p < d; p++)f = a.stepActs[p], null !== (m = this.createAction(f)) && (u = !0, h.stepActs.push(m)); if (!1 === u) return [2, w = new Promise((function (e, t) { t(W.Update_Value_Is_Error) }))]; o.push(h) } g = null, _ = {}, k.label = 1; case 1: return k.trys.push([1, 5, , 13]), [4, this.mBaseListener.checkChassisNetWork()]; case 2: return k.sent() ? [4, this.mBaseListener.getHeader()] : [2, new Promise((function (e, t) { t($.Update_Task_Fail) }))]; case 3: return y = k.sent(), _ = { taskPts: o }, [4, de.put("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/").concat(e, "?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), _, { headers: y })]; case 4: return g = k.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resData: g ? g.data : null }, "do-update-task-end"), [3, 13]; case 5: return v = k.sent(), x = { taskId: e, dataObj: _, error: v }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", x, "do-update-task-error"), w = null, v.response && 404 === v.response.status ? (w = new Promise((function (e, t) { t($.Update_Task_Fail_404) })), [3, 12]) : [3, 6]; case 6: return v.response && 401 === v.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (k.sent()) return [2, w = new Promise((function (e, t) { t(Q.Token_401) }))]; k.label = 8; case 8: return k.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return k.sent(), [3, 11]; case 10: return k.sent(), [2, w = new Promise((function (e, t) { t($.Update_Task_Fail) }))]; case 11: if (r > 0) return r--, [2, new Promise((function (n, i) { T.retryTimer = setTimeout((function () { return c(T, void 0, void 0, (function () { var i; return l(this, (function (o) { switch (o.label) { case 0: return [4, this.doUpdateTask(e, t, r)]; case 1: return i = o.sent(), n(i), [2] } })) })) }), T.requestRetryTime) }))]; w = new Promise((function (e, t) { t($.Update_Task_Fail) })), k.label = 12; case 12: return [2, w]; case 13: return g && g.data && 200 === g.data.status ? [2, !0] : (b = { taskId: e, error: g }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", b, "do-update-task-error"), g = g && g.data && g.data.message ? W.Api_Is_Error.errText = g.data.message : W.Api_Is_Error, [2, w = new Promise((function (e, t) { t(g) }))]) } })) })) }, e.prototype.setCurrentTaskProperty = function (e, t) { this.mCurTaskId = e, this.mCurTaskType = t }, e.prototype.getCurrentTaskProperty = function () { return { taskId: this.mCurTaskId, taskType: this.mCurTaskType } }, e.prototype.saveCruise = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Save_Cruise_Fail) }))]; this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", e, "save-cruise"), r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 13]), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "mobileapp/v1.1/cruise/save?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), e, { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resData: r ? r.data : null }, "save-cruise-end"), [3, 13]; case 5: return i = u.sent(), s = { cruiseInfo: e, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", s, "save-cruise-error"), o = null, i.response && 404 === i.response.status ? (o = new Promise((function (e, t) { t($.Save_Cruise_Fail_404) })), [3, 12]) : [3, 6]; case 6: return i.response && 401 === i.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (u.sent()) return [2, o = new Promise((function (e, t) { t(Q.Token_401) }))]; u.label = 8; case 8: return u.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return u.sent(), [3, 11]; case 10: return u.sent(), [2, o = new Promise((function (e, t) { t($.Save_Cruise_Fail) }))]; case 11: if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.saveCruise(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; o = new Promise((function (e, t) { t($.Save_Cruise_Fail) })), u.label = 12; case 12: return [2, o]; case 13: return r && r.data && 200 === r.data.status ? [2, !0] : (s = { cruiseInfo: e, error: r }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", s, "save-cruise-error"), [2, !1]) } })) })) }, e.prototype.getCruises = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u = this; return l(this, (function (h) { switch (h.label) { case 0: return e || (e = ""), r = { businessId: e }, [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!h.sent()) return [2, new Promise((function (e, t) { t($.Get_Cruise_By_businessId_Fail) }))]; this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", r, "get-cruise"), n = null, h.label = 2; case 2: return h.trys.push([2, 5, , 13]), [4, this.mBaseListener.getHeader()]; case 3: return i = h.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "mobileapp/v1.1/cruise/list?businessId=").concat(e, "&robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), { headers: i })]; case 4: return n = h.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resData: n ? n.data : null, businessId: e }, "get-cruise-end"), [3, 13]; case 5: return o = h.sent(), s = { businessId: e, error: o }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", s, "get-cruise-error"), a = null, o.response && 404 === o.response.status ? (a = new Promise((function (e, t) { t($.Get_Cruise_By_businessId_Fail_404) })), [3, 12]) : [3, 6]; case 6: return o.response && 401 === o.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (h.sent()) return [2, a = new Promise((function (e, t) { t(Q.Token_401) }))]; h.label = 8; case 8: return h.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return h.sent(), [3, 11]; case 10: return h.sent(), [2, a = new Promise((function (e, t) { t($.Get_Cruise_By_businessId_Fail) }))]; case 11: if (t > 0) return t--, [2, new Promise((function (r, n) { u.retryTimer = setTimeout((function () { return c(u, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getCruises(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), u.requestRetryTime) }))]; a = new Promise((function (e, t) { t($.Get_Cruise_By_businessId_Fail) })), h.label = 12; case 12: return [2, a]; case 13: return n ? [2, new Promise((function (e) { e(n.data) }))] : [2, null] } })) })) }, e.prototype.deleteCruise = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!d.sent()) return [2, new Promise((function (e, t) { t($.Delete_Cruise_By_Id_Fail) }))]; r = { ids: e }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", r, "delete-cruise"), n = null, d.label = 2; case 2: return d.trys.push([2, 5, , 13]), [4, this.mBaseListener.getHeader()]; case 3: return i = d.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "mobileapp/v1.1/cruise/delete?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), { ids: e }, { headers: i })]; case 4: return n = d.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resData: n ? n.data : null }, "delete-cruise-end"), [3, 13]; case 5: return o = d.sent(), s = { ids: e, error: o }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", s, "delete-cruise-error"), a = null, o.response && 404 === o.response.status ? (a = new Promise((function (e, t) { t($.Delete_Cruise_By_Id_Fail_404) })), [3, 12]) : [3, 6]; case 6: return o.response && 401 === o.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (d.sent()) return [2, a = new Promise((function (e, t) { t(Q.Token_401) }))]; d.label = 8; case 8: return d.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return d.sent(), [3, 11]; case 10: return d.sent(), [2, a = new Promise((function (e, t) { t($.Delete_Cruise_By_Id_Fail) }))]; case 11: if (t > 0) return t--, [2, new Promise((function (r, n) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.deleteCruise(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), h.requestRetryTime) }))]; a = new Promise((function (e, t) { t($.Delete_Cruise_By_Id_Fail) })), d.label = 12; case 12: return [2, a]; case 13: return n && n.data && 200 === n.data.status ? [2, !0] : (u = { ids: e, error: n }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", u, "delete-cruise-error"), [2, !1]) } })) })) }, e.prototype.syncCruiseCloud = function (e) { return c(this, void 0, Promise, (function () { var t, r, n, i, o; return l(this, (function (s) { switch (s.label) { case 0: return this.mBaseListener.getMode() === X.WAN_APP ? [2, !0] : [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!s.sent()) return [2, !1]; t = { businessId: e }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", t, "sync-cruise-cloud"), r = null, s.label = 2; case 2: return s.trys.push([2, 4, , 5]), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "mobileapp/v1.1/cruise/sync/cloud?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), t)]; case 3: return r = s.sent(), [3, 5]; case 4: return n = s.sent(), i = { businessId: e, error: n }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", i, "sync-cruise-cloud-error"), [3, 5]; case 5: return this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { res: r }, "sync-cruise-cloud-res"), r && r.data && 200 === r.data.status ? [2, !0] : (o = { businessId: e, error: r }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", o, "sync-cruise-cloud-error"), [2, !1]) } })) })) }, e.prototype.syncCruiseLocal = function () { return c(this, void 0, Promise, (function () { var e, t, r; return l(this, (function (n) { switch (n.label) { case 0: return this.mBaseListener.getMode() === X.WAN_APP ? [2, !0] : [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!n.sent()) return [2, !1]; this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", {}, "sync-cruise-local"), e = null, n.label = 2; case 2: return n.trys.push([2, 4, , 5]), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "mobileapp/v1.1/cruise/sync/local?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()))]; case 3: return e = n.sent(), [3, 5]; case 4: return t = n.sent(), r = { error: t }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", r, "sync-cruise-local-error"), [3, 5]; case 5: return e && e.data && 200 === e.data.status ? [2, !0] : (r = { error: e }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", r, "sync-cruise-local-error"), [2, !1]) } })) })) }, e.prototype.getTaskList = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Task_List_Fail) }))]; if (this.mBaseListener.getMode() !== X.WAN_APP) return [2, null]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 10]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { param: e }, "request-get-task-list"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "task/v2.0/list"), e, { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resData: r ? r.data : null }, "request-get-task-list-end"), [3, 10]; case 5: return i = u.sent(), o = { param: e, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", o, "request-get-task-list-error"), s = null, i.response && 404 === i.response.status ? (s = new Promise((function (e, t) { t($.Get_Task_List_Fail_404) })), [3, 9]) : [3, 6]; case 6: return i.response && 401 === i.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 8]; case 7: if (u.sent()) return [2, s = new Promise((function (e, t) { t(Q.Token_401) }))]; u.label = 8; case 8: if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getTaskList(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Task_List_Fail) })), u.label = 9; case 9: return [2, s]; case 10: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.getTaskDetail = function (e, t) { return c(this, void 0, Promise, (function () { var t, r, n, i, o, s; return l(this, (function (a) { switch (a.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: return a.sent() ? e ? [4, this.getLocalTaskInfo(e)] : [3, 8] : [2, new Promise((function (e, t) { t($.Get_Task_Detail_Fail) }))]; case 2: if (t = a.sent()) return delete t.id, [2, t]; r = null, a.label = 3; case 3: return a.trys.push([3, 6, , 7]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { taskId: e }, "get-task-detail"), [4, this.mBaseListener.getHeader()]; case 4: return n = a.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "task/v2.0/").concat(e), { headers: n })]; case 5: return r = a.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resData: r ? r.data : null }, "get-task-detail-end"), [3, 7]; case 6: return i = a.sent(), s = { taskId: e, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", s, "get-task-detail-error"), [3, 7]; case 7: return r && r.data && 200 === r.data.status ? ((o = r.data.data) && (o.id = o.taskId, "abort" !== o.taskState && "cancel" !== o.taskState && "success" !== o.taskState || this.addLocalTaskInfo(o)), [2, r.data.data]) : (s = { taskId: e, error: r }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", s, "get-task-detail-error"), r = r && r.data && r.data.message ? W.Task_Is_Error.errText = r.data.message : W.Task_Is_Error, [2, new Promise((function (e, t) { t(r) }))]); case 8: this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { taskId: "" }, "get-task-detail-error"), a.label = 9; case 9: return [2, new Promise((function (e, t) { t(W.Task_Is_Null) }))] } })) })) }, e.prototype.addLocalTaskInfo = function (e) { return c(this, void 0, void 0, (function () { return l(this, (function (t) { switch (t.label) { case 0: return "undefined" == typeof window ? [3, 2] : [4, this.indexedDB.addData(this.indexedDBName, e)]; case 1: t.sent(), t.label = 2; case 2: return [2] } })) })) }, e.prototype.getLocalTaskInfo = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return "undefined" == typeof window ? [3, 2] : [4, this.indexedDB.getData(this.indexedDBName, e)]; case 1: return [2, t.sent()]; case 2: return [2, null] } })) })) }, e.prototype.getCustomizeTaskList = function (e) { return void 0 === e && (e = 15), c(this, void 0, Promise, (function () { var t, r, n, i, o, s = this; return l(this, (function (a) { switch (a.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!a.sent()) return [2, new Promise((function (e, t) { t($.Get_Task_List_Fail) }))]; if (this.mBaseListener.getMode() === X.WAN_APP) return [2, null]; t = null, a.label = 2; case 2: return a.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", {}, "request-get-customize-task-list"), [4, this.mBaseListener.getHeader()]; case 3: return r = a.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "customize/task/v1.1/list"), {}, { headers: r })]; case 4: return t = a.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resData: t ? t.data : null }, "request-get-customize-task-list-end"), [3, 6]; case 5: if (n = a.sent(), i = { error: n }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", i, "request-get-customize-task-list-error"), o = null, n.response && 404 === n.response.status) o = new Promise((function (e, t) { t($.Get_Task_List_Fail_404) })); else { if (e > 0) return e--, [2, new Promise((function (t, r) { s.retryTimer = setTimeout((function () { return c(s, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.getCustomizeTaskList(e)]; case 1: return r = n.sent(), t(r), [2] } })) })) }), s.requestRetryTime) }))]; o = new Promise((function (e, t) { t($.Get_Task_List_Fail) })) } return [2, o]; case 6: return t ? [2, new Promise((function (e) { e(t.data) }))] : [2, null] } })) })) }, e.prototype.saveCustomizeTask = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Task_List_Fail) }))]; if (this.mBaseListener.getMode() === X.WAN_APP) return [2, null]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { taskData: e }, "request-save-customize-task-list"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.put("".concat(this.mBaseListener.getServerUrl(), "customize/task/v1.1"), e, { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resData: r ? r.data : null }, "request-save-customize-task-list-end"), [3, 6]; case 5: if (i = u.sent(), o = { taskData: e, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", o, "request-save-customize-task-list-error"), s = null, i.response && 404 === i.response.status) s = new Promise((function (e, t) { t($.Get_Task_List_Fail_404) })); else { if (t > 0) return t--, [2, new Promise((function (e, r) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.saveCustomizeTask(t)]; case 1: return r = n.sent(), e(r), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Task_List_Fail) })) } return [2, s]; case 6: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.delCustomizeTask = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Task_List_Fail) }))]; if (this.mBaseListener.getMode() === X.WAN_APP) return [2, null]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { taskId: e }, "request-del-customize-task-list"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.delete("".concat(this.mBaseListener.getServerUrl(), "customize/task/v1.1/").concat(e, "?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resData: r ? r.data : null }, "request-del-customize-task-list-end"), [3, 6]; case 5: if (i = u.sent(), o = { taskId: e, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", o, "request-del-customize-task-list-error"), s = null, i.response && 404 === i.response.status) s = new Promise((function (e, t) { t($.Get_Task_List_Fail_404) })); else { if (t > 0) return t--, [2, new Promise((function (e, r) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.delCustomizeTask(t)]; case 1: return r = n.sent(), e(r), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Task_List_Fail) })) } return [2, s]; case 6: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.getTaskDetailsById = function (e, t) { return c(this, void 0, Promise, (function () { var t, r, n, i; return l(this, (function (o) { switch (o.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!o.sent()) return [2, new Promise((function (e, t) { t($.Get_Task_Detail_Fail) }))]; if (!e) return [3, 7]; t = null, o.label = 2; case 2: return o.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { taskId: e }, "get-task-detail-by-id"), [4, this.mBaseListener.getHeader()]; case 3: return r = o.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/").concat(e), { headers: r })]; case 4: return t = o.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { data: t }, "get-task-detail-by-id-end"), [3, 6]; case 5: return n = o.sent(), i = { taskId: e, error: n }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", i, "get-task-detail-by-id-error"), [3, 6]; case 6: return t && t.data && 200 === t.data.status ? [2, t.data.data] : (i = { taskId: e, error: t }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", i, "get-task-detail-by-id-error"), t = t && t.data && t.data.message ? W.Task_Is_Error.errText = t.data.message : W.Task_Is_Error, [2, new Promise((function (e, r) { r(t) }))]); case 7: this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { taskId: "" }, "get-task-detail-by-id-error"), o.label = 8; case 8: return [2, new Promise((function (e, t) { t(W.Task_Is_Null) }))] } })) })) }, e.prototype.addTaskSimple = function (e, t) { return c(this, void 0, Promise, (function () { var r, n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getTaskSimpleTemplate(e)]; case 1: return (r = i.sent()) ? [3, 2] : [2, !1]; case 2: return n = !1, r ? [4, this.startTask(r, t)] : [3, 4]; case 3: n = i.sent(), i.label = 4; case 4: return [2, n] } })) })) }, e.prototype.getTaskSimpleTemplate = function (e) { return c(this, void 0, Promise, (function () { var t; return l(this, (function (r) { return t = {}, e && (e.x || e.y || (e.coordinate && e.coordinate.length) > 0) ? (t = { x: e.x ? e.x : e.coordinate[0], y: e.y ? e.y : e.coordinate[1], yaw: e.yaw, areaId: e.areaId, ext: { name: e.name, id: e.id } }, [2, { name: "task " + (new Date).getTime(), runNum: 1, runType: 21, pts: [t] }]) : [2, null] })) })) }, e.prototype.getTaskComplexTemplate = function (e, t, r) { return c(this, void 0, Promise, (function () { var n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return n = [], e ? (i = this, e.forEach((function (e) { return c(a, void 0, void 0, (function () { var t; return l(this, (function (r) { switch (r.label) { case 0: return t = null, [4, i.changePt(e)]; case 1: return (t = r.sent()).stepActs = e.stepActs, n.push(t), [2] } })) })) })), o = { name: "task " + (new Date).getTime(), runNum: 1, taskType: 2, runType: 20, sourceType: 6, pts: n, backPt: null }, t.name && (o.name = t.name), t.runNum && (o.runNum = Number(t.runNum)), (t.taskType || 0 === t.taskType) && (o.runType = Number(t.taskType)), (t.runType || 0 === t.runType) && (o.runType = Number(t.runType)), (t.sourceType || 0 === t.sourceType) && (o.sourceType = Number(t.sourceType)), [4, this.changePt(r)]) : [3, 2]; case 1: return (s = u.sent()) ? o.backPt = s : delete o.backPt, [2, o]; case 2: return [2, null] } })) })) }, e.prototype.getTaskAreaTemplate = function (e, t, r) { return c(this, void 0, Promise, (function () { var n; return l(this, (function (i) { n = []; try { return e.forEach((function (e) { n.push({ id: e.id, name: e.name, areaId: e.areaId, x: e.coordinates[0][0][0], y: e.coordinates[0][0][1], yaw: 0, stepActs: e.stepActs }) })), [2, this.getTaskComplexTemplate(n, t, r)] } catch (e) { return [2, e] } return [2] })) })) }, e.prototype.changePt = function (e) { return c(this, void 0, Promise, (function () { var t; return l(this, (function (r) { return e ? ((t = { x: null, y: null, yaw: null, areaId: null, type: null, ext: { name: null, id: null } }).x = e.x ? e.x : e.coordinate && e.coordinate.length > 0 ? e.coordinate[0] : "", t.y = e.y ? e.y : e.coordinate && e.coordinate.length > 0 ? e.coordinate[1] : "", t.yaw = e.yaw, t.areaId = e.areaId, t.type = e.type, t.ext.name = e.name, t.ext.id = e.id, [2, t]) : [2, null] })) })) }, e.prototype.format = function (e, t) { var r = { "M+": e.getMonth() + 1, "d+": e.getDate(), "h+": e.getHours(), "m+": e.getMinutes(), "s+": e.getSeconds(), "q+": Math.floor((e.getMonth() + 3) / 3), S: e.getMilliseconds() }; for (var n in /(y+)/.test(t) && (t = t.replace(RegExp.$1, (e.getFullYear() + "").substr(4 - RegExp.$1.length))), r) new RegExp("(" + n + ")").test(t) && (t = t.replace(RegExp.$1, 1 == RegExp.$1.length ? r[n] : ("00" + r[n]).substr(("" + r[n]).length))); return t }, e.prototype.createPathTaskItem = function (e) { var t = { incompleteName: !1, dispensable: !1, properties: [], deadline: null, type: null, destinations: null, intendedVehicle: null }, r = new Date((new Date).getTime() + 1728e5); return t.deadline = this.format(r, "yyyy-MM-ddThh:mm:ss.SZ"), t.type = e.pathName, t.destinations = [], t }, e.prototype.buildPathTaskData = function (e, t) { if (!Array.isArray(e.taskNodes) || 0 === e.taskNodes.length) return !1; Array.isArray(t.destinations) || (t.destinations = []); var r = []; Array.isArray(e.shelves) && e.shelves.forEach((function (e) { r.push(e.id) })), Array.isArray(t.properties) || (t.properties = []), e.properties && "object" == typeof e.properties && Object.keys(e.properties).forEach((function (r) { t.properties.push({ key: r, value: e.properties[r] }) })); for (var n = e.taskNodes.length, i = function (i) { var o = e.taskNodes[i]; if (!Array.isArray(o.nodes) || 0 === o.nodes.length) return { value: !1 }; var s = null; if ("Point" === o.type) s = o.nodes[0]; else if ("Area" === o.type) { if (!0 === o.block) if (0 === i) { s = o.nodes[0]; for (var a = 0; a < o.nodes.length; a++) { var c = o.nodes[a]; if (r.includes(c.id)) { s = c; break } } } else if (i === n - 1) for (s = o.nodes[o.nodes.length - 1], a = o.nodes.length - 1; a >= 0; a--)if (c = o.nodes[a], !r.includes(c.id)) { s = c; break } if (null === s) { var l = Math.floor(Math.random() * o.nodes.length); s = o.nodes[l] } "Mapping" === o.sourceType && ((s = JSON.parse(JSON.stringify(s))).id = o.id, s.action && Array.isArray(s.action.properties) && s.action.properties.forEach((function (e) { var t = JSON.parse(e.value); t.forEach((function (e) { e.data || (e.data = {}), e.data.useAreaId = s.id })), e.value = JSON.stringify(t) }))) } var u = { locationName: s.id, operation: "MOVE", properties: [] }; if (s.action) { if (!s.action.operation) return { value: !1 }; if ("MOVE" !== s.action.operation && (u.locationName = "Loc-" + u.locationName), u.operation = s.action.operation, 9 === s.type && (u.locationName = "Loc-" + u.locationName, u.operation = "Charge"), Array.isArray(s.action.properties)) { var h = {}; s.action.properties.forEach((function (e) { var t = h[e.key]; Array.isArray(t) || (t = []); var r = JSON.parse(e.value); Array.isArray(r) ? t = t.concat(r) : t.push(r), h[e.key] = t })), Object.keys(h).forEach((function (e) { u.properties.push({ key: e, value: JSON.stringify(h[e]) }) })) } } t.destinations.push(u) }, o = 0; o < n; o++) { var s = i(o); if ("object" == typeof s) return s.value } return !0 }, e.prototype.addRCSAreaTask = function (e, t, r, n) { return void 0 === r && (r = !1), void 0 === n && (n = 15), c(this, void 0, Promise, (function () { var i, o, s, a, u, h, d, p, f = this; return l(this, (function (m) { switch (m.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!m.sent()) return [2, new Promise((function (e, t) { t($.Add_RCS_Area_Task_Fail) }))]; if (this.mBaseListener.getMode() !== X.WAN_APP) return [2, null]; i = null, m.label = 2; case 2: return m.trys.push([2, 5, , 6]), t ? (o = Date.now(), s = "AX-" + t.type + "-" + o, a = this.createPathTaskItem(t), this.buildPathTaskData(t, a) ? (r ? delete a.intendedVehicle : a.intendedVehicle = e, this.mBaseListener.exportOperationLogger(V, e, "AXSearchEngin", {}, "add-rcs-area-task"), [4, this.mBaseListener.getHeader()]) : [2, null]) : [2, null]; case 3: return u = m.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "robot/v2.0/opentcs/transportOrders/").concat(s, "/").concat(e), a, { headers: u })]; case 4: return i = m.sent(), this.mBaseListener.exportOperationLogger(V, e, "AXSearchEngin", { resData: i ? i.data : null }, "response-add-rcs-area-task-end"), [3, 6]; case 5: if (h = m.sent(), d = { error: h }, this.mBaseListener.exportOperationLogger(N, e, "AXSearchEngin", d, "request-add-rcs-area-task-error"), p = null, h.response && 404 === h.response.status) p = new Promise((function (e, t) { h.response.data && re[h.response.data.status] && ($.Add_RCS_Area_Task_404.errText = re[h.response.data.status], $.Add_RCS_Area_Task_404.errCode = h.response.data.status, $.Add_RCS_Area_Task_404.data = h.response.data.data), t($.Add_RCS_Area_Task_404) })); else if (h.response && 400 === h.response.status) p = new Promise((function (e, t) { if (h.response.data) { var r = { errText: null, errCode: null, data: null }; re[h.response.data.status] ? (r.errText = re[h.response.data.status], r.errCode = h.response.data.status, r.data = h.response.data.data, t(r)) : e(h.response.data) } })); else { if (n > 0) return n--, [2, new Promise((function (i, o) { f.retryTimer = setTimeout((function () { return c(f, void 0, void 0, (function () { var o; return l(this, (function (s) { switch (s.label) { case 0: return [4, this.addRCSAreaTask(e, t, r, n)]; case 1: return o = s.sent(), i(o), [2] } })) })) }), f.requestRetryTime) }))]; p = new Promise((function (e, t) { t($.Add_RCS_Area_Task_Fail) })) } return [2, p]; case 6: return i ? [2, new Promise((function (e) { e(i.data) }))] : [2, null] } })) })) }, e.prototype.getGroupList = function (e, t) { return c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Group_List_Fail) }))]; if (this.mBaseListener.getMode() !== X.WAN_APP) return [2, null]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { param: e }, "request-get-group-list"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/grouped-task/group/list"), e, { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resData: r ? r.data : null }, "request-get-group-list"), [3, 6]; case 5: if (i = u.sent(), o = { param: e, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", o, "request-get-group-list-error"), s = null, i.response && 404 === i.response.status) s = new Promise((function (e, t) { t($.Get_Group_List_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getTaskList(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Group_List_Fail) })) } return [2, s]; case 6: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.addGroup = function (e, t) { return c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u = this; return l(this, (function (h) { switch (h.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!h.sent()) return [2, new Promise((function (e, t) { t($.Add_Group_Fail) }))]; r = null, h.label = 2; case 2: return h.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, "", "AXTaskEngin", {}, "put-add-group"), [4, this.mBaseListener.getHeader()]; case 3: return n = h.sent(), [4, de.put("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/grouped-task/group"), e, { headers: n })]; case 4: return r = h.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskEngin", { resData: r ? r.data : null }, "put-add-group-end"), [3, 6]; case 5: if (i = h.sent(), o = { error: i }, this.mBaseListener.exportOperationLogger(N, "", "AXTaskEngin", o, "put-add-group-error"), a = null, i.response && 404 === i.response.status) a = new Promise((function (e, t) { t($.Add_Group_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { u.retryTimer = setTimeout((function () { return c(u, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.addGroup(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), u.requestRetryTime) }))]; a = new Promise((function (e, t) { t($.Add_Group_Fail) })) } return [2, a]; case 6: return r && r.data && 200 === r.data.status ? [2, !0] : (s = $.Add_Group_Fail, r && r.data && 410 === r.data.status ? s = $.Add_Group_Fail_NameExit : r && r.data && r.data.message && (s = { errText: r.data.message, errCode: r.data.status }), [2, a = new Promise((function (e, t) { t(s) }))]) } })) })) }, e.prototype.editGroup = function (e, t, r) { return c(this, void 0, Promise, (function () { var n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!d.sent()) return [2, new Promise((function (e, t) { t($.Edit_Group_Fail) }))]; n = null, d.label = 2; case 2: return d.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, "", "AXTaskEngin", {}, "patch-edit-group"), [4, this.mBaseListener.getHeader()]; case 3: return i = d.sent(), [4, de.patch("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/grouped-task/group/").concat(e), t, { headers: i })]; case 4: return n = d.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskEngin", { resData: n ? n.data : null }, "patch-edit-group-end"), [3, 6]; case 5: if (o = d.sent(), s = { error: o }, this.mBaseListener.exportOperationLogger(N, "", "AXTaskEngin", s, "patch-edit-group-error"), u = null, o.response && 404 === o.response.status) u = new Promise((function (e, t) { t($.Edit_Group_404) })); else { if (r > 0) return r--, [2, new Promise((function (n, i) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var i; return l(this, (function (o) { switch (o.label) { case 0: return [4, this.editGroup(e, t, r)]; case 1: return i = o.sent(), n(i), [2] } })) })) }), h.requestRetryTime) }))]; u = new Promise((function (e, t) { t($.Edit_Group_Fail) })) } return [2, u]; case 6: return n && n.data && 200 === n.data.status ? [2, !0] : (a = $.Edit_Group_Fail, n && n.data && 410 === n.data.status ? a = $.Add_Group_Fail_NameExit : n && n.data && n.data.message && (a = { errText: n.data.message, errCode: n.data.status }), [2, u = new Promise((function (e, t) { t(a) }))]) } })) })) }, e.prototype.delGroup = function (e, t) { return c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u = this; return l(this, (function (h) { switch (h.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!h.sent()) return [2, new Promise((function (e, t) { t($.Del_Group_Fail) }))]; r = null, h.label = 2; case 2: return h.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, "", "AXTaskEngin", { groupId: e }, "delete-group"), [4, this.mBaseListener.getHeader()]; case 3: return n = h.sent(), [4, de.delete("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/grouped-task/group/").concat(e), { headers: n })]; case 4: return r = h.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskEngin", { resData: r ? r.data : null }, "delete-group-end"), [3, 6]; case 5: if (i = h.sent(), o = { error: i }, this.mBaseListener.exportOperationLogger(N, "", "AXTaskEngin", o, "delete-group-error"), a = null, i.response && 404 === i.response.status) a = new Promise((function (e, t) { t($.Del_Group_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { u.retryTimer = setTimeout((function () { return c(u, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.delGroup(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), u.requestRetryTime) }))]; a = new Promise((function (e, t) { t($.Del_Group_Fail) })) } return [2, a]; case 6: return r && r.data && 200 === r.data.status ? [2, !0] : (s = $.Del_Group_Fail, r && r.data && 411 === r.data.status ? s = $.Del_Group_Fail_bound : r && r.data && r.data.message && (s = { errText: r.data.message, errCode: r.data.status }), [2, a = new Promise((function (e, t) { t(s) }))]) } })) })) }, e.prototype.getGroupDetail = function (e, t) { return c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Group_Detail_Fail) }))]; if (this.mBaseListener.getMode() !== X.WAN_APP) return [2, null]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, "", "AXTaskEngin", { groupId: e }, "get-group-detail"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/grouped-task/group/").concat(e), { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskEngin", { resData: r ? r.data : null }, "get-group-detail"), [3, 6]; case 5: if (i = u.sent(), o = { groupId: e, error: i }, this.mBaseListener.exportOperationLogger(N, "", "AXTaskEngin", o, "get-group-detail-error"), s = null, i.response && 404 === i.response.status) s = new Promise((function (e, t) { t($.Get_Group_Detail_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getGroupDetail(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Group_Detail_Fail) })) } return [2, s]; case 6: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.getGroupTaskList = function (e, t) { return c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Group_Task_List_Fail) }))]; if (this.mBaseListener.getMode() !== X.WAN_APP) return [2, null]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { param: e }, "request-get-group-task-list"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/grouped-task/task/list"), e, { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resData: r ? r.data : null }, "request-get-group-task-list"), [3, 6]; case 5: if (i = u.sent(), o = { param: e, error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", o, "request-get-group-task-list-error"), s = null, i.response && 404 === i.response.status) s = new Promise((function (e, t) { t($.Get_Group_Task_List_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getTaskList(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Group_Task_List_Fail) })) } return [2, s]; case 6: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.addGroupTask = function (e, t) { return c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u = this; return l(this, (function (h) { switch (h.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!h.sent()) return [2, new Promise((function (e, t) { t($.Add_Group_Task_Fail) }))]; r = null, h.label = 2; case 2: return h.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, "", "AXTaskEngin", {}, "put-add-group-task"), [4, this.mBaseListener.getHeader()]; case 3: return n = h.sent(), [4, de.put("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/grouped-task/task"), e, { headers: n })]; case 4: return r = h.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskEngin", { resData: r ? r.data : null }, "put-add-group-task-end"), [3, 6]; case 5: if (i = h.sent(), o = { error: i }, this.mBaseListener.exportOperationLogger(N, "", "AXTaskEngin", o, "put-add-group-task-error"), a = null, i.response && 404 === i.response.status) a = new Promise((function (e, t) { t($.Add_Group_Task_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { u.retryTimer = setTimeout((function () { return c(u, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.addGroupTask(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), u.requestRetryTime) }))]; a = new Promise((function (e, t) { t($.Add_Group_Task_Fail) })) } return [2, a]; case 6: return r && r.data && 200 === r.data.status ? [2, !0] : (s = $.Add_Group_Task_Fail, r && r.data && 410 === r.data.status ? s = $.Add_Group_Task_Fail_NameExit : r && r.data && r.data.message && (s = { errText: r.data.message, errCode: r.data.status }), [2, a = new Promise((function (e, t) { t(s) }))]) } })) })) }, e.prototype.editGroupTask = function (e, t, r) { return c(this, void 0, Promise, (function () { var n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!d.sent()) return [2, new Promise((function (e, t) { t($.Edit_Group_Task_Fail) }))]; n = null, d.label = 2; case 2: return d.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, "", "AXTaskEngin", {}, "patch-edit-group-task"), [4, this.mBaseListener.getHeader()]; case 3: return i = d.sent(), [4, de.patch("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/grouped-task/task/").concat(e), t, { headers: i })]; case 4: return n = d.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskEngin", { resData: n ? n.data : null }, "patch-edit-group-task-end"), [3, 6]; case 5: if (o = d.sent(), s = { error: o }, this.mBaseListener.exportOperationLogger(N, "", "AXTaskEngin", s, "patch-edit-group-task-error"), u = null, o.response && 404 === o.response.status) u = new Promise((function (e, t) { t($.Edit_Group_Task_404) })); else { if (r > 0) return r--, [2, new Promise((function (n, i) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var i; return l(this, (function (o) { switch (o.label) { case 0: return [4, this.editGroupTask(e, t, r)]; case 1: return i = o.sent(), n(i), [2] } })) })) }), h.requestRetryTime) }))]; u = new Promise((function (e, t) { t($.Edit_Group_Task_Fail) })) } return [2, u]; case 6: return n && n.data && 200 === n.data.status ? [2, !0] : (a = $.Edit_Group_Task_Fail, n && n.data && 410 === n.data.status ? a = $.Add_Group_Task_Fail_NameExit : n && n.data && n.data.message && (a = { errText: n.data.message, errCode: n.data.status }), [2, u = new Promise((function (e, t) { t(a) }))]) } })) })) }, e.prototype.delGroupTask = function (e, t) { return c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u = this; return l(this, (function (h) { switch (h.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!h.sent()) return [2, new Promise((function (e, t) { t($.Del_Group_Task_Fail) }))]; r = null, h.label = 2; case 2: return h.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, "", "AXTaskEngin", {}, "delete-task-group"), [4, this.mBaseListener.getHeader()]; case 3: return n = h.sent(), [4, de.delete("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/grouped-task/task/").concat(e), { headers: n })]; case 4: return r = h.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskEngin", { resData: r ? r.data : null }, "delete-group-task-end"), [3, 6]; case 5: if (i = h.sent(), o = { error: i }, this.mBaseListener.exportOperationLogger(N, "", "AXTaskEngin", o, "delete-group-task-error"), a = null, i.response && 404 === i.response.status) a = new Promise((function (e, t) { t($.Del_Group_Task_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { u.retryTimer = setTimeout((function () { return c(u, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.delGroupTask(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), u.requestRetryTime) }))]; a = new Promise((function (e, t) { t($.Del_Group_Task_Fail) })) } return [2, a]; case 6: return r && r.data && 200 === r.data.status ? [2, !0] : (s = $.Del_Group_Task_Fail, r && r.data && r.data.message && (s = { errText: r.data.message, errCode: r.data.status }), [2, a = new Promise((function (e, t) { t(s) }))]) } })) })) }, e.prototype.getGroupTaskDetail = function (e, t) { return c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Group_Task_Detail_Fail) }))]; if (this.mBaseListener.getMode() !== X.WAN_APP) return [2, null]; r = null, u.label = 2; case 2: return u.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, "", "AXTaskEngin", { taskId: e }, "get-group-task-detail"), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/grouped-task/task/").concat(e), { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskEngin", { resData: r ? r.data : null }, "get-group-task-detail"), [3, 6]; case 5: if (i = u.sent(), o = { taskId: e, error: i }, this.mBaseListener.exportOperationLogger(N, "", "AXTaskEngin", o, "get-group-detail-task-error"), s = null, i.response && 404 === i.response.status) s = new Promise((function (e, t) { t($.Get_Group_Task_Detail_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getGroupTaskDetail(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Group_Task_Detail_Fail) })) } return [2, s]; case 6: return r ? [2, new Promise((function (e) { e(r.data) }))] : [2, null] } })) })) }, e.prototype.cancelTaskV3 = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h, d, p = this; return l(this, (function (f) { switch (f.label) { case 0: if (r = null, n = null, !(n = e && "" !== e ? e : this.mCurTaskId)) return [2, new Promise((function (e, t) { e(!0) }))]; f.label = 1; case 1: return f.trys.push([1, 5, , 13]), [4, this.mBaseListener.checkChassisNetWork()]; case 2: return f.sent() ? (i = { taskId: n }, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", i, "cancel-task-v3"), [4, this.mBaseListener.getHeader()]) : [2, new Promise((function (e, t) { t($.Cancel_Task_Fail) }))]; case 3: return o = f.sent(), s = { taskId: n }, [4, de.post("".concat(this.mBaseListener.getServerUrl(), "task/v3/").concat(n, "/cancel"), s, { headers: o })]; case 4: return r = f.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", { resData: r ? r.data : null }, "cancel-task-v3-end"), [3, 13]; case 5: return a = f.sent(), u = { taskId: n, error: a }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", u, "cancel-task-v3-error"), h = null, a.response && 404 === a.response.status ? (h = new Promise((function (e, t) { t($.Cancel_Task_Fail_404) })), [3, 12]) : [3, 6]; case 6: return a.response && 401 === a.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (f.sent()) return [2, h = new Promise((function (e, t) { t(Q.Token_401) }))]; f.label = 8; case 8: return f.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return f.sent(), [3, 11]; case 10: return f.sent(), [2, h = new Promise((function (e, t) { t($.Cancel_Task_Fail) }))]; case 11: if (t > 0) return t--, [2, new Promise((function (r, n) { p.retryTimer = setTimeout((function () { return c(p, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.cancelTaskV3(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), p.requestRetryTime) }))]; h = new Promise((function (e, t) { t($.Cancel_Task_Fail) })), f.label = 12; case 12: return [2, h]; case 13: return r && r.data && 200 === r.data.status ? (this.mCurTaskId = null, this.mCurTaskType = null, [2, !0]) : (d = { taskId: e, error: r }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXTaskEngin", d, "cancel-task-error"), r = r && r.data && r.data.message ? W.Api_Is_Error.errText = r.data.message : W.Api_Is_Error, [2, new Promise((function (e, t) { t(r) }))]) } })) })) }, e }(), Le = function () { function e(e) { this.isFinishBusinessChannel = !1, this.businessWsError = !1, this.requestRetryTime = 1e3, this.mCmds = new Map, this.updateMapTimer = null, this.mBaseListener = e, e.getMode() !== X.WAN_APP ? (this.requestRetryTime = 1e3, this.destroy()) : this.requestRetryTime = 5e3 } return e.prototype.destroy = function () { null !== this.retryTimer && (clearTimeout(this.retryTimer), this.retryTimer = null), this.mMyChannelWs && (this.mMyChannelWs.stop(), this.mMyChannelWs = null), this.businessHearBeatTimeout && (clearTimeout(this.businessHearBeatTimeout), this.businessHearBeatTimeout = null), this.isFinishBusinessChannel = !1 }, e.prototype.startChannel = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.startWebSocket(e, t)]; case 1: return r.sent(), [2, !0] } })) })) }, e.prototype.updateMapByRobotId = function (e, t, r) { return void 0 === r && (r = 90), c(this, void 0, void 0, (function () { var n, i; return l(this, (function (o) { switch (o.label) { case 0: return n = {}, "boolean" == typeof t ? !1 === t ? n = { syncCloud: !1 } : !0 === t && (n = { syncCloud: !0 }) : n = void 0 === t ? {} : t, n || (n = {}), i = { deviceId: e, id: Te.generateUUID(), cmd: "updateMap", args: n, needConfirm: !0, timeoutSec: r, timestamp: (new Date).getTime() }, this.mMyChannelWs.send(i), [4, this.checkCmd(i.id, 1e3 * r)]; case 1: return [2, o.sent()] } })) })) }, e.prototype.startWebSocket = function (e, t) { return c(this, void 0, Promise, (function () { var r, n, i, o = this; return l(this, (function (s) { switch (s.label) { case 0: return "string" != typeof e ? [2, null] : (this.businessId = e, r = this.mBaseListener.getWsUrl() + "robot-control/business/" + e, n = "bussiness", "string" == typeof t && "" !== t && (n = "area", r += "?areaId=" + t), this.mBaseListener.exportOperationLogger(V, "", "AXRobotsEngin", { isFinishBusinessChannel: this.isFinishBusinessChannel }, "start-subscribe-robots-state-by-" + n), !0 === this.isFinishBusinessChannel ? [2] : (this.mMyChannelWs && (this.mMyChannelWs.stop(), this.mMyChannelWs = null), [4, this.mBaseListener.getTokenKey()])); case 1: return (i = s.sent()) ? (this.mBaseListener.exportOperationLogger(V, "", "AXRobotsEngin", { isFinishBusinessChannel: this.isFinishBusinessChannel, tokenKey: i }, "start-subscribe-robots-state-by-" + n), this.mMyChannelWs = new _e, [4, this.mMyChannelWs.start((function (e, t) { return c(o, void 0, void 0, (function () { var r, n; return l(this, (function (i) { return t && t.commandId ? (this.mGetRobotSettingsCMD === t.commandId && (r = {}, t.commandData && t.commandData.data && (r = t.commandData.data), this.mBaseListener.onRobotSettingsStateChanged(r)), this.mCmds && this.mCmds.has(t.commandId) && (0 === t.code || 1 === t.state ? this.mCmds.get(t.commandId)(t.commandData) : (t.rawConfirm && (n = JSON.parse(t.rawConfirm), t.code = n.code), 5 === t.code ? this.mCmds.get(t.commandId + "_failed")(K.Update_Map_Failed_By_Updating) : 6 === t.code ? this.mCmds.get(t.commandId + "_failed")(K.Update_Map_Failed_By_Tasking) : 7 === t.code ? this.mCmds.get(t.commandId + "_failed")(K.Update_Map_Failed_By_Mapping) : this.mCmds.get(t.commandId + "_failed")()), this.mCmds.delete(t.commandId), this.mCmds.delete(t.commandId + "_failed"), "function" == typeof this.mCmds.get(t.commandId + "_timer") && this.mCmds.delete(t.commandId + "_timer"))) : 0 === e && t ? this.dealRobotsState(t) : 1 === e && null !== this.mMyChannelWs && this.setChannelFaild(t), [2] })) })) }), r, i)]) : [2]; case 2: return s.sent(), [2] } })) })) }, e.prototype.dealRobotsState = function (e) { this.mBaseListener.onRobotListStatusChanged(e) }, e.prototype.setChannelFaild = function (e, t) { return c(this, void 0, void 0, (function () { return l(this, (function (r) { return e && t ? this.mBaseListener.onRobotListStatusError(t) : this.mBaseListener.onRobotListStatusError(Z.Business_Execute_Failed_By_Network), this.mBaseListener.exportOperationLogger(G, this.businessId, "AXRobotsEngin", {}, "set-business-channel-faild"), this.businessHearBeatTimeout && (clearTimeout(this.businessHearBeatTimeout), this.businessHearBeatTimeout = null), [2] })) })) }, e.prototype.pauseTask = function (e, t) { return void 0 === t && (t = 15), this.sendTaskCmdToRobot("pauseTask", e, t) }, e.prototype.resumeTask = function (e, t) { return void 0 === t && (t = 15), this.sendTaskCmdToRobot("resumeTask", e, t) }, e.prototype.continueTask = function (e, t) { return void 0 === t && (t = 15), this.sendTaskCmdToRobot("onContinueTask", e, t) }, e.prototype.motionFor = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, Promise, (function () { var n, i, o; return l(this, (function (s) { switch (s.label) { case 0: if (!this.mMyChannelWs) return [2, !1]; switch (n = -1, e) { case q.Forward: n = 1; break; case q.Back: n = 2; break; case q.TurnLeft: n = 3; break; case q.TurnRight: n = 4; break; case q.Cancel: n = 0; break; case q.Auto: n = 5; break; case q.Manual: n = 6 }return -1 === n ? [3, 3] : (i = { type: n, duration: 100, val: 1 }, o = { deviceId: t, id: Te.generateUUID(), cmd: "move", args: i, needConfirm: !0, timeoutSec: r, timestamp: (new Date).getTime() }, this.mMyChannelWs.send(o), e !== q.Auto && e !== q.Manual ? [3, 2] : [4, this.checkCmd(o.id, 1e3 * r)]); case 1: return [2, s.sent()]; case 2: return [2, !0]; case 3: return [2, !1] } })) })) }, e.prototype.setJackActionToRobot = function (e, t, r) { return c(this, void 0, Promise, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return "number" != typeof e ? [2, new Promise((function (e, t) { Y.Param_type_is_number.errText = "action " + Y.Param_type_is_number.errText, t(Y.Param_type_is_number) }))] : (n = { deviceId: t, id: Te.generateUUID(), cmd: "startJacking", args: { type: e }, timeoutSec: r, needConfirm: !0, timestamp: (new Date).getTime() }, this.mMyChannelWs.send(n), [4, this.checkCmd(n.id, 1e3 * r)]); case 1: return [2, i.sent()] } })) })) }, e.prototype.sendTaskCmdToRobot = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return this.mMyChannelWs ? (n = { deviceId: t, id: Te.generateUUID(), cmd: e, args: {}, timeoutSec: r, needConfirm: !0, timestamp: (new Date).getTime() }, this.mMyChannelWs.send(n), [4, this.checkCmd(n.id, 1e3 * r)]) : [2, !1]; case 1: return [2, i.sent()] } })) })) }, e.prototype.checkCmd = function (e, t, r, n) { return c(this, void 0, Promise, (function () { var r = this; return l(this, (function (i) { return [2, new Promise((function (i, o) { var s = null; n ? r.mCmds.set(e + "_timer", (function () { r.mCmds.delete(e), r.mCmds.delete(e + "_failed"), r.mCmds.delete(e + "_timer"), r.updateMapTimer = null, o(K.Update_CMD_By_Timeout) })) : s = setTimeout((function () { r.mCmds.delete(e), r.mCmds.delete(e + "_failed"), i(!1) }), t), r.mCmds.set(e, (function (e) { s && clearTimeout(s), r.updateMapTimer && (clearTimeout(r.updateMapTimer), r.updateMapTimer = null), e && e.data ? i(e.data) : i(!0) })), r.mCmds.set(e + "_failed", (function (e) { s && clearTimeout(s), r.updateMapTimer && (clearTimeout(r.updateMapTimer), r.updateMapTimer = null), e ? o(e) : i(!1) })) }))] })) })) }, e.prototype.getRobotCustomSettingsInBus = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, void 0, (function () { var n, i; return l(this, (function (o) { switch (o.label) { case 0: return null != t && t || (t = {}), n = { deviceId: e, id: Te.generateUUID(), cmd: "getCustomSettings", args: t, timeoutSec: r, needConfirm: !0, timestamp: (new Date).getTime() }, this.mGetRobotSettingsCMD = n.id, this.mMyChannelWs.send(n), [4, this.checkCmd(n.id, 1e3 * r)]; case 1: return i = o.sent(), this.setLogger(e, n.id, i, "get-custom-settings-in-bus"), [2, i] } })) })) }, e.prototype.setLogger = function (e, t, r, n) { var i = { cmdId: t, isOk: r }; this.mBaseListener.exportOperationLogger(V, e, "AXRobotsEngin", i, n) }, e.prototype.requestTaskScheduling = function (e, t, r, n, i) { return void 0 === i && (i = 15), c(this, void 0, Promise, (function () { var o, s, a; return l(this, (function (c) { switch (c.label) { case 0: return o = { method: t, url: r, params: n }, s = { deviceId: e, id: Te.generateUUID(), cmd: "requestTaskScheduling", args: o, needConfirm: !0, timeoutSec: i, timestamp: (new Date).getTime() }, this.mMyChannelWs.send(s), [4, this.checkCmd(s.id, 1e3 * i)]; case 1: return a = c.sent(), this.setLogger(e, s.id, a, "request-task-Scheduling"), [2, a] } })) })) }, e.prototype.cancelRobotQueueTask = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return e && t ? [4, this.requestTaskScheduling(e, "PATCH", "/task/queue/cancel/" + e + "?taskSn=" + t, {}, r)] : [2, !1]; case 1: return [2, n.sent()] } })) })) }, e }(), Me = function () { function e(e) { this.requestRetryTime = 1e3, this.mBaseListener = e } return e.prototype.addQueueTask = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!d.sent()) return [2, new Promise((function (e, t) { t(ee.Add_Queue_Task_Fail) }))]; r = null, d.label = 2; case 2: return d.trys.push([2, 6, , 7]), [4, this.changeTaskParams(e)]; case 3: return d.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", {}, "put-add-queue-task"), [4, this.mBaseListener.getHeader()]; case 4: return n = d.sent(), i = "", i = this.mBaseListener.getMode() === X.WAN_APP ? "".concat(this.mBaseListener.getServerUrl(), "task-scheduling/v1.2/task") : "".concat(ke.queueTaskUrl, "task"), [4, de.put(i, e, { headers: n })]; case 5: return r = d.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", { resData: r ? r.data : null }, "put-add-queue-task-end"), [3, 7]; case 6: if (o = d.sent(), s = { error: o }, this.mBaseListener.exportOperationLogger(N, "", "AXTaskQueue", s, "put-add-queue-task-error"), u = null, o.response && 404 === o.response.status) u = new Promise((function (e, t) { t(ee.Add_Queue_Task_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.addQueueTask(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), h.requestRetryTime) }))]; u = new Promise((function (e, t) { t(ee.Add_Queue_Task_Fail) })) } return [2, u]; case 7: return r && r.data && 200 === r.data.status ? [2, !0] : (a = ee.Add_Queue_Task_Fail, r && r.data && r.data.message && (a = r.data.message), [2, u = new Promise((function (e, t) { t(a) }))]) } })) })) }, e.prototype.changeTaskParams = function (e) { return c(this, void 0, void 0, (function () { var t, r, n, i, o, s, a; return l(this, (function (c) { if (t = e.content, (r = {}).name = "Unknown", "string" == typeof t.name && (r.name = t.name), r.runNum = 1, "number" == typeof t.runNum && (r.runNum = t.runNum), r.taskType = 2, "number" == typeof t.taskType && (r.taskType = t.taskType), r.runType = 20, "number" == typeof t.runType && (r.runType = t.runType), r.routeMode = 1, "number" == typeof t.routeMode && (r.routeMode = t.routeMode), r.runMode = 1, "number" == typeof t.runMode && (r.runMode = t.runMode), r.ignorePublicSite = !1, t.ignorePublicSite && (r.ignorePublicSite = !0), r.speed = -1, "number" == typeof t.speed && (r.speed = t.speed), r.sourceType = -1, "number" == typeof t.sourceType && (r.sourceType = t.sourceType), "number" == typeof t.detourRadius && (r.detourRadius = t.detourRadius), r.creatorName = t.creatorName, r.robotName = t.robotName, "number" == typeof t.returnDest && (r.returnDest = t.returnDest), "number" == typeof t.returnTime && (r.returnTime = t.returnTime), t.curPt && (r.curPt = t.curPt), Array.isArray(t.taskPts) && t.taskPts.length > 0) r.taskPts = t.taskPts; else if (r.taskPts = [], Array.isArray(t.pts) && t.pts.length > 0) for (n = t.pts.length, i = 0; i < n; i++) { if (o = t.pts[i], null === (s = this.parseTaskPoint(o))) return this.mBaseListener.exportOperationLogger(N, "", "AXTaskEngin", { taskPoint: null, task: t }, "create-task-error"), [2, new Promise((function (e, t) { t(W.Task_AreaId_Is_Null) }))]; r.taskPts.push(s) } if (t.backPt && "number" == typeof t.backPt.x && "number" == typeof t.backPt.y) { if (null === (a = this.parseTaskPoint(t.backPt))) return this.mBaseListener.exportOperationLogger(N, "", "AXTaskEngin", { backPt: null, task: t }, "create-task-error"), [2, new Promise((function (e, t) { t(W.Task_AreaId_Is_Null) }))]; r.backPt = a } return t.ext && (r.ext = t.ext), e.content = r, [2, e] })) })) }, e.prototype.parseTaskPoint = function (e) { var t = "", r = -1; if ("string" != typeof e.areaId) return null; t = e.areaId, "number" == typeof e.type && (r = e.type); var n = {}; if (n.x = e.x, n.y = e.y, "number" == typeof e.yaw && (n.yaw = e.yaw), "string" == typeof e.dockingRadius ? n.stopRadius = parseFloat(e.dockingRadius) : n.stopRadius = 1, n.areaId = t, n.type = r, "object" == typeof e.ext && (n.ext = e.ext), Array.isArray(e.stepActs) && e.stepActs.length > 0) { n.stepActs = []; for (var i = e.stepActs.length, o = 0; o < i; o++) { var s = e.stepActs[o], a = this.createAction(s); null !== a && n.stepActs.push(a) } } return n }, e.prototype.createAction = function (e) { var t = e.type; if ("number" != typeof t) return null; var r = {}; r.type = t, r.data = {}; var n = !1; return (t === ae.PlayAudio || t === ae.GearOperation || t === ae.OpenDoor || t === ae.StopAudio || t === ae.OpenLight || t === ae.CloseLight) && (n = !0), "object" == typeof e.data && (r.data = e.data), !0 !== n || e.data.mode || (r.data.mode = this.mBaseListener.getActionMode()), r }, e.prototype.getQueueTaskList = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!d.sent()) return [2, new Promise((function (e, t) { t(ee.Get_Queue_Task_List_Data_Fail) }))]; r = null, d.label = 2; case 2: return d.trys.push([2, 6, , 7]), [4, this.mBaseListener.getToken(X.WAN_APP)]; case 3: return d.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", {}, "request-get-queue-task-list"), [4, this.mBaseListener.getHeader()]; case 4: return n = d.sent(), i = "", i = this.mBaseListener.getMode() === X.WAN_APP ? "".concat(this.mBaseListener.getServerUrl(), "task-scheduling/v1.2/task/list") : "".concat(ke.queueTaskUrl, "task/list"), [4, de.post(i, e, { headers: n })]; case 5: return r = d.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", { resData: r ? r.data : null }, "request-get-queue-task-list-end"), [3, 7]; case 6: if (o = d.sent(), s = { error: o }, this.mBaseListener.exportOperationLogger(N, "", "AXTaskQueue", s, "request-get-queue-task-list-error"), u = null, o.response && 404 === o.response.status) u = new Promise((function (e, t) { t(ee.Get_Queue_Task_List_Data_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getQueueTaskList(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), h.requestRetryTime) }))]; u = new Promise((function (e, t) { t(ee.Get_Queue_Task_List_Data_Fail) })) } return [2, u]; case 7: return r && r.data && 200 === r.data.status ? [2, r.data.data] : (a = ee.Get_Queue_Task_List_Data_Fail, r && r.data && r.data.message && (a = r.data.message), [2, u = new Promise((function (e, t) { t(a) }))]) } })) })) }, e.prototype.getQueueTaskDetail = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!d.sent()) return [2, new Promise((function (e, t) { t(ee.Get_Queue_Task_Detail_Fail) }))]; r = null, d.label = 2; case 2: return d.trys.push([2, 6, , 7]), [4, this.mBaseListener.getToken(X.WAN_APP)]; case 3: return d.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", {}, "request-get-queue-task-info"), [4, this.mBaseListener.getHeader()]; case 4: return n = d.sent(), i = "", i = this.mBaseListener.getMode() === X.WAN_APP ? "".concat(this.mBaseListener.getServerUrl(), "task-scheduling/v1.2/task/").concat(e) : "".concat(ke.queueTaskUrl, "task/").concat(e), [4, de.get(i, { headers: n })]; case 5: return r = d.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", { resData: r ? r.data : null }, "request-get-queue-task-info-end"), [3, 7]; case 6: if (o = d.sent(), s = { error: o }, this.mBaseListener.exportOperationLogger(N, "", "AXTaskQueue", s, "request-get-queue-task-info-error"), u = null, o.response && 404 === o.response.status) u = new Promise((function (e, t) { t(ee.Get_Queue_Task_Detail_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getQueueTaskDetail(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), h.requestRetryTime) }))]; u = new Promise((function (e, t) { t(ee.Get_Queue_Task_Detail_Fail) })) } return [2, u]; case 7: return r && r.data && 200 === r.data.status ? [2, r.data.data] : (a = ee.Get_Queue_Task_Detail_Fail, r && r.data && r.data.message && (a = r.data.message), [2, u = new Promise((function (e, t) { t(a) }))]) } })) })) }, e.prototype.getTaskQueue = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!d.sent()) return [2, new Promise((function (e, t) { t(ee.Get_Task_Queue_Fail) }))]; r = null, d.label = 2; case 2: return d.trys.push([2, 6, , 7]), [4, this.mBaseListener.getToken(X.WAN_APP)]; case 3: return d.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", {}, "request-get-task-queue"), [4, this.mBaseListener.getHeader()]; case 4: return n = d.sent(), i = "", i = this.mBaseListener.getMode() === X.WAN_APP ? "".concat(this.mBaseListener.getServerUrl(), "task-scheduling/v1.2/task/queue/").concat(e) : "".concat(ke.queueTaskUrl, "task/queue/").concat(e), [4, de.get(i, { headers: n })]; case 5: return r = d.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", { resData: r ? r.data : null }, "request-get-task-queue"), [3, 7]; case 6: if (o = d.sent(), s = { error: o }, this.mBaseListener.exportOperationLogger(N, e, "AXTaskQueue", s, "request-get-task-queue-error"), u = null, o.response && 404 === o.response.status) u = new Promise((function (e, t) { t(ee.Get_Task_Queue_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getTaskQueue(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), h.requestRetryTime) }))]; u = new Promise((function (e, t) { t(ee.Get_Task_Queue_Fail) })) } return [2, u]; case 7: return r && r.data && 200 === r.data.status ? [2, r.data.data] : (a = ee.Get_Task_Queue_Fail, r && r.data && r.data.message && (a = r.data.message), [2, u = new Promise((function (e, t) { t(a) }))]) } })) })) }, e.prototype.getTaskQueueAssigned = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!d.sent()) return [2, new Promise((function (e, t) { t(ee.Get_Task_Queue_Fail) }))]; r = null, d.label = 2; case 2: return d.trys.push([2, 6, , 7]), [4, this.mBaseListener.getToken(X.WAN_APP)]; case 3: return d.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", {}, "request-get-task-queue-issueds"), [4, this.mBaseListener.getHeader()]; case 4: return n = d.sent(), i = "", i = this.mBaseListener.getMode() === X.WAN_APP ? "".concat(this.mBaseListener.getServerUrl(), "task-scheduling/v1.2/task/queue-assigned/").concat(e) : "".concat(ke.queueTaskUrl, "task/queue-assigned/").concat(e), [4, de.get(i, { headers: n })]; case 5: return r = d.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", { resData: r ? r.data : null }, "request-get-task-queue-issued"), [3, 7]; case 6: if (o = d.sent(), s = { error: o }, this.mBaseListener.exportOperationLogger(N, "", "AXTaskQueue", s, "request-get-task-queue-issued-error"), u = null, o.response && 404 === o.response.status) u = new Promise((function (e, t) { t(ee.Get_Task_Queue_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getTaskQueueAssigned(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), h.requestRetryTime) }))]; u = new Promise((function (e, t) { t(ee.Get_Task_Queue_Fail) })) } return [2, u]; case 7: return r && r.data && 200 === r.data.status ? [2, r.data.data] : (a = ee.Get_Task_Queue_Fail, r && r.data && r.data.message && (a = r.data.message), [2, u = new Promise((function (e, t) { t(a) }))]) } })) })) }, e.prototype.getTaskQueueRobot = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, Promise, (function () { var n, i, o, s, a, u, h, d = this; return l(this, (function (p) { switch (p.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!p.sent()) return [2, new Promise((function (e, t) { t(ee.Get_Task_Queue_Robot_Fail) }))]; n = null, p.label = 2; case 2: return p.trys.push([2, 6, , 7]), [4, this.mBaseListener.getToken(X.WAN_APP)]; case 3: return p.sent(), this.mBaseListener.exportOperationLogger(V, t, "AXTaskQueue", {}, "request-get-task-queue-robot"), [4, this.mBaseListener.getHeader()]; case 4: return i = p.sent(), o = "", o = this.mBaseListener.getMode() === X.WAN_APP ? "".concat(this.mBaseListener.getServerUrl(), "task-scheduling/v1.2/task/queue/").concat(e, "/").concat(t) : "".concat(ke.queueTaskUrl, "task/queue/").concat(e, "/").concat(t), [4, de.get(o, { headers: i })]; case 5: return n = p.sent(), this.mBaseListener.exportOperationLogger(V, t, "AXTaskQueue", { resData: n ? n.data : null }, "request-get-task-queue-robot"), [3, 7]; case 6: if (s = p.sent(), a = { error: s }, this.mBaseListener.exportOperationLogger(N, t, "AXTaskQueue", a, "request-get-task-queue-robot-error"), h = null, s.response && 404 === s.response.status) h = new Promise((function (e, t) { t(ee.Get_Task_Queue_Robot_404) })); else { if (r > 0) return r--, [2, new Promise((function (n, i) { d.retryTimer = setTimeout((function () { return c(d, void 0, void 0, (function () { var i; return l(this, (function (o) { switch (o.label) { case 0: return [4, this.getTaskQueueRobot(e, t, r)]; case 1: return i = o.sent(), n(i), [2] } })) })) }), d.requestRetryTime) }))]; h = new Promise((function (e, t) { t(ee.Get_Task_Queue_Robot_Fail) })) } return [2, h]; case 7: return n && n.data && 200 === n.data.status ? [2, n.data.data] : (u = ee.Get_Task_Queue_Robot_Fail, n && n.data && n.data.message && (u = n.data.message), [2, h = new Promise((function (e, t) { t(u) }))]) } })) })) }, e.prototype.getTaskQueueIssued = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, Promise, (function () { var n, i, o, s, a, u, h, d = this; return l(this, (function (p) { switch (p.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!p.sent()) return [2, new Promise((function (e, t) { t(ee.Get_Task_Queue_Robot_Fail) }))]; n = null, p.label = 2; case 2: return p.trys.push([2, 6, , 7]), [4, this.mBaseListener.getToken(X.WAN_APP)]; case 3: return p.sent(), this.mBaseListener.exportOperationLogger(V, t, "AXTaskQueue", {}, "get-task-queue-issued"), [4, this.mBaseListener.getHeader()]; case 4: return i = p.sent(), o = "", o = this.mBaseListener.getMode() === X.WAN_APP ? "".concat(this.mBaseListener.getServerUrl(), "task-scheduling/v1.2/task/queue-issued/").concat(e, "/").concat(t) : "".concat(ke.queueTaskUrl, "task/queue-issued/").concat(e, "/").concat(t), [4, de.get(o, { headers: i })]; case 5: return n = p.sent(), this.mBaseListener.exportOperationLogger(V, t, "AXTaskQueue", { resData: n ? n.data : null }, "get-task-queue-issued"), [3, 7]; case 6: if (s = p.sent(), a = { error: s }, this.mBaseListener.exportOperationLogger(N, t, "AXTaskQueue", a, "get-task-queue-issued-error"), h = null, s.response && 404 === s.response.status) h = new Promise((function (e, t) { t(ee.Get_Task_Queue_Robot_404) })); else { if (r > 0) return r--, [2, new Promise((function (n, i) { d.retryTimer = setTimeout((function () { return c(d, void 0, void 0, (function () { var i; return l(this, (function (o) { switch (o.label) { case 0: return [4, this.getTaskQueueIssued(e, t, r)]; case 1: return i = o.sent(), n(i), [2] } })) })) }), d.requestRetryTime) }))]; h = new Promise((function (e, t) { t(ee.Get_Task_Queue_Robot_Fail) })) } return [2, h]; case 7: return n && n.data && 200 === n.data.status ? [2, n.data.data] : (u = ee.Get_Task_Queue_Robot_Fail, n && n.data && n.data.message && (u = n.data.message), [2, h = new Promise((function (e, t) { t(u) }))]) } })) })) }, e.prototype.setTaskOrder = function (e, t, r, n) { return void 0 === n && (n = 15), c(this, void 0, Promise, (function () { var i, o, s, a, u, h, d, p, f = this; return l(this, (function (m) { switch (m.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!m.sent()) return [2, new Promise((function (e, t) { t(ee.Set_Task_Order_Fail) }))]; i = null, o = { taskSn: e, refTaskSn: t, isFront: r }, m.label = 2; case 2: return m.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", {}, "patch-set-task-order"), [4, this.mBaseListener.getHeader()]; case 3: return s = m.sent(), a = "", a = this.mBaseListener.getMode() === X.WAN_APP ? "".concat(this.mBaseListener.getServerUrl(), "task-scheduling/v1.2/task/set-task-order") : "".concat(ke.queueTaskUrl, "task/set-task-order"), [4, de.patch(a, o, { headers: s })]; case 4: return i = m.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", {}, "patch-set-task-order-end"), [3, 6]; case 5: if (u = m.sent(), h = { error: u }, this.mBaseListener.exportOperationLogger(N, "", "AXTaskQueue", h, "patch-set-task-order-error"), p = null, u.response && 404 === u.response.status) p = new Promise((function (e, t) { t(ee.Set_Task_Order_404) })); else { if (n > 0) return n--, [2, new Promise((function (i, o) { f.retryTimer = setTimeout((function () { return c(f, void 0, void 0, (function () { var o; return l(this, (function (s) { switch (s.label) { case 0: return [4, this.setTaskOrder(e, t, r, n)]; case 1: return o = s.sent(), i(o), [2] } })) })) }), f.requestRetryTime) }))]; p = new Promise((function (e, t) { t(ee.Set_Task_Order_Fail) })) } return [2, p]; case 6: return i && i.data && 200 === i.data.status ? [2, !0] : (d = ee.Set_Task_Order_Fail, i && i.data && i.data.message && (d = i.data.message), [2, p = new Promise((function (e, t) { t(d) }))]) } })) })) }, e.prototype.pauseQueue = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!d.sent()) return [2, new Promise((function (e, t) { t(ee.Pause_Queue_Fail) }))]; r = null, d.label = 2; case 2: return d.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", {}, "patch-pause-queue"), [4, this.mBaseListener.getHeader()]; case 3: return n = d.sent(), i = "", i = this.mBaseListener.getMode() === X.WAN_APP ? "".concat(this.mBaseListener.getServerUrl(), "task-scheduling/v1.2/task/pause/queue/").concat(e) : "".concat(ke.queueTaskUrl, "task/pause/queue/").concat(e), [4, de.patch(i, null, { headers: n })]; case 4: return r = d.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", { resData: r ? r.data : null }, "patch-pause-queue-end"), [3, 6]; case 5: if (o = d.sent(), s = { error: o }, this.mBaseListener.exportOperationLogger(N, e, "AXTaskQueue", s, "patch-pause-queue-error"), u = null, o.response && 404 === o.response.status) u = new Promise((function (e, t) { t(ee.Pause_Queue_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.pauseQueue(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), h.requestRetryTime) }))]; u = new Promise((function (e, t) { t(ee.Pause_Queue_Fail) })) } return [2, u]; case 6: return r && r.data && 200 === r.data.status ? [2, !0] : (a = ee.Pause_Queue_Fail, r && r.data && r.data.message && (a = r.data.message), [2, u = new Promise((function (e, t) { t(a) }))]) } })) })) }, e.prototype.continueQueue = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!d.sent()) return [2, new Promise((function (e, t) { t(ee.Continue_Queue_Fail) }))]; r = null, d.label = 2; case 2: return d.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", {}, "patch-continue-queue"), [4, this.mBaseListener.getHeader()]; case 3: return n = d.sent(), i = "", i = this.mBaseListener.getMode() === X.WAN_APP ? "".concat(this.mBaseListener.getServerUrl(), "task-scheduling/v1.2/task/continue/queue/").concat(e) : "".concat(ke.queueTaskUrl, "task/continue/queue/").concat(e), [4, de.patch(i, null, { headers: n })]; case 4: return r = d.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", { resData: r ? r.data : null }, "patch-continue-queue-end"), [3, 6]; case 5: if (o = d.sent(), s = { error: o }, this.mBaseListener.exportOperationLogger(N, e, "AXTaskQueue", s, "patch-continue-queue-error"), u = null, o.response && 404 === o.response.status) u = new Promise((function (e, t) { t(ee.Continue_Queue_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.continueQueue(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), h.requestRetryTime) }))]; u = new Promise((function (e, t) { t(ee.Continue_Queue_Fail) })) } return [2, u]; case 6: return r && r.data && 200 === r.data.status ? [2, !0] : (a = ee.Pause_Queue_Fail, r && r.data && r.data.message && (a = r.data.message), [2, u = new Promise((function (e, t) { t(a) }))]) } })) })) }, e.prototype.setQueueOrder = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, Promise, (function () { var n, i, o, s, a, u, h, d, p = this; return l(this, (function (f) { switch (f.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!f.sent()) return [2, new Promise((function (e, t) { t(ee.Set_Queue_Order_Fail) }))]; n = null, i = { key: e, newOrder: t }, f.label = 2; case 2: return f.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", {}, "patch-queue-order"), [4, this.mBaseListener.getHeader()]; case 3: return o = f.sent(), s = "", s = this.mBaseListener.getMode() === X.WAN_APP ? "".concat(this.mBaseListener.getServerUrl(), "task-scheduling/v1.2/task/set-queue-order") : "".concat(ke.queueTaskUrl, "task/set-queue-order"), [4, de.patch(s, i, { headers: o })]; case 4: return n = f.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", { resData: n ? n.data : null }, "patch-queue-order-end"), [3, 6]; case 5: if (a = f.sent(), u = { error: a }, this.mBaseListener.exportOperationLogger(N, "", "AXTaskQueue", u, "patch-queue-order-error"), d = null, a.response && 404 === a.response.status) d = new Promise((function (e, t) { t(ee.Set_Queue_Order_404) })); else { if (r > 0) return r--, [2, new Promise((function (n, i) { p.retryTimer = setTimeout((function () { return c(p, void 0, void 0, (function () { var i; return l(this, (function (o) { switch (o.label) { case 0: return [4, this.setQueueOrder(e, t, r)]; case 1: return i = o.sent(), n(i), [2] } })) })) }), p.requestRetryTime) }))]; d = new Promise((function (e, t) { t(ee.Set_Queue_Order_Fail) })) } return [2, d]; case 6: return n && n.data && 200 === n.data.status ? [2, !0] : (h = ee.Set_Queue_Order_Fail, n && n.data && n.data.message && (h = n.data.message), [2, d = new Promise((function (e, t) { t(h) }))]) } })) })) }, e.prototype.deleteQueueTask = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!d.sent()) return [2, new Promise((function (e, t) { t(ee.Delete_Queue_Task_Fail) }))]; r = null, d.label = 2; case 2: return d.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", {}, "del-queue-task"), [4, this.mBaseListener.getHeader()]; case 3: return n = d.sent(), i = "", i = this.mBaseListener.getMode() === X.WAN_APP ? "".concat(this.mBaseListener.getServerUrl(), "task-scheduling/v1.2/task/").concat(e) : "".concat(ke.queueTaskUrl, "task/").concat(e), [4, de.delete(i, { headers: n })]; case 4: return r = d.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", { resData: r ? r.data : null }, "del-queue-task-end"), [3, 6]; case 5: if (o = d.sent(), s = { error: o }, this.mBaseListener.exportOperationLogger(N, "", "AXTaskQueue", s, "del-queue-task-error"), u = null, o.response && 404 === o.response.status) u = new Promise((function (e, t) { t(ee.Delete_Queue_Task_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.deleteQueueTask(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), h.requestRetryTime) }))]; u = new Promise((function (e, t) { t(ee.Delete_Queue_Task_Fail) })) } return [2, u]; case 6: return r && r.data && 200 === r.data.status ? [2, !0] : (a = ee.Delete_Queue_Task_Fail, r && r.data && r.data.message && (a = r.data.message), [2, u = new Promise((function (e, t) { t(a) }))]) } })) })) }, e.prototype.cancelCloudAllQueueTasks = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!d.sent()) return [2, new Promise((function (e, t) { t(ee.Cancel_All_Queue_Fail) }))]; r = null, d.label = 2; case 2: return d.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", {}, "cancel-all-queue"), [4, this.mBaseListener.getHeader()]; case 3: return n = d.sent(), i = "", i = this.mBaseListener.getMode() === X.WAN_APP ? "".concat(this.mBaseListener.getServerUrl(), "task-scheduling/v1.1/task/queue/cancel/").concat(e) : "".concat(ke.queueTaskUrl, "task/queue/cancel/").concat(e), [4, de.patch(i, null, { headers: n })]; case 4: return r = d.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXTaskQueue", { resData: r ? r.data : null }, "cancel-all-queue-end"), [3, 6]; case 5: if (o = d.sent(), s = { error: o }, this.mBaseListener.exportOperationLogger(N, e, "AXTaskQueue", s, "cancel-all-queue-error"), u = null, o.response && 404 === o.response.status) u = new Promise((function (e, t) { t(ee.Cancel_All_Queue_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.cancelCloudAllQueueTasks(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), h.requestRetryTime) }))]; u = new Promise((function (e, t) { t(ee.Cancel_All_Queue_Fail) })) } return [2, u]; case 6: return r && r.data && 200 === r.data.status ? [2, !0] : (a = ee.Cancel_All_Queue_Fail, r && r.data && r.data.message && (a = r.data.message), [2, u = new Promise((function (e, t) { t(a) }))]) } })) })) }, e }(), Be = function () { function e(e) { this.requestRetryTime = 1e3, this.mBaseListener = e } return e.prototype.createCustomTask = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u = this; return l(this, (function (h) { switch (h.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!h.sent()) return [2, new Promise((function (e, t) { t(te.Add_Custom_Task_Fail) }))]; r = null, h.label = 2; case 2: return h.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, "", "AXCustomTask", {}, "put-add-custom-task"), [4, this.mBaseListener.getHeader()]; case 3: return n = h.sent(), [4, de.put("".concat(this.mBaseListener.getServerUrl(), "/task/v1.1/preset"), e, { headers: n })]; case 4: return r = h.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXCustomTask", { resData: r ? r.data : null }, "put-add-custom-task-end"), [3, 6]; case 5: if (i = h.sent(), o = { error: i }, this.mBaseListener.exportOperationLogger(N, "", "AXCustomTask", o, "put-add-custom-task-error"), a = null, i.response && 404 === i.response.status) a = new Promise((function (e, t) { t(te.Add_Custom_Task_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { u.retryTimer = setTimeout((function () { return c(u, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.createCustomTask(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), u.requestRetryTime) }))]; a = new Promise((function (e, t) { t(te.Add_Custom_Task_Fail) })) } return [2, a]; case 6: return r && r.data && 200 === r.data.status ? [2, !0] : (s = te.Add_Custom_Task_Fail, r && r.data && r.data.message && (s = r.data.message), [2, a = new Promise((function (e, t) { t(s) }))]) } })) })) }, e.prototype.editCustomTask = function (e, t, r) { return void 0 === r && (r = 15), c(this, void 0, Promise, (function () { var n, i, o, s, a, u, h = this; return l(this, (function (d) { switch (d.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!d.sent()) return [2, new Promise((function (e, t) { t(te.Add_Custom_Task_Fail) }))]; n = null, d.label = 2; case 2: return d.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, "", "AXCustomTask", {}, "patch-edit-custom-task"), [4, this.mBaseListener.getHeader()]; case 3: return i = d.sent(), [4, de.patch("".concat(this.mBaseListener.getServerUrl(), "/task/v1.1/preset/").concat(t), e, { headers: i })]; case 4: return n = d.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXCustomTask", { resData: n ? n.data : null }, "patch-edit-custom-task-end"), [3, 6]; case 5: if (o = d.sent(), s = { error: o }, this.mBaseListener.exportOperationLogger(N, "", "AXCustomTask", s, "patch-edit-custom-task-error"), u = null, o.response && 404 === o.response.status) u = new Promise((function (e, t) { t(te.Add_Custom_Task_404) })); else { if (r > 0) return r--, [2, new Promise((function (n, i) { h.retryTimer = setTimeout((function () { return c(h, void 0, void 0, (function () { var i; return l(this, (function (o) { switch (o.label) { case 0: return [4, this.editCustomTask(e, t, r)]; case 1: return i = o.sent(), n(i), [2] } })) })) }), h.requestRetryTime) }))]; u = new Promise((function (e, t) { t(te.Add_Custom_Task_Fail) })) } return [2, u]; case 6: return n && n.data && 200 === n.data.status ? [2, !0] : (a = te.Add_Custom_Task_Fail, n && n.data && n.data.message && (a = n.data.message), [2, u = new Promise((function (e, t) { t(a) }))]) } })) })) }, e.prototype.getCustomTaskList = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u = this; return l(this, (function (h) { switch (h.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!h.sent()) return [2, new Promise((function (e, t) { t(te.Add_Custom_Task_Fail) }))]; r = null, h.label = 2; case 2: return h.trys.push([2, 6, , 7]), [4, this.mBaseListener.getToken(X.WAN_APP)]; case 3: return h.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXCustomTask", {}, "request-get-custom-task-list"), [4, this.mBaseListener.getHeader()]; case 4: return n = h.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/preset/list"), e, { headers: n })]; case 5: return r = h.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXCustomTask", { resData: r ? r.data : null }, "request-get-custom-task-list-end"), [3, 7]; case 6: if (i = h.sent(), o = { error: i }, this.mBaseListener.exportOperationLogger(N, "", "AXCustomTask", o, "request-get-custom-task-list-error"), a = null, i.response && 404 === i.response.status) a = new Promise((function (e, t) { t(te.Get_Custom_Task_List_Data_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { u.retryTimer = setTimeout((function () { return c(u, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getCustomTaskList(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), u.requestRetryTime) }))]; a = new Promise((function (e, t) { t(te.Get_Custom_Task_List_Data_Fail) })) } return [2, a]; case 7: return r && r.data && 200 === r.data.status ? [2, r.data.data] : (s = te.Get_Custom_Task_List_Data_Fail, r && r.data && r.data.message && (s = r.data.message), [2, a = new Promise((function (e, t) { t(s) }))]) } })) })) }, e.prototype.getCustomTaskInfo = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u = this; return l(this, (function (h) { switch (h.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!h.sent()) return [2, new Promise((function (e, t) { t(te.Get_Custom_Task_Fail) }))]; r = null, h.label = 2; case 2: return h.trys.push([2, 6, , 7]), [4, this.mBaseListener.getToken(X.WAN_APP)]; case 3: return h.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXCustomTask", {}, "request-get-custom-task-info"), [4, this.mBaseListener.getHeader()]; case 4: return n = h.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/preset/").concat(e), { headers: n })]; case 5: return r = h.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXCustomTask", { resData: r ? r.data : null }, "request-get-custom-task-info"), [3, 7]; case 6: if (i = h.sent(), o = { error: i }, this.mBaseListener.exportOperationLogger(N, "", "AXCustomTask", o, "request-get-custom-task-info-error"), a = null, i.response && 404 === i.response.status) a = new Promise((function (e, t) { t(te.Get_Custom_Task_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { u.retryTimer = setTimeout((function () { return c(u, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getCustomTaskInfo(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), u.requestRetryTime) }))]; a = new Promise((function (e, t) { t(te.Get_Custom_Task_Fail) })) } return [2, a]; case 7: return r && r.data && 200 === r.data.status ? [2, r.data.data] : (s = te.Get_Custom_Task_Fail, r && r.data && r.data.message && (s = r.data.message), [2, a = new Promise((function (e, t) { t(s) }))]) } })) })) }, e.prototype.deleteCustomTask = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u = this; return l(this, (function (h) { switch (h.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!h.sent()) return [2, new Promise((function (e, t) { t(te.Delete_Custom_Task_Fail) }))]; r = null, h.label = 2; case 2: return h.trys.push([2, 5, , 6]), this.mBaseListener.exportOperationLogger(V, "", "AXCustomTask", {}, "del-custom-task"), [4, this.mBaseListener.getHeader()]; case 3: return n = h.sent(), [4, de.delete("".concat(this.mBaseListener.getServerUrl(), "task/v1.1/preset/").concat(e), { headers: n })]; case 4: return r = h.sent(), this.mBaseListener.exportOperationLogger(V, "", "AXCustomTask", { resData: r ? r.data : null }, "del-custom-task-end"), [3, 6]; case 5: if (i = h.sent(), o = { error: i }, this.mBaseListener.exportOperationLogger(N, "", "AXCustomTask", o, "del-custom-taskerror"), a = null, i.response && 404 === i.response.status) a = new Promise((function (e, t) { t(te.Delete_Custom_Task_404) })); else { if (t > 0) return t--, [2, new Promise((function (r, n) { u.retryTimer = setTimeout((function () { return c(u, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.deleteCustomTask(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), u.requestRetryTime) }))]; a = new Promise((function (e, t) { t(te.Delete_Custom_Task_Fail) })) } return [2, a]; case 6: return r && r.data && 200 === r.data.status ? [2, !0] : (s = te.Delete_Custom_Task_Fail, r && r.data && r.data.message && (s = r.data.message), [2, a = new Promise((function (e, t) { t(s) }))]) } })) })) }, e }(), Re = function () { function e(e) { this.requestRetryTime = 1e3, this.mBaseListener = e } return e.prototype.getOverviewStatis = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u = this; return l(this, (function (h) { switch (h.label) { case 0: if (this.mBaseListener.getMode() == X.WAN_APP) return [2, new Promise((function (e, t) { t(se.Mode_Error) }))]; r = null, h.label = 1; case 1: for (i in h.trys.push([1, 4, , 5]), n = "".concat(ke.outlineStatisUrl, "api/statis/v1/overview?"), e) n += "".concat(i, "=").concat(e[i], "&"); return n = n.substring(0, n.length - 1), [4, this.mBaseListener.getHeader()]; case 2: return o = h.sent(), [4, de.get(n, { headers: o })]; case 3: return r = h.sent(), [3, 5]; case 4: if (s = h.sent(), a = null, s.toString().indexOf("Network") >= 0) a = new Promise((function (e, t) { t($.Network_Error) })); else if (s.response && 404 === s.response.status) a = new Promise((function (e, t) { t(se.Search_Overview_404) })); else { if (t > 0) return t--, [2, new Promise((function (e, r) { u.retryTimer = setTimeout((function () { return c(u, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.getOverviewStatis(t)]; case 1: return r = n.sent(), e(r), [2] } })) })) }), u.requestRetryTime) }))]; a = new Promise((function (e, t) { t(se.Search_Overview_Fail) })) } return [2, a]; case 5: return r ? (a = null, [2, a = "request:fail" === r.errMsg ? new Promise((function (e, t) { t($.Network_Error) })) : r.data && 200 === r.data.status ? new Promise((function (e) { e(r.data) })) : new Promise((function (e, t) { r.data && 500 === r.data.status ? (se.Sever_Error.data = r.data, t(se.Sever_Error)) : (se.Search_Overview_Fail.data = r.data, t(se.Search_Overview_Fail)) }))]) : [2, null] } })) })) }, e.prototype.getTasksStatis = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u = this; return l(this, (function (h) { switch (h.label) { case 0: if (this.mBaseListener.getMode() == X.WAN_APP) return [2, new Promise((function (e, t) { t(se.Mode_Error) }))]; r = null, h.label = 1; case 1: for (i in h.trys.push([1, 4, , 5]), n = "".concat(ke.outlineStatisUrl, "api/statis/v1/tasks?"), e) n += "".concat(i, "=").concat(e[i], "&"); return n = n.substring(0, n.length - 1), [4, this.mBaseListener.getHeader()]; case 2: return o = h.sent(), [4, de.get(n, { headers: o })]; case 3: return r = h.sent(), [3, 5]; case 4: if (s = h.sent(), a = null, s.toString().indexOf("Network") >= 0) a = new Promise((function (e, t) { t($.Network_Error) })); else if (s.response && 404 === s.response.status) a = new Promise((function (e, t) { t(se.Search_Tasks_404) })); else { if (t > 0) return t--, [2, new Promise((function (e, r) { u.retryTimer = setTimeout((function () { return c(u, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.getTasksStatis(t)]; case 1: return r = n.sent(), e(r), [2] } })) })) }), u.requestRetryTime) }))]; a = new Promise((function (e, t) { t(se.Search_Tasks_Fail) })) } return [2, a]; case 5: return r ? (a = null, [2, a = "request:fail" === r.errMsg ? new Promise((function (e, t) { t($.Network_Error) })) : r.data && 200 === r.data.status ? new Promise((function (e) { e(r.data) })) : new Promise((function (e, t) { r.data && 500 === r.data.status ? (se.Sever_Error.data = r.data, t(se.Sever_Error)) : (se.Search_Tasks_Fail.data = r.data, t(se.Search_Tasks_Fail)) }))]) : [2, null] } })) })) }, e.prototype.getHourlyRobotStatis = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u = this; return l(this, (function (h) { switch (h.label) { case 0: if (this.mBaseListener.getMode() == X.WAN_APP) return [2, new Promise((function (e, t) { t(se.Mode_Error) }))]; r = null, h.label = 1; case 1: for (i in h.trys.push([1, 4, , 5]), n = "".concat(ke.outlineStatisUrl, "api/statis/v1/robot_hourly?"), e) n += "".concat(i, "=").concat(e[i], "&"); return n = n.substring(0, n.length - 1), [4, this.mBaseListener.getHeader()]; case 2: return o = h.sent(), [4, de.get(n, { headers: o })]; case 3: return r = h.sent(), [3, 5]; case 4: if (s = h.sent(), a = null, s.toString().indexOf("Network") >= 0) a = new Promise((function (e, t) { t($.Network_Error) })); else if (s.response && 404 === s.response.status) a = new Promise((function (e, t) { t(se.Search_Hourly_Robot_404) })); else { if (t > 0) return t--, [2, new Promise((function (e, r) { u.retryTimer = setTimeout((function () { return c(u, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.getHourlyRobotStatis(t)]; case 1: return r = n.sent(), e(r), [2] } })) })) }), u.requestRetryTime) }))]; a = new Promise((function (e, t) { t(se.Search_Hourly_Robot_Fail) })) } return [2, a]; case 5: return r ? (a = null, [2, a = "request:fail" === r.errMsg ? new Promise((function (e, t) { t($.Network_Error) })) : r.data && 200 === r.data.status ? new Promise((function (e) { e(r.data) })) : new Promise((function (e, t) { r.data && 500 === r.data.status ? (se.Sever_Error.data = r.data, t(se.Sever_Error)) : (se.Search_Hourly_Robot_Fail.data = r.data, t(se.Search_Hourly_Robot_Fail)) }))]) : [2, null] } })) })) }, e.prototype.getHourlyTasksStatis = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u = this; return l(this, (function (h) { switch (h.label) { case 0: if (this.mBaseListener.getMode() == X.WAN_APP) return [2, new Promise((function (e, t) { t(se.Mode_Error) }))]; r = null, h.label = 1; case 1: for (i in h.trys.push([1, 4, , 5]), n = "".concat(ke.outlineStatisUrl, "api/statis/v1/task_hourly?"), e) n += "".concat(i, "=").concat(e[i], "&"); return n = n.substring(0, n.length - 1), [4, this.mBaseListener.getHeader()]; case 2: return o = h.sent(), [4, de.get(n, { headers: o })]; case 3: return r = h.sent(), [3, 5]; case 4: if (s = h.sent(), a = null, s.toString().indexOf("Network") >= 0) a = new Promise((function (e, t) { t($.Network_Error) })); else if (s.response && 404 === s.response.status) a = new Promise((function (e, t) { t(se.Search_HourlyTasks_404) })); else { if (t > 0) return t--, [2, new Promise((function (e, r) { u.retryTimer = setTimeout((function () { return c(u, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.getHourlyTasksStatis(t)]; case 1: return r = n.sent(), e(r), [2] } })) })) }), u.requestRetryTime) }))]; a = new Promise((function (e, t) { t(se.Search_HourlyTasks_Fail) })) } return [2, a]; case 5: return r ? (a = null, [2, a = "request:fail" === r.errMsg ? new Promise((function (e, t) { t($.Network_Error) })) : r.data && 200 === r.data.status ? new Promise((function (e) { e(r.data) })) : new Promise((function (e, t) { r.data && 500 === r.data.status ? (se.Sever_Error.data = r.data, t(se.Sever_Error)) : (se.Search_HourlyTasks_Fail.data = r.data, t(se.Search_HourlyTasks_Fail)) }))]) : [2, null] } })) })) }, e.prototype.getTaskCountByDayStatis = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a, u = this; return l(this, (function (h) { switch (h.label) { case 0: if (this.mBaseListener.getMode() == X.WAN_APP) return [2, new Promise((function (e, t) { t(se.Mode_Error) }))]; r = null, h.label = 1; case 1: for (i in h.trys.push([1, 4, , 5]), n = "".concat(ke.outlineStatisUrl, "api/statis/v1/task_count_by_day?"), e) n += "".concat(i, "=").concat(e[i], "&"); return n = n.substring(0, n.length - 1), [4, this.mBaseListener.getHeader()]; case 2: return o = h.sent(), [4, de.get(n, { headers: o })]; case 3: return r = h.sent(), [3, 5]; case 4: if (s = h.sent(), a = null, s.toString().indexOf("Network") >= 0) a = new Promise((function (e, t) { t($.Network_Error) })); else if (s.response && 404 === s.response.status) a = new Promise((function (e, t) { t(se.Search_TaskCountByDay_404) })); else { if (t > 0) return t--, [2, new Promise((function (e, r) { u.retryTimer = setTimeout((function () { return c(u, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.getTaskCountByDayStatis(t)]; case 1: return r = n.sent(), e(r), [2] } })) })) }), u.requestRetryTime) }))]; a = new Promise((function (e, t) { t(se.Search_TaskCountByDay_Fail) })) } return [2, a]; case 5: return r ? (a = null, [2, a = "request:fail" === r.errMsg ? new Promise((function (e, t) { t($.Network_Error) })) : r.data && 200 === r.data.status ? new Promise((function (e) { e(r.data) })) : new Promise((function (e, t) { r.data && 500 === r.data.status ? (se.Sever_Error.data = r.data, t(se.Sever_Error)) : (se.Search_TaskCountByDay_Fail.data = r.data, t(se.Search_TaskCountByDay_Fail)) }))]) : [2, null] } })) })) }, e }(), De = ve((function (e, t) { e.exports = function () { var e, t, r; function n(n, i) { if (e) if (t) { var o = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + e + ")(sharedChunk); (" + t + ")(sharedChunk); self.onerror = null;", s = {}; e(s), r = i(s), "undefined" != typeof window && window && window.URL && window.URL.createObjectURL && (r.workerUrl = window.URL.createObjectURL(new Blob([o], { type: "text/javascript" }))) } else t = i; else e = i } return n(["exports"], (function (e) { var t = "undefined" != typeof self ? self : {}, r = "2.14.0-dev"; let n; const i = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() { if (null == n) { const e = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i; try { n = null != process.env.API_URL_REGEX ? new RegExp(process.env.API_URL_REGEX) : e } catch (t) { n = e } } return n }, get API_TILEJSON_REGEX() { return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i }, get API_SPRITE_REGEX() { return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i }, get API_FONTS_REGEX() { return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i }, get API_STYLE_REGEX() { return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i }, get API_CDN_URL_REGEX() { return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i }, get EVENTS_URL() { return null }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", REQUIRE_ACCESS_TOKEN: !0, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, o = { supported: !1, testSupport: function (e) { !c && a && (l ? u(e) : s = e) } }; let s, a, c = !1, l = !1; function u(e) { const t = e.createTexture(); e.bindTexture(e.TEXTURE_2D, t); try { if (e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, a), e.isContextLost()) return; o.supported = !0 } catch (e) { } e.deleteTexture(t), c = !0 } t.document && (a = t.document.createElement("img"), a.onload = function () { s && u(s), s = null, l = !0 }, a.onerror = function () { c = !0, s = null }, a.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="); const h = "01"; var d = p; function p(e, t, r, n) { this.cx = 3 * e, this.bx = 3 * (r - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (n - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = t, this.p2x = r, this.p2y = n } p.prototype = { sampleCurveX: function (e) { return ((this.ax * e + this.bx) * e + this.cx) * e }, sampleCurveY: function (e) { return ((this.ay * e + this.by) * e + this.cy) * e }, sampleCurveDerivativeX: function (e) { return (3 * this.ax * e + 2 * this.bx) * e + this.cx }, solveCurveX: function (e, t) { if (void 0 === t && (t = 1e-6), e < 0) return 0; if (e > 1) return 1; for (var r = e, n = 0; n < 8; n++) { var i = this.sampleCurveX(r) - e; if (Math.abs(i) < t) return r; var o = this.sampleCurveDerivativeX(r); if (Math.abs(o) < 1e-6) break; r -= i / o } var s = 0, a = 1; for (r = e, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - e) < t)); n++)e > i ? s = r : a = r, r = .5 * (a - s) + s; return r }, solve: function (e, t) { return this.sampleCurveY(this.solveCurveX(e, t)) } }; var f = m; function m(e, t) { this.x = e, this.y = t } m.prototype = { clone: function () { return new m(this.x, this.y) }, add: function (e) { return this.clone()._add(e) }, sub: function (e) { return this.clone()._sub(e) }, multByPoint: function (e) { return this.clone()._multByPoint(e) }, divByPoint: function (e) { return this.clone()._divByPoint(e) }, mult: function (e) { return this.clone()._mult(e) }, div: function (e) { return this.clone()._div(e) }, rotate: function (e) { return this.clone()._rotate(e) }, rotateAround: function (e, t) { return this.clone()._rotateAround(e, t) }, matMult: function (e) { return this.clone()._matMult(e) }, unit: function () { return this.clone()._unit() }, perp: function () { return this.clone()._perp() }, round: function () { return this.clone()._round() }, mag: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, equals: function (e) { return this.x === e.x && this.y === e.y }, dist: function (e) { return Math.sqrt(this.distSqr(e)) }, distSqr: function (e) { var t = e.x - this.x, r = e.y - this.y; return t * t + r * r }, angle: function () { return Math.atan2(this.y, this.x) }, angleTo: function (e) { return Math.atan2(this.y - e.y, this.x - e.x) }, angleWith: function (e) { return this.angleWithSep(e.x, e.y) }, angleWithSep: function (e, t) { return Math.atan2(this.x * t - this.y * e, this.x * e + this.y * t) }, _matMult: function (e) { var t = e[2] * this.x + e[3] * this.y; return this.x = e[0] * this.x + e[1] * this.y, this.y = t, this }, _add: function (e) { return this.x += e.x, this.y += e.y, this }, _sub: function (e) { return this.x -= e.x, this.y -= e.y, this }, _mult: function (e) { return this.x *= e, this.y *= e, this }, _div: function (e) { return this.x /= e, this.y /= e, this }, _multByPoint: function (e) { return this.x *= e.x, this.y *= e.y, this }, _divByPoint: function (e) { return this.x /= e.x, this.y /= e.y, this }, _unit: function () { return this._div(this.mag()), this }, _perp: function () { var e = this.y; return this.y = this.x, this.x = -e, this }, _rotate: function (e) { var t = Math.cos(e), r = Math.sin(e), n = r * this.x + t * this.y; return this.x = t * this.x - r * this.y, this.y = n, this }, _rotateAround: function (e, t) { var r = Math.cos(e), n = Math.sin(e), i = t.y + n * (this.x - t.x) + r * (this.y - t.y); return this.x = t.x + r * (this.x - t.x) - n * (this.y - t.y), this.y = i, this }, _round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } }, m.convert = function (e) { return e instanceof m ? e : Array.isArray(e) ? new m(e[0], e[1]) : e }; const g = Math.PI / 180, _ = 180 / Math.PI; function y(e) { return e * g } function v(e) { return e * _ } const x = [[0, 0], [1, 0], [1, 1], [0, 1]]; function b(e) { if (e <= 0) return 0; if (e >= 1) return 1; const t = e * e, r = t * e; return 4 * (e < .5 ? r : 3 * (e - t) + r - .75) } function w(e, t, r, n) { const i = new d(e, t, r, n); return function (e) { return i.solve(e) } } const T = w(.25, .1, .25, 1); function k(e, t, r) { return Math.min(r, Math.max(t, e)) } function C(e, t, r) { return (r = k((r - e) / (t - e), 0, 1)) * r * (3 - 2 * r) } function E(e, t, r) { const n = r - t, i = ((e - t) % n + n) % n + t; return i === t ? r : i } function S(e, t, r) { if (!e.length) return r(null, []); let n = e.length; const i = new Array(e.length); let o = null; e.forEach(((e, s) => { t(e, ((e, t) => { e && (o = e), i[s] = t, 0 == --n && r(o, i) })) })) } function P(e) { const t = []; for (const r in e) t.push(e[r]); return t } function I(e, ...t) { for (const r of t) for (const t in r) e[t] = r[t]; return e } let A = 1; function L() { return A++ } function M() { return function e(t) { return t ? (t ^ Math.random() * (16 >> t / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, e) }() } function B(e) { return e <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(e) / Math.LN2)) } function R(e) { return !!e && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(e) } function D(e, t) { e.forEach((e => { t[e] && (t[e] = t[e].bind(t)) })) } function F(e, t) { return -1 !== e.indexOf(t, e.length - t.length) } function O(e, t, r) { const n = {}; for (const i in e) n[i] = t.call(r || this, e[i], i, e); return n } function z(e, t, r) { const n = {}; for (const i in e) t.call(r || this, e[i], i, e) && (n[i] = e[i]); return n } function U(e) { return Array.isArray(e) ? e.map(U) : "object" == typeof e && e ? O(e, U) : e } const N = {}; function G(e) { N[e] || ("undefined" != typeof console && console.warn(e), N[e] = !0) } function V(e, t, r) { return (r.y - e.y) * (t.x - e.x) > (t.y - e.y) * (r.x - e.x) } function q(e) { let t = 0; for (let r, n, i = 0, o = e.length, s = o - 1; i < o; s = i++)r = e[i], n = e[s], t += (n.x - r.x) * (r.y + n.y); return t } function j() { return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope } function X(e) { const t = {}; if (e.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((e, r, n, i) => { const o = n || i; return t[r] = !o || o.toLowerCase(), "" })), t["max-age"]) { const e = parseInt(t["max-age"], 10); isNaN(e) ? delete t["max-age"] : t["max-age"] = e } return t } let W = null; function Z(e) { if (null == W) { const t = e.navigator ? e.navigator.userAgent : null; W = !!e.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome"))) } return W } function H(e) { try { const r = t[e]; return r.setItem("_mapbox_test_", 1), r.removeItem("_mapbox_test_"), !0 } catch (e) { return !1 } } function Q(e, t) { return [e[4 * t], e[4 * t + 1], e[4 * t + 2], e[4 * t + 3]] } const $ = "mapbox-tiles"; let J = 500, K = 50; const Y = 42e4; let ee, te; function re() { try { return t.caches } catch (e) { } } function ne() { re() && !ee && (ee = t.caches.open($)) } function ie(e) { const t = e.indexOf("?"); if (t < 0) return e; const r = function (e) { const t = e.indexOf("?"); return t > 0 ? e.slice(t + 1).split("&") : [] }(e), n = r.filter((e => { const t = e.split("="); return "language" === t[0] || "worldview" === t[0] })); return n.length ? `${e.slice(0, t)}?${n.join("&")}` : e.slice(0, t) } let oe = 1 / 0; const se = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" }; "function" == typeof Object.freeze && Object.freeze(se); class ae extends Error { constructor(e, t, r) { 401 === t && ye(r) && (e += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(e), this.status = t, this.url = r } toString() { return `${this.name}: ${this.message} (${this.status}): ${this.url}` } } const ce = j() ? () => self.worker && self.worker.referrer : () => ("blob:" === t.location.protocol ? t.parent : t).location.href, le = function (e, r) { if (!(/^file:/.test(n = e.url) || /^file:/.test(ce()) && !/^\w+:/.test(n))) { if (t.fetch && t.Request && t.AbortController && t.Request.prototype.hasOwnProperty("signal")) return function (e, r) { const n = new t.AbortController, i = new t.Request(e.url, { method: e.method || "GET", body: e.body, credentials: e.credentials, headers: e.headers, referrer: ce(), referrerPolicy: e.referrerPolicy, signal: n.signal }); let o = !1, s = !1; const a = (c = i.url).indexOf("sku=") > 0 && ye(c); var c; "json" === e.type && i.headers.set("Accept", "application/json"); const l = (n, o, c) => { if (s) return; if (n && "SecurityError" !== n.message && G(n), o && c) return u(o); const l = Date.now(); t.fetch(i).then((t => { if (t.ok) { const e = a ? t.clone() : null; return u(t, e, l) } return r(new ae(t.statusText, t.status, e.url)) })).catch((t => { "AbortError" !== t.name && r(new Error(`${t.message} ${e.url}`)) })) }, u = (n, a, c) => { ("arrayBuffer" === e.type ? n.arrayBuffer() : "json" === e.type ? n.json() : n.text()).then((e => { s || (a && c && function (e, r, n) { if (ne(), !ee) return; const i = { status: r.status, statusText: r.statusText, headers: new t.Headers }; r.headers.forEach(((e, t) => i.headers.set(t, e))); const o = X(r.headers.get("Cache-Control") || ""); if (o["no-store"]) return; o["max-age"] && i.headers.set("Expires", new Date(n + 1e3 * o["max-age"]).toUTCString()); const s = i.headers.get("Expires"); s && (new Date(s).getTime() - n < Y || function (e, t) { if (void 0 === te) try { new Response(new ReadableStream), te = !0 } catch (e) { te = !1 } te ? t(e.body) : e.blob().then(t) }(r, (r => { const n = new t.Response(r, i); ne(), ee && ee.then((t => t.put(ie(e.url), n))).catch((e => G(e.message))) }))) }(i, a, c), o = !0, r(null, e, n.headers.get("Cache-Control"), n.headers.get("Expires"))) })).catch((e => { s || r(new Error(e.message)) })) }; return a ? function (e, t) { if (ne(), !ee) return t(null); const r = ie(e.url); ee.then((e => { e.match(r).then((n => { const i = function (e) { if (!e) return !1; const t = new Date(e.headers.get("Expires") || 0), r = X(e.headers.get("Cache-Control") || ""); return t > Date.now() && !r["no-cache"] }(n); e.delete(r), i && e.put(r, n.clone()), t(null, n, i) })).catch(t) })).catch(t) }(i, l) : l(null, null), { cancel: () => { s = !0, o || n.abort() } } }(e, r); if (j() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", e, r, void 0, !0) } var n; return function (e, r) { const n = new t.XMLHttpRequest; n.open(e.method || "GET", e.url, !0), "arrayBuffer" === e.type && (n.responseType = "arraybuffer"); for (const t in e.headers) n.setRequestHeader(t, e.headers[t]); return "json" === e.type && (n.responseType = "text", n.setRequestHeader("Accept", "application/json")), n.withCredentials = "include" === e.credentials, n.onerror = () => { r(new Error(n.statusText)) }, n.onload = () => { if ((n.status >= 200 && n.status < 300 || 0 === n.status) && null !== n.response) { let t = n.response; if ("json" === e.type) try { t = JSON.parse(n.response) } catch (e) { return r(e) } r(null, t, n.getResponseHeader("Cache-Control"), n.getResponseHeader("Expires")) } else r(new ae(n.statusText, n.status, e.url)) }, n.send(e.body), { cancel: () => n.abort() } }(e, r) }, ue = function (e, t) { return le(I(e, { type: "arrayBuffer" }), t) }; function he(e) { const r = t.document.createElement("a"); return r.href = e, r.protocol === t.document.location.protocol && r.host === t.document.location.host } const de = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII="; let pe, fe; pe = [], fe = 0; const me = function (e, r) { if (o.supported && (e.headers || (e.headers = {}), e.headers.accept = "image/webp,*/*"), fe >= i.MAX_PARALLEL_IMAGE_REQUESTS) { const t = { requestParameters: e, callback: r, cancelled: !1, cancel() { this.cancelled = !0 } }; return pe.push(t), t } fe++; let n = !1; const s = () => { if (!n) for (n = !0, fe--; pe.length && fe < i.MAX_PARALLEL_IMAGE_REQUESTS;) { const e = pe.shift(), { requestParameters: t, callback: r, cancelled: n } = e; n || (e.cancel = me(t, r).cancel) } }, a = ue(e, ((e, n, i, o) => { s(), e ? r(e) : n && (t.createImageBitmap ? function (e, r) { const n = new t.Blob([new Uint8Array(e)], { type: "image/png" }); t.createImageBitmap(n).then((e => { r(null, e) })).catch((e => { r(new Error(`Could not load image because of ${e.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)) })) }(n, ((e, t) => r(e, t, i, o))) : function (e, r) { const n = new t.Image, i = t.URL; n.onload = () => { r(null, n), i.revokeObjectURL(n.src), n.onload = null, t.requestAnimationFrame((() => { n.src = de })) }, n.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")); const o = new t.Blob([new Uint8Array(e)], { type: "image/png" }); n.src = e.byteLength ? i.createObjectURL(o) : de }(n, ((e, t) => r(e, t, i, o)))) })); return { cancel: () => { a.cancel(), s() } } }, ge = "NO_ACCESS_TOKEN"; function _e(e) { return 0 === e.indexOf("mapbox:") } function ye(e) { return i.API_URL_REGEX.test(e) } function ve(e) { return i.API_CDN_URL_REGEX.test(e) } function xe(e) { return i.API_STYLE_REGEX.test(e) && !be(e) } function be(e) { return i.API_SPRITE_REGEX.test(e) } const we = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/; function Te(e) { const t = e.match(we); if (!t) throw new Error("Unable to parse URL object"); return { protocol: t[1], authority: t[2], path: t[3] || "/", params: t[4] ? t[4].split("&") : [] } } function ke(e) { const t = e.params.length ? `?${e.params.join("&")}` : ""; return `${e.protocol}://${e.authority}${e.path}${t}` } const Ce = "mapbox.eventData"; function Ee(e) { if (!e) return null; const r = e.split("."); if (!r || 3 !== r.length) return null; try { return JSON.parse(decodeURIComponent(t.atob(r[1]).split("").map((e => "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2))).join(""))) } catch (e) { return null } } class Se { constructor(e) { this.type = e, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null } getStorageKey(e) { const r = Ee(i.ACCESS_TOKEN); let n = ""; return n = r && r.u ? t.btoa(encodeURIComponent(r.u).replace(/%([0-9A-F]{2})/g, ((e, t) => String.fromCharCode(Number("0x" + t))))) : i.ACCESS_TOKEN || "", e ? `${Ce}.${e}:${n}` : `${Ce}:${n}` } fetchEventData() { const e = H("localStorage"), r = this.getStorageKey(), n = this.getStorageKey("uuid"); if (e) try { const e = t.localStorage.getItem(r); e && (this.eventData = JSON.parse(e)); const i = t.localStorage.getItem(n); i && (this.anonId = i) } catch (e) { G("Unable to read from LocalStorage") } } saveEventData() { const e = H("localStorage"), r = this.getStorageKey(), n = this.getStorageKey("uuid"); if (e) try { t.localStorage.setItem(n, this.anonId), Object.keys(this.eventData).length >= 1 && t.localStorage.setItem(r, JSON.stringify(this.eventData)) } catch (e) { G("Unable to write to LocalStorage") } } processRequests(e) { } postEvent(e, t, r, n) { if (!i.EVENTS_URL) return; const o = Te(i.EVENTS_URL); o.params.push(`access_token=${n || i.ACCESS_TOKEN || ""}`); const s = { event: this.type, created: new Date(e).toISOString() }, a = t ? I(s, t) : s, c = { url: ke(o), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([a]) }; this.pendingRequest = function (e, t) { return le(I(e, { method: "POST" }), t) }(c, (e => { this.pendingRequest = null, r(e), this.saveEventData(), this.processRequests(n) })) } queueRequest(e, t) { this.queue.push(e), this.processRequests(t) } } const Pe = new class extends Se { constructor(e) { super("appUserTurnstile"), this._customAccessToken = e } postTurnstileEvent(e, t) { i.EVENTS_URL && i.ACCESS_TOKEN && Array.isArray(e) && e.some((e => _e(e) || ye(e))) && this.queueRequest(Date.now(), t) } processRequests(e) { if (this.pendingRequest || 0 === this.queue.length) return; this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData(); const t = Ee(i.ACCESS_TOKEN), n = t ? t.u : i.ACCESS_TOKEN; let o = n !== this.eventData.tokenU; R(this.anonId) || (this.anonId = M(), o = !0); const s = this.queue.shift(); if (this.eventData.lastSuccess) { const e = new Date(this.eventData.lastSuccess), t = new Date(s), r = (s - this.eventData.lastSuccess) / 864e5; o = o || r >= 1 || r < -1 || e.getDate() !== t.getDate() } else o = !0; o ? this.postEvent(s, { sdkIdentifier: "mapbox-gl-js", sdkVersion: r, skuId: h, "enabled.telemetry": !1, userId: this.anonId }, (e => { e || (this.eventData.lastSuccess = s, this.eventData.tokenU = n) }), e) : this.processRequests() } }, Ie = Pe.postTurnstileEvent.bind(Pe), Ae = new class extends Se { constructor() { super("map.load"), this.success = {}, this.skuToken = "" } postMapLoadEvent(e, t, r, n) { this.skuToken = t, this.errorCb = n, i.EVENTS_URL && (r || i.ACCESS_TOKEN ? this.queueRequest({ id: e, timestamp: Date.now() }, r) : this.errorCb(new Error(ge))) } processRequests(e) { if (this.pendingRequest || 0 === this.queue.length) return; const { id: t, timestamp: n } = this.queue.shift(); t && this.success[t] || (this.anonId || this.fetchEventData(), R(this.anonId) || (this.anonId = M()), this.postEvent(n, { sdkIdentifier: "mapbox-gl-js", sdkVersion: r, skuId: h, skuToken: this.skuToken, userId: this.anonId }, (e => { e ? this.errorCb(e) : t && (this.success[t] = !0) }), e)) } }, Le = Ae.postMapLoadEvent.bind(Ae), Me = new class extends Se { constructor() { super("gljs.performance") } postPerformanceEvent(e, t) { i.EVENTS_URL && (e || i.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: t }, e) } processRequests(e) { if (this.pendingRequest || 0 === this.queue.length) return; const { timestamp: n, performanceData: i } = this.queue.shift(), o = function (e) { const n = t.performance.getEntriesByType("resource"), i = t.performance.getEntriesByType("mark"), o = function (e) { const t = {}; if (e) for (const r in e) if ("other" !== r) for (const n of e[r]) { const e = `${r}ResolveRangeMin`, i = `${r}ResolveRangeMax`, o = `${r}RequestCount`, s = `${r}RequestCachedCount`; t[e] = Math.min(t[e] || 1 / 0, n.startTime), t[i] = Math.max(t[i] || -1 / 0, n.responseEnd); const a = e => { void 0 === t[e] && (t[e] = 0), ++t[e] }; void 0 !== n.transferSize && 0 === n.transferSize && a(s), a(o) } return t }(function (e, t) { const r = {}; if (e) for (const n of e) { const e = t(n); void 0 === r[e] && (r[e] = []), r[e].push(n) } return r }(n, Ue)), s = t.devicePixelRatio, a = t.navigator.connection || t.navigator.mozConnection || t.navigator.webkitConnection, c = { counters: [], metadata: [], attributes: [] }, l = (e, t, r) => { null != r && e.push({ name: t, value: r.toString() }) }; for (const t in o) l(c.counters, t, o[t]); if (e.interactionRange[0] !== 1 / 0 && e.interactionRange[1] !== -1 / 0 && (l(c.counters, "interactionRangeMin", e.interactionRange[0]), l(c.counters, "interactionRangeMax", e.interactionRange[1])), i) for (const t of Object.keys(Oe)) { const e = Oe[t], r = i.find((t => t.name === e)); r && l(c.counters, e, r.startTime) } return l(c.counters, "visibilityHidden", e.visibilityHidden), l(c.attributes, "style", function (e) { if (e) for (const t of e) { const e = t.name.split("?")[0]; if (xe(e)) { const t = e.split("/").slice(-2); if (2 === t.length) return `mapbox://styles/${t[0]}/${t[1]}` } } }(n)), l(c.attributes, "terrainEnabled", e.terrainEnabled ? "true" : "false"), l(c.attributes, "fogEnabled", e.fogEnabled ? "true" : "false"), l(c.attributes, "projection", e.projection), l(c.attributes, "zoom", e.zoom), l(c.metadata, "devicePixelRatio", s), l(c.metadata, "connectionEffectiveType", a ? a.effectiveType : void 0), l(c.metadata, "navigatorUserAgent", t.navigator.userAgent), l(c.metadata, "screenWidth", t.screen.width), l(c.metadata, "screenHeight", t.screen.height), l(c.metadata, "windowWidth", t.innerWidth), l(c.metadata, "windowHeight", t.innerHeight), l(c.metadata, "mapWidth", e.width / s), l(c.metadata, "mapHeight", e.height / s), l(c.metadata, "webglRenderer", e.renderer), l(c.metadata, "webglVendor", e.vendor), l(c.metadata, "sdkVersion", r), l(c.metadata, "sdkIdentifier", "mapbox-gl-js"), c }(i); for (const t of o.metadata); for (const t of o.counters); for (const t of o.attributes); this.postEvent(n, o, (() => { }), e) } }, Be = Me.postPerformanceEvent.bind(Me), Re = new class extends Se { constructor() { super("map.auth"), this.success = {}, this.skuToken = "" } getSession(e, t, r, n) { if (!i.API_URL || !i.SESSION_PATH) return; const o = Te(i.API_URL + i.SESSION_PATH); o.params.push(`sku=${t || ""}`), o.params.push(`access_token=${n || i.ACCESS_TOKEN || ""}`); const s = { url: ke(o), headers: { "Content-Type": "text/plain" } }; this.pendingRequest = function (e, t) { return le(I(e, { method: "GET" }), t) }(s, (e => { this.pendingRequest = null, r(e), this.saveEventData(), this.processRequests(n) })) } getSessionAPI(e, t, r, n) { this.skuToken = t, this.errorCb = n, i.SESSION_PATH && i.API_URL && (r || i.ACCESS_TOKEN ? this.queueRequest({ id: e, timestamp: Date.now() }, r) : this.errorCb(new Error(ge))) } processRequests(e) { if (this.pendingRequest || 0 === this.queue.length) return; const { id: t, timestamp: r } = this.queue.shift(); t && this.success[t] || this.getSession(r, this.skuToken, (e => { e ? this.errorCb(e) : t && (this.success[t] = !0) }), e) } }, De = Re.getSessionAPI.bind(Re), Fe = new Set, Oe = { create: "create", load: "load", fullLoad: "fullLoad" }, ze = { mark(e) { t.performance.mark(e) }, measure(e, r, n) { t.performance.measure(e, r, n) } }; function Ue(e) { const t = e.name.split("?")[0]; return ve(t) && t.includes("mapbox-gl.js") ? "javascript" : ve(t) && t.includes("mapbox-gl.css") ? "css" : function (e) { return i.API_FONTS_REGEX.test(e) }(t) ? "fontRange" : be(t) ? "sprite" : xe(t) ? "style" : function (e) { return i.API_TILEJSON_REGEX.test(e) }(t) ? "tilejson" : "other" } const Ne = t.performance; function Ge(e) { const t = e ? e.url.toString() : void 0; return Ne.getEntriesByName(t) } let Ve, qe, je, Xe; const We = { now: () => void 0 !== je ? je : t.performance.now(), setNow(e) { je = e }, restoreNow() { je = void 0 }, frame(e) { const r = t.requestAnimationFrame(e); return { cancel: () => t.cancelAnimationFrame(r) } }, getImageData(e, r = 0) { const { width: n, height: i } = e; Xe || (Xe = t.document.createElement("canvas")); const o = Xe.getContext("2d", { willReadFrequently: !0 }); if (!o) throw new Error("failed to create canvas 2d context"); return (n > Xe.width || i > Xe.height) && (Xe.width = n, Xe.height = i), o.clearRect(-r, -r, n + 2 * r, i + 2 * r), o.drawImage(e, 0, 0, n, i), o.getImageData(-r, -r, n + 2 * r, i + 2 * r) }, resolveURL: e => (Ve || (Ve = t.document.createElement("a")), Ve.href = e, Ve.href), get devicePixelRatio() { return t.devicePixelRatio }, get prefersReducedMotion() { return !!t.matchMedia && (null == qe && (qe = t.matchMedia("(prefers-reduced-motion: reduce)")), qe.matches) } }; function Ze(e, t, r) { r[e] && -1 !== r[e].indexOf(t) || (r[e] = r[e] || [], r[e].push(t)) } function He(e, t, r) { if (r && r[e]) { const n = r[e].indexOf(t); -1 !== n && r[e].splice(n, 1) } } class Qe { constructor(e, t = {}) { I(this, t), this.type = e } } class $e extends Qe { constructor(e, t = {}) { super("error", I({ error: e }, t)) } } class Je { on(e, t) { return this._listeners = this._listeners || {}, Ze(e, t, this._listeners), this } off(e, t) { return He(e, t, this._listeners), He(e, t, this._oneTimeListeners), this } once(e, t) { return t ? (this._oneTimeListeners = this._oneTimeListeners || {}, Ze(e, t, this._oneTimeListeners), this) : new Promise((t => this.once(e, t))) } fire(e, t) { "string" == typeof e && (e = new Qe(e, t || {})); const r = e.type; if (this.listens(r)) { e.target = this; const t = this._listeners && this._listeners[r] ? this._listeners[r].slice() : []; for (const r of t) r.call(this, e); const n = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : []; for (const o of n) He(r, o, this._oneTimeListeners), o.call(this, e); const i = this._eventedParent; i && (I(e, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i.fire(e)) } else e instanceof $e && console.error(e.error); return this } listens(e) { return !!(this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e)) } setEventedParent(e, t) { return this._eventedParent = e, this._eventedParentData = t, this } } var Ke = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}'); function Ye(e, ...t) { for (const r of t) for (const t in r) e[t] = r[t]; return e } function et(e) { return e instanceof Number || e instanceof String || e instanceof Boolean ? e.valueOf() : e } function tt(e) { if (Array.isArray(e)) return e.map(tt); if (e instanceof Object && !(e instanceof Number || e instanceof String || e instanceof Boolean)) { const t = {}; for (const r in e) t[r] = tt(e[r]); return t } return et(e) } class rt extends Error { constructor(e, t) { super(t), this.message = t, this.key = e } } var nt = rt; class it { constructor(e, t = []) { this.parent = e, this.bindings = {}; for (const [r, n] of t) this.bindings[r] = n } concat(e) { return new it(this, e) } get(e) { if (this.bindings[e]) return this.bindings[e]; if (this.parent) return this.parent.get(e); throw new Error(`${e} not found in scope.`) } has(e) { return !!this.bindings[e] || !!this.parent && this.parent.has(e) } } var ot = it; const st = { kind: "null" }, at = { kind: "number" }, ct = { kind: "string" }, lt = { kind: "boolean" }, ut = { kind: "color" }, ht = { kind: "object" }, dt = { kind: "value" }, pt = { kind: "collator" }, ft = { kind: "formatted" }, mt = { kind: "resolvedImage" }; function gt(e, t) { return { kind: "array", itemType: e, N: t } } function _t(e) { if ("array" === e.kind) { const t = _t(e.itemType); return "number" == typeof e.N ? `array<${t}, ${e.N}>` : "value" === e.itemType.kind ? "array" : `array<${t}>` } return e.kind } const yt = [st, at, ct, lt, ut, ft, ht, gt(dt), mt]; function vt(e, t) { if ("error" === t.kind) return null; if ("array" === e.kind) { if ("array" === t.kind && (0 === t.N && "value" === t.itemType.kind || !vt(e.itemType, t.itemType)) && ("number" != typeof e.N || e.N === t.N)) return null } else { if (e.kind === t.kind) return null; if ("value" === e.kind) for (const e of yt) if (!vt(e, t)) return null } return `Expected ${_t(e)} but found ${_t(t)} instead.` } function xt(e, t) { return t.some((t => t.kind === e.kind)) } function bt(e, t) { return t.some((t => "null" === t ? null === e : "array" === t ? Array.isArray(e) : "object" === t ? e && !Array.isArray(e) && "object" == typeof e : t === typeof e)) } var wt, Tt = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] }; function kt(e) { return (e = Math.round(e)) < 0 ? 0 : e > 255 ? 255 : e } function Ct(e) { return kt("%" === e[e.length - 1] ? parseFloat(e) / 100 * 255 : parseInt(e)) } function Et(e) { return (t = "%" === e[e.length - 1] ? parseFloat(e) / 100 : parseFloat(e)) < 0 ? 0 : t > 1 ? 1 : t; var t } function St(e, t, r) { return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? e + (t - e) * r * 6 : 2 * r < 1 ? t : 3 * r < 2 ? e + (t - e) * (2 / 3 - r) * 6 : e } try { wt = {}.parseCSSColor = function (e) { var t, r = e.replace(/ /g, "").toLowerCase(); if (r in Tt) return Tt[r].slice(); if ("#" === r[0]) return 4 === r.length ? (t = parseInt(r.substr(1), 16)) >= 0 && t <= 4095 ? [(3840 & t) >> 4 | (3840 & t) >> 8, 240 & t | (240 & t) >> 4, 15 & t | (15 & t) << 4, 1] : null : 7 === r.length && (t = parseInt(r.substr(1), 16)) >= 0 && t <= 16777215 ? [(16711680 & t) >> 16, (65280 & t) >> 8, 255 & t, 1] : null; var n = r.indexOf("("), i = r.indexOf(")"); if (-1 !== n && i + 1 === r.length) { var o = r.substr(0, n), s = r.substr(n + 1, i - (n + 1)).split(","), a = 1; switch (o) { case "rgba": if (4 !== s.length) return null; a = Et(s.pop()); case "rgb": return 3 !== s.length ? null : [Ct(s[0]), Ct(s[1]), Ct(s[2]), a]; case "hsla": if (4 !== s.length) return null; a = Et(s.pop()); case "hsl": if (3 !== s.length) return null; var c = (parseFloat(s[0]) % 360 + 360) % 360 / 360, l = Et(s[1]), u = Et(s[2]), h = u <= .5 ? u * (l + 1) : u + l - u * l, d = 2 * u - h; return [kt(255 * St(d, h, c + 1 / 3)), kt(255 * St(d, h, c)), kt(255 * St(d, h, c - 1 / 3)), a]; default: return null } } return null } } catch (e) { } class Pt { constructor(e, t, r, n = 1) { this.r = e, this.g = t, this.b = r, this.a = n } static parse(e) { if (!e) return; if (e instanceof Pt) return e; if ("string" != typeof e) return; const t = wt(e); return t ? new Pt(t[0] / 255 * t[3], t[1] / 255 * t[3], t[2] / 255 * t[3], t[3]) : void 0 } toString() { const [e, t, r, n] = this.toArray(); return `rgba(${Math.round(e)},${Math.round(t)},${Math.round(r)},${n})` } toArray() { const { r: e, g: t, b: r, a: n } = this; return 0 === n ? [0, 0, 0, 0] : [255 * e / n, 255 * t / n, 255 * r / n, n] } toArray01() { const { r: e, g: t, b: r, a: n } = this; return 0 === n ? [0, 0, 0, 0] : [e / n, t / n, r / n, n] } toArray01PremultipliedAlpha() { const { r: e, g: t, b: r, a: n } = this; return [e, t, r, n] } } Pt.black = new Pt(0, 0, 0, 1), Pt.white = new Pt(1, 1, 1, 1), Pt.transparent = new Pt(0, 0, 0, 0), Pt.red = new Pt(1, 0, 0, 1), Pt.blue = new Pt(0, 0, 1, 1); var It = Pt; class At { constructor(e, t, r) { this.sensitivity = e ? t ? "variant" : "case" : t ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" }) } compare(e, t) { return this.collator.compare(e, t) } resolvedLocale() { return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale } } class Lt { constructor(e, t, r, n, i) { this.text = e.normalize ? e.normalize() : e, this.image = t, this.scale = r, this.fontStack = n, this.textColor = i } } class Mt { constructor(e) { this.sections = e } static fromString(e) { return new Mt([new Lt(e, null, null, null, null)]) } isEmpty() { return 0 === this.sections.length || !this.sections.some((e => 0 !== e.text.length || e.image && 0 !== e.image.name.length)) } static factory(e) { return e instanceof Mt ? e : Mt.fromString(e) } toString() { return 0 === this.sections.length ? "" : this.sections.map((e => e.text)).join("") } serialize() { const e = ["format"]; for (const t of this.sections) { if (t.image) { e.push(["image", t.image.name]); continue } e.push(t.text); const r = {}; t.fontStack && (r["text-font"] = ["literal", t.fontStack.split(",")]), t.scale && (r["font-scale"] = t.scale), t.textColor && (r["text-color"] = ["rgba"].concat(t.textColor.toArray())), e.push(r) } return e } } class Bt { constructor(e) { this.name = e.name, this.available = e.available } toString() { return this.name } static fromString(e) { return e ? new Bt({ name: e, available: !1 }) : null } serialize() { return ["image", this.name] } } function Rt(e, t, r, n) { return "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof t && t >= 0 && t <= 255 && "number" == typeof r && r >= 0 && r <= 255 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[e, t, r, n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n ? [e, t, r, n] : [e, t, r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.` } function Dt(e) { if (null === e) return !0; if ("string" == typeof e) return !0; if ("boolean" == typeof e) return !0; if ("number" == typeof e) return !0; if (e instanceof It) return !0; if (e instanceof At) return !0; if (e instanceof Mt) return !0; if (e instanceof Bt) return !0; if (Array.isArray(e)) { for (const t of e) if (!Dt(t)) return !1; return !0 } if ("object" == typeof e) { for (const t in e) if (!Dt(e[t])) return !1; return !0 } return !1 } function Ft(e) { if (null === e) return st; if ("string" == typeof e) return ct; if ("boolean" == typeof e) return lt; if ("number" == typeof e) return at; if (e instanceof It) return ut; if (e instanceof At) return pt; if (e instanceof Mt) return ft; if (e instanceof Bt) return mt; if (Array.isArray(e)) { const t = e.length; let r; for (const n of e) { const e = Ft(n); if (r) { if (r === e) continue; r = dt; break } r = e } return gt(r || dt, t) } return ht } function Ot(e) { const t = typeof e; return null === e ? "" : "string" === t || "number" === t || "boolean" === t ? String(e) : e instanceof It || e instanceof Mt || e instanceof Bt ? e.toString() : JSON.stringify(e) } class zt { constructor(e, t) { this.type = e, this.value = t } static parse(e, t) { if (2 !== e.length) return t.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`); if (!Dt(e[1])) return t.error("invalid value"); const r = e[1]; let n = Ft(r); const i = t.expectedType; return "array" !== n.kind || 0 !== n.N || !i || "array" !== i.kind || "number" == typeof i.N && 0 !== i.N || (n = i), new zt(n, r) } evaluate() { return this.value } eachChild() { } outputDefined() { return !0 } serialize() { return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof It ? ["rgba"].concat(this.value.toArray()) : this.value instanceof Mt ? this.value.serialize() : this.value } } var Ut = zt, Nt = class { constructor(e) { this.name = "ExpressionEvaluationError", this.message = e } toJSON() { return this.message } }; const Gt = { string: ct, number: at, boolean: lt, object: ht }; class Vt { constructor(e, t) { this.type = e, this.args = t } static parse(e, t) { if (e.length < 2) return t.error("Expected at least one argument."); let r, n = 1; const i = e[0]; if ("array" === i) { let i, o; if (e.length > 2) { const r = e[1]; if ("string" != typeof r || !(r in Gt) || "object" === r) return t.error('The item type argument of "array" must be one of string, number, boolean', 1); i = Gt[r], n++ } else i = dt; if (e.length > 3) { if (null !== e[2] && ("number" != typeof e[2] || e[2] < 0 || e[2] !== Math.floor(e[2]))) return t.error('The length argument to "array" must be a positive integer literal', 2); o = e[2], n++ } r = gt(i, o) } else r = Gt[i]; const o = []; for (; n < e.length; n++) { const r = t.parse(e[n], n, dt); if (!r) return null; o.push(r) } return new Vt(r, o) } evaluate(e) { for (let t = 0; t < this.args.length; t++) { const r = this.args[t].evaluate(e); if (!vt(this.type, Ft(r))) return r; if (t === this.args.length - 1) throw new Nt(`Expected value to be of type ${_t(this.type)}, but found ${_t(Ft(r))} instead.`) } return null } eachChild(e) { this.args.forEach(e) } outputDefined() { return this.args.every((e => e.outputDefined())) } serialize() { const e = this.type, t = [e.kind]; if ("array" === e.kind) { const r = e.itemType; if ("string" === r.kind || "number" === r.kind || "boolean" === r.kind) { t.push(r.kind); const n = e.N; ("number" == typeof n || this.args.length > 1) && t.push(n) } } return t.concat(this.args.map((e => e.serialize()))) } } var qt = Vt; class jt { constructor(e) { this.type = ft, this.sections = e } static parse(e, t) { if (e.length < 2) return t.error("Expected at least one argument."); const r = e[1]; if (!Array.isArray(r) && "object" == typeof r) return t.error("First argument must be an image or text section."); const n = []; let i = !1; for (let o = 1; o <= e.length - 1; ++o) { const r = e[o]; if (i && "object" == typeof r && !Array.isArray(r)) { i = !1; let e = null; if (r["font-scale"] && (e = t.parse(r["font-scale"], 1, at), !e)) return null; let o = null; if (r["text-font"] && (o = t.parse(r["text-font"], 1, gt(ct)), !o)) return null; let s = null; if (r["text-color"] && (s = t.parse(r["text-color"], 1, ut), !s)) return null; const a = n[n.length - 1]; a.scale = e, a.font = o, a.textColor = s } else { const r = t.parse(e[o], 1, dt); if (!r) return null; const s = r.type.kind; if ("string" !== s && "value" !== s && "null" !== s && "resolvedImage" !== s) return t.error("Formatted text type must be 'string', 'value', 'image' or 'null'."); i = !0, n.push({ content: r, scale: null, font: null, textColor: null }) } } return new jt(n) } evaluate(e) { return new Mt(this.sections.map((t => { const r = t.content.evaluate(e); return Ft(r) === mt ? new Lt("", r, null, null, null) : new Lt(Ot(r), null, t.scale ? t.scale.evaluate(e) : null, t.font ? t.font.evaluate(e).join(",") : null, t.textColor ? t.textColor.evaluate(e) : null) }))) } eachChild(e) { for (const t of this.sections) e(t.content), t.scale && e(t.scale), t.font && e(t.font), t.textColor && e(t.textColor) } outputDefined() { return !1 } serialize() { const e = ["format"]; for (const t of this.sections) { e.push(t.content.serialize()); const r = {}; t.scale && (r["font-scale"] = t.scale.serialize()), t.font && (r["text-font"] = t.font.serialize()), t.textColor && (r["text-color"] = t.textColor.serialize()), e.push(r) } return e } } class Xt { constructor(e) { this.type = mt, this.input = e } static parse(e, t) { if (2 !== e.length) return t.error("Expected two arguments."); const r = t.parse(e[1], 1, ct); return r ? new Xt(r) : t.error("No image name provided.") } evaluate(e) { const t = this.input.evaluate(e), r = Bt.fromString(t); return r && e.availableImages && (r.available = e.availableImages.indexOf(t) > -1), r } eachChild(e) { e(this.input) } outputDefined() { return !1 } serialize() { return ["image", this.input.serialize()] } } const Wt = { "to-boolean": lt, "to-color": ut, "to-number": at, "to-string": ct }; class Zt { constructor(e, t) { this.type = e, this.args = t } static parse(e, t) { if (e.length < 2) return t.error("Expected at least one argument."); const r = e[0]; if (("to-boolean" === r || "to-string" === r) && 2 !== e.length) return t.error("Expected one argument."); const n = Wt[r], i = []; for (let o = 1; o < e.length; o++) { const r = t.parse(e[o], o, dt); if (!r) return null; i.push(r) } return new Zt(n, i) } evaluate(e) { if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(e)); if ("color" === this.type.kind) { let t, r; for (const n of this.args) { if (t = n.evaluate(e), r = null, t instanceof It) return t; if ("string" == typeof t) { const r = e.parseColor(t); if (r) return r } else if (Array.isArray(t) && (r = t.length < 3 || t.length > 4 ? `Invalid rbga value ${JSON.stringify(t)}: expected an array containing either three or four numeric values.` : Rt(t[0], t[1], t[2], t[3]), !r)) return new It(t[0] / 255, t[1] / 255, t[2] / 255, t[3]) } throw new Nt(r || `Could not parse color from value '${"string" == typeof t ? t : String(JSON.stringify(t))}'`) } if ("number" === this.type.kind) { let t = null; for (const r of this.args) { if (t = r.evaluate(e), null === t) return 0; const n = Number(t); if (!isNaN(n)) return n } throw new Nt(`Could not convert ${JSON.stringify(t)} to number.`) } return "formatted" === this.type.kind ? Mt.fromString(Ot(this.args[0].evaluate(e))) : "resolvedImage" === this.type.kind ? Bt.fromString(Ot(this.args[0].evaluate(e))) : Ot(this.args[0].evaluate(e)) } eachChild(e) { this.args.forEach(e) } outputDefined() { return this.args.every((e => e.outputDefined())) } serialize() { if ("formatted" === this.type.kind) return new jt([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize(); if ("resolvedImage" === this.type.kind) return new Xt(this.args[0]).serialize(); const e = [`to-${this.type.kind}`]; return this.eachChild((t => { e.push(t.serialize()) })), e } } var Ht = Zt; const Qt = ["Unknown", "Point", "LineString", "Polygon"]; var $t = class { constructor() { this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null } id() { return this.feature && void 0 !== this.feature.id ? this.feature.id : null } geometryType() { return this.feature ? "number" == typeof this.feature.type ? Qt[this.feature.type] : this.feature.type : null } geometry() { return this.feature && "geometry" in this.feature ? this.feature.geometry : null } canonicalID() { return this.canonical } properties() { return this.feature && this.feature.properties || {} } distanceFromCenter() { if (this.featureTileCoord && this.featureDistanceData) { const e = this.featureDistanceData.center, t = this.featureDistanceData.scale, { x: r, y: n } = this.featureTileCoord; return this.featureDistanceData.bearing[0] * (r * t - e[0]) + this.featureDistanceData.bearing[1] * (n * t - e[1]) } return 0 } parseColor(e) { let t = this._parseColorCache[e]; return t || (t = this._parseColorCache[e] = It.parse(e)), t } }; class Jt { constructor(e, t, r, n) { this.name = e, this.type = t, this._evaluate = r, this.args = n } evaluate(e) { return this._evaluate(e, this.args) } eachChild(e) { this.args.forEach(e) } outputDefined() { return !1 } serialize() { return [this.name].concat(this.args.map((e => e.serialize()))) } static parse(e, t) { const r = e[0], n = Jt.definitions[r]; if (!n) return t.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0); const i = Array.isArray(n) ? n[0] : n.type, o = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads, s = o.filter((([t]) => !Array.isArray(t) || t.length === e.length - 1)); let a = null; for (const [c, l] of s) { a = new kr(t.registry, t.path, null, t.scope); const n = []; let o = !1; for (let t = 1; t < e.length; t++) { const r = e[t], i = Array.isArray(c) ? c[t - 1] : c.type, s = a.parse(r, 1 + n.length, i); if (!s) { o = !0; break } n.push(s) } if (!o) if (Array.isArray(c) && c.length !== n.length) a.error(`Expected ${c.length} arguments, but found ${n.length} instead.`); else { for (let e = 0; e < n.length; e++) { const t = Array.isArray(c) ? c[e] : c.type, r = n[e]; a.concat(e + 1).checkSubtype(t, r.type) } if (0 === a.errors.length) return new Jt(r, i, l, n) } } if (1 === s.length) t.errors.push(...a.errors); else { const r = (s.length ? s : o).map((([e]) => { return t = e, Array.isArray(t) ? `(${t.map(_t).join(", ")})` : `(${_t(t.type)}...)`; var t })).join(" | "), n = []; for (let i = 1; i < e.length; i++) { const r = t.parse(e[i], 1 + n.length); if (!r) return null; n.push(_t(r.type)) } t.error(`Expected arguments of type ${r}, but found (${n.join(", ")}) instead.`) } return null } static register(e, t) { Jt.definitions = t; for (const r in t) e[r] = Jt } } var Kt = Jt; class Yt { constructor(e, t, r) { this.type = pt, this.locale = r, this.caseSensitive = e, this.diacriticSensitive = t } static parse(e, t) { if (2 !== e.length) return t.error("Expected one argument."); const r = e[1]; if ("object" != typeof r || Array.isArray(r)) return t.error("Collator options argument must be an object."); const n = t.parse(void 0 !== r["case-sensitive"] && r["case-sensitive"], 1, lt); if (!n) return null; const i = t.parse(void 0 !== r["diacritic-sensitive"] && r["diacritic-sensitive"], 1, lt); if (!i) return null; let o = null; return r.locale && (o = t.parse(r.locale, 1, ct), !o) ? null : new Yt(n, i, o) } evaluate(e) { return new At(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null) } eachChild(e) { e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale) } outputDefined() { return !1 } serialize() { const e = {}; return e["case-sensitive"] = this.caseSensitive.serialize(), e["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (e.locale = this.locale.serialize()), ["collator", e] } } const er = 8192; function tr(e, t) { e[0] = Math.min(e[0], t[0]), e[1] = Math.min(e[1], t[1]), e[2] = Math.max(e[2], t[0]), e[3] = Math.max(e[3], t[1]) } function rr(e, t) { return !(e[0] <= t[0] || e[2] >= t[2] || e[1] <= t[1] || e[3] >= t[3]) } function nr(e, t) { const r = (180 + e[0]) / 360, n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e[1] * Math.PI / 360))) / 360, i = Math.pow(2, t.z); return [Math.round(r * i * er), Math.round(n * i * er)] } function ir(e, t, r) { const n = e[0] - t[0], i = e[1] - t[1], o = e[0] - r[0], s = e[1] - r[1]; return n * s - o * i == 0 && n * o <= 0 && i * s <= 0 } function or(e, t) { let r = !1; for (let s = 0, a = t.length; s < a; s++) { const a = t[s]; for (let t = 0, s = a.length; t < s - 1; t++) { if (ir(e, a[t], a[t + 1])) return !1; (i = a[t])[1] > (n = e)[1] != (o = a[t + 1])[1] > n[1] && n[0] < (o[0] - i[0]) * (n[1] - i[1]) / (o[1] - i[1]) + i[0] && (r = !r) } } var n, i, o; return r } function sr(e, t) { for (let r = 0; r < t.length; r++)if (or(e, t[r])) return !0; return !1 } function ar(e, t, r, n) { const i = n[0] - r[0], o = n[1] - r[1], s = (e[0] - r[0]) * o - i * (e[1] - r[1]), a = (t[0] - r[0]) * o - i * (t[1] - r[1]); return s > 0 && a < 0 || s < 0 && a > 0 } function cr(e, t, r) { for (const l of r) for (let r = 0; r < l.length - 1; ++r)if (0 != (a = [(s = l[r + 1])[0] - (o = l[r])[0], s[1] - o[1]])[0] * (c = [(i = t)[0] - (n = e)[0], i[1] - n[1]])[1] - a[1] * c[0] && ar(n, i, o, s) && ar(o, s, n, i)) return !0; var n, i, o, s, a, c; return !1 } function lr(e, t) { for (let r = 0; r < e.length; ++r)if (!or(e[r], t)) return !1; for (let r = 0; r < e.length - 1; ++r)if (cr(e[r], e[r + 1], t)) return !1; return !0 } function ur(e, t) { for (let r = 0; r < t.length; r++)if (lr(e, t[r])) return !0; return !1 } function hr(e, t, r) { const n = []; for (let i = 0; i < e.length; i++) { const o = []; for (let n = 0; n < e[i].length; n++) { const s = nr(e[i][n], r); tr(t, s), o.push(s) } n.push(o) } return n } function dr(e, t, r) { const n = []; for (let i = 0; i < e.length; i++) { const o = hr(e[i], t, r); n.push(o) } return n } function pr(e, t, r, n) { if (e[0] < r[0] || e[0] > r[2]) { const t = .5 * n; let i = e[0] - r[0] > t ? -n : r[0] - e[0] > t ? n : 0; 0 === i && (i = e[0] - r[2] > t ? -n : r[2] - e[0] > t ? n : 0), e[0] += i } tr(t, e) } function fr(e, t, r, n) { const i = Math.pow(2, n.z) * er, o = [n.x * er, n.y * er], s = []; if (!e) return s; for (const a of e) for (const e of a) { const n = [e.x + o[0], e.y + o[1]]; pr(n, t, r, i), s.push(n) } return s } function mr(e, t, r, n) { const i = Math.pow(2, n.z) * er, o = [n.x * er, n.y * er], s = []; if (!e) return s; for (const c of e) { const e = []; for (const r of c) { const n = [r.x + o[0], r.y + o[1]]; tr(t, n), e.push(n) } s.push(e) } if (t[2] - t[0] <= i / 2) { (a = t)[0] = a[1] = 1 / 0, a[2] = a[3] = -1 / 0; for (const e of s) for (const n of e) pr(n, t, r, i) } var a; return s } class gr { constructor(e, t) { this.type = lt, this.geojson = e, this.geometries = t } static parse(e, t) { if (2 !== e.length) return t.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`); if (Dt(e[1])) { const t = e[1]; if ("FeatureCollection" === t.type) for (let e = 0; e < t.features.length; ++e) { const r = t.features[e].geometry.type; if ("Polygon" === r || "MultiPolygon" === r) return new gr(t, t.features[e].geometry) } else if ("Feature" === t.type) { const e = t.geometry.type; if ("Polygon" === e || "MultiPolygon" === e) return new gr(t, t.geometry) } else if ("Polygon" === t.type || "MultiPolygon" === t.type) return new gr(t, t) } return t.error("'within' expression requires valid geojson object that contains polygon geometry type.") } evaluate(e) { if (null != e.geometry() && null != e.canonicalID()) { if ("Point" === e.geometryType()) return function (e, t) { const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = e.canonicalID(); if (!i) return !1; if ("Polygon" === t.type) { const o = hr(t.coordinates, n, i), s = fr(e.geometry(), r, n, i); if (!rr(r, n)) return !1; for (const e of s) if (!or(e, o)) return !1 } if ("MultiPolygon" === t.type) { const o = dr(t.coordinates, n, i), s = fr(e.geometry(), r, n, i); if (!rr(r, n)) return !1; for (const e of s) if (!sr(e, o)) return !1 } return !0 }(e, this.geometries); if ("LineString" === e.geometryType()) return function (e, t) { const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = e.canonicalID(); if (!i) return !1; if ("Polygon" === t.type) { const o = hr(t.coordinates, n, i), s = mr(e.geometry(), r, n, i); if (!rr(r, n)) return !1; for (const e of s) if (!lr(e, o)) return !1 } if ("MultiPolygon" === t.type) { const o = dr(t.coordinates, n, i), s = mr(e.geometry(), r, n, i); if (!rr(r, n)) return !1; for (const e of s) if (!ur(e, o)) return !1 } return !0 }(e, this.geometries) } return !1 } eachChild() { } outputDefined() { return !0 } serialize() { return ["within", this.geojson] } } var _r = gr; function yr(e) { if (e instanceof Kt) { if ("get" === e.name && 1 === e.args.length) return !1; if ("feature-state" === e.name) return !1; if ("has" === e.name && 1 === e.args.length) return !1; if ("properties" === e.name || "geometry-type" === e.name || "id" === e.name) return !1; if (/^filter-/.test(e.name)) return !1 } if (e instanceof _r) return !1; let t = !0; return e.eachChild((e => { t && !yr(e) && (t = !1) })), t } function vr(e) { if (e instanceof Kt && "feature-state" === e.name) return !1; let t = !0; return e.eachChild((e => { t && !vr(e) && (t = !1) })), t } function xr(e, t) { if (e instanceof Kt && t.indexOf(e.name) >= 0) return !1; let r = !0; return e.eachChild((e => { r && !xr(e, t) && (r = !1) })), r } class br { constructor(e, t) { this.type = t.type, this.name = e, this.boundExpression = t } static parse(e, t) { if (2 !== e.length || "string" != typeof e[1]) return t.error("'var' expression requires exactly one string literal argument."); const r = e[1]; return t.scope.has(r) ? new br(r, t.scope.get(r)) : t.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`, 1) } evaluate(e) { return this.boundExpression.evaluate(e) } eachChild() { } outputDefined() { return !1 } serialize() { return ["var", this.name] } } var wr = br; class Tr { constructor(e, t = [], r, n = new ot, i = []) { this.registry = e, this.path = t, this.key = t.map((e => `[${e}]`)).join(""), this.scope = n, this.errors = i, this.expectedType = r } parse(e, t, r, n, i = {}) { return t ? this.concat(t, r, n)._parse(e, i) : this._parse(e, i) } _parse(e, t) { function r(e, t, r) { return "assert" === r ? new qt(t, [e]) : "coerce" === r ? new Ht(t, [e]) : e } if (null !== e && "string" != typeof e && "boolean" != typeof e && "number" != typeof e || (e = ["literal", e]), Array.isArray(e)) { if (0 === e.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].'); const n = e[0]; if ("string" != typeof n) return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null; const i = this.registry[n]; if (i) { let n = i.parse(e, this); if (!n) return null; if (this.expectedType) { const e = this.expectedType, i = n.type; if ("string" !== e.kind && "number" !== e.kind && "boolean" !== e.kind && "object" !== e.kind && "array" !== e.kind || "value" !== i.kind) if ("color" !== e.kind && "formatted" !== e.kind && "resolvedImage" !== e.kind || "value" !== i.kind && "string" !== i.kind) { if (this.checkSubtype(e, i)) return null } else n = r(n, e, t.typeAnnotation || "coerce"); else n = r(n, e, t.typeAnnotation || "assert") } if (!(n instanceof Ut) && "resolvedImage" !== n.type.kind && Cr(n)) { const t = new $t; try { n = new Ut(n.type, n.evaluate(t)) } catch (e) { return this.error(e.message), null } } return n } return this.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0) } return this.error(void 0 === e ? "'undefined' value invalid. Use null instead." : "object" == typeof e ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e} instead.`) } concat(e, t, r) { const n = "number" == typeof e ? this.path.concat(e) : this.path, i = r ? this.scope.concat(r) : this.scope; return new Tr(this.registry, n, t || null, i, this.errors) } error(e, ...t) { const r = `${this.key}${t.map((e => `[${e}]`)).join("")}`; this.errors.push(new nt(r, e)) } checkSubtype(e, t) { const r = vt(e, t); return r && this.error(r), r } } var kr = Tr; function Cr(e) { if (e instanceof wr) return Cr(e.boundExpression); if (e instanceof Kt && "error" === e.name) return !1; if (e instanceof Yt) return !1; if (e instanceof _r) return !1; const t = e instanceof Ht || e instanceof qt; let r = !0; return e.eachChild((e => { r = t ? r && Cr(e) : r && e instanceof Ut })), !!r && yr(e) && xr(e, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"]) } function Er(e, t) { const r = e.length - 1; let n, i, o = 0, s = r, a = 0; for (; o <= s;)if (a = Math.floor((o + s) / 2), n = e[a], i = e[a + 1], n <= t) { if (a === r || t < i) return a; o = a + 1 } else { if (!(n > t)) throw new Nt("Input is not a number."); s = a - 1 } return 0 } class Sr { constructor(e, t, r) { this.type = e, this.input = t, this.labels = [], this.outputs = []; for (const [n, i] of r) this.labels.push(n), this.outputs.push(i) } static parse(e, t) { if (e.length - 1 < 4) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`); if ((e.length - 1) % 2 != 0) return t.error("Expected an even number of arguments."); const r = t.parse(e[1], 1, at); if (!r) return null; const n = []; let i = null; t.expectedType && "value" !== t.expectedType.kind && (i = t.expectedType); for (let o = 1; o < e.length; o += 2) { const r = 1 === o ? -1 / 0 : e[o], s = e[o + 1], a = o, c = o + 1; if ("number" != typeof r) return t.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', a); if (n.length && n[n.length - 1][0] >= r) return t.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', a); const l = t.parse(s, c, i); if (!l) return null; i = i || l.type, n.push([r, l]) } return new Sr(i, r, n) } evaluate(e) { const t = this.labels, r = this.outputs; if (1 === t.length) return r[0].evaluate(e); const n = this.input.evaluate(e); if (n <= t[0]) return r[0].evaluate(e); const i = t.length; return n >= t[i - 1] ? r[i - 1].evaluate(e) : r[Er(t, n)].evaluate(e) } eachChild(e) { e(this.input); for (const t of this.outputs) e(t) } outputDefined() { return this.outputs.every((e => e.outputDefined())) } serialize() { const e = ["step", this.input.serialize()]; for (let t = 0; t < this.labels.length; t++)t > 0 && e.push(this.labels[t]), e.push(this.outputs[t].serialize()); return e } } var Pr = Sr; function Ir(e, t, r) { return e * (1 - r) + t * r } var Ar = Object.freeze({ __proto__: null, number: Ir, color: function (e, t, r) { return new It(Ir(e.r, t.r, r), Ir(e.g, t.g, r), Ir(e.b, t.b, r), Ir(e.a, t.a, r)) }, array: function (e, t, r) { return e.map(((e, n) => Ir(e, t[n], r))) } }); const Lr = .95047, Mr = 1, Br = 1.08883, Rr = 4 / 29, Dr = 6 / 29, Fr = 3 * Dr * Dr, Or = Dr * Dr * Dr, zr = Math.PI / 180, Ur = 180 / Math.PI; function Nr(e) { return e > Or ? Math.pow(e, 1 / 3) : e / Fr + Rr } function Gr(e) { return e > Dr ? e * e * e : Fr * (e - Rr) } function Vr(e) { return 255 * (e <= .0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - .055) } function qr(e) { return (e /= 255) <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4) } function jr(e) { const t = qr(e.r), r = qr(e.g), n = qr(e.b), i = Nr((.4124564 * t + .3575761 * r + .1804375 * n) / Lr), o = Nr((.2126729 * t + .7151522 * r + .072175 * n) / Mr); return { l: 116 * o - 16, a: 500 * (i - o), b: 200 * (o - Nr((.0193339 * t + .119192 * r + .9503041 * n) / Br)), alpha: e.a } } function Xr(e) { let t = (e.l + 16) / 116, r = isNaN(e.a) ? t : t + e.a / 500, n = isNaN(e.b) ? t : t - e.b / 200; return t = Mr * Gr(t), r = Lr * Gr(r), n = Br * Gr(n), new It(Vr(3.2404542 * r - 1.5371385 * t - .4985314 * n), Vr(-.969266 * r + 1.8760108 * t + .041556 * n), Vr(.0556434 * r - .2040259 * t + 1.0572252 * n), e.alpha) } function Wr(e, t, r) { const n = t - e; return e + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n) } const Zr = { forward: jr, reverse: Xr, interpolate: function (e, t, r) { return { l: Ir(e.l, t.l, r), a: Ir(e.a, t.a, r), b: Ir(e.b, t.b, r), alpha: Ir(e.alpha, t.alpha, r) } } }, Hr = { forward: function (e) { const { l: t, a: r, b: n } = jr(e), i = Math.atan2(n, r) * Ur; return { h: i < 0 ? i + 360 : i, c: Math.sqrt(r * r + n * n), l: t, alpha: e.a } }, reverse: function (e) { const t = e.h * zr, r = e.c; return Xr({ l: e.l, a: Math.cos(t) * r, b: Math.sin(t) * r, alpha: e.alpha }) }, interpolate: function (e, t, r) { return { h: Wr(e.h, t.h, r), c: Ir(e.c, t.c, r), l: Ir(e.l, t.l, r), alpha: Ir(e.alpha, t.alpha, r) } } }; var Qr = Object.freeze({ __proto__: null, lab: Zr, hcl: Hr }); class $r { constructor(e, t, r, n, i) { this.type = e, this.operator = t, this.interpolation = r, this.input = n, this.labels = [], this.outputs = []; for (const [o, s] of i) this.labels.push(o), this.outputs.push(s) } static interpolationFactor(e, t, r, n) { let i = 0; if ("exponential" === e.name) i = Jr(t, e.base, r, n); else if ("linear" === e.name) i = Jr(t, 1, r, n); else if ("cubic-bezier" === e.name) { const o = e.controlPoints; i = new d(o[0], o[1], o[2], o[3]).solve(Jr(t, 1, r, n)) } return i } static parse(e, t) { let [r, n, i, ...o] = e; if (!Array.isArray(n) || 0 === n.length) return t.error("Expected an interpolation type expression.", 1); if ("linear" === n[0]) n = { name: "linear" }; else if ("exponential" === n[0]) { const e = n[1]; if ("number" != typeof e) return t.error("Exponential interpolation requires a numeric base.", 1, 1); n = { name: "exponential", base: e } } else { if ("cubic-bezier" !== n[0]) return t.error(`Unknown interpolation type ${String(n[0])}`, 1, 0); { const e = n.slice(1); if (4 !== e.length || e.some((e => "number" != typeof e || e < 0 || e > 1))) return t.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1); n = { name: "cubic-bezier", controlPoints: e } } } if (e.length - 1 < 4) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`); if ((e.length - 1) % 2 != 0) return t.error("Expected an even number of arguments."); if (i = t.parse(i, 2, at), !i) return null; const s = []; let a = null; "interpolate-hcl" === r || "interpolate-lab" === r ? a = ut : t.expectedType && "value" !== t.expectedType.kind && (a = t.expectedType); for (let c = 0; c < o.length; c += 2) { const e = o[c], r = o[c + 1], n = c + 3, i = c + 4; if ("number" != typeof e) return t.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', n); if (s.length && s[s.length - 1][0] >= e) return t.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', n); const l = t.parse(r, i, a); if (!l) return null; a = a || l.type, s.push([e, l]) } return "number" === a.kind || "color" === a.kind || "array" === a.kind && "number" === a.itemType.kind && "number" == typeof a.N ? new $r(a, r, n, i, s) : t.error(`Type ${_t(a)} is not interpolatable.`) } evaluate(e) { const t = this.labels, r = this.outputs; if (1 === t.length) return r[0].evaluate(e); const n = this.input.evaluate(e); if (n <= t[0]) return r[0].evaluate(e); const i = t.length; if (n >= t[i - 1]) return r[i - 1].evaluate(e); const o = Er(t, n), s = $r.interpolationFactor(this.interpolation, n, t[o], t[o + 1]), a = r[o].evaluate(e), c = r[o + 1].evaluate(e); return "interpolate" === this.operator ? Ar[this.type.kind.toLowerCase()](a, c, s) : "interpolate-hcl" === this.operator ? Hr.reverse(Hr.interpolate(Hr.forward(a), Hr.forward(c), s)) : Zr.reverse(Zr.interpolate(Zr.forward(a), Zr.forward(c), s)) } eachChild(e) { e(this.input); for (const t of this.outputs) e(t) } outputDefined() { return this.outputs.every((e => e.outputDefined())) } serialize() { let e; e = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints); const t = [this.operator, e, this.input.serialize()]; for (let r = 0; r < this.labels.length; r++)t.push(this.labels[r], this.outputs[r].serialize()); return t } } function Jr(e, t, r, n) { const i = n - r, o = e - r; return 0 === i ? 0 : 1 === t ? o / i : (Math.pow(t, o) - 1) / (Math.pow(t, i) - 1) } var Kr = $r; class Yr { constructor(e, t) { this.type = e, this.args = t } static parse(e, t) { if (e.length < 2) return t.error("Expectected at least one argument."); let r = null; const n = t.expectedType; n && "value" !== n.kind && (r = n); const i = []; for (const s of e.slice(1)) { const e = t.parse(s, 1 + i.length, r, void 0, { typeAnnotation: "omit" }); if (!e) return null; r = r || e.type, i.push(e) } const o = n && i.some((e => vt(n, e.type))); return new Yr(o ? dt : r, i) } evaluate(e) { let t, r = null, n = 0; for (const i of this.args) { if (n++, r = i.evaluate(e), r && r instanceof Bt && !r.available && (t || (t = r), r = null, n === this.args.length)) return t; if (null !== r) break } return r } eachChild(e) { this.args.forEach(e) } outputDefined() { return this.args.every((e => e.outputDefined())) } serialize() { const e = ["coalesce"]; return this.eachChild((t => { e.push(t.serialize()) })), e } } var en = Yr; class tn { constructor(e, t) { this.type = t.type, this.bindings = [].concat(e), this.result = t } evaluate(e) { return this.result.evaluate(e) } eachChild(e) { for (const t of this.bindings) e(t[1]); e(this.result) } static parse(e, t) { if (e.length < 4) return t.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`); const r = []; for (let i = 1; i < e.length - 1; i += 2) { const n = e[i]; if ("string" != typeof n) return t.error(`Expected string, but found ${typeof n} instead.`, i); if (/[^a-zA-Z0-9_]/.test(n)) return t.error("Variable names must contain only alphanumeric characters or '_'.", i); const o = t.parse(e[i + 1], i + 1); if (!o) return null; r.push([n, o]) } const n = t.parse(e[e.length - 1], e.length - 1, t.expectedType, r); return n ? new tn(r, n) : null } outputDefined() { return this.result.outputDefined() } serialize() { const e = ["let"]; for (const [t, r] of this.bindings) e.push(t, r.serialize()); return e.push(this.result.serialize()), e } } var rn = tn; class nn { constructor(e, t, r) { this.type = e, this.index = t, this.input = r } static parse(e, t) { if (3 !== e.length) return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`); const r = t.parse(e[1], 1, at), n = t.parse(e[2], 2, gt(t.expectedType || dt)); return r && n ? new nn(n.type.itemType, r, n) : null } evaluate(e) { const t = this.index.evaluate(e), r = this.input.evaluate(e); if (t < 0) throw new Nt(`Array index out of bounds: ${t} < 0.`); if (t >= r.length) throw new Nt(`Array index out of bounds: ${t} > ${r.length - 1}.`); if (t !== Math.floor(t)) throw new Nt(`Array index must be an integer, but found ${t} instead.`); return r[t] } eachChild(e) { e(this.index), e(this.input) } outputDefined() { return !1 } serialize() { return ["at", this.index.serialize(), this.input.serialize()] } } var on = nn; class sn { constructor(e, t) { this.type = lt, this.needle = e, this.haystack = t } static parse(e, t) { if (3 !== e.length) return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`); const r = t.parse(e[1], 1, dt), n = t.parse(e[2], 2, dt); return r && n ? xt(r.type, [lt, ct, at, st, dt]) ? new sn(r, n) : t.error(`Expected first argument to be of type boolean, string, number or null, but found ${_t(r.type)} instead`) : null } evaluate(e) { const t = this.needle.evaluate(e), r = this.haystack.evaluate(e); if (null == r) return !1; if (!bt(t, ["boolean", "string", "number", "null"])) throw new Nt(`Expected first argument to be of type boolean, string, number or null, but found ${_t(Ft(t))} instead.`); if (!bt(r, ["string", "array"])) throw new Nt(`Expected second argument to be of type array or string, but found ${_t(Ft(r))} instead.`); return r.indexOf(t) >= 0 } eachChild(e) { e(this.needle), e(this.haystack) } outputDefined() { return !0 } serialize() { return ["in", this.needle.serialize(), this.haystack.serialize()] } } var an = sn; class cn { constructor(e, t, r) { this.type = at, this.needle = e, this.haystack = t, this.fromIndex = r } static parse(e, t) { if (e.length <= 2 || e.length >= 5) return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`); const r = t.parse(e[1], 1, dt), n = t.parse(e[2], 2, dt); if (!r || !n) return null; if (!xt(r.type, [lt, ct, at, st, dt])) return t.error(`Expected first argument to be of type boolean, string, number or null, but found ${_t(r.type)} instead`); if (4 === e.length) { const i = t.parse(e[3], 3, at); return i ? new cn(r, n, i) : null } return new cn(r, n) } evaluate(e) { const t = this.needle.evaluate(e), r = this.haystack.evaluate(e); if (!bt(t, ["boolean", "string", "number", "null"])) throw new Nt(`Expected first argument to be of type boolean, string, number or null, but found ${_t(Ft(t))} instead.`); if (!bt(r, ["string", "array"])) throw new Nt(`Expected second argument to be of type array or string, but found ${_t(Ft(r))} instead.`); if (this.fromIndex) { const n = this.fromIndex.evaluate(e); return r.indexOf(t, n) } return r.indexOf(t) } eachChild(e) { e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex) } outputDefined() { return !1 } serialize() { if (null != this.fromIndex && void 0 !== this.fromIndex) { const e = this.fromIndex.serialize(); return ["index-of", this.needle.serialize(), this.haystack.serialize(), e] } return ["index-of", this.needle.serialize(), this.haystack.serialize()] } } var ln = cn; class un { constructor(e, t, r, n, i, o) { this.inputType = e, this.type = t, this.input = r, this.cases = n, this.outputs = i, this.otherwise = o } static parse(e, t) { if (e.length < 5) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`); if (e.length % 2 != 1) return t.error("Expected an even number of arguments."); let r, n; t.expectedType && "value" !== t.expectedType.kind && (n = t.expectedType); const i = {}, o = []; for (let c = 2; c < e.length - 1; c += 2) { let s = e[c]; const a = e[c + 1]; Array.isArray(s) || (s = [s]); const l = t.concat(c); if (0 === s.length) return l.error("Expected at least one branch label."); for (const e of s) { if ("number" != typeof e && "string" != typeof e) return l.error("Branch labels must be numbers or strings."); if ("number" == typeof e && Math.abs(e) > Number.MAX_SAFE_INTEGER) return l.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`); if ("number" == typeof e && Math.floor(e) !== e) return l.error("Numeric branch labels must be integer values."); if (r) { if (l.checkSubtype(r, Ft(e))) return null } else r = Ft(e); if (void 0 !== i[String(e)]) return l.error("Branch labels must be unique."); i[String(e)] = o.length } const u = t.parse(a, c, n); if (!u) return null; n = n || u.type, o.push(u) } const s = t.parse(e[1], 1, dt); if (!s) return null; const a = t.parse(e[e.length - 1], e.length - 1, n); return a ? "value" !== s.type.kind && t.concat(1).checkSubtype(r, s.type) ? null : new un(r, n, s, i, o, a) : null } evaluate(e) { const t = this.input.evaluate(e); return (Ft(t) === this.inputType && this.outputs[this.cases[t]] || this.otherwise).evaluate(e) } eachChild(e) { e(this.input), this.outputs.forEach(e), e(this.otherwise) } outputDefined() { return this.outputs.every((e => e.outputDefined())) && this.otherwise.outputDefined() } serialize() { const e = ["match", this.input.serialize()], t = Object.keys(this.cases).sort(), r = [], n = {}; for (const o of t) { const e = n[this.cases[o]]; void 0 === e ? (n[this.cases[o]] = r.length, r.push([this.cases[o], [o]])) : r[e][1].push(o) } const i = e => "number" === this.inputType.kind ? Number(e) : e; for (const [o, s] of r) e.push(1 === s.length ? i(s[0]) : s.map(i)), e.push(this.outputs[o].serialize()); return e.push(this.otherwise.serialize()), e } } var hn = un; class dn { constructor(e, t, r) { this.type = e, this.branches = t, this.otherwise = r } static parse(e, t) { if (e.length < 4) return t.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`); if (e.length % 2 != 0) return t.error("Expected an odd number of arguments."); let r; t.expectedType && "value" !== t.expectedType.kind && (r = t.expectedType); const n = []; for (let o = 1; o < e.length - 1; o += 2) { const i = t.parse(e[o], o, lt); if (!i) return null; const s = t.parse(e[o + 1], o + 1, r); if (!s) return null; n.push([i, s]), r = r || s.type } const i = t.parse(e[e.length - 1], e.length - 1, r); return i ? new dn(r, n, i) : null } evaluate(e) { for (const [t, r] of this.branches) if (t.evaluate(e)) return r.evaluate(e); return this.otherwise.evaluate(e) } eachChild(e) { for (const [t, r] of this.branches) e(t), e(r); e(this.otherwise) } outputDefined() { return this.branches.every((([e, t]) => t.outputDefined())) && this.otherwise.outputDefined() } serialize() { const e = ["case"]; return this.eachChild((t => { e.push(t.serialize()) })), e } } var pn = dn; class fn { constructor(e, t, r, n) { this.type = e, this.input = t, this.beginIndex = r, this.endIndex = n } static parse(e, t) { if (e.length <= 2 || e.length >= 5) return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`); const r = t.parse(e[1], 1, dt), n = t.parse(e[2], 2, at); if (!r || !n) return null; if (!xt(r.type, [gt(dt), ct, dt])) return t.error(`Expected first argument to be of type array or string, but found ${_t(r.type)} instead`); if (4 === e.length) { const i = t.parse(e[3], 3, at); return i ? new fn(r.type, r, n, i) : null } return new fn(r.type, r, n) } evaluate(e) { const t = this.input.evaluate(e), r = this.beginIndex.evaluate(e); if (!bt(t, ["string", "array"])) throw new Nt(`Expected first argument to be of type array or string, but found ${_t(Ft(t))} instead.`); if (this.endIndex) { const n = this.endIndex.evaluate(e); return t.slice(r, n) } return t.slice(r) } eachChild(e) { e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex) } outputDefined() { return !1 } serialize() { if (null != this.endIndex && void 0 !== this.endIndex) { const e = this.endIndex.serialize(); return ["slice", this.input.serialize(), this.beginIndex.serialize(), e] } return ["slice", this.input.serialize(), this.beginIndex.serialize()] } } var mn = fn; function gn(e, t) { return "==" === e || "!=" === e ? "boolean" === t.kind || "string" === t.kind || "number" === t.kind || "null" === t.kind || "value" === t.kind : "string" === t.kind || "number" === t.kind || "value" === t.kind } function _n(e, t, r, n) { return 0 === n.compare(t, r) } function yn(e, t, r) { const n = "==" !== e && "!=" !== e; return class i { constructor(e, t, r) { this.type = lt, this.lhs = e, this.rhs = t, this.collator = r, this.hasUntypedArgument = "value" === e.type.kind || "value" === t.type.kind } static parse(e, t) { if (3 !== e.length && 4 !== e.length) return t.error("Expected two or three arguments."); const r = e[0]; let o = t.parse(e[1], 1, dt); if (!o) return null; if (!gn(r, o.type)) return t.concat(1).error(`"${r}" comparisons are not supported for type '${_t(o.type)}'.`); let s = t.parse(e[2], 2, dt); if (!s) return null; if (!gn(r, s.type)) return t.concat(2).error(`"${r}" comparisons are not supported for type '${_t(s.type)}'.`); if (o.type.kind !== s.type.kind && "value" !== o.type.kind && "value" !== s.type.kind) return t.error(`Cannot compare types '${_t(o.type)}' and '${_t(s.type)}'.`); n && ("value" === o.type.kind && "value" !== s.type.kind ? o = new qt(s.type, [o]) : "value" !== o.type.kind && "value" === s.type.kind && (s = new qt(o.type, [s]))); let a = null; if (4 === e.length) { if ("string" !== o.type.kind && "string" !== s.type.kind && "value" !== o.type.kind && "value" !== s.type.kind) return t.error("Cannot use collator to compare non-string types."); if (a = t.parse(e[3], 3, pt), !a) return null } return new i(o, s, a) } evaluate(i) { const o = this.lhs.evaluate(i), s = this.rhs.evaluate(i); if (n && this.hasUntypedArgument) { const t = Ft(o), r = Ft(s); if (t.kind !== r.kind || "string" !== t.kind && "number" !== t.kind) throw new Nt(`Expected arguments for "${e}" to be (string, string) or (number, number), but found (${t.kind}, ${r.kind}) instead.`) } if (this.collator && !n && this.hasUntypedArgument) { const e = Ft(o), r = Ft(s); if ("string" !== e.kind || "string" !== r.kind) return t(i, o, s) } return this.collator ? r(i, o, s, this.collator.evaluate(i)) : t(i, o, s) } eachChild(e) { e(this.lhs), e(this.rhs), this.collator && e(this.collator) } outputDefined() { return !0 } serialize() { const t = [e]; return this.eachChild((e => { t.push(e.serialize()) })), t } } } const vn = yn("==", (function (e, t, r) { return t === r }), _n), xn = yn("!=", (function (e, t, r) { return t !== r }), (function (e, t, r, n) { return !_n(0, t, r, n) })), bn = yn("<", (function (e, t, r) { return t < r }), (function (e, t, r, n) { return n.compare(t, r) < 0 })), wn = yn(">", (function (e, t, r) { return t > r }), (function (e, t, r, n) { return n.compare(t, r) > 0 })), Tn = yn("<=", (function (e, t, r) { return t <= r }), (function (e, t, r, n) { return n.compare(t, r) <= 0 })), kn = yn(">=", (function (e, t, r) { return t >= r }), (function (e, t, r, n) { return n.compare(t, r) >= 0 })); class Cn { constructor(e, t, r, n, i, o) { this.type = ct, this.number = e, this.locale = t, this.currency = r, this.unit = n, this.minFractionDigits = i, this.maxFractionDigits = o } static parse(e, t) { if (3 !== e.length) return t.error("Expected two arguments."); const r = t.parse(e[1], 1, at); if (!r) return null; const n = e[2]; if ("object" != typeof n || Array.isArray(n)) return t.error("NumberFormat options argument must be an object."); let i = null; if (n.locale && (i = t.parse(n.locale, 1, ct), !i)) return null; let o = null; if (n.currency && (o = t.parse(n.currency, 1, ct), !o)) return null; let s = null; if (n.unit && (s = t.parse(n.unit, 1, ct), !s)) return null; let a = null; if (n["min-fraction-digits"] && (a = t.parse(n["min-fraction-digits"], 1, at), !a)) return null; let c = null; return n["max-fraction-digits"] && (c = t.parse(n["max-fraction-digits"], 1, at), !c) ? null : new Cn(r, i, o, s, a, c) } evaluate(e) { return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, unit: this.unit ? this.unit.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e)) } eachChild(e) { e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.unit && e(this.unit), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits) } outputDefined() { return !1 } serialize() { const e = {}; return this.locale && (e.locale = this.locale.serialize()), this.currency && (e.currency = this.currency.serialize()), this.unit && (e.unit = this.unit.serialize()), this.minFractionDigits && (e["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (e["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), e] } } class En { constructor(e) { this.type = at, this.input = e } static parse(e, t) { if (2 !== e.length) return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`); const r = t.parse(e[1], 1); return r ? "array" !== r.type.kind && "string" !== r.type.kind && "value" !== r.type.kind ? t.error(`Expected argument of type string or array, but found ${_t(r.type)} instead.`) : new En(r) : null } evaluate(e) { const t = this.input.evaluate(e); if ("string" == typeof t) return t.length; if (Array.isArray(t)) return t.length; throw new Nt(`Expected value to be of type string or array, but found ${_t(Ft(t))} instead.`) } eachChild(e) { e(this.input) } outputDefined() { return !1 } serialize() { const e = ["length"]; return this.eachChild((t => { e.push(t.serialize()) })), e } } const Sn = { "==": vn, "!=": xn, ">": wn, "<": bn, ">=": kn, "<=": Tn, array: qt, at: on, boolean: qt, case: pn, coalesce: en, collator: Yt, format: jt, image: Xt, in: an, "index-of": ln, interpolate: Kr, "interpolate-hcl": Kr, "interpolate-lab": Kr, length: En, let: rn, literal: Ut, match: hn, number: qt, "number-format": Cn, object: qt, slice: mn, step: Pr, string: qt, "to-boolean": Ht, "to-color": Ht, "to-number": Ht, "to-string": Ht, var: wr, within: _r }; function Pn(e, [t, r, n, i]) { t = t.evaluate(e), r = r.evaluate(e), n = n.evaluate(e); const o = i ? i.evaluate(e) : 1, s = Rt(t, r, n, o); if (s) throw new Nt(s); return new It(t / 255 * o, r / 255 * o, n / 255 * o, o) } function In(e, t) { return e in t } function An(e, t) { const r = t[e]; return void 0 === r ? null : r } function Ln(e) { return { type: e } } Kt.register(Sn, { error: [{ kind: "error" }, [ct], (e, [t]) => { throw new Nt(t.evaluate(e)) }], typeof: [ct, [dt], (e, [t]) => _t(Ft(t.evaluate(e)))], "to-rgba": [gt(at, 4), [ut], (e, [t]) => t.evaluate(e).toArray()], rgb: [ut, [at, at, at], Pn], rgba: [ut, [at, at, at, at], Pn], has: { type: lt, overloads: [[[ct], (e, [t]) => In(t.evaluate(e), e.properties())], [[ct, ht], (e, [t, r]) => In(t.evaluate(e), r.evaluate(e))]] }, get: { type: dt, overloads: [[[ct], (e, [t]) => An(t.evaluate(e), e.properties())], [[ct, ht], (e, [t, r]) => An(t.evaluate(e), r.evaluate(e))]] }, "feature-state": [dt, [ct], (e, [t]) => An(t.evaluate(e), e.featureState || {})], properties: [ht, [], e => e.properties()], "geometry-type": [ct, [], e => e.geometryType()], id: [dt, [], e => e.id()], zoom: [at, [], e => e.globals.zoom], pitch: [at, [], e => e.globals.pitch || 0], "distance-from-center": [at, [], e => e.distanceFromCenter()], "heatmap-density": [at, [], e => e.globals.heatmapDensity || 0], "line-progress": [at, [], e => e.globals.lineProgress || 0], "sky-radial-progress": [at, [], e => e.globals.skyRadialProgress || 0], accumulated: [dt, [], e => void 0 === e.globals.accumulated ? null : e.globals.accumulated], "+": [at, Ln(at), (e, t) => { let r = 0; for (const n of t) r += n.evaluate(e); return r }], "*": [at, Ln(at), (e, t) => { let r = 1; for (const n of t) r *= n.evaluate(e); return r }], "-": { type: at, overloads: [[[at, at], (e, [t, r]) => t.evaluate(e) - r.evaluate(e)], [[at], (e, [t]) => -t.evaluate(e)]] }, "/": [at, [at, at], (e, [t, r]) => t.evaluate(e) / r.evaluate(e)], "%": [at, [at, at], (e, [t, r]) => t.evaluate(e) % r.evaluate(e)], ln2: [at, [], () => Math.LN2], pi: [at, [], () => Math.PI], e: [at, [], () => Math.E], "^": [at, [at, at], (e, [t, r]) => Math.pow(t.evaluate(e), r.evaluate(e))], sqrt: [at, [at], (e, [t]) => Math.sqrt(t.evaluate(e))], log10: [at, [at], (e, [t]) => Math.log(t.evaluate(e)) / Math.LN10], ln: [at, [at], (e, [t]) => Math.log(t.evaluate(e))], log2: [at, [at], (e, [t]) => Math.log(t.evaluate(e)) / Math.LN2], sin: [at, [at], (e, [t]) => Math.sin(t.evaluate(e))], cos: [at, [at], (e, [t]) => Math.cos(t.evaluate(e))], tan: [at, [at], (e, [t]) => Math.tan(t.evaluate(e))], asin: [at, [at], (e, [t]) => Math.asin(t.evaluate(e))], acos: [at, [at], (e, [t]) => Math.acos(t.evaluate(e))], atan: [at, [at], (e, [t]) => Math.atan(t.evaluate(e))], min: [at, Ln(at), (e, t) => Math.min(...t.map((t => t.evaluate(e))))], max: [at, Ln(at), (e, t) => Math.max(...t.map((t => t.evaluate(e))))], abs: [at, [at], (e, [t]) => Math.abs(t.evaluate(e))], round: [at, [at], (e, [t]) => { const r = t.evaluate(e); return r < 0 ? -Math.round(-r) : Math.round(r) }], floor: [at, [at], (e, [t]) => Math.floor(t.evaluate(e))], ceil: [at, [at], (e, [t]) => Math.ceil(t.evaluate(e))], "filter-==": [lt, [ct, dt], (e, [t, r]) => e.properties()[t.value] === r.value], "filter-id-==": [lt, [dt], (e, [t]) => e.id() === t.value], "filter-type-==": [lt, [ct], (e, [t]) => e.geometryType() === t.value], "filter-<": [lt, [ct, dt], (e, [t, r]) => { const n = e.properties()[t.value], i = r.value; return typeof n == typeof i && n < i }], "filter-id-<": [lt, [dt], (e, [t]) => { const r = e.id(), n = t.value; return typeof r == typeof n && r < n }], "filter->": [lt, [ct, dt], (e, [t, r]) => { const n = e.properties()[t.value], i = r.value; return typeof n == typeof i && n > i }], "filter-id->": [lt, [dt], (e, [t]) => { const r = e.id(), n = t.value; return typeof r == typeof n && r > n }], "filter-<=": [lt, [ct, dt], (e, [t, r]) => { const n = e.properties()[t.value], i = r.value; return typeof n == typeof i && n <= i }], "filter-id-<=": [lt, [dt], (e, [t]) => { const r = e.id(), n = t.value; return typeof r == typeof n && r <= n }], "filter->=": [lt, [ct, dt], (e, [t, r]) => { const n = e.properties()[t.value], i = r.value; return typeof n == typeof i && n >= i }], "filter-id->=": [lt, [dt], (e, [t]) => { const r = e.id(), n = t.value; return typeof r == typeof n && r >= n }], "filter-has": [lt, [dt], (e, [t]) => t.value in e.properties()], "filter-has-id": [lt, [], e => null !== e.id() && void 0 !== e.id()], "filter-type-in": [lt, [gt(ct)], (e, [t]) => t.value.indexOf(e.geometryType()) >= 0], "filter-id-in": [lt, [gt(dt)], (e, [t]) => t.value.indexOf(e.id()) >= 0], "filter-in-small": [lt, [ct, gt(dt)], (e, [t, r]) => r.value.indexOf(e.properties()[t.value]) >= 0], "filter-in-large": [lt, [ct, gt(dt)], (e, [t, r]) => function (e, t, r, n) { for (; r <= n;) { const i = r + n >> 1; if (t[i] === e) return !0; t[i] > e ? n = i - 1 : r = i + 1 } return !1 }(e.properties()[t.value], r.value, 0, r.value.length - 1)], all: { type: lt, overloads: [[[lt, lt], (e, [t, r]) => t.evaluate(e) && r.evaluate(e)], [Ln(lt), (e, t) => { for (const r of t) if (!r.evaluate(e)) return !1; return !0 }]] }, any: { type: lt, overloads: [[[lt, lt], (e, [t, r]) => t.evaluate(e) || r.evaluate(e)], [Ln(lt), (e, t) => { for (const r of t) if (r.evaluate(e)) return !0; return !1 }]] }, "!": [lt, [lt], (e, [t]) => !t.evaluate(e)], "is-supported-script": [lt, [ct], (e, [t]) => { const r = e.globals && e.globals.isSupportedScript; return !r || r(t.evaluate(e)) }], upcase: [ct, [ct], (e, [t]) => t.evaluate(e).toUpperCase()], downcase: [ct, [ct], (e, [t]) => t.evaluate(e).toLowerCase()], concat: [ct, Ln(dt), (e, t) => t.map((t => Ot(t.evaluate(e)))).join("")], "resolved-locale": [ct, [pt], (e, [t]) => t.evaluate(e).resolvedLocale()] }); var Mn = Sn; function Bn(e) { return { result: "success", value: e } } function Rn(e) { return { result: "error", value: e } } function Dn(e) { return "data-driven" === e["property-type"] } function Fn(e) { return !!e.expression && e.expression.parameters.indexOf("zoom") > -1 } function On(e) { return !!e.expression && e.expression.interpolated } function zn(e) { return e instanceof Number ? "number" : e instanceof String ? "string" : e instanceof Boolean ? "boolean" : Array.isArray(e) ? "array" : null === e ? "null" : typeof e } function Un(e) { return "object" == typeof e && null !== e && !Array.isArray(e) } function Nn(e) { return e } function Gn(e, t) { const r = "color" === t.type, n = e.stops && "object" == typeof e.stops[0][0], i = n || !(n || void 0 !== e.property), o = e.type || (On(t) ? "exponential" : "interval"); if (r && ((e = Ye({}, e)).stops && (e.stops = e.stops.map((e => [e[0], It.parse(e[1])]))), e.default = It.parse(e.default ? e.default : t.default)), e.colorSpace && "rgb" !== e.colorSpace && !Qr[e.colorSpace]) throw new Error(`Unknown color space: ${e.colorSpace}`); let s, a, c; if ("exponential" === o) s = Xn; else if ("interval" === o) s = jn; else if ("categorical" === o) { s = qn, a = Object.create(null); for (const t of e.stops) a[t[0]] = t[1]; c = typeof e.stops[0][0] } else { if ("identity" !== o) throw new Error(`Unknown function type "${o}"`); s = Wn } if (n) { const r = {}, n = []; for (let t = 0; t < e.stops.length; t++) { const i = e.stops[t], o = i[0].zoom; void 0 === r[o] && (r[o] = { zoom: o, type: e.type, property: e.property, default: e.default, stops: [] }, n.push(o)), r[o].stops.push([i[0].value, i[1]]) } const i = []; for (const e of n) i.push([r[e].zoom, Gn(r[e], t)]); const o = { name: "linear" }; return { kind: "composite", interpolationType: o, interpolationFactor: Kr.interpolationFactor.bind(void 0, o), zoomStops: i.map((e => e[0])), evaluate: ({ zoom: r }, n) => Xn({ stops: i, base: e.base }, t, r).evaluate(r, n) } } if (i) { const r = "exponential" === o ? { name: "exponential", base: void 0 !== e.base ? e.base : 1 } : null; return { kind: "camera", interpolationType: r, interpolationFactor: Kr.interpolationFactor.bind(void 0, r), zoomStops: e.stops.map((e => e[0])), evaluate: ({ zoom: r }) => s(e, t, r, a, c) } } return { kind: "source", evaluate(r, n) { const i = n && n.properties ? n.properties[e.property] : void 0; return void 0 === i ? Vn(e.default, t.default) : s(e, t, i, a, c) } } } function Vn(e, t, r) { return void 0 !== e ? e : void 0 !== t ? t : void 0 !== r ? r : void 0 } function qn(e, t, r, n, i) { return Vn(typeof r === i ? n[r] : void 0, e.default, t.default) } function jn(e, t, r) { if ("number" !== zn(r)) return Vn(e.default, t.default); const n = e.stops.length; if (1 === n) return e.stops[0][1]; if (r <= e.stops[0][0]) return e.stops[0][1]; if (r >= e.stops[n - 1][0]) return e.stops[n - 1][1]; const i = Er(e.stops.map((e => e[0])), r); return e.stops[i][1] } function Xn(e, t, r) { const n = void 0 !== e.base ? e.base : 1; if ("number" !== zn(r)) return Vn(e.default, t.default); const i = e.stops.length; if (1 === i) return e.stops[0][1]; if (r <= e.stops[0][0]) return e.stops[0][1]; if (r >= e.stops[i - 1][0]) return e.stops[i - 1][1]; const o = Er(e.stops.map((e => e[0])), r), s = function (e, t, r, n) { const i = n - r, o = e - r; return 0 === i ? 0 : 1 === t ? o / i : (Math.pow(t, o) - 1) / (Math.pow(t, i) - 1) }(r, n, e.stops[o][0], e.stops[o + 1][0]), a = e.stops[o][1], c = e.stops[o + 1][1]; let l = Ar[t.type] || Nn; if (e.colorSpace && "rgb" !== e.colorSpace) { const t = Qr[e.colorSpace]; l = (e, r) => t.reverse(t.interpolate(t.forward(e), t.forward(r), s)) } return "function" == typeof a.evaluate ? { evaluate(...e) { const t = a.evaluate.apply(void 0, e), r = c.evaluate.apply(void 0, e); if (void 0 !== t && void 0 !== r) return l(t, r, s) } } : l(a, c, s) } function Wn(e, t, r) { return "color" === t.type ? r = It.parse(r) : "formatted" === t.type ? r = Mt.fromString(r.toString()) : "resolvedImage" === t.type ? r = Bt.fromString(r.toString()) : zn(r) === t.type || "enum" === t.type && t.values[r] || (r = void 0), Vn(r, e.default, t.default) } class Zn { constructor(e, t) { this.expression = e, this._warningHistory = {}, this._evaluator = new $t, this._defaultValue = t ? function (e) { return "color" === e.type && (Un(e.default) || Array.isArray(e.default)) ? new It(0, 0, 0, 0) : "color" === e.type ? It.parse(e.default) || null : void 0 === e.default ? null : e.default }(t) : null, this._enumValues = t && "enum" === t.type ? t.values : null } evaluateWithoutErrorHandling(e, t, r, n, i, o, s, a) { return this._evaluator.globals = e, this._evaluator.feature = t, this._evaluator.featureState = r, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = o, this._evaluator.featureTileCoord = s || null, this._evaluator.featureDistanceData = a || null, this.expression.evaluate(this._evaluator) } evaluate(e, t, r, n, i, o, s, a) { this._evaluator.globals = e, this._evaluator.feature = t || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = o || null, this._evaluator.featureTileCoord = s || null, this._evaluator.featureDistanceData = a || null; try { const e = this.expression.evaluate(this._evaluator); if (null == e || "number" == typeof e && e != e) return this._defaultValue; if (this._enumValues && !(e in this._enumValues)) throw new Nt(`Expected value to be one of ${Object.keys(this._enumValues).map((e => JSON.stringify(e))).join(", ")}, but found ${JSON.stringify(e)} instead.`); return e } catch (e) { return this._warningHistory[e.message] || (this._warningHistory[e.message] = !0, "undefined" != typeof console && console.warn(e.message)), this._defaultValue } } } function Hn(e) { return Array.isArray(e) && e.length > 0 && "string" == typeof e[0] && e[0] in Mn } function Qn(e, t) { const r = new kr(Mn, [], t ? function (e) { const t = { color: ut, string: ct, number: at, enum: ct, boolean: lt, formatted: ft, resolvedImage: mt }; return "array" === e.type ? gt(t[e.value] || dt, e.length) : t[e.type] }(t) : void 0), n = r.parse(e, void 0, void 0, void 0, t && "string" === t.type ? { typeAnnotation: "coerce" } : void 0); return n ? Bn(new Zn(n, t)) : Rn(r.errors) } class $n { constructor(e, t) { this.kind = e, this._styleExpression = t, this.isStateDependent = "constant" !== e && !vr(t.expression) } evaluateWithoutErrorHandling(e, t, r, n, i, o) { return this._styleExpression.evaluateWithoutErrorHandling(e, t, r, n, i, o) } evaluate(e, t, r, n, i, o) { return this._styleExpression.evaluate(e, t, r, n, i, o) } } class Jn { constructor(e, t, r, n) { this.kind = e, this.zoomStops = r, this._styleExpression = t, this.isStateDependent = "camera" !== e && !vr(t.expression), this.interpolationType = n } evaluateWithoutErrorHandling(e, t, r, n, i, o) { return this._styleExpression.evaluateWithoutErrorHandling(e, t, r, n, i, o) } evaluate(e, t, r, n, i, o) { return this._styleExpression.evaluate(e, t, r, n, i, o) } interpolationFactor(e, t, r) { return this.interpolationType ? Kr.interpolationFactor(this.interpolationType, e, t, r) : 0 } } function Kn(e, t) { if ("error" === (e = Qn(e, t)).result) return e; const r = e.value.expression, n = yr(r); if (!n && !Dn(t)) return Rn([new nt("", "data expressions not supported")]); const i = xr(r, ["zoom", "pitch", "distance-from-center"]); if (!i && !Fn(t)) return Rn([new nt("", "zoom expressions not supported")]); const o = ei(r); return o || i ? o instanceof nt ? Rn([o]) : o instanceof Kr && !On(t) ? Rn([new nt("", '"interpolate" expressions cannot be used with this property')]) : Bn(o ? new Jn(n ? "camera" : "composite", e.value, o.labels, o instanceof Kr ? o.interpolation : void 0) : new $n(n ? "constant" : "source", e.value)) : Rn([new nt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]) } class Yn { constructor(e, t) { this._parameters = e, this._specification = t, Ye(this, Gn(this._parameters, this._specification)) } static deserialize(e) { return new Yn(e._parameters, e._specification) } static serialize(e) { return { _parameters: e._parameters, _specification: e._specification } } } function ei(e) { let t = null; if (e instanceof rn) t = ei(e.result); else if (e instanceof en) { for (const r of e.args) if (t = ei(r), t) break } else (e instanceof Pr || e instanceof Kr) && e.input instanceof Kt && "zoom" === e.input.name && (t = e); return t instanceof nt || e.eachChild((e => { const r = ei(e); r instanceof nt ? t = r : !t && r ? t = new nt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && r && t !== r && (t = new nt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.')) })), t } class ti { constructor(e, t, r, n) { this.message = (e ? `${e}: ` : "") + r, n && (this.identifier = n), null != t && t.__line__ && (this.line = t.__line__) } } function ri(e) { const t = e.key, r = e.value, n = e.valueSpec || {}, i = e.objectElementValidators || {}, o = e.style, s = e.styleSpec; let a = []; const c = zn(r); if ("object" !== c) return [new ti(t, r, `object expected, ${c} found`)]; for (const l in r) { const e = l.split(".")[0]; let c; i[e] ? c = i[e] : n[e] ? c = Fi : i["*"] ? c = i["*"] : n["*"] && (c = Fi), c ? a = a.concat(c({ key: (t ? `${t}.` : t) + l, value: r[l], valueSpec: n[e] || n["*"], style: o, styleSpec: s, object: r, objectKey: l }, r)) : a.push(new ti(t, r[l], `unknown property "${l}"`)) } for (const l in n) i[l] || n[l].required && void 0 === n[l].default && void 0 === r[l] && a.push(new ti(t, r, `missing required property "${l}"`)); return a } function ni(e) { const t = e.value, r = e.valueSpec, n = e.style, i = e.styleSpec, o = e.key, s = e.arrayElementValidator || Fi; if ("array" !== zn(t)) return [new ti(o, t, `array expected, ${zn(t)} found`)]; if (r.length && t.length !== r.length) return [new ti(o, t, `array length ${r.length} expected, length ${t.length} found`)]; if (r["min-length"] && t.length < r["min-length"]) return [new ti(o, t, `array length at least ${r["min-length"]} expected, length ${t.length} found`)]; let a = { type: r.value, values: r.values, minimum: r.minimum, maximum: r.maximum, function: void 0 }; i.$version < 7 && (a.function = r.function), "object" === zn(r.value) && (a = r.value); let c = []; for (let l = 0; l < t.length; l++)c = c.concat(s({ array: t, arrayIndex: l, value: t[l], valueSpec: a, style: n, styleSpec: i, key: `${o}[${l}]` })); return c } function ii(e) { const t = e.key, r = e.value, n = e.valueSpec; let i = zn(r); if ("number" === i && r != r && (i = "NaN"), "number" !== i) return [new ti(t, r, `number expected, ${i} found`)]; if ("minimum" in n) { let i = n.minimum; if ("array" === zn(n.minimum) && (i = n.minimum[e.arrayIndex]), r < i) return [new ti(t, r, `${r} is less than the minimum value ${i}`)] } if ("maximum" in n) { let i = n.maximum; if ("array" === zn(n.maximum) && (i = n.maximum[e.arrayIndex]), r > i) return [new ti(t, r, `${r} is greater than the maximum value ${i}`)] } return [] } function oi(e) { const t = e.valueSpec, r = et(e.value.type); let n, i, o, s = {}; const a = "categorical" !== r && void 0 === e.value.property, c = !a, l = "array" === zn(e.value.stops) && "array" === zn(e.value.stops[0]) && "object" === zn(e.value.stops[0][0]), u = ri({ key: e.key, value: e.value, valueSpec: e.styleSpec.function, style: e.style, styleSpec: e.styleSpec, objectElementValidators: { stops: function (e) { if ("identity" === r) return [new ti(e.key, e.value, 'identity function may not have a "stops" property')]; let t = []; const n = e.value; return t = t.concat(ni({ key: e.key, value: n, valueSpec: e.valueSpec, style: e.style, styleSpec: e.styleSpec, arrayElementValidator: h })), "array" === zn(n) && 0 === n.length && t.push(new ti(e.key, n, "array must have at least one stop")), t }, default: function (e) { return Fi({ key: e.key, value: e.value, valueSpec: t, style: e.style, styleSpec: e.styleSpec }) } } }); return "identity" === r && a && u.push(new ti(e.key, e.value, 'missing required property "property"')), "identity" === r || e.value.stops || u.push(new ti(e.key, e.value, 'missing required property "stops"')), "exponential" === r && e.valueSpec.expression && !On(e.valueSpec) && u.push(new ti(e.key, e.value, "exponential functions not supported")), e.styleSpec.$version >= 8 && (c && !Dn(e.valueSpec) ? u.push(new ti(e.key, e.value, "property functions not supported")) : a && !Fn(e.valueSpec) && u.push(new ti(e.key, e.value, "zoom functions not supported"))), "categorical" !== r && !l || void 0 !== e.value.property || u.push(new ti(e.key, e.value, '"property" property is required')), u; function h(e) { let r = []; const n = e.value, a = e.key; if ("array" !== zn(n)) return [new ti(a, n, `array expected, ${zn(n)} found`)]; if (2 !== n.length) return [new ti(a, n, `array length 2 expected, length ${n.length} found`)]; if (l) { if ("object" !== zn(n[0])) return [new ti(a, n, `object expected, ${zn(n[0])} found`)]; if (void 0 === n[0].zoom) return [new ti(a, n, "object stop key must have zoom")]; if (void 0 === n[0].value) return [new ti(a, n, "object stop key must have value")]; const t = et(n[0].zoom); if ("number" != typeof t) return [new ti(a, n[0].zoom, "stop zoom values must be numbers")]; if (o && o > t) return [new ti(a, n[0].zoom, "stop zoom values must appear in ascending order")]; t !== o && (o = t, i = void 0, s = {}), r = r.concat(ri({ key: `${a}[0]`, value: n[0], valueSpec: { zoom: {} }, style: e.style, styleSpec: e.styleSpec, objectElementValidators: { zoom: ii, value: d } })) } else r = r.concat(d({ key: `${a}[0]`, value: n[0], valueSpec: {}, style: e.style, styleSpec: e.styleSpec }, n)); return Hn(tt(n[1])) ? r.concat([new ti(`${a}[1]`, n[1], "expressions are not allowed in function stops.")]) : r.concat(Fi({ key: `${a}[1]`, value: n[1], valueSpec: t, style: e.style, styleSpec: e.styleSpec })) } function d(e, o) { const a = zn(e.value), c = et(e.value), l = null !== e.value ? e.value : o; if (n) { if (a !== n) return [new ti(e.key, l, `${a} stop domain type must match previous stop domain type ${n}`)] } else n = a; if ("number" !== a && "string" !== a && "boolean" !== a && "number" != typeof c && "string" != typeof c && "boolean" != typeof c) return [new ti(e.key, l, "stop domain value must be a number, string, or boolean")]; if ("number" !== a && "categorical" !== r) { let n = `number expected, ${a} found`; return Dn(t) && void 0 === r && (n += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ti(e.key, l, n)] } return "categorical" !== r || "number" !== a || "number" == typeof c && isFinite(c) && Math.floor(c) === c ? "categorical" !== r && "number" === a && "number" == typeof c && "number" == typeof i && void 0 !== i && c < i ? [new ti(e.key, l, "stop domain values must appear in ascending order")] : (i = c, "categorical" === r && c in s ? [new ti(e.key, l, "stop domain values must be unique")] : (s[c] = !0, [])) : [new ti(e.key, l, `integer expected, found ${String(c)}`)] } } function si(e) { const t = ("property" === e.expressionContext ? Kn : Qn)(tt(e.value), e.valueSpec); if ("error" === t.result) return t.value.map((t => new ti(`${e.key}${t.key}`, e.value, t.message))); const r = t.value.expression || t.value._styleExpression.expression; if ("property" === e.expressionContext && "text-font" === e.propertyKey && !r.outputDefined()) return [new ti(e.key, e.value, `Invalid data expression for "${e.propertyKey}". Output values must be contained as literals within the expression.`)]; if ("property" === e.expressionContext && "layout" === e.propertyType && !vr(r)) return [new ti(e.key, e.value, '"feature-state" data expressions are not supported with layout properties.')]; if ("filter" === e.expressionContext) return ai(r, e); if (e.expressionContext && 0 === e.expressionContext.indexOf("cluster")) { if (!xr(r, ["zoom", "feature-state"])) return [new ti(e.key, e.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')]; if ("cluster-initial" === e.expressionContext && !yr(r)) return [new ti(e.key, e.value, "Feature data expressions are not supported with initial expression part of cluster properties.")] } return [] } function ai(e, t) { const r = new Set(["zoom", "feature-state", "pitch", "distance-from-center"]); if (t.valueSpec && t.valueSpec.expression) for (const i of t.valueSpec.expression.parameters) r.delete(i); if (0 === r.size) return []; const n = []; return e instanceof Kt && r.has(e.name) ? [new ti(t.key, t.value, `["${e.name}"] expression is not supported in a filter for a ${t.object.type} layer with id: ${t.object.id}`)] : (e.eachChild((e => { n.push(...ai(e, t)) })), n) } function ci(e) { const t = e.key, r = e.value, n = e.valueSpec, i = []; return Array.isArray(n.values) ? -1 === n.values.indexOf(et(r)) && i.push(new ti(t, r, `expected one of [${n.values.join(", ")}], ${JSON.stringify(r)} found`)) : -1 === Object.keys(n.values).indexOf(et(r)) && i.push(new ti(t, r, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(r)} found`)), i } function li(e) { if (!0 === e || !1 === e) return !0; if (!Array.isArray(e) || 0 === e.length) return !1; switch (e[0]) { case "has": return e.length >= 2 && "$id" !== e[1] && "$type" !== e[1]; case "in": return e.length >= 3 && ("string" != typeof e[1] || Array.isArray(e[2])); case "!in": case "!has": case "none": return !1; case "==": case "!=": case ">": case ">=": case "<": case "<=": return 3 !== e.length || Array.isArray(e[1]) || Array.isArray(e[2]); case "any": case "all": for (const t of e.slice(1)) if (!li(t) && "boolean" != typeof t) return !1; return !0; default: return !0 } } function ui(e, t = "fill") { if (null == e) return { filter: () => !0, needGeometry: !1, needFeature: !1 }; li(e) || (e = _i(e)); const r = e; let n = !0; try { n = function (e) { if (!pi(e)) return e; let t = tt(e); return di(t), t = hi(t), t }(r) } catch (e) { console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(r, null, 2)}\n        `) } const i = Ke[`filter_${t}`], o = Qn(n, i); let s = null; if ("error" === o.result) throw new Error(o.value.map((e => `${e.key}: ${e.message}`)).join(", ")); s = (e, t, r) => o.value.evaluate(e, t, {}, r); let a = null, c = null; if (n !== r) { const e = Qn(r, i); if ("error" === e.result) throw new Error(e.value.map((e => `${e.key}: ${e.message}`)).join(", ")); a = (t, r, n, i, o) => e.value.evaluate(t, r, {}, n, void 0, void 0, i, o), c = !yr(e.value.expression) } return { filter: s, dynamicFilter: a || void 0, needGeometry: gi(n), needFeature: !!c } } function hi(e) { if (!Array.isArray(e)) return e; const t = function (e) { if (fi.has(e[0])) for (let t = 1; t < e.length; t++)if (pi(e[t])) return !0; return e }(e); return !0 === t ? t : t.map((e => hi(e))) } function di(e) { let t = !1; const r = []; if ("case" === e[0]) { for (let n = 1; n < e.length - 1; n += 2)t = t || pi(e[n]), r.push(e[n + 1]); r.push(e[e.length - 1]) } else if ("match" === e[0]) { t = t || pi(e[1]); for (let t = 2; t < e.length - 1; t += 2)r.push(e[t + 1]); r.push(e[e.length - 1]) } else if ("step" === e[0]) { t = t || pi(e[1]); for (let t = 1; t < e.length - 1; t += 2)r.push(e[t + 1]) } t && (e.length = 0, e.push("any", ...r)); for (let n = 1; n < e.length; n++)di(e[n]) } function pi(e) { if (!Array.isArray(e)) return !1; if ("pitch" === (t = e[0]) || "distance-from-center" === t) return !0; var t; for (let r = 1; r < e.length; r++)if (pi(e[r])) return !0; return !1 } const fi = new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]); function mi(e, t) { return e < t ? -1 : e > t ? 1 : 0 } function gi(e) { if (!Array.isArray(e)) return !1; if ("within" === e[0]) return !0; for (let t = 1; t < e.length; t++)if (gi(e[t])) return !0; return !1 } function _i(e) { if (!e) return !0; const t = e[0]; return e.length <= 1 ? "any" !== t : "==" === t ? yi(e[1], e[2], "==") : "!=" === t ? bi(yi(e[1], e[2], "==")) : "<" === t || ">" === t || "<=" === t || ">=" === t ? yi(e[1], e[2], t) : "any" === t ? (r = e.slice(1), ["any"].concat(r.map(_i))) : "all" === t ? ["all"].concat(e.slice(1).map(_i)) : "none" === t ? ["all"].concat(e.slice(1).map(_i).map(bi)) : "in" === t ? vi(e[1], e.slice(2)) : "!in" === t ? bi(vi(e[1], e.slice(2))) : "has" === t ? xi(e[1]) : "!has" === t ? bi(xi(e[1])) : "within" !== t || e; var r } function yi(e, t, r) { switch (e) { case "$type": return [`filter-type-${r}`, t]; case "$id": return [`filter-id-${r}`, t]; default: return [`filter-${r}`, e, t] } } function vi(e, t) { if (0 === t.length) return !1; switch (e) { case "$type": return ["filter-type-in", ["literal", t]]; case "$id": return ["filter-id-in", ["literal", t]]; default: return t.length > 200 && !t.some((e => typeof e != typeof t[0])) ? ["filter-in-large", e, ["literal", t.sort(mi)]] : ["filter-in-small", e, ["literal", t]] } } function xi(e) { switch (e) { case "$type": return !0; case "$id": return ["filter-has-id"]; default: return ["filter-has", e] } } function bi(e) { return ["!", e] } function wi(e) { return li(tt(e.value)) ? si(Ye({}, e, { expressionContext: "filter", valueSpec: e.styleSpec[`filter_${e.layerType || "fill"}`] })) : Ti(e) } function Ti(e) { const t = e.value, r = e.key; if ("array" !== zn(t)) return [new ti(r, t, `array expected, ${zn(t)} found`)]; const n = e.styleSpec; let i, o = []; if (t.length < 1) return [new ti(r, t, "filter array must have at least 1 element")]; switch (o = o.concat(ci({ key: `${r}[0]`, value: t[0], valueSpec: n.filter_operator, style: e.style, styleSpec: e.styleSpec })), et(t[0])) { case "<": case "<=": case ">": case ">=": t.length >= 2 && "$type" === et(t[1]) && o.push(new ti(r, t, `"$type" cannot be use with operator "${t[0]}"`)); case "==": case "!=": 3 !== t.length && o.push(new ti(r, t, `filter array for operator "${t[0]}" must have 3 elements`)); case "in": case "!in": t.length >= 2 && (i = zn(t[1]), "string" !== i && o.push(new ti(`${r}[1]`, t[1], `string expected, ${i} found`))); for (let s = 2; s < t.length; s++)i = zn(t[s]), "$type" === et(t[1]) ? o = o.concat(ci({ key: `${r}[${s}]`, value: t[s], valueSpec: n.geometry_type, style: e.style, styleSpec: e.styleSpec })) : "string" !== i && "number" !== i && "boolean" !== i && o.push(new ti(`${r}[${s}]`, t[s], `string, number, or boolean expected, ${i} found`)); break; case "any": case "all": case "none": for (let n = 1; n < t.length; n++)o = o.concat(Ti({ key: `${r}[${n}]`, value: t[n], style: e.style, styleSpec: e.styleSpec })); break; case "has": case "!has": i = zn(t[1]), 2 !== t.length ? o.push(new ti(r, t, `filter array for "${t[0]}" operator must have 2 elements`)) : "string" !== i && o.push(new ti(`${r}[1]`, t[1], `string expected, ${i} found`)); break; case "within": i = zn(t[1]), 2 !== t.length ? o.push(new ti(r, t, `filter array for "${t[0]}" operator must have 2 elements`)) : "object" !== i && o.push(new ti(`${r}[1]`, t[1], `object expected, ${i} found`)) }return o } function ki(e, t) { const r = e.key, n = e.style, i = e.styleSpec, o = e.value, s = e.objectKey, a = i[`${t}_${e.layerType}`]; if (!a) return []; const c = s.match(/^(.*)-transition$/); if ("paint" === t && c && a[c[1]] && a[c[1]].transition) return Fi({ key: r, value: o, valueSpec: i.transition, style: n, styleSpec: i }); const l = e.valueSpec || a[s]; if (!l) return [new ti(r, o, `unknown property "${s}"`)]; let u; if ("string" === zn(o) && Dn(l) && !l.tokens && (u = /^{([^}]+)}$/.exec(o))) return [new ti(r, o, `"${s}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(u[1])} }\`.`)]; const h = []; return "symbol" === e.layerType && ("text-field" === s && n && !n.glyphs && h.push(new ti(r, o, 'use of "text-field" requires a style "glyphs" property')), "text-font" === s && Un(tt(o)) && "identity" === et(o.type) && h.push(new ti(r, o, '"text-font" does not support identity functions'))), h.concat(Fi({ key: e.key, value: o, valueSpec: l, style: n, styleSpec: i, expressionContext: "property", propertyType: t, propertyKey: s })) } function Ci(e) { return ki(e, "paint") } function Ei(e) { return ki(e, "layout") } function Si(e) { let t = []; const r = e.value, n = e.key, i = e.style, o = e.styleSpec; r.type || r.ref || t.push(new ti(n, r, 'either "type" or "ref" is required')); let s = et(r.type); const a = et(r.ref); if (r.id) { const o = et(r.id); for (let s = 0; s < e.arrayIndex; s++) { const e = i.layers[s]; et(e.id) === o && t.push(new ti(n, r.id, `duplicate layer id "${r.id}", previously used at line ${e.id.__line__}`)) } } if ("ref" in r) { let e;["type", "source", "source-layer", "filter", "layout"].forEach((e => { e in r && t.push(new ti(n, r[e], `"${e}" is prohibited for ref layers`)) })), i.layers.forEach((t => { et(t.id) === a && (e = t) })), e ? e.ref ? t.push(new ti(n, r.ref, "ref cannot reference another ref layer")) : s = et(e.type) : "string" == typeof a && t.push(new ti(n, r.ref, `ref layer "${a}" not found`)) } else if ("background" !== s && "sky" !== s) if (r.source) { const e = i.sources && i.sources[r.source], o = e && et(e.type); e ? "vector" === o && "raster" === s ? t.push(new ti(n, r.source, `layer "${r.id}" requires a raster source`)) : "raster" === o && "raster" !== s ? t.push(new ti(n, r.source, `layer "${r.id}" requires a vector source`)) : "vector" !== o || r["source-layer"] ? "raster-dem" === o && "hillshade" !== s ? t.push(new ti(n, r.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s || !r.paint || !r.paint["line-gradient"] && !r.paint["line-trim-offset"] || "geojson" === o && e.lineMetrics || t.push(new ti(n, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new ti(n, r, `layer "${r.id}" must specify a "source-layer"`)) : t.push(new ti(n, r.source, `source "${r.source}" not found`)) } else t.push(new ti(n, r, 'missing required property "source"')); return t = t.concat(ri({ key: n, value: r, valueSpec: o.layer, style: e.style, styleSpec: e.styleSpec, objectElementValidators: { "*": () => [], type: () => Fi({ key: `${n}.type`, value: r.type, valueSpec: o.layer.type, style: e.style, styleSpec: e.styleSpec, object: r, objectKey: "type" }), filter: e => wi(Ye({ layerType: s }, e)), layout: e => ri({ layer: r, key: e.key, value: e.value, valueSpec: {}, style: e.style, styleSpec: e.styleSpec, objectElementValidators: { "*": e => Ei(Ye({ layerType: s }, e)) } }), paint: e => ri({ layer: r, key: e.key, value: e.value, valueSpec: {}, style: e.style, styleSpec: e.styleSpec, objectElementValidators: { "*": e => Ci(Ye({ layerType: s }, e)) } }) } })), t } function Pi(e) { const t = e.value, r = e.key, n = zn(t); return "string" !== n ? [new ti(r, t, `string expected, ${n} found`)] : [] } const Ii = { promoteId: function ({ key: e, value: t }) { if ("string" === zn(t)) return Pi({ key: e, value: t }); { const r = []; for (const n in t) r.push(...Pi({ key: `${e}.${n}`, value: t[n] })); return r } } }; function Ai(e) { const t = e.value, r = e.key, n = e.styleSpec, i = e.style; if (!t.type) return [new ti(r, t, '"type" is required')]; const o = et(t.type); let s; switch (o) { case "vector": case "raster": case "raster-dem": return s = ri({ key: r, value: t, valueSpec: n[`source_${o.replace("-", "_")}`], style: e.style, styleSpec: n, objectElementValidators: Ii }), s; case "geojson": if (s = ri({ key: r, value: t, valueSpec: n.source_geojson, style: i, styleSpec: n, objectElementValidators: Ii }), t.cluster) for (const e in t.clusterProperties) { const [n, i] = t.clusterProperties[e], o = "string" == typeof n ? [n, ["accumulated"], ["get", e]] : n; s.push(...si({ key: `${r}.${e}.map`, value: i, expressionContext: "cluster-map" })), s.push(...si({ key: `${r}.${e}.reduce`, value: o, expressionContext: "cluster-reduce" })) } return s; case "video": return ri({ key: r, value: t, valueSpec: n.source_video, style: i, styleSpec: n }); case "image": return ri({ key: r, value: t, valueSpec: n.source_image, style: i, styleSpec: n }); case "canvas": return [new ti(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")]; default: return ci({ key: `${r}.type`, value: t.type, valueSpec: { values: Li(n) }, style: i, styleSpec: n }) } } function Li(e) { return e.source.reduce(((t, r) => { const n = e[r]; return "enum" === n.type.type && (t = t.concat(Object.keys(n.type.values))), t }), []) } function Mi(e) { const t = e.value, r = e.styleSpec, n = r.light, i = e.style; let o = []; const s = zn(t); if (void 0 === t) return o; if ("object" !== s) return o = o.concat([new ti("light", t, `object expected, ${s} found`)]), o; for (const a in t) { const e = a.match(/^(.*)-transition$/); o = o.concat(e && n[e[1]] && n[e[1]].transition ? Fi({ key: a, value: t[a], valueSpec: r.transition, style: i, styleSpec: r }) : n[a] ? Fi({ key: a, value: t[a], valueSpec: n[a], style: i, styleSpec: r }) : [new ti(a, t[a], `unknown property "${a}"`)]) } return o } function Bi(e) { const t = e.value, r = e.key, n = e.style, i = e.styleSpec, o = i.terrain; let s = []; const a = zn(t); if (void 0 === t) return s; if ("object" !== a) return s = s.concat([new ti("terrain", t, `object expected, ${a} found`)]), s; for (const c in t) { const e = c.match(/^(.*)-transition$/); s = s.concat(e && o[e[1]] && o[e[1]].transition ? Fi({ key: c, value: t[c], valueSpec: i.transition, style: n, styleSpec: i }) : o[c] ? Fi({ key: c, value: t[c], valueSpec: o[c], style: n, styleSpec: i }) : [new ti(c, t[c], `unknown property "${c}"`)]) } if (t.source) { const e = n.sources && n.sources[t.source], i = e && et(e.type); e ? "raster-dem" !== i && s.push(new ti(r, t.source, `terrain cannot be used with a source of type ${String(i)}, it only be used with a "raster-dem" source type`)) : s.push(new ti(r, t.source, `source "${t.source}" not found`)) } else s.push(new ti(r, t, 'terrain is missing required property "source"')); return s } function Ri(e) { const t = e.value, r = e.style, n = e.styleSpec, i = n.fog; let o = []; const s = zn(t); if (void 0 === t) return o; if ("object" !== s) return o = o.concat([new ti("fog", t, `object expected, ${s} found`)]), o; for (const a in t) { const e = a.match(/^(.*)-transition$/); o = o.concat(e && i[e[1]] && i[e[1]].transition ? Fi({ key: a, value: t[a], valueSpec: n.transition, style: r, styleSpec: n }) : i[a] ? Fi({ key: a, value: t[a], valueSpec: i[a], style: r, styleSpec: n }) : [new ti(a, t[a], `unknown property "${a}"`)]) } return o } const Di = { "*": () => [], array: ni, boolean: function (e) { const t = e.value, r = e.key, n = zn(t); return "boolean" !== n ? [new ti(r, t, `boolean expected, ${n} found`)] : [] }, number: ii, color: function (e) { const t = e.key, r = e.value, n = zn(r); return "string" !== n ? [new ti(t, r, `color expected, ${n} found`)] : null === wt(r) ? [new ti(t, r, `color expected, "${r}" found`)] : [] }, enum: ci, filter: wi, function: oi, layer: Si, object: ri, source: Ai, light: Mi, terrain: Bi, fog: Ri, string: Pi, formatted: function (e) { return 0 === Pi(e).length ? [] : si(e) }, resolvedImage: function (e) { return 0 === Pi(e).length ? [] : si(e) }, projection: function (e) { const t = e.value, r = e.styleSpec, n = r.projection, i = e.style; let o = []; const s = zn(t); if ("object" === s) for (const a in t) o = o.concat(Fi({ key: a, value: t[a], valueSpec: n[a], style: i, styleSpec: r })); else "string" !== s && (o = o.concat([new ti("projection", t, `object or string expected, ${s} found`)])); return o } }; function Fi(e) { const t = e.value, r = e.valueSpec, n = e.styleSpec; return r.expression && Un(et(t)) ? oi(e) : r.expression && Hn(tt(t)) ? si(e) : r.type && Di[r.type] ? Di[r.type](e) : ri(Ye({}, e, { valueSpec: r.type ? n[r.type] : r })) } function Oi(e) { const t = e.value, r = e.key, n = Pi(e); return n.length || (-1 === t.indexOf("{fontstack}") && n.push(new ti(r, t, '"glyphs" url must include a "{fontstack}" token')), -1 === t.indexOf("{range}") && n.push(new ti(r, t, '"glyphs" url must include a "{range}" token'))), n } function zi(e, t = Ke) { return Gi(Fi({ key: "", value: e, valueSpec: t.$root, styleSpec: t, style: e, objectElementValidators: { glyphs: Oi, "*": () => [] } })) } const Ui = e => Gi(Ci(e)), Ni = e => Gi(Ei(e)); function Gi(e) { return e.slice().sort(((e, t) => e.line && t.line ? e.line - t.line : 0)) } function Vi(e, t) { let r = !1; if (t && t.length) for (const n of t) e.fire(new $e(new Error(n.message))), r = !0; return r } var qi = Xi, ji = 3; function Xi(e, t, r) { var n = this.cells = []; if (e instanceof ArrayBuffer) { this.arrayBuffer = e; var i = new Int32Array(this.arrayBuffer); e = i[0], this.d = (t = i[1]) + 2 * (r = i[2]); for (var o = 0; o < this.d * this.d; o++) { var s = i[ji + o], a = i[ji + o + 1]; n.push(s === a ? null : i.subarray(s, a)) } var c = i[ji + n.length + 1]; this.keys = i.subarray(i[ji + n.length], c), this.bboxes = i.subarray(c), this.insert = this._insertReadonly } else { this.d = t + 2 * r; for (var l = 0; l < this.d * this.d; l++)n.push([]); this.keys = [], this.bboxes = [] } this.n = t, this.extent = e, this.padding = r, this.scale = t / e, this.uid = 0; var u = r / t * e; this.min = -u, this.max = e + u } Xi.prototype.insert = function (e, t, r, n, i) { this._forEachCell(t, r, n, i, this._insertCell, this.uid++), this.keys.push(e), this.bboxes.push(t), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i) }, Xi.prototype._insertReadonly = function () { throw "Cannot insert into a GridIndex created from an ArrayBuffer." }, Xi.prototype._insertCell = function (e, t, r, n, i, o) { this.cells[i].push(o) }, Xi.prototype.query = function (e, t, r, n, i) { var o = this.min, s = this.max; if (e <= o && t <= o && s <= r && s <= n && !i) return Array.prototype.slice.call(this.keys); var a = []; return this._forEachCell(e, t, r, n, this._queryCell, a, {}, i), a }, Xi.prototype._queryCell = function (e, t, r, n, i, o, s, a) { var c = this.cells[i]; if (null !== c) for (var l = this.keys, u = this.bboxes, h = 0; h < c.length; h++) { var d = c[h]; if (void 0 === s[d]) { var p = 4 * d; (a ? a(u[p + 0], u[p + 1], u[p + 2], u[p + 3]) : e <= u[p + 2] && t <= u[p + 3] && r >= u[p + 0] && n >= u[p + 1]) ? (s[d] = !0, o.push(l[d])) : s[d] = !1 } } }, Xi.prototype._forEachCell = function (e, t, r, n, i, o, s, a) { for (var c = this._convertToCellCoord(e), l = this._convertToCellCoord(t), u = this._convertToCellCoord(r), h = this._convertToCellCoord(n), d = c; d <= u; d++)for (var p = l; p <= h; p++) { var f = this.d * p + d; if ((!a || a(this._convertFromCellCoord(d), this._convertFromCellCoord(p), this._convertFromCellCoord(d + 1), this._convertFromCellCoord(p + 1))) && i.call(this, e, t, r, n, f, o, s, a)) return } }, Xi.prototype._convertFromCellCoord = function (e) { return (e - this.padding) / this.scale }, Xi.prototype._convertToCellCoord = function (e) { return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding)) }, Xi.prototype.toArrayBuffer = function () { if (this.arrayBuffer) return this.arrayBuffer; for (var e = this.cells, t = ji + this.cells.length + 1 + 1, r = 0, n = 0; n < this.cells.length; n++)r += this.cells[n].length; var i = new Int32Array(t + r + this.keys.length + this.bboxes.length); i[0] = this.extent, i[1] = this.n, i[2] = this.padding; for (var o = t, s = 0; s < e.length; s++) { var a = e[s]; i[ji + s] = o, i.set(a, o), o += a.length } return i[ji + e.length] = o, i.set(this.keys, o), i[ji + e.length + 1] = o += this.keys.length, i.set(this.bboxes, o), o += this.bboxes.length, i.buffer }; const Wi = {}; function Zi(e, t, r = {}) { Object.defineProperty(e, "_classRegistryKey", { value: t, writeable: !1 }), Wi[t] = { klass: e, omit: r.omit || [] } } Zi(Object, "Object"), qi.serialize = function (e, t) { const r = e.toArrayBuffer(); return t && t.push(r), { buffer: r } }, qi.deserialize = function (e) { return new qi(e.buffer) }, Object.defineProperty(qi, "name", { value: "Grid" }), Zi(qi, "Grid"), Zi(It, "Color"), Zi(Error, "Error"), Zi(ae, "AJAXError"), Zi(Bt, "ResolvedImage"), Zi(Yn, "StylePropertyFunction"), Zi(Zn, "StyleExpression", { omit: ["_evaluator"] }), Zi(Jn, "ZoomDependentExpression"), Zi($n, "ZoomConstantExpression"), Zi(Kt, "CompoundExpression", { omit: ["_evaluate"] }); for (const um in Mn) Wi[Mn[um]._classRegistryKey] || Zi(Mn[um], `Expression${um}`); function Hi(e) { return e && "undefined" != typeof ArrayBuffer && (e instanceof ArrayBuffer || e.constructor && "ArrayBuffer" === e.constructor.name) } function Qi(e) { return t.ImageBitmap && e instanceof t.ImageBitmap } function $i(e, r) { if (null == e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || e instanceof Boolean || e instanceof Number || e instanceof String || e instanceof Date || e instanceof RegExp) return e; if (Hi(e) || Qi(e)) return r && r.push(e), e; if (ArrayBuffer.isView(e)) { const t = e; return r && r.push(t.buffer), t } if (e instanceof t.ImageData) return r && r.push(e.data.buffer), e; if (Array.isArray(e)) { const t = []; for (const n of e) t.push($i(n, r)); return t } if ("object" == typeof e) { const t = e.constructor, n = t._classRegistryKey; if (!n) throw new Error(`can't serialize object of unregistered class ${n}`); const i = t.serialize ? t.serialize(e, r) : {}; if (!t.serialize) { for (const t in e) e.hasOwnProperty(t) && (Wi[n].omit.indexOf(t) >= 0 || (i[t] = $i(e[t], r))); e instanceof Error && (i.message = e.message) } if (i.$name) throw new Error("$name property is reserved for worker serialization logic."); return "Object" !== n && (i.$name = n), i } throw new Error("can't serialize object of type " + typeof e) } function Ji(e) { if (null == e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || e instanceof Boolean || e instanceof Number || e instanceof String || e instanceof Date || e instanceof RegExp || Hi(e) || Qi(e) || ArrayBuffer.isView(e) || e instanceof t.ImageData) return e; if (Array.isArray(e)) return e.map(Ji); if ("object" == typeof e) { const t = e.$name || "Object", { klass: r } = Wi[t]; if (!r) throw new Error(`can't deserialize unregistered class ${t}`); if (r.deserialize) return r.deserialize(e); const n = Object.create(r.prototype); for (const i of Object.keys(e)) "$name" !== i && (n[i] = Ji(e[i])); return n } throw new Error("can't deserialize object of type " + typeof e) } const Ki = { "Latin-1 Supplement": e => e >= 128 && e <= 255, Arabic: e => e >= 1536 && e <= 1791, "Arabic Supplement": e => e >= 1872 && e <= 1919, "Arabic Extended-A": e => e >= 2208 && e <= 2303, "Hangul Jamo": e => e >= 4352 && e <= 4607, "Unified Canadian Aboriginal Syllabics": e => e >= 5120 && e <= 5759, Khmer: e => e >= 6016 && e <= 6143, "Unified Canadian Aboriginal Syllabics Extended": e => e >= 6320 && e <= 6399, "General Punctuation": e => e >= 8192 && e <= 8303, "Letterlike Symbols": e => e >= 8448 && e <= 8527, "Number Forms": e => e >= 8528 && e <= 8591, "Miscellaneous Technical": e => e >= 8960 && e <= 9215, "Control Pictures": e => e >= 9216 && e <= 9279, "Optical Character Recognition": e => e >= 9280 && e <= 9311, "Enclosed Alphanumerics": e => e >= 9312 && e <= 9471, "Geometric Shapes": e => e >= 9632 && e <= 9727, "Miscellaneous Symbols": e => e >= 9728 && e <= 9983, "Miscellaneous Symbols and Arrows": e => e >= 11008 && e <= 11263, "CJK Radicals Supplement": e => e >= 11904 && e <= 12031, "Kangxi Radicals": e => e >= 12032 && e <= 12255, "Ideographic Description Characters": e => e >= 12272 && e <= 12287, "CJK Symbols and Punctuation": e => e >= 12288 && e <= 12351, Hiragana: e => e >= 12352 && e <= 12447, Katakana: e => e >= 12448 && e <= 12543, Bopomofo: e => e >= 12544 && e <= 12591, "Hangul Compatibility Jamo": e => e >= 12592 && e <= 12687, Kanbun: e => e >= 12688 && e <= 12703, "Bopomofo Extended": e => e >= 12704 && e <= 12735, "CJK Strokes": e => e >= 12736 && e <= 12783, "Katakana Phonetic Extensions": e => e >= 12784 && e <= 12799, "Enclosed CJK Letters and Months": e => e >= 12800 && e <= 13055, "CJK Compatibility": e => e >= 13056 && e <= 13311, "CJK Unified Ideographs Extension A": e => e >= 13312 && e <= 19903, "Yijing Hexagram Symbols": e => e >= 19904 && e <= 19967, "CJK Unified Ideographs": e => e >= 19968 && e <= 40959, "Yi Syllables": e => e >= 40960 && e <= 42127, "Yi Radicals": e => e >= 42128 && e <= 42191, "Hangul Jamo Extended-A": e => e >= 43360 && e <= 43391, "Hangul Syllables": e => e >= 44032 && e <= 55215, "Hangul Jamo Extended-B": e => e >= 55216 && e <= 55295, "Private Use Area": e => e >= 57344 && e <= 63743, "CJK Compatibility Ideographs": e => e >= 63744 && e <= 64255, "Arabic Presentation Forms-A": e => e >= 64336 && e <= 65023, "Vertical Forms": e => e >= 65040 && e <= 65055, "CJK Compatibility Forms": e => e >= 65072 && e <= 65103, "Small Form Variants": e => e >= 65104 && e <= 65135, "Arabic Presentation Forms-B": e => e >= 65136 && e <= 65279, "Halfwidth and Fullwidth Forms": e => e >= 65280 && e <= 65519 }; function Yi(e) { for (const t of e) if (ro(t.charCodeAt(0))) return !0; return !1 } function eo(e) { for (const t of e) if (!to(t.charCodeAt(0))) return !1; return !0 } function to(e) { return !(Ki.Arabic(e) || Ki["Arabic Supplement"](e) || Ki["Arabic Extended-A"](e) || Ki["Arabic Presentation Forms-A"](e) || Ki["Arabic Presentation Forms-B"](e)) } function ro(e) { return !(746 !== e && 747 !== e && (e < 4352 || !(Ki["Bopomofo Extended"](e) || Ki.Bopomofo(e) || Ki["CJK Compatibility Forms"](e) && !(e >= 65097 && e <= 65103) || Ki["CJK Compatibility Ideographs"](e) || Ki["CJK Compatibility"](e) || Ki["CJK Radicals Supplement"](e) || Ki["CJK Strokes"](e) || !(!Ki["CJK Symbols and Punctuation"](e) || e >= 12296 && e <= 12305 || e >= 12308 && e <= 12319 || 12336 === e) || Ki["CJK Unified Ideographs Extension A"](e) || Ki["CJK Unified Ideographs"](e) || Ki["Enclosed CJK Letters and Months"](e) || Ki["Hangul Compatibility Jamo"](e) || Ki["Hangul Jamo Extended-A"](e) || Ki["Hangul Jamo Extended-B"](e) || Ki["Hangul Jamo"](e) || Ki["Hangul Syllables"](e) || Ki.Hiragana(e) || Ki["Ideographic Description Characters"](e) || Ki.Kanbun(e) || Ki["Kangxi Radicals"](e) || Ki["Katakana Phonetic Extensions"](e) || Ki.Katakana(e) && 12540 !== e || !(!Ki["Halfwidth and Fullwidth Forms"](e) || 65288 === e || 65289 === e || 65293 === e || e >= 65306 && e <= 65310 || 65339 === e || 65341 === e || 65343 === e || e >= 65371 && e <= 65503 || 65507 === e || e >= 65512 && e <= 65519) || !(!Ki["Small Form Variants"](e) || e >= 65112 && e <= 65118 || e >= 65123 && e <= 65126) || Ki["Unified Canadian Aboriginal Syllabics"](e) || Ki["Unified Canadian Aboriginal Syllabics Extended"](e) || Ki["Vertical Forms"](e) || Ki["Yijing Hexagram Symbols"](e) || Ki["Yi Syllables"](e) || Ki["Yi Radicals"](e)))) } function no(e) { return !(ro(e) || function (e) { return !!(Ki["Latin-1 Supplement"](e) && (167 === e || 169 === e || 174 === e || 177 === e || 188 === e || 189 === e || 190 === e || 215 === e || 247 === e) || Ki["General Punctuation"](e) && (8214 === e || 8224 === e || 8225 === e || 8240 === e || 8241 === e || 8251 === e || 8252 === e || 8258 === e || 8263 === e || 8264 === e || 8265 === e || 8273 === e) || Ki["Letterlike Symbols"](e) || Ki["Number Forms"](e) || Ki["Miscellaneous Technical"](e) && (e >= 8960 && e <= 8967 || e >= 8972 && e <= 8991 || e >= 8996 && e <= 9e3 || 9003 === e || e >= 9085 && e <= 9114 || e >= 9150 && e <= 9165 || 9167 === e || e >= 9169 && e <= 9179 || e >= 9186 && e <= 9215) || Ki["Control Pictures"](e) && 9251 !== e || Ki["Optical Character Recognition"](e) || Ki["Enclosed Alphanumerics"](e) || Ki["Geometric Shapes"](e) || Ki["Miscellaneous Symbols"](e) && !(e >= 9754 && e <= 9759) || Ki["Miscellaneous Symbols and Arrows"](e) && (e >= 11026 && e <= 11055 || e >= 11088 && e <= 11097 || e >= 11192 && e <= 11243) || Ki["CJK Symbols and Punctuation"](e) || Ki.Katakana(e) || Ki["Private Use Area"](e) || Ki["CJK Compatibility Forms"](e) || Ki["Small Form Variants"](e) || Ki["Halfwidth and Fullwidth Forms"](e) || 8734 === e || 8756 === e || 8757 === e || e >= 9984 && e <= 10087 || e >= 10102 && e <= 10131 || 65532 === e || 65533 === e) }(e)) } function io(e) { return e >= 1424 && e <= 2303 || Ki["Arabic Presentation Forms-A"](e) || Ki["Arabic Presentation Forms-B"](e) } function oo(e, t) { return !(!t && io(e) || e >= 2304 && e <= 3583 || e >= 3840 && e <= 4255 || Ki.Khmer(e)) } function so(e) { for (const t of e) if (io(t.charCodeAt(0))) return !0; return !1 } const ao = "deferred", co = "loading", lo = "loaded"; let uo = null, ho = "unavailable", po = null; const fo = function (e) { e && "string" == typeof e && e.indexOf("NetworkError") > -1 && (ho = "error"), uo && uo(e) }; function mo() { go.fire(new Qe("pluginStateChange", { pluginStatus: ho, pluginURL: po })) } const go = new Je, _o = function () { return ho }, yo = function () { if (ho !== ao || !po) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified"); ho = co, mo(), po && ue({ url: po }, (e => { e ? fo(e) : (ho = lo, mo()) })) }, vo = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => ho === lo || null != vo.applyArabicShaping, isLoading: () => ho === co, setState(e) { ho = e.pluginStatus, po = e.pluginURL }, isParsed: () => null != vo.applyArabicShaping && null != vo.processBidirectionalText && null != vo.processStyledBidirectionalText, getPluginURL: () => po }; class xo { constructor(e, t) { this.zoom = e, t ? (this.now = t.now, this.fadeDuration = t.fadeDuration, this.transition = t.transition, this.pitch = t.pitch) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0) } isSupportedScript(e) { return function (e, t) { for (const r of e) if (!oo(r.charCodeAt(0), t)) return !1; return !0 }(e, vo.isLoaded()) } } class bo { constructor(e, t) { this.property = e, this.value = t, this.expression = function (e, t) { if (Un(e)) return new Yn(e, t); if (Hn(e)) { const r = Kn(e, t); if ("error" === r.result) throw new Error(r.value.map((e => `${e.key}: ${e.message}`)).join(", ")); return r.value } { let r = e; return "string" == typeof e && "color" === t.type && (r = It.parse(e)), { kind: "constant", evaluate: () => r } } }(void 0 === t ? e.specification.default : t, e.specification) } isDataDriven() { return "source" === this.expression.kind || "composite" === this.expression.kind } possiblyEvaluate(e, t, r) { return this.property.possiblyEvaluate(this, e, t, r) } } class wo { constructor(e) { this.property = e, this.value = new bo(e, void 0) } transitioned(e, t) { return new ko(this.property, this.value, t, I({}, e.transition, this.transition), e.now) } untransitioned() { return new ko(this.property, this.value, null, {}, 0) } } class To { constructor(e) { this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues) } getValue(e) { return U(this._values[e].value.value) } setValue(e, t) { this._values.hasOwnProperty(e) || (this._values[e] = new wo(this._values[e].property)), this._values[e].value = new bo(this._values[e].property, null === t ? void 0 : U(t)) } getTransition(e) { return U(this._values[e].transition) } setTransition(e, t) { this._values.hasOwnProperty(e) || (this._values[e] = new wo(this._values[e].property)), this._values[e].transition = U(t) || void 0 } serialize() { const e = {}; for (const t of Object.keys(this._values)) { const r = this.getValue(t); void 0 !== r && (e[t] = r); const n = this.getTransition(t); void 0 !== n && (e[`${t}-transition`] = n) } return e } transitioned(e, t) { const r = new Co(this._properties); for (const n of Object.keys(this._values)) r._values[n] = this._values[n].transitioned(e, t._values[n]); return r } untransitioned() { const e = new Co(this._properties); for (const t of Object.keys(this._values)) e._values[t] = this._values[t].untransitioned(); return e } } class ko { constructor(e, t, r, n, i) { const o = n.delay || 0, s = n.duration || 0; i = i || 0, this.property = e, this.value = t, this.begin = i + o, this.end = this.begin + s, e.specification.transition && (n.delay || n.duration) && (this.prior = r) } possiblyEvaluate(e, t, r) { const n = e.now || 0, i = this.value.possiblyEvaluate(e, t, r), o = this.prior; if (o) { if (n > this.end) return this.prior = null, i; if (this.value.isDataDriven()) return this.prior = null, i; if (n < this.begin) return o.possiblyEvaluate(e, t, r); { const s = (n - this.begin) / (this.end - this.begin); return this.property.interpolate(o.possiblyEvaluate(e, t, r), i, b(s)) } } return i } } class Co { constructor(e) { this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues) } possiblyEvaluate(e, t, r) { const n = new Po(this._properties); for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(e, t, r); return n } hasTransition() { for (const e of Object.keys(this._values)) if (this._values[e].prior) return !0; return !1 } } class Eo { constructor(e) { this._properties = e, this._values = Object.create(e.defaultPropertyValues) } getValue(e) { return U(this._values[e].value) } setValue(e, t) { this._values[e] = new bo(this._values[e].property, null === t ? void 0 : U(t)) } serialize() { const e = {}; for (const t of Object.keys(this._values)) { const r = this.getValue(t); void 0 !== r && (e[t] = r) } return e } possiblyEvaluate(e, t, r) { const n = new Po(this._properties); for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(e, t, r); return n } } class So { constructor(e, t, r) { this.property = e, this.value = t, this.parameters = r } isConstant() { return "constant" === this.value.kind } constantOr(e) { return "constant" === this.value.kind ? this.value.value : e } evaluate(e, t, r, n) { return this.property.evaluate(this.value, this.parameters, e, t, r, n) } } class Po { constructor(e) { this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues) } get(e) { return this._values[e] } } class Io { constructor(e) { this.specification = e } possiblyEvaluate(e, t) { return e.expression.evaluate(t) } interpolate(e, t, r) { const n = Ar[this.specification.type]; return n ? n(e, t, r) : e } } class Ao { constructor(e, t) { this.specification = e, this.overrides = t } possiblyEvaluate(e, t, r, n) { return new So(this, "constant" === e.expression.kind || "camera" === e.expression.kind ? { kind: "constant", value: e.expression.evaluate(t, null, {}, r, n) } : e.expression, t) } interpolate(e, t, r) { if ("constant" !== e.value.kind || "constant" !== t.value.kind) return e; if (void 0 === e.value.value || void 0 === t.value.value) return new So(this, { kind: "constant", value: void 0 }, e.parameters); const n = Ar[this.specification.type]; return n ? new So(this, { kind: "constant", value: n(e.value.value, t.value.value, r) }, e.parameters) : e } evaluate(e, t, r, n, i, o) { return "constant" === e.kind ? e.value : e.evaluate(t, r, n, i, o) } } class Lo { constructor(e) { this.specification = e } possiblyEvaluate(e, t, r, n) { return !!e.expression.evaluate(t, null, {}, r, n) } interpolate() { return !1 } } class Mo { constructor(e) { this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = []; const t = new xo(0, {}); for (const r in e) { const n = e[r]; n.specification.overridable && this.overridableProperties.push(r); const i = this.defaultPropertyValues[r] = new bo(n, void 0), o = this.defaultTransitionablePropertyValues[r] = new wo(n); this.defaultTransitioningPropertyValues[r] = o.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = i.possiblyEvaluate(t) } } } function Bo(e, t) { return 256 * (e = k(Math.floor(e), 0, 255)) + k(Math.floor(t), 0, 255) } Zi(Ao, "DataDrivenProperty"), Zi(Io, "DataConstantProperty"), Zi(Lo, "ColorRampProperty"); const Ro = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array }; class Do { constructor(e, t) { this._structArray = e, this._pos1 = t * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8 } } class Fo { constructor() { this.isTransferred = !1, this.capacity = -1, this.resize(0) } static serialize(e, t) { return e._trim(), t && (e.isTransferred = !0, t.push(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer } } static deserialize(e) { const t = Object.create(this.prototype); return t.arrayBuffer = e.arrayBuffer, t.length = e.length, t.capacity = e.arrayBuffer.byteLength / t.bytesPerElement, t._refreshViews(), t } _trim() { this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews()) } clear() { this.length = 0 } resize(e) { this.reserve(e), this.length = e } reserve(e) { if (e > this.capacity) { this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement); const t = this.uint8; this._refreshViews(), t && this.uint8.set(t) } } _refreshViews() { throw new Error("_refreshViews() must be implemented by each concrete StructArray layout") } destroy() { this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null } } function Oo(e, t = 1) { let r = 0, n = 0; return { members: e.map((e => { const i = Ro[e.type].BYTES_PER_ELEMENT, o = r = zo(r, Math.max(t, i)), s = e.components || 1; return n = Math.max(n, i), r += i * s, { name: e.name, type: e.type, components: s, offset: o } })), size: zo(r, Math.max(n, t)), alignment: t } } function zo(e, t) { return Math.ceil(e / t) * t } class Uo extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(e, t) { const r = this.length; return this.resize(r + 1), this.emplace(r, e, t) } emplace(e, t, r) { const n = 2 * e; return this.int16[n + 0] = t, this.int16[n + 1] = r, e } } Uo.prototype.bytesPerElement = 4, Zi(Uo, "StructArrayLayout2i4"); class No extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(e, t, r) { const n = this.length; return this.resize(n + 1), this.emplace(n, e, t, r) } emplace(e, t, r, n) { const i = 3 * e; return this.int16[i + 0] = t, this.int16[i + 1] = r, this.int16[i + 2] = n, e } } No.prototype.bytesPerElement = 6, Zi(No, "StructArrayLayout3i6"); class Go extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(e, t, r, n) { const i = this.length; return this.resize(i + 1), this.emplace(i, e, t, r, n) } emplace(e, t, r, n, i) { const o = 4 * e; return this.int16[o + 0] = t, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, e } } Go.prototype.bytesPerElement = 8, Zi(Go, "StructArrayLayout4i8"); class Vo extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(e, t, r, n, i, o, s) { const a = this.length; return this.resize(a + 1), this.emplace(a, e, t, r, n, i, o, s) } emplace(e, t, r, n, i, o, s, a) { const c = 6 * e, l = 12 * e, u = 3 * e; return this.int16[c + 0] = t, this.int16[c + 1] = r, this.uint8[l + 4] = n, this.uint8[l + 5] = i, this.uint8[l + 6] = o, this.uint8[l + 7] = s, this.float32[u + 2] = a, e } } Vo.prototype.bytesPerElement = 12, Zi(Vo, "StructArrayLayout2i4ub1f12"); class qo extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(e, t, r, n) { const i = this.length; return this.resize(i + 1), this.emplace(i, e, t, r, n) } emplace(e, t, r, n, i) { const o = 4 * e; return this.float32[o + 0] = t, this.float32[o + 1] = r, this.float32[o + 2] = n, this.float32[o + 3] = i, e } } qo.prototype.bytesPerElement = 16, Zi(qo, "StructArrayLayout4f16"); class jo extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(e, t, r, n, i) { const o = this.length; return this.resize(o + 1), this.emplace(o, e, t, r, n, i) } emplace(e, t, r, n, i, o) { const s = 6 * e, a = 3 * e; return this.uint16[s + 0] = t, this.uint16[s + 1] = r, this.uint16[s + 2] = n, this.uint16[s + 3] = i, this.float32[a + 2] = o, e } } jo.prototype.bytesPerElement = 12, Zi(jo, "StructArrayLayout4ui1f12"); class Xo extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(e, t, r, n) { const i = this.length; return this.resize(i + 1), this.emplace(i, e, t, r, n) } emplace(e, t, r, n, i) { const o = 4 * e; return this.uint16[o + 0] = t, this.uint16[o + 1] = r, this.uint16[o + 2] = n, this.uint16[o + 3] = i, e } } Xo.prototype.bytesPerElement = 8, Zi(Xo, "StructArrayLayout4ui8"); class Wo extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(e, t, r, n, i, o) { const s = this.length; return this.resize(s + 1), this.emplace(s, e, t, r, n, i, o) } emplace(e, t, r, n, i, o, s) { const a = 6 * e; return this.int16[a + 0] = t, this.int16[a + 1] = r, this.int16[a + 2] = n, this.int16[a + 3] = i, this.int16[a + 4] = o, this.int16[a + 5] = s, e } } Wo.prototype.bytesPerElement = 12, Zi(Wo, "StructArrayLayout6i12"); class Zo extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(e, t, r, n, i, o, s, a, c, l, u, h) { const d = this.length; return this.resize(d + 1), this.emplace(d, e, t, r, n, i, o, s, a, c, l, u, h) } emplace(e, t, r, n, i, o, s, a, c, l, u, h, d) { const p = 12 * e; return this.int16[p + 0] = t, this.int16[p + 1] = r, this.int16[p + 2] = n, this.int16[p + 3] = i, this.uint16[p + 4] = o, this.uint16[p + 5] = s, this.uint16[p + 6] = a, this.uint16[p + 7] = c, this.int16[p + 8] = l, this.int16[p + 9] = u, this.int16[p + 10] = h, this.int16[p + 11] = d, e } } Zo.prototype.bytesPerElement = 24, Zi(Zo, "StructArrayLayout4i4ui4i24"); class Ho extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(e, t, r, n, i, o) { const s = this.length; return this.resize(s + 1), this.emplace(s, e, t, r, n, i, o) } emplace(e, t, r, n, i, o, s) { const a = 10 * e, c = 5 * e; return this.int16[a + 0] = t, this.int16[a + 1] = r, this.int16[a + 2] = n, this.float32[c + 2] = i, this.float32[c + 3] = o, this.float32[c + 4] = s, e } } Ho.prototype.bytesPerElement = 20, Zi(Ho, "StructArrayLayout3i3f20"); class Qo extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer) } emplaceBack(e) { const t = this.length; return this.resize(t + 1), this.emplace(t, e) } emplace(e, t) { return this.uint32[1 * e + 0] = t, e } } Qo.prototype.bytesPerElement = 4, Zi(Qo, "StructArrayLayout1ul4"); class $o extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(e, t, r, n, i, o, s, a, c, l, u, h, d) { const p = this.length; return this.resize(p + 1), this.emplace(p, e, t, r, n, i, o, s, a, c, l, u, h, d) } emplace(e, t, r, n, i, o, s, a, c, l, u, h, d, p) { const f = 20 * e, m = 10 * e; return this.int16[f + 0] = t, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.int16[f + 4] = o, this.float32[m + 3] = s, this.float32[m + 4] = a, this.float32[m + 5] = c, this.float32[m + 6] = l, this.int16[f + 14] = u, this.uint32[m + 8] = h, this.uint16[f + 18] = d, this.uint16[f + 19] = p, e } } $o.prototype.bytesPerElement = 40, Zi($o, "StructArrayLayout5i4f1i1ul2ui40"); class Jo extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(e, t, r, n, i, o, s) { const a = this.length; return this.resize(a + 1), this.emplace(a, e, t, r, n, i, o, s) } emplace(e, t, r, n, i, o, s, a) { const c = 8 * e; return this.int16[c + 0] = t, this.int16[c + 1] = r, this.int16[c + 2] = n, this.int16[c + 4] = i, this.int16[c + 5] = o, this.int16[c + 6] = s, this.int16[c + 7] = a, e } } Jo.prototype.bytesPerElement = 16, Zi(Jo, "StructArrayLayout3i2i2i16"); class Ko extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(e, t, r, n, i) { const o = this.length; return this.resize(o + 1), this.emplace(o, e, t, r, n, i) } emplace(e, t, r, n, i, o) { const s = 4 * e, a = 8 * e; return this.float32[s + 0] = t, this.float32[s + 1] = r, this.float32[s + 2] = n, this.int16[a + 6] = i, this.int16[a + 7] = o, e } } Ko.prototype.bytesPerElement = 16, Zi(Ko, "StructArrayLayout2f1f2i16"); class Yo extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(e, t, r, n) { const i = this.length; return this.resize(i + 1), this.emplace(i, e, t, r, n) } emplace(e, t, r, n, i) { const o = 12 * e, s = 3 * e; return this.uint8[o + 0] = t, this.uint8[o + 1] = r, this.float32[s + 1] = n, this.float32[s + 2] = i, e } } Yo.prototype.bytesPerElement = 12, Zi(Yo, "StructArrayLayout2ub2f12"); class es extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(e, t, r) { const n = this.length; return this.resize(n + 1), this.emplace(n, e, t, r) } emplace(e, t, r, n) { const i = 3 * e; return this.float32[i + 0] = t, this.float32[i + 1] = r, this.float32[i + 2] = n, e } } es.prototype.bytesPerElement = 12, Zi(es, "StructArrayLayout3f12"); class ts extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(e, t, r) { const n = this.length; return this.resize(n + 1), this.emplace(n, e, t, r) } emplace(e, t, r, n) { const i = 3 * e; return this.uint16[i + 0] = t, this.uint16[i + 1] = r, this.uint16[i + 2] = n, e } } ts.prototype.bytesPerElement = 6, Zi(ts, "StructArrayLayout3ui6"); class rs extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer) } emplaceBack(e, t, r, n, i, o, s, a, c, l, u, h, d, p, f, m, g, _, y, v, x) { const b = this.length; return this.resize(b + 1), this.emplace(b, e, t, r, n, i, o, s, a, c, l, u, h, d, p, f, m, g, _, y, v, x) } emplace(e, t, r, n, i, o, s, a, c, l, u, h, d, p, f, m, g, _, y, v, x, b) { const w = 30 * e, T = 15 * e, k = 60 * e; return this.int16[w + 0] = t, this.int16[w + 1] = r, this.int16[w + 2] = n, this.float32[T + 2] = i, this.float32[T + 3] = o, this.uint16[w + 8] = s, this.uint16[w + 9] = a, this.uint32[T + 5] = c, this.uint32[T + 6] = l, this.uint32[T + 7] = u, this.uint16[w + 16] = h, this.uint16[w + 17] = d, this.uint16[w + 18] = p, this.float32[T + 10] = f, this.float32[T + 11] = m, this.uint8[k + 48] = g, this.uint8[k + 49] = _, this.uint8[k + 50] = y, this.uint32[T + 13] = v, this.int16[w + 28] = x, this.uint8[k + 58] = b, e } } rs.prototype.bytesPerElement = 60, Zi(rs, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60"); class ns extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer) } emplaceBack(e, t, r, n, i, o, s, a, c, l, u, h, d, p, f, m, g, _, y, v, x, b, w, T, k, C, E, S, P, I) { const A = this.length; return this.resize(A + 1), this.emplace(A, e, t, r, n, i, o, s, a, c, l, u, h, d, p, f, m, g, _, y, v, x, b, w, T, k, C, E, S, P, I) } emplace(e, t, r, n, i, o, s, a, c, l, u, h, d, p, f, m, g, _, y, v, x, b, w, T, k, C, E, S, P, I, A) { const L = 38 * e, M = 19 * e; return this.int16[L + 0] = t, this.int16[L + 1] = r, this.int16[L + 2] = n, this.float32[M + 2] = i, this.float32[M + 3] = o, this.int16[L + 8] = s, this.int16[L + 9] = a, this.int16[L + 10] = c, this.int16[L + 11] = l, this.int16[L + 12] = u, this.int16[L + 13] = h, this.uint16[L + 14] = d, this.uint16[L + 15] = p, this.uint16[L + 16] = f, this.uint16[L + 17] = m, this.uint16[L + 18] = g, this.uint16[L + 19] = _, this.uint16[L + 20] = y, this.uint16[L + 21] = v, this.uint16[L + 22] = x, this.uint16[L + 23] = b, this.uint16[L + 24] = w, this.uint16[L + 25] = T, this.uint16[L + 26] = k, this.uint16[L + 27] = C, this.uint16[L + 28] = E, this.uint32[M + 15] = S, this.float32[M + 16] = P, this.float32[M + 17] = I, this.float32[M + 18] = A, e } } ns.prototype.bytesPerElement = 76, Zi(ns, "StructArrayLayout3i2f6i15ui1ul3f76"); class is extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(e) { const t = this.length; return this.resize(t + 1), this.emplace(t, e) } emplace(e, t) { return this.float32[1 * e + 0] = t, e } } is.prototype.bytesPerElement = 4, Zi(is, "StructArrayLayout1f4"); class os extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(e, t, r, n, i) { const o = this.length; return this.resize(o + 1), this.emplace(o, e, t, r, n, i) } emplace(e, t, r, n, i, o) { const s = 5 * e; return this.float32[s + 0] = t, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, this.float32[s + 4] = o, e } } os.prototype.bytesPerElement = 20, Zi(os, "StructArrayLayout5f20"); class ss extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(e, t, r, n) { const i = this.length; return this.resize(i + 1), this.emplace(i, e, t, r, n) } emplace(e, t, r, n, i) { const o = 6 * e; return this.uint32[3 * e + 0] = t, this.uint16[o + 2] = r, this.uint16[o + 3] = n, this.uint16[o + 4] = i, e } } ss.prototype.bytesPerElement = 12, Zi(ss, "StructArrayLayout1ul3ui12"); class as extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(e, t) { const r = this.length; return this.resize(r + 1), this.emplace(r, e, t) } emplace(e, t, r) { const n = 2 * e; return this.uint16[n + 0] = t, this.uint16[n + 1] = r, e } } as.prototype.bytesPerElement = 4, Zi(as, "StructArrayLayout2ui4"); class cs extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(e) { const t = this.length; return this.resize(t + 1), this.emplace(t, e) } emplace(e, t) { return this.uint16[1 * e + 0] = t, e } } cs.prototype.bytesPerElement = 2, Zi(cs, "StructArrayLayout1ui2"); class ls extends Fo { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(e, t) { const r = this.length; return this.resize(r + 1), this.emplace(r, e, t) } emplace(e, t, r) { const n = 2 * e; return this.float32[n + 0] = t, this.float32[n + 1] = r, e } } ls.prototype.bytesPerElement = 8, Zi(ls, "StructArrayLayout2f8"); class us extends Do { get projectedAnchorX() { return this._structArray.int16[this._pos2 + 0] } get projectedAnchorY() { return this._structArray.int16[this._pos2 + 1] } get projectedAnchorZ() { return this._structArray.int16[this._pos2 + 2] } get tileAnchorX() { return this._structArray.int16[this._pos2 + 3] } get tileAnchorY() { return this._structArray.int16[this._pos2 + 4] } get x1() { return this._structArray.float32[this._pos4 + 3] } get y1() { return this._structArray.float32[this._pos4 + 4] } get x2() { return this._structArray.float32[this._pos4 + 5] } get y2() { return this._structArray.float32[this._pos4 + 6] } get padding() { return this._structArray.int16[this._pos2 + 14] } get featureIndex() { return this._structArray.uint32[this._pos4 + 8] } get sourceLayerIndex() { return this._structArray.uint16[this._pos2 + 18] } get bucketIndex() { return this._structArray.uint16[this._pos2 + 19] } } us.prototype.size = 40; class hs extends $o { get(e) { return new us(this, e) } } Zi(hs, "CollisionBoxArray"); class ds extends Do { get projectedAnchorX() { return this._structArray.int16[this._pos2 + 0] } get projectedAnchorY() { return this._structArray.int16[this._pos2 + 1] } get projectedAnchorZ() { return this._structArray.int16[this._pos2 + 2] } get tileAnchorX() { return this._structArray.float32[this._pos4 + 2] } get tileAnchorY() { return this._structArray.float32[this._pos4 + 3] } get glyphStartIndex() { return this._structArray.uint16[this._pos2 + 8] } get numGlyphs() { return this._structArray.uint16[this._pos2 + 9] } get vertexStartIndex() { return this._structArray.uint32[this._pos4 + 5] } get lineStartIndex() { return this._structArray.uint32[this._pos4 + 6] } get lineLength() { return this._structArray.uint32[this._pos4 + 7] } get segment() { return this._structArray.uint16[this._pos2 + 16] } get lowerSize() { return this._structArray.uint16[this._pos2 + 17] } get upperSize() { return this._structArray.uint16[this._pos2 + 18] } get lineOffsetX() { return this._structArray.float32[this._pos4 + 10] } get lineOffsetY() { return this._structArray.float32[this._pos4 + 11] } get writingMode() { return this._structArray.uint8[this._pos1 + 48] } get placedOrientation() { return this._structArray.uint8[this._pos1 + 49] } set placedOrientation(e) { this._structArray.uint8[this._pos1 + 49] = e } get hidden() { return this._structArray.uint8[this._pos1 + 50] } set hidden(e) { this._structArray.uint8[this._pos1 + 50] = e } get crossTileID() { return this._structArray.uint32[this._pos4 + 13] } set crossTileID(e) { this._structArray.uint32[this._pos4 + 13] = e } get associatedIconIndex() { return this._structArray.int16[this._pos2 + 28] } get flipState() { return this._structArray.uint8[this._pos1 + 58] } set flipState(e) { this._structArray.uint8[this._pos1 + 58] = e } } ds.prototype.size = 60; class ps extends rs { get(e) { return new ds(this, e) } } Zi(ps, "PlacedSymbolArray"); class fs extends Do { get projectedAnchorX() { return this._structArray.int16[this._pos2 + 0] } get projectedAnchorY() { return this._structArray.int16[this._pos2 + 1] } get projectedAnchorZ() { return this._structArray.int16[this._pos2 + 2] } get tileAnchorX() { return this._structArray.float32[this._pos4 + 2] } get tileAnchorY() { return this._structArray.float32[this._pos4 + 3] } get rightJustifiedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 8] } get centerJustifiedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 9] } get leftJustifiedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 10] } get verticalPlacedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 11] } get placedIconSymbolIndex() { return this._structArray.int16[this._pos2 + 12] } get verticalPlacedIconSymbolIndex() { return this._structArray.int16[this._pos2 + 13] } get key() { return this._structArray.uint16[this._pos2 + 14] } get textBoxStartIndex() { return this._structArray.uint16[this._pos2 + 15] } get textBoxEndIndex() { return this._structArray.uint16[this._pos2 + 16] } get verticalTextBoxStartIndex() { return this._structArray.uint16[this._pos2 + 17] } get verticalTextBoxEndIndex() { return this._structArray.uint16[this._pos2 + 18] } get iconBoxStartIndex() { return this._structArray.uint16[this._pos2 + 19] } get iconBoxEndIndex() { return this._structArray.uint16[this._pos2 + 20] } get verticalIconBoxStartIndex() { return this._structArray.uint16[this._pos2 + 21] } get verticalIconBoxEndIndex() { return this._structArray.uint16[this._pos2 + 22] } get featureIndex() { return this._structArray.uint16[this._pos2 + 23] } get numHorizontalGlyphVertices() { return this._structArray.uint16[this._pos2 + 24] } get numVerticalGlyphVertices() { return this._structArray.uint16[this._pos2 + 25] } get numIconVertices() { return this._structArray.uint16[this._pos2 + 26] } get numVerticalIconVertices() { return this._structArray.uint16[this._pos2 + 27] } get useRuntimeCollisionCircles() { return this._structArray.uint16[this._pos2 + 28] } get crossTileID() { return this._structArray.uint32[this._pos4 + 15] } set crossTileID(e) { this._structArray.uint32[this._pos4 + 15] = e } get textOffset0() { return this._structArray.float32[this._pos4 + 16] } get textOffset1() { return this._structArray.float32[this._pos4 + 17] } get collisionCircleDiameter() { return this._structArray.float32[this._pos4 + 18] } } fs.prototype.size = 76; class ms extends ns { get(e) { return new fs(this, e) } } Zi(ms, "SymbolInstanceArray"); class gs extends is { getoffsetX(e) { return this.float32[1 * e + 0] } } Zi(gs, "GlyphOffsetArray"); class _s extends Uo { getx(e) { return this.int16[2 * e + 0] } gety(e) { return this.int16[2 * e + 1] } } Zi(_s, "SymbolLineVertexArray"); class ys extends Do { get featureIndex() { return this._structArray.uint32[this._pos4 + 0] } get sourceLayerIndex() { return this._structArray.uint16[this._pos2 + 2] } get bucketIndex() { return this._structArray.uint16[this._pos2 + 3] } get layoutVertexArrayOffset() { return this._structArray.uint16[this._pos2 + 4] } } ys.prototype.size = 12; class vs extends ss { get(e) { return new ys(this, e) } } Zi(vs, "FeatureIndexArray"); class xs extends as { geta_centroid_pos0(e) { return this.uint16[2 * e + 0] } geta_centroid_pos1(e) { return this.uint16[2 * e + 1] } } Zi(xs, "FillExtrusionCentroidArray"); const bs = Oo([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), ws = Oo([{ name: "a_dash", components: 4, type: "Uint16" }]); var Ts = {}, ks = { get exports() { return Ts }, set exports(e) { Ts = e } }, Cs = {}; ({ get exports() { return Cs }, set exports(e) { Cs = e } }).exports = function (e, t) { var r, n, i, o, s, a, c, l; for (n = e.length - (r = 3 & e.length), i = t, s = 3432918353, a = 461845907, l = 0; l < n;)c = 255 & e.charCodeAt(l) | (255 & e.charCodeAt(++l)) << 8 | (255 & e.charCodeAt(++l)) << 16 | (255 & e.charCodeAt(++l)) << 24, ++l, i = 27492 + (65535 & (o = 5 * (65535 & (i = (i ^= c = (65535 & (c = (c = (65535 & c) * s + (((c >>> 16) * s & 65535) << 16) & 4294967295) << 15 | c >>> 17)) * a + (((c >>> 16) * a & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (o >>> 16) & 65535) << 16); switch (c = 0, r) { case 3: c ^= (255 & e.charCodeAt(l + 2)) << 16; case 2: c ^= (255 & e.charCodeAt(l + 1)) << 8; case 1: i ^= c = (65535 & (c = (c = (65535 & (c ^= 255 & e.charCodeAt(l))) * s + (((c >>> 16) * s & 65535) << 16) & 4294967295) << 15 | c >>> 17)) * a + (((c >>> 16) * a & 65535) << 16) & 4294967295 }return i ^= e.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0 }; var Es = {}; ({ get exports() { return Es }, set exports(e) { Es = e } }).exports = function (e, t) { for (var r, n = e.length, i = t ^ n, o = 0; n >= 4;)r = 1540483477 * (65535 & (r = 255 & e.charCodeAt(o) | (255 & e.charCodeAt(++o)) << 8 | (255 & e.charCodeAt(++o)) << 16 | (255 & e.charCodeAt(++o)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++o; switch (n) { case 3: i ^= (255 & e.charCodeAt(o + 2)) << 16; case 2: i ^= (255 & e.charCodeAt(o + 1)) << 8; case 1: i = 1540483477 * (65535 & (i ^= 255 & e.charCodeAt(o))) + ((1540483477 * (i >>> 16) & 65535) << 16) }return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0 }; var Ss = Cs, Ps = Es; ks.exports = Ss, Ts.murmur3 = Ss, Ts.murmur2 = Ps; class Is { constructor() { this.ids = [], this.positions = [], this.indexed = !1 } add(e, t, r, n) { this.ids.push(As(e)), this.positions.push(t, r, n) } getPositions(e) { const t = As(e); let r = 0, n = this.ids.length - 1; for (; r < n;) { const e = r + n >> 1; this.ids[e] >= t ? n = e : r = e + 1 } const i = []; for (; this.ids[r] === t;)i.push({ index: this.positions[3 * r], start: this.positions[3 * r + 1], end: this.positions[3 * r + 2] }), r++; return i } static serialize(e, t) { const r = new Float64Array(e.ids), n = new Uint32Array(e.positions); return Ls(r, n, 0, r.length - 1), t && t.push(r.buffer, n.buffer), { ids: r, positions: n } } static deserialize(e) { const t = new Is; return t.ids = e.ids, t.positions = e.positions, t.indexed = !0, t } } function As(e) { const t = +e; return !isNaN(t) && Number.MIN_SAFE_INTEGER <= t && t <= Number.MAX_SAFE_INTEGER ? t : Ts(String(e)) } function Ls(e, t, r, n) { for (; r < n;) { const i = e[r + n >> 1]; let o = r - 1, s = n + 1; for (; ;) { do { o++ } while (e[o] < i); do { s-- } while (e[s] > i); if (o >= s) break; Ms(e, o, s), Ms(t, 3 * o, 3 * s), Ms(t, 3 * o + 1, 3 * s + 1), Ms(t, 3 * o + 2, 3 * s + 2) } s - r < n - s ? (Ls(e, t, r, s), r = s + 1) : (Ls(e, t, s + 1, n), n = s) } } function Ms(e, t, r) { const n = e[t]; e[t] = e[r], e[r] = n } Zi(Is, "FeaturePositionMap"); class Bs { constructor(e) { this.gl = e.gl, this.initialized = !1 } fetchUniformLocation(e, t) { return this.location || this.initialized || (this.location = this.gl.getUniformLocation(e, t), this.initialized = !0), !!this.location } } class Rs extends Bs { constructor(e) { super(e), this.current = 0 } set(e, t, r) { this.fetchUniformLocation(e, t) && this.current !== r && (this.current = r, this.gl.uniform1f(this.location, r)) } } class Ds extends Bs { constructor(e) { super(e), this.current = [0, 0, 0, 0] } set(e, t, r) { this.fetchUniformLocation(e, t) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] && r[3] === this.current[3] || (this.current = r, this.gl.uniform4f(this.location, r[0], r[1], r[2], r[3]))) } } class Fs extends Bs { constructor(e) { super(e), this.current = It.transparent } set(e, t, r) { this.fetchUniformLocation(e, t) && (r.r === this.current.r && r.g === this.current.g && r.b === this.current.b && r.a === this.current.a || (this.current = r, this.gl.uniform4f(this.location, r.r, r.g, r.b, r.a))) } } const Os = new Float32Array(16), zs = new Float32Array(9), Us = new Float32Array(4); function Ns(e) { return [Bo(255 * e.r, 255 * e.g), Bo(255 * e.b, 255 * e.a)] } class Gs { constructor(e, t, r) { this.value = e, this.uniformNames = t.map((e => `u_${e}`)), this.type = r } setUniform(e, t, r, n, i) { t.set(e, i, n.constantOr(this.value)) } getBinding(e, t) { return "color" === this.type ? new Fs(e) : new Rs(e) } } class Vs { constructor(e, t) { this.uniformNames = t.map((e => `u_${e}`)), this.pattern = null, this.pixelRatio = 1 } setConstantPatternPositions(e) { this.pixelRatio = e.pixelRatio || 1, this.pattern = e.tl.concat(e.br) } setUniform(e, t, r, n, i) { const o = "u_pattern" === i || "u_dash" === i ? this.pattern : "u_pixel_ratio" === i ? this.pixelRatio : null; o && t.set(e, i, o) } getBinding(e, t) { return "u_pattern" === t || "u_dash" === t ? new Ds(e) : new Rs(e) } } class qs { constructor(e, t, r, n) { this.expression = e, this.type = r, this.maxValue = 0, this.paintVertexAttributes = t.map((e => ({ name: `a_${e}`, type: "Float32", components: "color" === r ? 2 : 1, offset: 0 }))), this.paintVertexArray = new n } populatePaintArray(e, t, r, n, i, o) { const s = this.paintVertexArray.length, a = this.expression.evaluate(new xo(0), t, {}, i, n, o); this.paintVertexArray.resize(e), this._setPaintValue(s, e, a) } updatePaintArray(e, t, r, n, i) { const o = this.expression.evaluate({ zoom: 0 }, r, n, void 0, i); this._setPaintValue(e, t, o) } _setPaintValue(e, t, r) { if ("color" === this.type) { const n = Ns(r); for (let r = e; r < t; r++)this.paintVertexArray.emplace(r, n[0], n[1]) } else { for (let n = e; n < t; n++)this.paintVertexArray.emplace(n, r); this.maxValue = Math.max(this.maxValue, Math.abs(r)) } } upload(e) { this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent)) } destroy() { this.paintVertexBuffer && this.paintVertexBuffer.destroy() } } class js { constructor(e, t, r, n, i, o) { this.expression = e, this.uniformNames = t.map((e => `u_${e}_t`)), this.type = r, this.useIntegerZoom = n, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = t.map((e => ({ name: `a_${e}`, type: "Float32", components: "color" === r ? 4 : 2, offset: 0 }))), this.paintVertexArray = new o } populatePaintArray(e, t, r, n, i, o) { const s = this.expression.evaluate(new xo(this.zoom), t, {}, i, n, o), a = this.expression.evaluate(new xo(this.zoom + 1), t, {}, i, n, o), c = this.paintVertexArray.length; this.paintVertexArray.resize(e), this._setPaintValue(c, e, s, a) } updatePaintArray(e, t, r, n, i) { const o = this.expression.evaluate({ zoom: this.zoom }, r, n, void 0, i), s = this.expression.evaluate({ zoom: this.zoom + 1 }, r, n, void 0, i); this._setPaintValue(e, t, o, s) } _setPaintValue(e, t, r, n) { if ("color" === this.type) { const i = Ns(r), o = Ns(n); for (let r = e; r < t; r++)this.paintVertexArray.emplace(r, i[0], i[1], o[0], o[1]) } else { for (let i = e; i < t; i++)this.paintVertexArray.emplace(i, r, n); this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n)) } } upload(e) { this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent)) } destroy() { this.paintVertexBuffer && this.paintVertexBuffer.destroy() } setUniform(e, t, r, n, i) { const o = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom, s = k(this.expression.interpolationFactor(o, this.zoom, this.zoom + 1), 0, 1); t.set(e, i, s) } getBinding(e, t) { return new Rs(e) } } class Xs { constructor(e, t, r, n, i) { this.expression = e, this.layerId = i, this.paintVertexAttributes = ("array" === r ? ws : bs).members; for (let o = 0; o < t.length; ++o); this.paintVertexArray = new n } populatePaintArray(e, t, r) { const n = this.paintVertexArray.length; this.paintVertexArray.resize(e), this._setPaintValues(n, e, t.patterns && t.patterns[this.layerId], r) } updatePaintArray(e, t, r, n, i, o) { this._setPaintValues(e, t, r.patterns && r.patterns[this.layerId], o) } _setPaintValues(e, t, r, n) { if (!n || !r) return; const i = n[r]; if (!i) return; const { tl: o, br: s, pixelRatio: a } = i; for (let c = e; c < t; c++)this.paintVertexArray.emplace(c, o[0], o[1], s[0], s[1], a) } upload(e) { this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent)) } destroy() { this.paintVertexBuffer && this.paintVertexBuffer.destroy() } } class Ws { constructor(e, t, r = (() => !0)) { this.binders = {}, this._buffers = []; const n = []; for (const i in e.paint._values) { if (!r(i)) continue; const o = e.paint.get(i); if (!(o instanceof So && Dn(o.property.specification))) continue; const s = Qs(i, e.type), a = o.value, c = o.property.specification.type, l = o.property.useIntegerZoom, u = "line-dasharray" === i || i.endsWith("pattern"), h = "line-dasharray" === i && "constant" !== e.layout.get("line-cap").value.kind; if ("constant" !== a.kind || h) if ("source" === a.kind || h || u) { const t = Ks(i, c, "source"); this.binders[i] = u ? new Xs(a, s, c, t, e.id) : new qs(a, s, c, t), n.push(`/a_${i}`) } else { const e = Ks(i, c, "composite"); this.binders[i] = new js(a, s, c, l, t, e), n.push(`/z_${i}`) } else this.binders[i] = u ? new Vs(a.value, s) : new Gs(a.value, s, c), n.push(`/u_${i}`) } this.cacheKey = n.sort().join("") } getMaxValue(e) { const t = this.binders[e]; return t instanceof qs || t instanceof js ? t.maxValue : 0 } populatePaintArrays(e, t, r, n, i, o) { for (const s in this.binders) { const a = this.binders[s]; (a instanceof qs || a instanceof js || a instanceof Xs) && a.populatePaintArray(e, t, r, n, i, o) } } setConstantPatternPositions(e) { for (const t in this.binders) { const r = this.binders[t]; r instanceof Vs && r.setConstantPatternPositions(e) } } updatePaintArrays(e, t, r, n, i, o) { let s = !1; for (const a in e) { const c = t.getPositions(a); for (const t of c) { const c = r.feature(t.index); for (const r in this.binders) { const l = this.binders[r]; if ((l instanceof qs || l instanceof js || l instanceof Xs) && !0 === l.expression.isStateDependent) { const u = n.paint.get(r); l.expression = u.value, l.updatePaintArray(t.start, t.end, c, e[a], i, o), s = !0 } } } } return s } defines() { const e = []; for (const t in this.binders) { const r = this.binders[t]; (r instanceof Gs || r instanceof Vs) && e.push(...r.uniformNames.map((e => `#define HAS_UNIFORM_${e}`))) } return e } getBinderAttributes() { const e = []; for (const t in this.binders) { const r = this.binders[t]; if (r instanceof qs || r instanceof js || r instanceof Xs) for (let t = 0; t < r.paintVertexAttributes.length; t++)e.push(r.paintVertexAttributes[t].name) } return e } getBinderUniforms() { const e = []; for (const t in this.binders) { const r = this.binders[t]; if (r instanceof Gs || r instanceof Vs || r instanceof js) for (const t of r.uniformNames) e.push(t) } return e } getPaintVertexBuffers() { return this._buffers } getUniforms(e) { const t = []; for (const r in this.binders) { const n = this.binders[r]; if (n instanceof Gs || n instanceof Vs || n instanceof js) for (const i of n.uniformNames) t.push({ name: i, property: r, binding: n.getBinding(e, i) }) } return t } setUniforms(e, t, r, n, i) { for (const { name: o, property: s, binding: a } of r) this.binders[s].setUniform(e, a, i, n.get(s), o) } updatePaintBuffers() { this._buffers = []; for (const e in this.binders) { const t = this.binders[e]; (t instanceof qs || t instanceof js || t instanceof Xs) && t.paintVertexBuffer && this._buffers.push(t.paintVertexBuffer) } } upload(e) { for (const t in this.binders) { const r = this.binders[t]; (r instanceof qs || r instanceof js || r instanceof Xs) && r.upload(e) } this.updatePaintBuffers() } destroy() { for (const e in this.binders) { const t = this.binders[e]; (t instanceof qs || t instanceof js || t instanceof Xs) && t.destroy() } } } class Zs { constructor(e, t, r = (() => !0)) { this.programConfigurations = {}; for (const n of e) this.programConfigurations[n.id] = new Ws(n, t, r); this.needsUpload = !1, this._featureMap = new Is, this._bufferOffset = 0 } populatePaintArrays(e, t, r, n, i, o, s) { for (const a in this.programConfigurations) this.programConfigurations[a].populatePaintArrays(e, t, n, i, o, s); void 0 !== t.id && this._featureMap.add(t.id, r, this._bufferOffset, e), this._bufferOffset = e, this.needsUpload = !0 } updatePaintArrays(e, t, r, n, i) { for (const o of r) this.needsUpload = this.programConfigurations[o.id].updatePaintArrays(e, this._featureMap, t, o, n, i) || this.needsUpload } get(e) { return this.programConfigurations[e] } upload(e) { if (this.needsUpload) { for (const t in this.programConfigurations) this.programConfigurations[t].upload(e); this.needsUpload = !1 } } destroy() { for (const e in this.programConfigurations) this.programConfigurations[e].destroy() } } const Hs = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] }; function Qs(e, t) { return Hs[e] || [e.replace(`${t}-`, "").replace(/-/g, "_")] } const $s = { "line-pattern": { source: jo, composite: jo }, "fill-pattern": { source: jo, composite: jo }, "fill-extrusion-pattern": { source: jo, composite: jo }, "line-dasharray": { source: Xo, composite: Xo } }, Js = { color: { source: ls, composite: qo }, number: { source: is, composite: ls } }; function Ks(e, t, r) { const n = $s[e]; return n && n[r] || Js[t][r] } Zi(Gs, "ConstantBinder"), Zi(Vs, "PatternConstantBinder"), Zi(qs, "SourceExpressionBinder"), Zi(Xs, "PatternCompositeBinder"), Zi(js, "CompositeExpressionBinder"), Zi(Ws, "ProgramConfiguration", { omit: ["_buffers"] }), Zi(Zs, "ProgramConfigurationSet"); const Ys = "-transition"; class ea extends Je { constructor(e, t) { if (super(), this.id = e.id, this.type = e.type, this._featureFilter = { filter: () => !0, needGeometry: !1, needFeature: !1 }, this._filterCompiled = !1, "custom" !== e.type && (this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, "background" !== e.type && "sky" !== e.type && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter), t.layout && (this._unevaluatedLayout = new Eo(t.layout)), t.paint)) { this._transitionablePaint = new To(t.paint); for (const t in e.paint) this.setPaintProperty(t, e.paint[t], { validate: !1 }); for (const t in e.layout) this.setLayoutProperty(t, e.layout[t], { validate: !1 }); this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Po(t.paint) } } getLayoutProperty(e) { return "visibility" === e ? this.visibility : this._unevaluatedLayout.getValue(e) } setLayoutProperty(e, t, r = {}) { null != t && this._validate(Ni, `layers.${this.id}.layout.${e}`, e, t, r) || ("visibility" !== e ? this._unevaluatedLayout.setValue(e, t) : this.visibility = t) } getPaintProperty(e) { return F(e, Ys) ? this._transitionablePaint.getTransition(e.slice(0, -Ys.length)) : this._transitionablePaint.getValue(e) } setPaintProperty(e, t, r = {}) { if (null != t && this._validate(Ui, `layers.${this.id}.paint.${e}`, e, t, r)) return !1; if (F(e, Ys)) return this._transitionablePaint.setTransition(e.slice(0, -Ys.length), t || void 0), !1; { const r = this._transitionablePaint._values[e], n = r.value.isDataDriven(), i = r.value; this._transitionablePaint.setValue(e, t), this._handleSpecialPaintPropertyUpdate(e); const o = this._transitionablePaint._values[e].value, s = o.isDataDriven(), a = F(e, "pattern") || "line-dasharray" === e; return s || n || a || this._handleOverridablePaintPropertyUpdate(e, i, o) } } _handleSpecialPaintPropertyUpdate(e) { } getProgramIds() { return null } getProgramConfiguration(e) { return null } _handleOverridablePaintPropertyUpdate(e, t, r) { return !1 } isHidden(e) { return !!(this.minzoom && e < this.minzoom) || !!(this.maxzoom && e >= this.maxzoom) || "none" === this.visibility } updateTransitions(e) { this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint) } hasTransition() { return this._transitioningPaint.hasTransition() } recalculate(e, t) { this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, t)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, t) } serialize() { const e = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }; return this.visibility && (e.layout = e.layout || {}, e.layout.visibility = this.visibility), z(e, ((e, t) => !(void 0 === e || "layout" === t && !Object.keys(e).length || "paint" === t && !Object.keys(e).length))) } _validate(e, t, r, n, i = {}) { return (!i || !1 !== i.validate) && Vi(this, e.call(zi, { key: t, layerType: this.type, objectKey: r, value: n, styleSpec: Ke, style: { glyphs: !0, sprite: !0 } })) } is3D() { return !1 } isSky() { return !1 } isTileClipped() { return !1 } hasOffscreenPass() { return !1 } resize() { } isStateDependent() { for (const e in this.paint._values) { const t = this.paint.get(e); if (t instanceof So && Dn(t.property.specification) && ("source" === t.value.kind || "composite" === t.value.kind) && t.value.isStateDependent) return !0 } return !1 } compileFilter() { this._filterCompiled || (this._featureFilter = ui(this.filter), this._filterCompiled = !0) } invalidateCompiledFilter() { this._filterCompiled = !1 } dynamicFilter() { return this._featureFilter.dynamicFilter } dynamicFilterNeedsFeature() { return this._featureFilter.needFeature } } const ta = Oo([{ name: "a_pos", components: 2, type: "Int16" }], 4), ra = Oo([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]); class na { constructor(e = []) { this.segments = e } prepareSegment(e, t, r, n) { let i = this.segments[this.segments.length - 1]; return e > na.MAX_VERTEX_ARRAY_LENGTH && G(`Max vertices per segment is ${na.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}`), (!i || i.vertexLength + e > na.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = { vertexOffset: t.length, primitiveOffset: r.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i } get() { return this.segments } destroy() { for (const e of this.segments) for (const t in e.vaos) e.vaos[t].destroy() } static simpleSegment(e, t, r, n) { return new na([{ vertexOffset: e, primitiveOffset: t, vertexLength: r, primitiveLength: n, vaos: {}, sortKey: 0 }]) } } na.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Zi(na, "SegmentVector"); var ia = 8192; class oa { constructor(e, t) { e && (t ? this.setSouthWest(e).setNorthEast(t) : 4 === e.length ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])) } setNorthEast(e) { return this._ne = e instanceof zc ? new zc(e.lng, e.lat) : zc.convert(e), this } setSouthWest(e) { return this._sw = e instanceof zc ? new zc(e.lng, e.lat) : zc.convert(e), this } extend(e) { const t = this._sw, r = this._ne; let n, i; if (e instanceof zc) n = e, i = e; else { if (!(e instanceof oa)) return Array.isArray(e) ? 4 === e.length || e.every(Array.isArray) ? this.extend(oa.convert(e)) : this.extend(zc.convert(e)) : "object" == typeof e && null !== e && e.hasOwnProperty("lat") && (e.hasOwnProperty("lon") || e.hasOwnProperty("lng")) ? this.extend(zc.convert(e)) : this; if (n = e._sw, i = e._ne, !n || !i) return this } return t || r ? (t.lng = Math.min(n.lng, t.lng), t.lat = Math.min(n.lat, t.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new zc(n.lng, n.lat), this._ne = new zc(i.lng, i.lat)), this } getCenter() { return new zc((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2) } getSouthWest() { return this._sw } getNorthEast() { return this._ne } getNorthWest() { return new zc(this.getWest(), this.getNorth()) } getSouthEast() { return new zc(this.getEast(), this.getSouth()) } getWest() { return this._sw.lng } getSouth() { return this._sw.lat } getEast() { return this._ne.lng } getNorth() { return this._ne.lat } toArray() { return [this._sw.toArray(), this._ne.toArray()] } toString() { return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})` } isEmpty() { return !(this._sw && this._ne) } contains(e) { const { lng: t, lat: r } = zc.convert(e); let n = this._sw.lng <= t && t <= this._ne.lng; return this._sw.lng > this._ne.lng && (n = this._sw.lng >= t && t >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n } static convert(e) { return !e || e instanceof oa ? e : new oa(e) } } var sa = 1e-6, aa = "undefined" != typeof Float32Array ? Float32Array : Array; function ca() { var e = new aa(9); return aa != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[0] = 1, e[4] = 1, e[8] = 1, e } function la(e, t, r) { var n = t[0], i = t[1], o = t[2], s = t[3], a = t[4], c = t[5], l = t[6], u = t[7], h = t[8], d = r[0], p = r[1], f = r[2], m = r[3], g = r[4], _ = r[5], y = r[6], v = r[7], x = r[8]; return e[0] = d * n + p * s + f * l, e[1] = d * i + p * a + f * u, e[2] = d * o + p * c + f * h, e[3] = m * n + g * s + _ * l, e[4] = m * i + g * a + _ * u, e[5] = m * o + g * c + _ * h, e[6] = y * n + v * s + x * l, e[7] = y * i + v * a + x * u, e[8] = y * o + v * c + x * h, e } function ua(e) { return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e } function ha(e, t) { var r = t[0], n = t[1], i = t[2], o = t[3], s = t[4], a = t[5], c = t[6], l = t[7], u = t[8], h = t[9], d = t[10], p = t[11], f = t[12], m = t[13], g = t[14], _ = t[15], y = r * a - n * s, v = r * c - i * s, x = r * l - o * s, b = n * c - i * a, w = n * l - o * a, T = i * l - o * c, k = u * m - h * f, C = u * g - d * f, E = u * _ - p * f, S = h * g - d * m, P = h * _ - p * m, I = d * _ - p * g, A = y * I - v * P + x * S + b * E - w * C + T * k; return A ? (e[0] = (a * I - c * P + l * S) * (A = 1 / A), e[1] = (i * P - n * I - o * S) * A, e[2] = (m * T - g * w + _ * b) * A, e[3] = (d * w - h * T - p * b) * A, e[4] = (c * E - s * I - l * C) * A, e[5] = (r * I - i * E + o * C) * A, e[6] = (g * x - f * T - _ * v) * A, e[7] = (u * T - d * x + p * v) * A, e[8] = (s * P - a * E + l * k) * A, e[9] = (n * E - r * P - o * k) * A, e[10] = (f * w - m * x + _ * y) * A, e[11] = (h * x - u * w - p * y) * A, e[12] = (a * C - s * S - c * k) * A, e[13] = (r * S - n * C + i * k) * A, e[14] = (m * v - f * b - g * y) * A, e[15] = (u * b - h * v + d * y) * A, e) : null } function da(e, t, r) { var n = t[0], i = t[1], o = t[2], s = t[3], a = t[4], c = t[5], l = t[6], u = t[7], h = t[8], d = t[9], p = t[10], f = t[11], m = t[12], g = t[13], _ = t[14], y = t[15], v = r[0], x = r[1], b = r[2], w = r[3]; return e[0] = v * n + x * a + b * h + w * m, e[1] = v * i + x * c + b * d + w * g, e[2] = v * o + x * l + b * p + w * _, e[3] = v * s + x * u + b * f + w * y, e[4] = (v = r[4]) * n + (x = r[5]) * a + (b = r[6]) * h + (w = r[7]) * m, e[5] = v * i + x * c + b * d + w * g, e[6] = v * o + x * l + b * p + w * _, e[7] = v * s + x * u + b * f + w * y, e[8] = (v = r[8]) * n + (x = r[9]) * a + (b = r[10]) * h + (w = r[11]) * m, e[9] = v * i + x * c + b * d + w * g, e[10] = v * o + x * l + b * p + w * _, e[11] = v * s + x * u + b * f + w * y, e[12] = (v = r[12]) * n + (x = r[13]) * a + (b = r[14]) * h + (w = r[15]) * m, e[13] = v * i + x * c + b * d + w * g, e[14] = v * o + x * l + b * p + w * _, e[15] = v * s + x * u + b * f + w * y, e } function pa(e, t, r) { var n, i, o, s, a, c, l, u, h, d, p, f, m = r[0], g = r[1], _ = r[2]; return t === e ? (e[12] = t[0] * m + t[4] * g + t[8] * _ + t[12], e[13] = t[1] * m + t[5] * g + t[9] * _ + t[13], e[14] = t[2] * m + t[6] * g + t[10] * _ + t[14], e[15] = t[3] * m + t[7] * g + t[11] * _ + t[15]) : (i = t[1], o = t[2], s = t[3], a = t[4], c = t[5], l = t[6], u = t[7], h = t[8], d = t[9], p = t[10], f = t[11], e[0] = n = t[0], e[1] = i, e[2] = o, e[3] = s, e[4] = a, e[5] = c, e[6] = l, e[7] = u, e[8] = h, e[9] = d, e[10] = p, e[11] = f, e[12] = n * m + a * g + h * _ + t[12], e[13] = i * m + c * g + d * _ + t[13], e[14] = o * m + l * g + p * _ + t[14], e[15] = s * m + u * g + f * _ + t[15]), e } function fa(e, t, r) { var n = r[0], i = r[1], o = r[2]; return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e[4] = t[4] * i, e[5] = t[5] * i, e[6] = t[6] * i, e[7] = t[7] * i, e[8] = t[8] * o, e[9] = t[9] * o, e[10] = t[10] * o, e[11] = t[11] * o, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e } function ma(e, t, r) { var n = Math.sin(r), i = Math.cos(r), o = t[4], s = t[5], a = t[6], c = t[7], l = t[8], u = t[9], h = t[10], d = t[11]; return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = o * i + l * n, e[5] = s * i + u * n, e[6] = a * i + h * n, e[7] = c * i + d * n, e[8] = l * i - o * n, e[9] = u * i - s * n, e[10] = h * i - a * n, e[11] = d * i - c * n, e } function ga(e, t, r) { var n = Math.sin(r), i = Math.cos(r), o = t[0], s = t[1], a = t[2], c = t[3], l = t[8], u = t[9], h = t[10], d = t[11]; return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = o * i - l * n, e[1] = s * i - u * n, e[2] = a * i - h * n, e[3] = c * i - d * n, e[8] = o * n + l * i, e[9] = s * n + u * i, e[10] = a * n + h * i, e[11] = c * n + d * i, e } function _a(e, t) { return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e } function ya(e, t, r) { var n, i, o, s = r[0], a = r[1], c = r[2], l = Math.hypot(s, a, c); return l < sa ? null : (s *= l = 1 / l, a *= l, c *= l, n = Math.sin(t), i = Math.cos(t), e[0] = s * s * (o = 1 - i) + i, e[1] = a * s * o + c * n, e[2] = c * s * o - a * n, e[3] = 0, e[4] = s * a * o - c * n, e[5] = a * a * o + i, e[6] = c * a * o + s * n, e[7] = 0, e[8] = s * c * o + a * n, e[9] = a * c * o - s * n, e[10] = c * c * o + i, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e) } Math.hypot || (Math.hypot = function () { for (var e = 0, t = arguments.length; t--;)e += arguments[t] * arguments[t]; return Math.sqrt(e) }); var va = da; function xa() { var e = new aa(3); return aa != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e } function ba(e) { var t = new aa(3); return t[0] = e[0], t[1] = e[1], t[2] = e[2], t } function wa(e) { return Math.hypot(e[0], e[1], e[2]) } function Ta(e, t, r) { var n = new aa(3); return n[0] = e, n[1] = t, n[2] = r, n } function ka(e, t, r) { return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e } function Ca(e, t, r) { return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e } function Ea(e, t, r) { return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e } function Sa(e, t, r) { return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e } function Pa(e, t, r) { return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e } function Ia(e, t, r) { return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e } function Aa(e, t, r, n) { return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e } function La(e, t) { var r = t[0], n = t[1], i = t[2], o = r * r + n * n + i * i; return o > 0 && (o = 1 / Math.sqrt(o)), e[0] = t[0] * o, e[1] = t[1] * o, e[2] = t[2] * o, e } function Ma(e, t) { return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] } function Ba(e, t, r) { var n = t[0], i = t[1], o = t[2], s = r[0], a = r[1], c = r[2]; return e[0] = i * c - o * a, e[1] = o * s - n * c, e[2] = n * a - i * s, e } function Ra(e, t, r) { var n = t[0], i = t[1], o = t[2], s = r[3] * n + r[7] * i + r[11] * o + r[15]; return e[0] = (r[0] * n + r[4] * i + r[8] * o + r[12]) / (s = s || 1), e[1] = (r[1] * n + r[5] * i + r[9] * o + r[13]) / s, e[2] = (r[2] * n + r[6] * i + r[10] * o + r[14]) / s, e } function Da(e, t, r) { var n = r[0], i = r[1], o = r[2], s = t[0], a = t[1], c = t[2], l = i * c - o * a, u = o * s - n * c, h = n * a - i * s, d = i * h - o * u, p = o * l - n * h, f = n * u - i * l, m = 2 * r[3]; return u *= m, h *= m, p *= 2, f *= 2, e[0] = s + (l *= m) + (d *= 2), e[1] = a + u + p, e[2] = c + h + f, e } var Fa, Oa = Ca, za = Ea, Ua = wa; function Na(e, t, r) { return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e } function Ga(e, t) { var r = t[0], n = t[1], i = t[2], o = t[3], s = r * r + n * n + i * i + o * o; return s > 0 && (s = 1 / Math.sqrt(s)), e[0] = r * s, e[1] = n * s, e[2] = i * s, e[3] = o * s, e } function Va(e, t, r) { var n = t[0], i = t[1], o = t[2], s = t[3]; return e[0] = r[0] * n + r[4] * i + r[8] * o + r[12] * s, e[1] = r[1] * n + r[5] * i + r[9] * o + r[13] * s, e[2] = r[2] * n + r[6] * i + r[10] * o + r[14] * s, e[3] = r[3] * n + r[7] * i + r[11] * o + r[15] * s, e } function qa() { var e = new aa(4); return aa != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e[3] = 1, e } function ja(e) { return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e } function Xa(e, t, r) { r *= .5; var n = t[0], i = t[1], o = t[2], s = t[3], a = Math.sin(r), c = Math.cos(r); return e[0] = n * c + s * a, e[1] = i * c + o * a, e[2] = o * c - i * a, e[3] = s * c - n * a, e } function Wa(e, t, r) { r *= .5; var n = t[0], i = t[1], o = t[2], s = t[3], a = Math.sin(r), c = Math.cos(r); return e[0] = n * c - o * a, e[1] = i * c + s * a, e[2] = o * c + n * a, e[3] = s * c - i * a, e } xa(), Fa = new aa(4), aa != Float32Array && (Fa[0] = 0, Fa[1] = 0, Fa[2] = 0, Fa[3] = 0); var Za = Ga; xa(), Ta(1, 0, 0), Ta(0, 1, 0), qa(), qa(), ca(); const Ha = Oo([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: Qa } = Ha, $a = Oo([{ name: "a_pos_3", components: 3, type: "Int16" }]); var Ja = Oo([{ name: "a_pos", type: "Int16", components: 2 }]); class Ka { constructor(e, t) { this.pos = e, this.dir = t } intersectsPlane(e, t, r) { const n = Ma(t, this.dir); if (Math.abs(n) < 1e-6) return !1; const i = ((e[0] - this.pos[0]) * t[0] + (e[1] - this.pos[1]) * t[1] + (e[2] - this.pos[2]) * t[2]) / n; return r[0] = this.pos[0] + this.dir[0] * i, r[1] = this.pos[1] + this.dir[1] * i, r[2] = this.pos[2] + this.dir[2] * i, !0 } closestPointOnSphere(e, t, r) { if (function (e, t) { var r = e[0], n = e[1], i = e[2], o = t[0], s = t[1], a = t[2]; return Math.abs(r - o) <= sa * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(n - s) <= sa * Math.max(1, Math.abs(n), Math.abs(s)) && Math.abs(i - a) <= sa * Math.max(1, Math.abs(i), Math.abs(a)) }(this.pos, e) || 0 === t) return r[0] = r[1] = r[2] = 0, !1; const [n, i, o] = this.dir, s = this.pos[0] - e[0], a = this.pos[1] - e[1], c = this.pos[2] - e[2], l = n * n + i * i + o * o, u = 2 * (s * n + a * i + c * o), h = u * u - 4 * l * (s * s + a * a + c * c - t * t); if (h < 0) { const e = Math.max(-u / 2, 0), l = s + n * e, h = a + i * e, d = c + o * e, p = Math.hypot(l, h, d); return r[0] = l * t / p, r[1] = h * t / p, r[2] = d * t / p, !1 } { const e = (-u - Math.sqrt(h)) / (2 * l); if (e < 0) { const e = Math.hypot(s, a, c); return r[0] = s * t / e, r[1] = a * t / e, r[2] = c * t / e, !1 } return r[0] = s + n * e, r[1] = a + i * e, r[2] = c + o * e, !0 } } } class Ya { constructor(e, t, r, n, i) { this.TL = e, this.TR = t, this.BR = r, this.BL = n, this.horizon = i } static fromInvProjectionMatrix(e, t, r) { const n = [-1, 1, 1], i = [1, 1, 1], o = [1, -1, 1], s = [-1, -1, 1], a = Ra(n, n, e), c = Ra(i, i, e), l = Ra(o, o, e), u = Ra(s, s, e); return new Ya(a, c, l, u, t / r) } } class ec { constructor(e, t) { this.points = e, this.planes = t } static fromInvProjectionMatrix(e, t, r, n) { const i = Math.pow(2, r), o = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r => { const o = Va([], r, e), s = 1 / o[3] / t * i; return function (e, t, r) { return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e[3] = t[3] * r[3], e }(o, o, [s, s, n ? 1 / o[3] : s, s]) })), s = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((e => { const t = La([], Ba([], Oa([], o[e[0]], o[e[1]]), Oa([], o[e[2]], o[e[1]]))), r = -Ma(t, o[e[1]]); return t.concat(r) })); return new ec(o, s) } } class tc { static fromPoints(e) { const t = [1 / 0, 1 / 0, 1 / 0], r = [-1 / 0, -1 / 0, -1 / 0]; for (const n of e) Sa(t, t, n), Pa(r, r, n); return new tc(t, r) } static applyTransform(e, t) { const r = e.getCorners(); for (let n = 0; n < r.length; ++n)Ra(r[n], r[n], t); return tc.fromPoints(r) } constructor(e, t) { this.min = e, this.max = t, this.center = Ia([], ka([], this.min, this.max), .5) } quadrant(e) { const t = [e % 2 == 0, e < 2], r = ba(this.min), n = ba(this.max); for (let i = 0; i < t.length; i++)r[i] = t[i] ? this.min[i] : this.center[i], n[i] = t[i] ? this.center[i] : this.max[i]; return n[2] = this.max[2], new tc(r, n) } distanceX(e) { return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0] } distanceY(e) { return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1] } distanceZ(e) { return Math.max(Math.min(this.max[2], e[2]), this.min[2]) - e[2] } getCorners() { const e = this.min, t = this.max; return [[e[0], e[1], e[2]], [t[0], e[1], e[2]], [t[0], t[1], e[2]], [e[0], t[1], e[2]], [e[0], e[1], t[2]], [t[0], e[1], t[2]], [t[0], t[1], t[2]], [e[0], t[1], t[2]]] } intersects(e) { const t = this.getCorners(); let r = !0; for (let n = 0; n < e.planes.length; n++) { const i = e.planes[n]; let o = 0; for (let e = 0; e < t.length; e++)o += Ma(i, t[e]) + i[3] >= 0; if (0 === o) return 0; o !== t.length && (r = !1) } if (r) return 2; for (let n = 0; n < 3; n++) { let t = Number.MAX_VALUE, r = -Number.MAX_VALUE; for (let i = 0; i < e.points.length; i++) { const o = e.points[i][n] - this.min[n]; t = Math.min(t, o), r = Math.max(r, o) } if (r < 0 || t > this.max[n] - this.min[n]) return 0 } return 1 } } const rc = 5, nc = 6, ic = ia / Math.PI / 2, oc = 16383, sc = 64, ac = [sc, 32, 16], cc = -ic, lc = ic, uc = [new tc([cc, cc, cc], [lc, lc, lc]), new tc([cc, cc, cc], [0, 0, lc]), new tc([0, cc, cc], [lc, 0, lc]), new tc([cc, 0, cc], [0, lc, lc]), new tc([0, 0, cc], [lc, lc, lc])]; function hc(e) { return e * ic / Fc } function dc(e, t, r, n = !0) { const i = Ia([], e._camera.position, e.worldSize), o = [t, r, 1, 1]; Va(o, o, e.pixelMatrixInverse), Na(o, o, 1 / o[3]); const s = La([], Oa([], o, i)), a = e.globeMatrix, c = [a[12], a[13], a[14]], l = Oa([], c, i), u = wa(l), h = La([], l), d = e.worldSize / (2 * Math.PI), p = Ma(h, s), f = Math.asin(d / u); if (f < Math.acos(p)) { if (!n) return null; const e = [], t = []; Ia(e, s, u / p), La(t, Oa(t, e, l)), La(s, ka(s, l, Ia(s, t, Math.tan(f) * u))) } const m = []; new Ka(i, s).closestPointOnSphere(c, d, m); const g = La([], Q(a, 0)), _ = La([], Q(a, 1)), y = La([], Q(a, 2)), x = Ma(g, m), b = Ma(_, m), w = Ma(y, m), T = v(Math.asin(-b / d)); let C = v(Math.atan2(x, w)); C = e.center.lng + function (e, t) { const r = (t - e + 180) % 360 - 180; return r < -180 ? r + 360 : r }(e.center.lng, C); const E = Nc(C), S = k(Gc(T), 0, 1); return new Hc(E, S) } class pc { constructor(e, t, r) { this.a = Oa([], e, r), this.b = Oa([], t, r), this.center = r; const n = La([], this.a), i = La([], this.b); this.angle = Math.acos(Ma(n, i)) } } function fc(e, t) { if (0 === e.angle) return null; let r; return r = 0 === e.a[t] ? 1 / e.angle * .5 * Math.PI : 1 / e.angle * Math.atan(e.b[t] / e.a[t] / Math.sin(e.angle) - 1 / Math.tan(e.angle)), r < 0 || r > 1 ? null : function (e, t, r, n) { const i = Math.sin(r); return e * (Math.sin((1 - n) * r) / i) + t * (Math.sin(n * r) / i) }(e.a[t], e.b[t], e.angle, k(r, 0, 1)) + e.center[t] } function mc(e) { if (e.z <= 1) return uc[e.z + 2 * e.y + e.x]; const t = bc(xc(e)); return tc.fromPoints(t) } function gc(e, t, r) { return Ia(e, e, 1 - r), Aa(e, e, t, r) } function _c(e, t) { const r = Ac(t.zoom); if (0 === r) return mc(e); const n = xc(e), i = bc(n), o = Nc(n.getWest()) * t.worldSize, s = Nc(n.getEast()) * t.worldSize, a = Gc(n.getNorth()) * t.worldSize, c = Gc(n.getSouth()) * t.worldSize, l = [o, a, 0], u = [s, a, 0], h = [o, c, 0], d = [s, c, 0], p = ha([], t.globeMatrix); return Ra(l, l, p), Ra(u, u, p), Ra(h, h, p), Ra(d, d, p), i[0] = gc(i[0], h, r), i[1] = gc(i[1], d, r), i[2] = gc(i[2], u, r), i[3] = gc(i[3], l, r), tc.fromPoints(i) } function yc(e, t, r) { for (const n of e) Ra(n, n, t), Ia(n, n, r) } function vc(e, t, r) { const n = t / e.worldSize, i = e.globeMatrix; if (r.z <= 1) { const e = mc(r).getCorners(); return yc(e, i, n), tc.fromPoints(e) } const o = xc(r), s = bc(o); yc(s, i, n); const a = Number.MAX_VALUE, c = [-a, -a, -a], l = [a, a, a]; if (o.contains(e.center)) { for (const e of s) Sa(l, l, e), Pa(c, c, e); c[2] = 0; const t = e.point, r = [t.x * n, t.y * n, 0]; return Sa(l, l, r), Pa(c, c, r), new tc(l, c) } const u = [i[12] * n, i[13] * n, i[14] * n], h = o.getCenter(), d = k(e.center.lat, -Wc, Wc), p = k(h.lat, -Wc, Wc), f = Nc(e.center.lng), m = Gc(d); let g = f - Nc(h.lng); const _ = m - Gc(p); g > .5 ? g -= 1 : g < -.5 && (g += 1); let v = 0; Math.abs(g) > Math.abs(_) ? v = g >= 0 ? 1 : 3 : (v = _ >= 0 ? 0 : 2, Aa(u, u, [i[4] * n, i[5] * n, i[6] * n], -Math.sin(y(_ >= 0 ? o.getSouth() : o.getNorth())) * ic)); const x = s[v], b = s[(v + 1) % 4], w = new pc(x, b, u), T = [fc(w, 0) || x[0], fc(w, 1) || x[1], fc(w, 2) || x[2]], C = Ac(e.zoom); if (C > 0) { const n = function ({ x: e, y: t, z: r }, n, i, o, s) { const a = 1 / (1 << r); let c = e * a, l = c + a, u = t * a, h = u + a, d = 0; const p = (c + l) / 2 - o; return p > .5 ? d = -1 : p < -.5 && (d = 1), c = ((c + d) * n - (o *= n)) * i + o, l = ((l + d) * n - o) * i + o, u = (u * n - (s *= n)) * i + s, h = (h * n - s) * i + s, [[c, h, 0], [l, h, 0], [l, u, 0], [c, u, 0]] }(r, t, e._pixelsPerMercatorPixel, f, m); for (let e = 0; e < s.length; e++)gc(s[e], n[e], C); const i = ka([], n[v], n[(v + 1) % 4]); Ia(i, i, .5), gc(T, i, C) } for (const y of s) Sa(l, l, y), Pa(c, c, y); return l[2] = Math.min(x[2], b[2]), Sa(l, l, T), Pa(c, c, T), new tc(l, c) } function xc({ x: e, y: t, z: r }) { const n = 1 / (1 << r), i = new zc(qc(e * n), jc((t + 1) * n)), o = new zc(qc((e + 1) * n), jc(t * n)); return new oa(i, o) } function bc(e) { const t = y(e.getNorth()), r = y(e.getSouth()), n = Math.cos(t), i = Math.cos(r), o = Math.sin(t), s = Math.sin(r), a = e.getWest(), c = e.getEast(); return [wc(i, s, a), wc(i, s, c), wc(n, o, c), wc(n, o, a)] } function wc(e, t, r, n = ic) { return r = y(r), [e * Math.sin(r) * n, -t * n, e * Math.cos(r) * n] } function Tc(e, t, r) { return wc(Math.cos(y(e)), Math.sin(y(e)), t, r) } function kc(e, t, r, n) { const i = 1 << r.z, o = (e / ia + r.x) / i; return Tc(jc((t / ia + r.y) / i), qc(o), n) } function Cc({ min: e, max: t }) { return oc / Math.max(t[0] - e[0], t[1] - e[1], t[2] - e[2]) } const Ec = new Float64Array(16); function Sc(e) { const t = Cc(e), r = _a(Ec, [t, t, t]); return pa(r, r, ((n = [])[0] = -(i = e.min)[0], n[1] = -i[1], n[2] = -i[2], n)); var n, i } function Pc(e) { const t = (n = e.min, (r = Ec)[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = n[0], r[13] = n[1], r[14] = n[2], r[15] = 1, r); var r, n; const i = 1 / Cc(e); return fa(t, t, [i, i, i]) } function Ic(e, t, r, n, i) { const o = function (e) { const t = ia / (2 * Math.PI); return e / (2 * Math.PI) / t }(r), s = [e, t, -r / (2 * Math.PI)], a = ua(new Float64Array(16)); return pa(a, a, s), fa(a, a, [o, o, o]), ma(a, a, y(-i)), ga(a, a, y(-n)), a } function Ac(e) { return C(rc, nc, e) } function Lc(e, t) { const r = Tc(t.lat, t.lng), n = function (e) { const t = Tc(e._center.lat, e._center.lng); let r = Ba([], Ta(0, 1, 0), t); const n = ya([], -e.angle, t); r = Ra(r, r, n), ya(n, -e._pitch, r); const i = La([], t); return Ia(i, i, hc(e.cameraToCenterDistance / e.pixelsPerMeter)), Ra(i, i, n), ka([], t, i) }(e); return s = (i = Ca([], n, r))[0], a = i[1], c = i[2], l = (o = r)[0], u = o[1], h = o[2], p = (d = Math.sqrt(s * s + a * a + c * c) * Math.sqrt(l * l + u * u + h * h)) && Ma(i, o) / d, Math.acos(Math.min(Math.max(p, -1), 1)); var i, o, s, a, c, l, u, h, d, p } function Mc(e, t) { return Lc(e, t) > Math.PI / 2 * 1.01 } const Bc = y(85), Rc = Math.cos(Bc), Dc = Math.sin(Bc), Fc = 6371008.8, Oc = 2 * Math.PI * Fc; class zc { constructor(e, t) { if (isNaN(e) || isNaN(t)) throw new Error(`Invalid LngLat object: (${e}, ${t})`); if (this.lng = +e, this.lat = +t, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90") } wrap() { return new zc(E(this.lng, -180, 180), this.lat) } toArray() { return [this.lng, this.lat] } toString() { return `LngLat(${this.lng}, ${this.lat})` } distanceTo(e) { const t = Math.PI / 180, r = this.lat * t, n = e.lat * t, i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((e.lng - this.lng) * t); return Fc * Math.acos(Math.min(i, 1)) } toBounds(e = 0) { const t = 360 * e / 40075017, r = t / Math.cos(Math.PI / 180 * this.lat); return new oa(new zc(this.lng - r, this.lat - t), new zc(this.lng + r, this.lat + t)) } toEcef(e) { const t = hc(e); return Tc(this.lat, this.lng, ic + t) } static convert(e) { if (e instanceof zc) return e; if (Array.isArray(e) && (2 === e.length || 3 === e.length)) return new zc(Number(e[0]), Number(e[1])); if (!Array.isArray(e) && "object" == typeof e && null !== e) return new zc(Number("lng" in e ? e.lng : e.lon), Number(e.lat)); throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]") } } function Uc(e) { return Oc * Math.cos(e * Math.PI / 180) } function Nc(e) { return (180 + e) / 360 } function Gc(e) { return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e * Math.PI / 360))) / 360 } function Vc(e, t) { return e / Uc(t) } function qc(e) { return 360 * e - 180 } function jc(e) { return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * e) * Math.PI / 180)) - 90 } function Xc(e, t) { return e * Uc(jc(t)) } const Wc = 85.051129; function Zc(e) { return 1 / Math.cos(e * Math.PI / 180) } class Hc { constructor(e, t, r = 0) { this.x = +e, this.y = +t, this.z = +r } static fromLngLat(e, t = 0) { const r = zc.convert(e); return new Hc(Nc(r.lng), Gc(r.lat), Vc(t, r.lat)) } toLngLat() { return new zc(qc(this.x), jc(this.y)) } toAltitude() { return Xc(this.z, this.y) } meterInMercatorCoordinateUnits() { return 1 / Oc * Zc(jc(this.y)) } } function Qc(e, t, r, n, i, o, s, a, c) { const l = (t + n) / 2, u = (r + i) / 2, h = new f(l, u); a(h), function (e, t, r, n, i, o) { const s = r - i, a = n - o; return Math.abs((n - t) * s - (r - e) * a) / Math.hypot(s, a) }(h.x, h.y, o.x, o.y, s.x, s.y) >= c ? (Qc(e, t, r, l, u, o, h, a, c), Qc(e, l, u, n, i, h, s, a, c)) : e.push(s) } function $c(e, t, r) { let n = e[0], i = n.x, o = n.y; t(n); const s = [n]; for (let a = 1; a < e.length; a++) { const c = e[a], { x: l, y: u } = c; t(c), Qc(s, i, o, l, u, n, c, t, r), i = l, o = u, n = c } return s } function Jc(e, t, r, n) { if (n(t, r)) { const i = t.add(r)._mult(.5); Jc(e, t, i, n), Jc(e, i, r, n) } else e.push(r) } function Kc(e, t) { let r = e[0]; const n = [r]; for (let i = 1; i < e.length; i++) { const o = e[i]; Jc(n, r, o, t), r = o } return n } const Yc = Math.pow(2, 14) - 1, el = -Yc - 1; function tl(e, t) { const r = Math.round(e.x * t), n = Math.round(e.y * t); return e.x = k(r, el, Yc), e.y = k(n, el, Yc), (r < e.x || r > e.x + 1 || n < e.y || n > e.y + 1) && G("Geometry exceeds allowed extent, reduce your vector tile buffer size"), e } function rl(e, t, r) { const n = e.loadGeometry(), i = e.extent, o = ia / i; if (t && r && r.projection.isReprojectedInTileSpace) { const o = 1 << t.z, { scale: s, x: a, y: c, projection: l } = r, u = e => { const r = qc((t.x + e.x / i) / o), n = jc((t.y + e.y / i) / o), u = l.project(r, n); e.x = (u.x * s - a) * i, e.y = (u.y * s - c) * i }; for (let t = 0; t < n.length; t++)if (1 !== e.type) n[t] = $c(n[t], u, 1); else { const e = []; for (const r of n[t]) r.x < 0 || r.x >= i || r.y < 0 || r.y >= i || (u(r), e.push(r)); n[t] = e } } for (const s of n) for (const e of s) tl(e, o); return n } function nl(e, t) { return { type: e.type, id: e.id, properties: e.properties, geometry: t ? rl(e) : [] } } function il(e, t, r, n, i) { e.emplaceBack(2 * t + (n + 1) / 2, 2 * r + (i + 1) / 2) } function ol(e, t, r) { const n = 16384; e.emplaceBack(t.x, t.y, t.z, r[0] * n, r[1] * n, r[2] * n) } class sl { constructor(e) { this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((e => e.id)), this.index = e.index, this.hasPattern = !1, this.projection = e.projection, this.layoutVertexArray = new Uo, this.indexArray = new ts, this.segments = new na, this.programConfigurations = new Zs(e.layers, e.zoom), this.stateDependentLayerIds = this.layers.filter((e => e.isStateDependent())).map((e => e.id)) } populate(e, t, r, n) { const i = this.layers[0], o = []; let s = null; "circle" === i.type && (s = i.layout.get("circle-sort-key")); for (const { feature: c, id: l, index: u, sourceLayerIndex: h } of e) { const e = this.layers[0]._featureFilter.needGeometry, t = nl(c, e); if (!this.layers[0]._featureFilter.filter(new xo(this.zoom), t, r)) continue; const i = s ? s.evaluate(t, {}, r) : void 0, a = { id: l, properties: c.properties, type: c.type, sourceLayerIndex: h, index: u, geometry: e ? t.geometry : rl(c, r, n), patterns: {}, sortKey: i }; o.push(a) } s && o.sort(((e, t) => e.sortKey - t.sortKey)); let a = null; "globe" === n.projection.name && (this.globeExtVertexArray = new Wo, a = n.projection); for (const c of o) { const { geometry: n, index: i, sourceLayerIndex: o } = c, s = e[i].feature; this.addFeature(c, n, i, t.availableImages, r, a), t.featureIndex.insert(s, n, i, o, this.index) } } update(e, t, r, n) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, r, n) } isEmpty() { return 0 === this.layoutVertexArray.length } uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload } upload(e) { this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, ta.members), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, ra.members))), this.programConfigurations.upload(e), this.uploaded = !0 } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy()) } addFeature(e, t, r, n, i, o) { for (const s of t) for (const t of s) { const r = t.x, n = t.y; if (r < 0 || r >= ia || n < 0 || n >= ia) continue; if (o) { const e = o.projectTilePoint(r, n, i), t = o.upVector(i, r, n), s = this.globeExtVertexArray; ol(s, e, t), ol(s, e, t), ol(s, e, t), ol(s, e, t) } const s = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e.sortKey), a = s.vertexLength; il(this.layoutVertexArray, r, n, -1, -1), il(this.layoutVertexArray, r, n, 1, -1), il(this.layoutVertexArray, r, n, 1, 1), il(this.layoutVertexArray, r, n, -1, 1), this.indexArray.emplaceBack(a, a + 1, a + 2), this.indexArray.emplaceBack(a, a + 2, a + 3), s.vertexLength += 4, s.primitiveLength += 2 } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, r, {}, n, i) } } function al(e, t) { for (let r = 0; r < e.length; r++)if (gl(t, e[r])) return !0; for (let r = 0; r < t.length; r++)if (gl(e, t[r])) return !0; return !!hl(e, t) } function cl(e, t, r) { return !!gl(e, t) || !!pl(t, e, r) } function ll(e, t) { if (1 === e.length) return ml(t, e[0]); for (let r = 0; r < t.length; r++) { const n = t[r]; for (let t = 0; t < n.length; t++)if (gl(e, n[t])) return !0 } for (let r = 0; r < e.length; r++)if (ml(t, e[r])) return !0; for (let r = 0; r < t.length; r++)if (hl(e, t[r])) return !0; return !1 } function ul(e, t, r) { if (e.length > 1) { if (hl(e, t)) return !0; for (let n = 0; n < t.length; n++)if (pl(t[n], e, r)) return !0 } for (let n = 0; n < e.length; n++)if (pl(e[n], t, r)) return !0; return !1 } function hl(e, t) { if (0 === e.length || 0 === t.length) return !1; for (let r = 0; r < e.length - 1; r++) { const n = e[r], i = e[r + 1]; for (let e = 0; e < t.length - 1; e++)if (dl(n, i, t[e], t[e + 1])) return !0 } return !1 } function dl(e, t, r, n) { return V(e, r, n) !== V(t, r, n) && V(e, t, r) !== V(e, t, n) } function pl(e, t, r) { const n = r * r; if (1 === t.length) return e.distSqr(t[0]) < n; for (let i = 1; i < t.length; i++)if (fl(e, t[i - 1], t[i]) < n) return !0; return !1 } function fl(e, t, r) { const n = t.distSqr(r); if (0 === n) return e.distSqr(t); const i = ((e.x - t.x) * (r.x - t.x) + (e.y - t.y) * (r.y - t.y)) / n; return e.distSqr(i < 0 ? t : i > 1 ? r : r.sub(t)._mult(i)._add(t)) } function ml(e, t) { let r, n, i, o = !1; for (let s = 0; s < e.length; s++) { r = e[s]; for (let e = 0, s = r.length - 1; e < r.length; s = e++)n = r[e], i = r[s], n.y > t.y != i.y > t.y && t.x < (i.x - n.x) * (t.y - n.y) / (i.y - n.y) + n.x && (o = !o) } return o } function gl(e, t) { let r = !1; for (let n = 0, i = e.length - 1; n < e.length; i = n++) { const o = e[n], s = e[i]; o.y > t.y != s.y > t.y && t.x < (s.x - o.x) * (t.y - o.y) / (s.y - o.y) + o.x && (r = !r) } return r } function _l(e, t, r, n, i) { for (const s of e) if (t <= s.x && r <= s.y && n >= s.x && i >= s.y) return !0; const o = [new f(t, r), new f(t, i), new f(n, i), new f(n, r)]; if (e.length > 2) for (const s of o) if (gl(e, s)) return !0; for (let s = 0; s < e.length - 1; s++)if (yl(e[s], e[s + 1], o)) return !0; return !1 } function yl(e, t, r) { const n = r[0], i = r[2]; if (e.x < n.x && t.x < n.x || e.x > i.x && t.x > i.x || e.y < n.y && t.y < n.y || e.y > i.y && t.y > i.y) return !1; const o = V(e, t, r[0]); return o !== V(e, t, r[1]) || o !== V(e, t, r[2]) || o !== V(e, t, r[3]) } function vl(e, t, r) { const n = t.paint.get(e).value; return "constant" === n.kind ? n.value : r.programConfigurations.get(t.id).getMaxValue(e) } function xl(e) { return Math.sqrt(e[0] * e[0] + e[1] * e[1]) } function bl(e, t, r, n, i) { if (!t[0] && !t[1]) return e; const o = f.convert(t)._mult(i); "viewport" === r && o._rotate(-n); const s = []; for (let a = 0; a < e.length; a++)s.push(e[a].sub(o)); return s } function wl(e, t, r, n) { const i = f.convert(e)._mult(n); return "viewport" === t && i._rotate(-r), i } Zi(sl, "CircleBucket", { omit: ["layers"] }); const Tl = new Mo({ "circle-sort-key": new Ao(Ke.layout_circle["circle-sort-key"]) }); var kl = { paint: new Mo({ "circle-radius": new Ao(Ke.paint_circle["circle-radius"]), "circle-color": new Ao(Ke.paint_circle["circle-color"]), "circle-blur": new Ao(Ke.paint_circle["circle-blur"]), "circle-opacity": new Ao(Ke.paint_circle["circle-opacity"]), "circle-translate": new Io(Ke.paint_circle["circle-translate"]), "circle-translate-anchor": new Io(Ke.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Io(Ke.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Io(Ke.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Ao(Ke.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Ao(Ke.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Ao(Ke.paint_circle["circle-stroke-opacity"]) }), layout: Tl }; function Cl(e, t, r, n, i, o, s, a, c) { if (o && e.queryGeometry.isAboveHorizon) return !1; o && (c *= e.pixelToTileUnitsFactor); const l = e.tileID.canonical, u = r.projection.upVectorScale(l, r.center.lat, r.worldSize).metersToTile; for (const h of t) for (const t of h) { const h = t.add(a), d = i && r.elevation ? r.elevation.exaggeration() * i.getElevationAt(h.x, h.y, !0) : 0, p = r.projection.projectTilePoint(h.x, h.y, l); if (d > 0) { const e = r.projection.upVector(l, h.x, h.y); p.x += e[0] * u * d, p.y += e[1] * u * d, p.z += e[2] * u * d } const f = o ? h : El(p.x, p.y, p.z, n), m = o ? e.tilespaceRays.map((e => Il(e, d))) : e.queryGeometry.screenGeometry, g = Va([], [p.x, p.y, p.z, 1], n); if (!s && o ? c *= g[3] / r.cameraToCenterDistance : s && !o && (c *= r.cameraToCenterDistance / g[3]), o) { const e = jc((t.y / ia + l.y) / (1 << l.z)); c /= r.projection.pixelsPerMeter(e, 1) / Vc(1, e) } if (cl(m, f, c)) return !0 } return !1 } function El(e, t, r, n) { const i = Va([], [e, t, r, 1], n); return new f(i[0] / i[3], i[1] / i[3]) } const Sl = Ta(0, 0, 0), Pl = Ta(0, 0, 1); function Il(e, t) { const r = xa(); return Sl[2] = t, e.intersectsPlane(Sl, Pl, r), new f(r[0], r[1]) } class Al extends sl { } function Ll(e, { width: t, height: r }, n, i) { if (i) { if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer); else if (i.length !== t * r * n) throw new RangeError("mismatched image size") } else i = new Uint8Array(t * r * n); return e.width = t, e.height = r, e.data = i, e } function Ml(e, t, r) { const { width: n, height: i } = t; n === e.width && i === e.height || (Bl(e, t, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(e.width, n), height: Math.min(e.height, i) }, r), e.width = n, e.height = i, e.data = t.data) } function Bl(e, t, r, n, i, o) { if (0 === i.width || 0 === i.height) return t; if (i.width > e.width || i.height > e.height || r.x > e.width - i.width || r.y > e.height - i.height) throw new RangeError("out of range source coordinates for image copy"); if (i.width > t.width || i.height > t.height || n.x > t.width - i.width || n.y > t.height - i.height) throw new RangeError("out of range destination coordinates for image copy"); const s = e.data, a = t.data; for (let c = 0; c < i.height; c++) { const l = ((r.y + c) * e.width + r.x) * o, u = ((n.y + c) * t.width + n.x) * o; for (let e = 0; e < i.width * o; e++)a[u + e] = s[l + e] } return t } Zi(Al, "HeatmapBucket", { omit: ["layers"] }); class Rl { constructor(e, t) { Ll(this, e, 1, t) } resize(e) { Ml(this, new Rl(e), 1) } clone() { return new Rl({ width: this.width, height: this.height }, new Uint8Array(this.data)) } static copy(e, t, r, n, i) { Bl(e, t, r, n, i, 1) } } class Dl { constructor(e, t) { Ll(this, e, 4, t) } resize(e) { Ml(this, new Dl(e), 4) } replace(e, t) { t ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e } clone() { return new Dl({ width: this.width, height: this.height }, new Uint8Array(this.data)) } static copy(e, t, r, n, i) { Bl(e, t, r, n, i, 4) } } Zi(Rl, "AlphaImage"), Zi(Dl, "RGBAImage"); var Fl = { paint: new Mo({ "heatmap-radius": new Ao(Ke.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Ao(Ke.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Io(Ke.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Lo(Ke.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Io(Ke.paint_heatmap["heatmap-opacity"]) }) }; function Ol(e) { const t = {}, r = e.resolution || 256, n = e.clips ? e.clips.length : 1, i = e.image || new Dl({ width: r, height: n }), o = (r, n, o) => { t[e.evaluationKey] = o; const s = e.expression.evaluate(t); i.data[r + n + 0] = Math.floor(255 * s.r / s.a), i.data[r + n + 1] = Math.floor(255 * s.g / s.a), i.data[r + n + 2] = Math.floor(255 * s.b / s.a), i.data[r + n + 3] = Math.floor(255 * s.a) }; if (e.clips) for (let s = 0, a = 0; s < n; ++s, a += 4 * r)for (let t = 0, n = 0; t < r; t++, n += 4) { const i = t / (r - 1), { start: c, end: l } = e.clips[s]; o(a, n, c * (1 - i) + l * i) } else for (let s = 0, a = 0; s < r; s++, a += 4)o(0, a, s / (r - 1)); return i } var zl = { paint: new Mo({ "hillshade-illumination-direction": new Io(Ke.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Io(Ke.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Io(Ke.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Io(Ke.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Io(Ke.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Io(Ke.paint_hillshade["hillshade-accent-color"]) }) }; const Ul = Oo([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Nl } = Ul; var Gl = {}; function Vl(e, t, r) { r = r || 2; var n, i, o, s, a, c, l, u = t && t.length, h = u ? t[0] * r : e.length, d = ql(e, 0, h, r, !0), p = []; if (!d || d.next === d.prev) return p; if (u && (d = function (e, t, r, n) { var i, o, s, a = []; for (i = 0, o = t.length; i < o; i++)(s = ql(e, t[i] * n, i < o - 1 ? t[i + 1] * n : e.length, n, !1)) === s.next && (s.steiner = !0), a.push(eu(s)); for (a.sort($l), i = 0; i < a.length; i++)r = Jl(a[i], r); return r }(e, t, d, r)), e.length > 80 * r) { n = o = e[0], i = s = e[1]; for (var f = r; f < h; f += r)(a = e[f]) < n && (n = a), (c = e[f + 1]) < i && (i = c), a > o && (o = a), c > s && (s = c); l = 0 !== (l = Math.max(o - n, s - i)) ? 32767 / l : 0 } return Xl(d, p, r, n, i, l, 0), p } function ql(e, t, r, n, i) { var o, s; if (i === pu(e, t, r, n) > 0) for (o = t; o < r; o += n)s = uu(o, e[o], e[o + 1], s); else for (o = r - n; o >= t; o -= n)s = uu(o, e[o], e[o + 1], s); return s && iu(s, s.next) && (hu(s), s = s.next), s } function jl(e, t) { if (!e) return e; t || (t = e); var r, n = e; do { if (r = !1, n.steiner || !iu(n, n.next) && 0 !== nu(n.prev, n, n.next)) n = n.next; else { if (hu(n), (n = t = n.prev) === n.next) break; r = !0 } } while (r || n !== t); return t } function Xl(e, t, r, n, i, o, s) { if (e) { !s && o && function (e, t, r, n) { var i = e; do { 0 === i.z && (i.z = Yl(i.x, i.y, t, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next } while (i !== e); i.prevZ.nextZ = null, i.prevZ = null, function (e) { var t, r, n, i, o, s, a, c, l = 1; do { for (r = e, e = null, o = null, s = 0; r;) { for (s++, n = r, a = 0, t = 0; t < l && (a++, n = n.nextZ); t++); for (c = l; a > 0 || c > 0 && n;)0 !== a && (0 === c || !n || r.z <= n.z) ? (i = r, r = r.nextZ, a--) : (i = n, n = n.nextZ, c--), o ? o.nextZ = i : e = i, i.prevZ = o, o = i; r = n } o.nextZ = null, l *= 2 } while (s > 1) }(i) }(e, n, i, o); for (var a, c, l = e; e.prev !== e.next;)if (a = e.prev, c = e.next, o ? Zl(e, n, i, o) : Wl(e)) t.push(a.i / r | 0), t.push(e.i / r | 0), t.push(c.i / r | 0), hu(e), e = c.next, l = c.next; else if ((e = c) === l) { s ? 1 === s ? Xl(e = Hl(jl(e), t, r), t, r, n, i, o, 2) : 2 === s && Ql(e, t, r, n, i, o) : Xl(jl(e), t, r, n, i, o, 1); break } } } function Wl(e) { var t = e.prev, r = e, n = e.next; if (nu(t, r, n) >= 0) return !1; for (var i = t.x, o = r.x, s = n.x, a = t.y, c = r.y, l = n.y, u = i < o ? i < s ? i : s : o < s ? o : s, h = a < c ? a < l ? a : l : c < l ? c : l, d = i > o ? i > s ? i : s : o > s ? o : s, p = a > c ? a > l ? a : l : c > l ? c : l, f = n.next; f !== t;) { if (f.x >= u && f.x <= d && f.y >= h && f.y <= p && tu(i, a, o, c, s, l, f.x, f.y) && nu(f.prev, f, f.next) >= 0) return !1; f = f.next } return !0 } function Zl(e, t, r, n) { var i = e.prev, o = e, s = e.next; if (nu(i, o, s) >= 0) return !1; for (var a = i.x, c = o.x, l = s.x, u = i.y, h = o.y, d = s.y, p = a < c ? a < l ? a : l : c < l ? c : l, f = u < h ? u < d ? u : d : h < d ? h : d, m = a > c ? a > l ? a : l : c > l ? c : l, g = u > h ? u > d ? u : d : h > d ? h : d, _ = Yl(p, f, t, r, n), y = Yl(m, g, t, r, n), v = e.prevZ, x = e.nextZ; v && v.z >= _ && x && x.z <= y;) { if (v.x >= p && v.x <= m && v.y >= f && v.y <= g && v !== i && v !== s && tu(a, u, c, h, l, d, v.x, v.y) && nu(v.prev, v, v.next) >= 0) return !1; if (v = v.prevZ, x.x >= p && x.x <= m && x.y >= f && x.y <= g && x !== i && x !== s && tu(a, u, c, h, l, d, x.x, x.y) && nu(x.prev, x, x.next) >= 0) return !1; x = x.nextZ } for (; v && v.z >= _;) { if (v.x >= p && v.x <= m && v.y >= f && v.y <= g && v !== i && v !== s && tu(a, u, c, h, l, d, v.x, v.y) && nu(v.prev, v, v.next) >= 0) return !1; v = v.prevZ } for (; x && x.z <= y;) { if (x.x >= p && x.x <= m && x.y >= f && x.y <= g && x !== i && x !== s && tu(a, u, c, h, l, d, x.x, x.y) && nu(x.prev, x, x.next) >= 0) return !1; x = x.nextZ } return !0 } function Hl(e, t, r) { var n = e; do { var i = n.prev, o = n.next.next; !iu(i, o) && ou(i, n, n.next, o) && cu(i, o) && cu(o, i) && (t.push(i.i / r | 0), t.push(n.i / r | 0), t.push(o.i / r | 0), hu(n), hu(n.next), n = e = o), n = n.next } while (n !== e); return jl(n) } function Ql(e, t, r, n, i, o) { var s = e; do { for (var a = s.next.next; a !== s.prev;) { if (s.i !== a.i && ru(s, a)) { var c = lu(s, a); return s = jl(s, s.next), c = jl(c, c.next), Xl(s, t, r, n, i, o, 0), void Xl(c, t, r, n, i, o, 0) } a = a.next } s = s.next } while (s !== e) } function $l(e, t) { return e.x - t.x } function Jl(e, t) { var r = function (e, t) { var r, n = t, i = e.x, o = e.y, s = -1 / 0; do { if (o <= n.y && o >= n.next.y && n.next.y !== n.y) { var a = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (a <= i && a > s && (s = a, r = n.x < n.next.x ? n : n.next, a === i)) return r } n = n.next } while (n !== t); if (!r) return null; var c, l = r, u = r.x, h = r.y, d = 1 / 0; n = r; do { i >= n.x && n.x >= u && i !== n.x && tu(o < h ? i : s, o, u, h, o < h ? s : i, o, n.x, n.y) && (c = Math.abs(o - n.y) / (i - n.x), cu(n, e) && (c < d || c === d && (n.x > r.x || n.x === r.x && Kl(r, n))) && (r = n, d = c)), n = n.next } while (n !== l); return r }(e, t); if (!r) return t; var n = lu(r, e); return jl(n, n.next), jl(r, r.next) } function Kl(e, t) { return nu(e.prev, e, t.prev) < 0 && nu(t.next, e, e.next) < 0 } function Yl(e, t, r, n, i) { return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - r) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - n) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1 } function eu(e) { var t = e, r = e; do { (t.x < r.x || t.x === r.x && t.y < r.y) && (r = t), t = t.next } while (t !== e); return r } function tu(e, t, r, n, i, o, s, a) { return (i - s) * (t - a) >= (e - s) * (o - a) && (e - s) * (n - a) >= (r - s) * (t - a) && (r - s) * (o - a) >= (i - s) * (n - a) } function ru(e, t) { return e.next.i !== t.i && e.prev.i !== t.i && !function (e, t) { var r = e; do { if (r.i !== e.i && r.next.i !== e.i && r.i !== t.i && r.next.i !== t.i && ou(r, r.next, e, t)) return !0; r = r.next } while (r !== e); return !1 }(e, t) && (cu(e, t) && cu(t, e) && function (e, t) { var r = e, n = !1, i = (e.x + t.x) / 2, o = (e.y + t.y) / 2; do { r.y > o != r.next.y > o && r.next.y !== r.y && i < (r.next.x - r.x) * (o - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next } while (r !== e); return n }(e, t) && (nu(e.prev, e, t.prev) || nu(e, t.prev, t)) || iu(e, t) && nu(e.prev, e, e.next) > 0 && nu(t.prev, t, t.next) > 0) } function nu(e, t, r) { return (t.y - e.y) * (r.x - t.x) - (t.x - e.x) * (r.y - t.y) } function iu(e, t) { return e.x === t.x && e.y === t.y } function ou(e, t, r, n) { var i = au(nu(e, t, r)), o = au(nu(e, t, n)), s = au(nu(r, n, e)), a = au(nu(r, n, t)); return i !== o && s !== a || !(0 !== i || !su(e, r, t)) || !(0 !== o || !su(e, n, t)) || !(0 !== s || !su(r, e, n)) || !(0 !== a || !su(r, t, n)) } function su(e, t, r) { return t.x <= Math.max(e.x, r.x) && t.x >= Math.min(e.x, r.x) && t.y <= Math.max(e.y, r.y) && t.y >= Math.min(e.y, r.y) } function au(e) { return e > 0 ? 1 : e < 0 ? -1 : 0 } function cu(e, t) { return nu(e.prev, e, e.next) < 0 ? nu(e, t, e.next) >= 0 && nu(e, e.prev, t) >= 0 : nu(e, t, e.prev) < 0 || nu(e, e.next, t) < 0 } function lu(e, t) { var r = new du(e.i, e.x, e.y), n = new du(t.i, t.x, t.y), i = e.next, o = t.prev; return e.next = t, t.prev = e, r.next = i, i.prev = r, n.next = r, r.prev = n, o.next = n, n.prev = o, n } function uu(e, t, r, n) { var i = new du(e, t, r); return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i } function hu(e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ) } function du(e, t, r) { this.i = e, this.x = t, this.y = r, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function pu(e, t, r, n) { for (var i = 0, o = t, s = r - n; o < r; o += n)i += (e[s] - e[o]) * (e[o + 1] + e[s + 1]), s = o; return i } function fu(e, t, r, n, i) { mu(e, t, r || 0, n || e.length - 1, i || _u) } function mu(e, t, r, n, i) { for (; n > r;) { if (n - r > 600) { var o = n - r + 1, s = t - r + 1, a = Math.log(o), c = .5 * Math.exp(2 * a / 3), l = .5 * Math.sqrt(a * c * (o - c) / o) * (s - o / 2 < 0 ? -1 : 1); mu(e, t, Math.max(r, Math.floor(t - s * c / o + l)), Math.min(n, Math.floor(t + (o - s) * c / o + l)), i) } var u = e[t], h = r, d = n; for (gu(e, r, t), i(e[n], u) > 0 && gu(e, r, n); h < d;) { for (gu(e, h, d), h++, d--; i(e[h], u) < 0;)h++; for (; i(e[d], u) > 0;)d-- } 0 === i(e[r], u) ? gu(e, r, d) : gu(e, ++d, n), d <= t && (r = d + 1), t <= d && (n = d - 1) } } function gu(e, t, r) { var n = e[t]; e[t] = e[r], e[r] = n } function _u(e, t) { return e < t ? -1 : e > t ? 1 : 0 } function yu(e, t) { const r = e.length; if (r <= 1) return [e]; const n = []; let i, o; for (let s = 0; s < r; s++) { const t = q(e[s]); 0 !== t && (e[s].area = Math.abs(t), void 0 === o && (o = t < 0), o === t < 0 ? (i && n.push(i), i = [e[s]]) : i.push(e[s])) } if (i && n.push(i), t > 1) for (let s = 0; s < n.length; s++)n[s].length <= t || (fu(n[s], t, 1, n[s].length - 1, vu), n[s] = n[s].slice(0, t)); return n } function vu(e, t) { return t.area - e.area } function xu(e, t, r) { const n = r.patternDependencies; let i = !1; for (const o of t) { const t = o.paint.get(`${e}-pattern`); t.isConstant() || (i = !0); const r = t.constantOr(null); r && (i = !0, n[r] = !0) } return i } function bu(e, t, r, n, i) { const o = i.patternDependencies; for (const s of t) { const t = s.paint.get(`${e}-pattern`).value; if ("constant" !== t.kind) { let e = t.evaluate({ zoom: n }, r, {}, i.availableImages); e = e && e.name ? e.name : e, o[e] = !0, r.patterns[s.id] = e } } return r } ({ get exports() { return Gl }, set exports(e) { Gl = e } }).exports = Vl, Gl.default = Vl, Vl.deviation = function (e, t, r, n) { var i = t && t.length, o = Math.abs(pu(e, 0, i ? t[0] * r : e.length, r)); if (i) for (var s = 0, a = t.length; s < a; s++)o -= Math.abs(pu(e, t[s] * r, s < a - 1 ? t[s + 1] * r : e.length, r)); var c = 0; for (s = 0; s < n.length; s += 3) { var l = n[s] * r, u = n[s + 1] * r, h = n[s + 2] * r; c += Math.abs((e[l] - e[h]) * (e[u + 1] - e[l + 1]) - (e[l] - e[u]) * (e[h + 1] - e[l + 1])) } return 0 === o && 0 === c ? 0 : Math.abs((c - o) / o) }, Vl.flatten = function (e) { for (var t = e[0][0].length, r = { vertices: [], holes: [], dimensions: t }, n = 0, i = 0; i < e.length; i++) { for (var o = 0; o < e[i].length; o++)for (var s = 0; s < t; s++)r.vertices.push(e[i][o][s]); i > 0 && r.holes.push(n += e[i - 1].length) } return r }; class wu { constructor(e) { this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((e => e.id)), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Uo, this.indexArray = new ts, this.indexArray2 = new as, this.programConfigurations = new Zs(e.layers, e.zoom), this.segments = new na, this.segments2 = new na, this.stateDependentLayerIds = this.layers.filter((e => e.isStateDependent())).map((e => e.id)), this.projection = e.projection } populate(e, t, r, n) { this.hasPattern = xu("fill", this.layers, t); const i = this.layers[0].layout.get("fill-sort-key"), o = []; for (const { feature: s, id: a, index: c, sourceLayerIndex: l } of e) { const e = this.layers[0]._featureFilter.needGeometry, u = nl(s, e); if (!this.layers[0]._featureFilter.filter(new xo(this.zoom), u, r)) continue; const h = i ? i.evaluate(u, {}, r, t.availableImages) : void 0, d = { id: a, properties: s.properties, type: s.type, sourceLayerIndex: l, index: c, geometry: e ? u.geometry : rl(s, r, n), patterns: {}, sortKey: h }; o.push(d) } i && o.sort(((e, t) => e.sortKey - t.sortKey)); for (const s of o) { const { geometry: n, index: i, sourceLayerIndex: o } = s; if (this.hasPattern) { const e = bu("fill", this.layers, s, this.zoom, t); this.patternFeatures.push(e) } else this.addFeature(s, n, i, r, {}, t.availableImages); t.featureIndex.insert(e[i].feature, n, i, o, this.index) } } update(e, t, r, n) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, r, n) } addFeatures(e, t, r, n, i) { for (const o of this.patternFeatures) this.addFeature(o, o.geometry, o.index, t, r, n) } isEmpty() { return 0 === this.layoutVertexArray.length } uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload } upload(e) { this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Nl), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = !0 } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy()) } addFeature(e, t, r, n, i, o = []) { for (const s of yu(t, 500)) { let e = 0; for (const a of s) e += a.length; const t = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray), r = t.vertexLength, n = [], i = []; for (const a of s) { if (0 === a.length) continue; a !== s[0] && i.push(n.length / 2); const e = this.segments2.prepareSegment(a.length, this.layoutVertexArray, this.indexArray2), t = e.vertexLength; this.layoutVertexArray.emplaceBack(a[0].x, a[0].y), this.indexArray2.emplaceBack(t + a.length - 1, t), n.push(a[0].x), n.push(a[0].y); for (let r = 1; r < a.length; r++)this.layoutVertexArray.emplaceBack(a[r].x, a[r].y), this.indexArray2.emplaceBack(t + r - 1, t + r), n.push(a[r].x), n.push(a[r].y); e.vertexLength += a.length, e.primitiveLength += a.length } const o = Gl(n, i); for (let s = 0; s < o.length; s += 3)this.indexArray.emplaceBack(r + o[s], r + o[s + 1], r + o[s + 2]); t.vertexLength += e, t.primitiveLength += o.length / 3 } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, r, i, o, n) } } Zi(wu, "FillBucket", { omit: ["layers", "patternFeatures"] }); const Tu = new Mo({ "fill-sort-key": new Ao(Ke.layout_fill["fill-sort-key"]) }); var ku = { paint: new Mo({ "fill-antialias": new Io(Ke.paint_fill["fill-antialias"]), "fill-opacity": new Ao(Ke.paint_fill["fill-opacity"]), "fill-color": new Ao(Ke.paint_fill["fill-color"]), "fill-outline-color": new Ao(Ke.paint_fill["fill-outline-color"]), "fill-translate": new Io(Ke.paint_fill["fill-translate"]), "fill-translate-anchor": new Io(Ke.paint_fill["fill-translate-anchor"]), "fill-pattern": new Ao(Ke.paint_fill["fill-pattern"]) }), layout: Tu }; const Cu = Oo([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), Eu = Oo([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Su = Oo([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Pu } = Cu; var Iu = f, Au = Lu; function Lu(e, t, r, n, i) { this.properties = {}, this.extent = r, this.type = 0, this._pbf = e, this._geometry = -1, this._keys = n, this._values = i, e.readFields(Mu, this, t) } function Mu(e, t, r) { 1 == e ? t.id = r.readVarint() : 2 == e ? function (e, t) { for (var r = e.readVarint() + e.pos; e.pos < r;) { var n = t._keys[e.readVarint()], i = t._values[e.readVarint()]; t.properties[n] = i } }(r, t) : 3 == e ? t.type = r.readVarint() : 4 == e && (t._geometry = r.pos) } function Bu(e) { for (var t, r, n = 0, i = 0, o = e.length, s = o - 1; i < o; s = i++)n += ((r = e[s]).x - (t = e[i]).x) * (t.y + r.y); return n } Lu.types = ["Unknown", "Point", "LineString", "Polygon"], Lu.prototype.loadGeometry = function () { var e = this._pbf; e.pos = this._geometry; for (var t, r = e.readVarint() + e.pos, n = 1, i = 0, o = 0, s = 0, a = []; e.pos < r;) { if (i <= 0) { var c = e.readVarint(); n = 7 & c, i = c >> 3 } if (i--, 1 === n || 2 === n) o += e.readSVarint(), s += e.readSVarint(), 1 === n && (t && a.push(t), t = []), t.push(new Iu(o, s)); else { if (7 !== n) throw new Error("unknown command " + n); t && t.push(t[0].clone()) } } return t && a.push(t), a }, Lu.prototype.bbox = function () { var e = this._pbf; e.pos = this._geometry; for (var t = e.readVarint() + e.pos, r = 1, n = 0, i = 0, o = 0, s = 1 / 0, a = -1 / 0, c = 1 / 0, l = -1 / 0; e.pos < t;) { if (n <= 0) { var u = e.readVarint(); r = 7 & u, n = u >> 3 } if (n--, 1 === r || 2 === r) (i += e.readSVarint()) < s && (s = i), i > a && (a = i), (o += e.readSVarint()) < c && (c = o), o > l && (l = o); else if (7 !== r) throw new Error("unknown command " + r) } return [s, c, a, l] }, Lu.prototype.toGeoJSON = function (e, t, r) { var n, i, o = this.extent * Math.pow(2, r), s = this.extent * e, a = this.extent * t, c = this.loadGeometry(), l = Lu.types[this.type]; function u(e) { for (var t = 0; t < e.length; t++) { var r = e[t]; e[t] = [360 * (r.x + s) / o - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + a) / o) * Math.PI / 180)) - 90] } } switch (this.type) { case 1: var h = []; for (n = 0; n < c.length; n++)h[n] = c[n][0]; u(c = h); break; case 2: for (n = 0; n < c.length; n++)u(c[n]); break; case 3: for (c = function (e) { var t = e.length; if (t <= 1) return [e]; for (var r, n, i = [], o = 0; o < t; o++) { var s = Bu(e[o]); 0 !== s && (void 0 === n && (n = s < 0), n === s < 0 ? (r && i.push(r), r = [e[o]]) : r.push(e[o])) } return r && i.push(r), i }(c), n = 0; n < c.length; n++)for (i = 0; i < c[n].length; i++)u(c[n][i]) }1 === c.length ? c = c[0] : l = "Multi" + l; var d = { type: "Feature", geometry: { type: l, coordinates: c }, properties: this.properties }; return "id" in this && (d.id = this.id), d }; var Ru = Au, Du = Fu; function Fu(e, t) { this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = e, this._keys = [], this._values = [], this._features = [], e.readFields(Ou, this, t), this.length = this._features.length } function Ou(e, t, r) { 15 === e ? t.version = r.readVarint() : 1 === e ? t.name = r.readString() : 5 === e ? t.extent = r.readVarint() : 2 === e ? t._features.push(r.pos) : 3 === e ? t._keys.push(r.readString()) : 4 === e && t._values.push(function (e) { for (var t = null, r = e.readVarint() + e.pos; e.pos < r;) { var n = e.readVarint() >> 3; t = 1 === n ? e.readString() : 2 === n ? e.readFloat() : 3 === n ? e.readDouble() : 4 === n ? e.readVarint64() : 5 === n ? e.readVarint() : 6 === n ? e.readSVarint() : 7 === n ? e.readBoolean() : null } return t }(r)) } Fu.prototype.feature = function (e) { if (e < 0 || e >= this._features.length) throw new Error("feature index out of bounds"); this._pbf.pos = this._features[e]; var t = this._pbf.readVarint() + this._pbf.pos; return new Ru(this._pbf, t, this.extent, this._keys, this._values) }; var zu = Du; function Uu(e, t, r) { if (3 === e) { var n = new zu(r, r.readVarint() + r.pos); n.length && (t[n.name] = n) } } var Nu = function (e, t) { this.layers = e.readFields(Uu, {}, t) }, Gu = Au; function Vu(e, t, r, n) { const i = [], o = 0 === n ? (e, t, r, n, i, o) => { e.push(new f(o, r + (o - t) / (n - t) * (i - r))) } : (e, t, r, n, i, o) => { e.push(new f(t + (o - r) / (i - r) * (n - t), o)) }; for (const s of e) { const e = []; for (const i of s) { if (i.length <= 2) continue; const s = []; for (let e = 0; e < i.length - 1; e++) { const a = i[e].x, c = i[e].y, l = i[e + 1].x, u = i[e + 1].y, h = 0 === n ? a : c, d = 0 === n ? l : u; h < t ? d > t && o(s, a, c, l, u, t) : h > r ? d < r && o(s, a, c, l, u, r) : s.push(i[e]), d < t && h >= t && o(s, a, c, l, u, t), d > r && h <= r && o(s, a, c, l, u, r) } let a = i[i.length - 1]; const c = 0 === n ? a.x : a.y; c >= t && c <= r && s.push(a), s.length && (a = s[s.length - 1], s[0].x === a.x && s[0].y === a.y || s.push(s[0]), e.push(s)) } e.length && i.push(e) } return i } const qu = Gu.types, ju = Math.pow(2, 13), Xu = 7, Wu = 450; function Zu(e, t, r, n, i, o, s, a) { e.emplaceBack((t << 1) + s, (r << 1) + o, (Math.floor(n * ju) << 1) + i, Math.round(a)) } function Hu(e, t, r) { const n = 16384; e.emplaceBack(t.x, t.y, t.z, r[0] * n, r[1] * n, r[2] * n) } class Qu { constructor() { this.acc = new f(0, 0), this.polyCount = [] } startRing(e) { this.currentPolyCount = { edges: 0, top: 0 }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new f(e.x, e.y), this.max = new f(e.x, e.y)) } append(e, t) { this.currentPolyCount.edges++, this.acc._add(e); const r = this.min, n = this.max; e.x < r.x ? r.x = e.x : e.x > n.x && (n.x = e.x), e.y < r.y ? r.y = e.y : e.y > n.y && (n.y = e.y), ((0 === e.x || e.x === ia) && e.x === t.x) != ((0 === e.y || e.y === ia) && e.y === t.y) && this.processBorderOverlap(e, t), t.x < 0 != e.x < 0 && this.addBorderIntersection(0, Ir(t.y, e.y, (0 - t.x) / (e.x - t.x))), t.x > ia != e.x > ia && this.addBorderIntersection(1, Ir(t.y, e.y, (ia - t.x) / (e.x - t.x))), t.y < 0 != e.y < 0 && this.addBorderIntersection(2, Ir(t.x, e.x, (0 - t.y) / (e.y - t.y))), t.y > ia != e.y > ia && this.addBorderIntersection(3, Ir(t.x, e.x, (ia - t.y) / (e.y - t.y))) } addBorderIntersection(e, t) { this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]); const r = this.borders[e]; t < r[0] && (r[0] = t), t > r[1] && (r[1] = t) } processBorderOverlap(e, t) { if (e.x === t.x) { if (e.y === t.y) return; const r = 0 === e.x ? 0 : 1; this.addBorderIntersection(r, t.y), this.addBorderIntersection(r, e.y) } else { const r = 0 === e.y ? 2 : 3; this.addBorderIntersection(r, t.x), this.addBorderIntersection(r, e.x) } } centroid() { const e = this.polyCount.reduce(((e, t) => e + t.edges), 0); return 0 !== e ? this.acc.div(e)._round() : new f(0, 0) } span() { return new f(this.max.x - this.min.x, this.max.y - this.min.y) } intersectsCount() { return this.borders.reduce(((e, t) => e + +(t[0] !== Number.MAX_VALUE)), 0) } } class $u { constructor(e) { this.zoom = e.zoom, this.canonical = e.canonical, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((e => e.id)), this.index = e.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = e.projection, this.layoutVertexArray = new Go, this.centroidVertexArray = new xs, this.indexArray = new ts, this.programConfigurations = new Zs(e.layers, e.zoom), this.segments = new na, this.stateDependentLayerIds = this.layers.filter((e => e.isStateDependent())).map((e => e.id)), this.enableTerrain = e.enableTerrain } populate(e, t, r, n) { this.features = [], this.hasPattern = xu("fill-extrusion", this.layers, t), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = function (e) { const t = Math.exp(Math.PI * (1 - e.y / (1 << e.z) * 2)); return 80150034 * t / (t * t + 1) / ia / (1 << e.z) }(r), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter; for (const { feature: i, id: o, index: s, sourceLayerIndex: a } of e) { const e = this.layers[0]._featureFilter.needGeometry, c = nl(i, e); if (!this.layers[0]._featureFilter.filter(new xo(this.zoom), c, r)) continue; const l = { id: o, sourceLayerIndex: a, index: s, geometry: e ? c.geometry : rl(i, r, n), properties: i.properties, type: i.type, patterns: {} }, u = this.layoutVertexArray.length; this.hasPattern ? this.features.push(bu("fill-extrusion", this.layers, l, this.zoom, t)) : this.addFeature(l, l.geometry, s, r, {}, t.availableImages, n), t.featureIndex.insert(i, l.geometry, s, a, this.index, u) } this.sortBorders() } addFeatures(e, t, r, n, i) { for (const o of this.features) { const { geometry: e } = o; this.addFeature(o, e, o.index, t, r, n, i) } this.sortBorders() } update(e, t, r, n) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, r, n) } isEmpty() { return 0 === this.layoutVertexArray.length } uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload } upload(e) { this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Pu), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = e.createVertexBuffer(this.layoutVertexExtArray, Su.members, !0))), this.programConfigurations.upload(e), this.uploaded = !0 } uploadCentroid(e) { 0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, Eu.members, !0), this.needsCentroidUpdate = !1) } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()) } addFeature(e, t, r, n, i, o, s) { const a = [new f(0, 0), new f(ia, ia)], c = s.projection, l = "globe" === c.name, u = this.enableTerrain && !l ? new Qu : null, h = "Polygon" === qu[e.type]; l && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Wo); const d = yu(t, 500); for (let f = d.length - 1; f >= 0; f--) { const e = d[f]; (0 === e.length || (p = e[0]).every((e => e.x <= 0)) || p.every((e => e.x >= ia)) || p.every((e => e.y <= 0)) || p.every((e => e.y >= ia))) && d.splice(f, 1) } var p; let m; if (l) m = ih(d, a, n); else { m = []; for (const e of d) m.push({ polygon: e, bounds: a }) } const g = h ? this.edgeRadius : 0; for (const { polygon: f, bounds: _ } of m) { let e = 0, t = 0; for (const n of f) h && !n[0].equals(n[n.length - 1]) && n.push(n[0]), t += h ? n.length - 1 : n.length; const r = this.segments.prepareSegment((h ? 5 : 4) * t, this.layoutVertexArray, this.indexArray); if (h) { const t = [], i = []; e = r.vertexLength; for (const e of f) { let o, s; e.length && e !== f[0] && i.push(t.length / 2), o = e[1].sub(e[0])._perp()._unit(); for (let i = 1; i < e.length; i++) { const a = e[i], u = e[i === e.length - 1 ? 1 : i + 1]; let { x: h, y: d } = a; if (g) { s = u.sub(a)._perp()._unit(); const e = o.add(s)._unit(), t = g * Math.min(4, 1 / (o.x * e.x + o.y * e.y)); h += t * e.x, d += t * e.y, o = s } Zu(this.layoutVertexArray, h, d, 0, 0, 1, 1, 0), r.vertexLength++, t.push(a.x, a.y), l && Hu(this.layoutVertexExtArray, c.projectTilePoint(h, d, n), c.upVector(n, h, d)) } } const o = Gl(t, i); for (let n = 0; n < o.length; n += 3)this.indexArray.emplaceBack(e + o[n], e + o[n + 2], e + o[n + 1]), r.primitiveLength++ } for (const i of f) { u && i.length && u.startRing(i[0]); let t, o, s, a = i.length > 4 && th(i[i.length - 2], i[0], i[1]), d = g ? Ku(i[i.length - 2], i[0], i[1], g) : 0; o = i[1].sub(i[0])._perp()._unit(); let p = !0; for (let f = 1, m = 0; f < i.length; f++) { let y = i[f - 1], v = i[f]; const x = i[f === i.length - 1 ? 1 : f + 1]; if (u && h && u.currentPolyCount.top++, eh(v, y, _)) { g && (o = x.sub(v)._perp()._unit(), p = !p); continue } u && u.append(v, y); const b = v.sub(y)._perp(), w = b.x / (Math.abs(b.x) + Math.abs(b.y)), T = b.y > 0 ? 1 : 0, k = y.dist(v); if (m + k > 32768 && (m = 0), g) { s = x.sub(v)._perp()._unit(); let e = Yu(y, v, x, Ju(o, s), g); isNaN(e) && (e = 0); const t = v.sub(y)._unit(); y = y.add(t.mult(d))._round(), v = v.add(t.mult(-e))._round(), d = e, o = s } const C = r.vertexLength, E = i.length > 4 && th(y, v, x); let S = rh(m, a, p); if (Zu(this.layoutVertexArray, y.x, y.y, w, T, 0, 0, S), Zu(this.layoutVertexArray, y.x, y.y, w, T, 0, 1, S), m += k, S = rh(m, E, !p), a = E, Zu(this.layoutVertexArray, v.x, v.y, w, T, 0, 0, S), Zu(this.layoutVertexArray, v.x, v.y, w, T, 0, 1, S), r.vertexLength += 4, this.indexArray.emplaceBack(C + 0, C + 1, C + 2), this.indexArray.emplaceBack(C + 1, C + 3, C + 2), r.primitiveLength += 2, g) { const n = e + (1 === f ? i.length - 2 : f - 2), o = 1 === f ? e : n + 1; if (this.indexArray.emplaceBack(C + 1, n, C + 3), this.indexArray.emplaceBack(n, o, C + 3), r.primitiveLength += 2, void 0 === t && (t = C), !eh(x, i[f], _)) { const e = f === i.length - 1 ? t : r.vertexLength; this.indexArray.emplaceBack(C + 2, C + 3, e), this.indexArray.emplaceBack(C + 3, e + 1, e), this.indexArray.emplaceBack(C + 3, o, e + 1), r.primitiveLength += 3 } p = !p } if (l) { const e = this.layoutVertexExtArray, t = c.projectTilePoint(y.x, y.y, n), r = c.projectTilePoint(v.x, v.y, n), i = c.upVector(n, y.x, y.y), o = c.upVector(n, v.x, v.y); Hu(e, t, i), Hu(e, t, i), Hu(e, r, o), Hu(e, r, o) } } h && (e += i.length - 1) } } if (u && u.polyCount.length > 0) { if (u.borders) { u.vertexArrayOffset = this.centroidVertexArray.length; const e = u.borders, t = this.featuresOnBorder.push(u) - 1; for (let r = 0; r < 4; r++)e[r][0] !== Number.MAX_VALUE && this.borders[r].push(t) } this.encodeCentroid(u.borders ? void 0 : u.centroid(), u) } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, r, i, o, n) } sortBorders() { for (let e = 0; e < 4; e++)this.borders[e].sort(((t, r) => this.featuresOnBorder[t].borders[e][0] - this.featuresOnBorder[r].borders[e][0])) } encodeCentroid(e, t, r = !0) { let n, i; if (e) if (0 !== e.y) { const r = t.span()._mult(this.tileToMeter); n = (Math.max(e.x, 1) << 3) + Math.min(7, Math.round(r.x / 10)), i = (Math.max(e.y, 1) << 3) + Math.min(7, Math.round(r.y / 10)) } else n = Math.ceil((e.x + Wu) * Xu), i = 0; else n = 0, i = +r; let o = r ? this.centroidVertexArray.length : t.vertexArrayOffset; for (const s of t.polyCount) { r && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * s.edges + s.top); for (let e = 0; e < s.top; e++)this.centroidVertexArray.emplace(o++, n, i); for (let e = 0; e < 2 * s.edges; e++)this.centroidVertexArray.emplace(o++, 0, i), this.centroidVertexArray.emplace(o++, n, i) } } } function Ju(e, t) { const r = e.add(t)._unit(); return e.x * r.x + e.y * r.y } function Ku(e, t, r, n) { const i = t.sub(e)._perp()._unit(), o = r.sub(t)._perp()._unit(); return Yu(e, t, r, Ju(i, o), n) } function Yu(e, t, r, n, i) { const o = Math.sqrt(1 - n * n); return Math.min(e.dist(t) / 3, t.dist(r) / 3, i * o / n) } function eh(e, t, r) { return e.x < r[0].x && t.x < r[0].x || e.x > r[1].x && t.x > r[1].x || e.y < r[0].y && t.y < r[0].y || e.y > r[1].y && t.y > r[1].y } function th(e, t, r) { if (e.x < 0 || e.x >= ia || t.x < 0 || t.x >= ia || r.x < 0 || r.x >= ia) return !1; const n = r.sub(t), i = n.perp(), o = e.sub(t); return (n.x * o.x + n.y * o.y) / Math.sqrt((n.x * n.x + n.y * n.y) * (o.x * o.x + o.y * o.y)) > -.866 && i.x * o.x + i.y * o.y < 0 } function rh(e, t, r) { const n = t ? 2 | e : -3 & e; return r ? 1 | n : -2 & n } function nh() { const e = Math.PI / 32, t = Math.tan(e), r = Fc; return r * Math.sqrt(1 + 2 * t * t) - r } function ih(e, t, r) { const n = 1 << r.z, i = qc(r.x / n), o = qc((r.x + 1) / n), s = jc(r.y / n), a = jc((r.y + 1) / n); return function (e, t, r, n, i = 0, o) { const s = []; if (!e.length || !r || !n) return s; const a = (e, t) => { for (const r of e) s.push({ polygon: r, bounds: t }) }, c = Math.ceil(Math.log2(r)), l = Math.ceil(Math.log2(n)), u = c - l, h = []; for (let f = 0; f < Math.abs(u); f++)h.push(u > 0 ? 0 : 1); for (let f = 0; f < Math.min(c, l); f++)h.push(0), h.push(1); let d = e; if (d = Vu(d, t[0].y - i, t[1].y + i, 1), d = Vu(d, t[0].x - i, t[1].x + i, 0), !d.length) return s; const p = []; for (h.length ? p.push({ polygons: d, bounds: t, depth: 0 }) : a(d, t); p.length;) { const e = p.pop(), t = e.depth, r = h[t], n = e.bounds[0], s = e.bounds[1], c = 0 === r ? n.x : n.y, l = 0 === r ? s.x : s.y, u = o ? o(r, c, l) : .5 * (c + l), d = Vu(e.polygons, c - i, u + i, r), m = Vu(e.polygons, u - i, l + i, r); if (d.length) { const e = [n, new f(0 === r ? u : s.x, 1 === r ? u : s.y)]; h.length > t + 1 ? p.push({ polygons: d, bounds: e, depth: t + 1 }) : a(d, e) } if (m.length) { const e = [new f(0 === r ? u : n.x, 1 === r ? u : n.y), s]; h.length > t + 1 ? p.push({ polygons: m, bounds: e, depth: t + 1 }) : a(m, e) } } return s }(e, t, Math.ceil((o - i) / 11.25), Math.ceil((s - a) / 11.25), 1, ((e, t, i) => { if (0 === e) return .5 * (t + i); { const e = jc((r.y + t / ia) / n); return (Gc(.5 * (jc((r.y + i / ia) / n) + e)) * n - r.y) * ia } })) } Zi($u, "FillExtrusionBucket", { omit: ["layers", "features"] }), Zi(Qu, "PartMetadata"); const oh = new Mo({ "fill-extrusion-edge-radius": new Io(Ke["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) }); var sh = { paint: new Mo({ "fill-extrusion-opacity": new Io(Ke["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Ao(Ke["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Io(Ke["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Io(Ke["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Ao(Ke["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Ao(Ke["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Ao(Ke["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Io(Ke["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new Io(Ke["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new Io(Ke["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]) }), layout: oh }; function ah(e, t, r) { var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r); return [e * n - 2 * Math.PI * 6378137 / 2, t * n - 2 * Math.PI * 6378137 / 2] } class ch { constructor(e, t, r) { this.z = e, this.x = t, this.y = r, this.key = hh(0, e, e, t, r) } equals(e) { return this.z === e.z && this.x === e.x && this.y === e.y } url(e, t) { const r = function (e, t, r) { var n = ah(256 * e, 256 * (t = Math.pow(2, r) - t - 1), r), i = ah(256 * (e + 1), 256 * (t + 1), r); return n[0] + "," + n[1] + "," + i[0] + "," + i[1] }(this.x, this.y, this.z), n = function (e, t, r) { let n, i = ""; for (let o = e; o > 0; o--)n = 1 << o - 1, i += (t & n ? 1 : 0) + (r & n ? 2 : 0); return i }(this.z, this.x, this.y); return e[(this.x + this.y) % e.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === t ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n).replace("{bbox-epsg-3857}", r) } toString() { return `${this.z}/${this.x}/${this.y}` } } class lh { constructor(e, t) { this.wrap = e, this.canonical = t, this.key = hh(e, t.z, t.z, t.x, t.y) } } class uh { constructor(e, t, r, n, i) { this.overscaledZ = e, this.wrap = t, this.canonical = new ch(r, +n, +i), this.key = 0 === t && e === r ? this.canonical.key : hh(t, e, r, n, i) } equals(e) { return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical) } scaledTo(e) { const t = this.canonical.z - e; return e > this.canonical.z ? new uh(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new uh(e, this.wrap, e, this.canonical.x >> t, this.canonical.y >> t) } calculateScaledKey(e, t = !0) { if (this.overscaledZ === e && t) return this.key; if (e > this.canonical.z) return hh(this.wrap * +t, e, this.canonical.z, this.canonical.x, this.canonical.y); { const r = this.canonical.z - e; return hh(this.wrap * +t, e, e, this.canonical.x >> r, this.canonical.y >> r) } } isChildOf(e) { if (e.wrap !== this.wrap) return !1; const t = this.canonical.z - e.canonical.z; return 0 === e.overscaledZ || e.overscaledZ < this.overscaledZ && e.canonical.x === this.canonical.x >> t && e.canonical.y === this.canonical.y >> t } children(e) { if (this.overscaledZ >= e) return [new uh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)]; const t = this.canonical.z + 1, r = 2 * this.canonical.x, n = 2 * this.canonical.y; return [new uh(t, this.wrap, t, r, n), new uh(t, this.wrap, t, r + 1, n), new uh(t, this.wrap, t, r, n + 1), new uh(t, this.wrap, t, r + 1, n + 1)] } isLessThan(e) { return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y)) } wrapped() { return new uh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y) } unwrapTo(e) { return new uh(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y) } overscaleFactor() { return Math.pow(2, this.overscaledZ - this.canonical.z) } toUnwrapped() { return new lh(this.wrap, this.canonical) } toString() { return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}` } } function hh(e, t, r, n, i) { const o = 1 << Math.min(r, 22); let s = o * (i % o) + n % o; return e && r < 22 && (s += o * o * ((e < 0 ? -2 * e - 1 : 2 * e) % (1 << 2 * (22 - r)))), 16 * (32 * s + r) + (t - r) } Zi(ch, "CanonicalTileID"), Zi(uh, "OverscaledTileID", { omit: ["projMatrix"] }); class dh extends f { constructor(e, t, r) { super(e, t), this.z = r } } function ph(e, t) { return e.x * t.x + e.y * t.y } function fh(e, t) { if (1 === e.length) { let r = 0; const n = t[r++]; let i; for (; !i || n.equals(i);)if (i = t[r++], !i) return 1 / 0; for (; r < t.length; r++) { const o = t[r], s = e[0], a = i.sub(n), c = o.sub(n), l = s.sub(n), u = ph(a, a), h = ph(a, c), d = ph(c, c), p = ph(l, a), f = ph(l, c), m = u * d - h * h, g = (d * p - h * f) / m, _ = (u * f - h * p) / m, y = n.z * (1 - g - _) + i.z * g + o.z * _; if (isFinite(y)) return y } return 1 / 0 } { let e = 1 / 0; for (const r of t) e = Math.min(e, r.z); return e } } function mh(e, t, r, n, i, o, s, a) { const c = s * i.getElevationAt(e, t, !0, !0), l = 0 !== o[0], u = l ? 0 === o[1] ? s * (o[0] / Xu - Wu) : s * function (e, t, r) { const n = Math.floor(t[0] / 8), i = Math.floor(t[1] / 8), o = 10 * (t[0] - 8 * n), s = 10 * (t[1] - 8 * i), a = e.getElevationAt(n, i, !0, !0), c = e.getMeterToDEM(r), l = Math.floor(.5 * (o * c - 1)), u = Math.floor(.5 * (s * c - 1)), h = e.tileCoordToPixel(n, i), d = 2 * l + 1, p = 2 * u + 1, f = function (e, t, r, n, i) { return [e.getElevationAtPixel(t, r, !0), e.getElevationAtPixel(t + i, r, !0), e.getElevationAtPixel(t, r + i, !0), e.getElevationAtPixel(t + n, r + i, !0)] }(e, h.x - l, h.y - u, d, p), m = Math.abs(f[0] - f[1]), g = Math.abs(f[2] - f[3]), _ = Math.abs(f[0] - f[2]) + Math.abs(f[1] - f[3]), y = Math.min(.25, .5 * c * (m + g) / d), v = Math.min(.25, .5 * c * _ / p); return a + Math.max(y * o, v * s) }(i, o, a) : c; return { base: c + (0 === r) ? -1 : r, top: l ? Math.max(u + n, c + r + 2) : c + n } } const gh = Oo([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), { members: _h } = gh, yh = Oo([{ name: "a_packed", components: 4, type: "Float32" }]), { members: vh } = yh, xh = Gu.types, bh = Math.cos(Math.PI / 180 * 37.5); class wh { constructor(e) { this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((e => e.id)), this.index = e.index, this.projection = e.projection, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((e => { this.gradients[e.id] = {} })), this.layoutVertexArray = new Vo, this.layoutVertexArray2 = new qo, this.indexArray = new ts, this.programConfigurations = new Zs(e.layers, e.zoom), this.segments = new na, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((e => e.isStateDependent())).map((e => e.id)) } populate(e, t, r, n) { this.hasPattern = xu("line", this.layers, t); const i = this.layers[0].layout.get("line-sort-key"), o = []; for (const { feature: l, id: u, index: h, sourceLayerIndex: d } of e) { const e = this.layers[0]._featureFilter.needGeometry, t = nl(l, e); if (!this.layers[0]._featureFilter.filter(new xo(this.zoom), t, r)) continue; const s = i ? i.evaluate(t, {}, r) : void 0, a = { id: u, properties: l.properties, type: l.type, sourceLayerIndex: d, index: h, geometry: e ? t.geometry : rl(l, r, n), patterns: {}, sortKey: s }; o.push(a) } i && o.sort(((e, t) => e.sortKey - t.sortKey)); const { lineAtlas: s, featureIndex: a } = t, c = this.addConstantDashes(s); for (const l of o) { const { geometry: n, index: i, sourceLayerIndex: o } = l; if (c && this.addFeatureDashes(l, s), this.hasPattern) { const e = bu("line", this.layers, l, this.zoom, t); this.patternFeatures.push(e) } else this.addFeature(l, n, i, r, s.positions, t.availableImages); a.insert(e[i].feature, n, i, o, this.index) } } addConstantDashes(e) { let t = !1; for (const r of this.layers) { const n = r.paint.get("line-dasharray").value, i = r.layout.get("line-cap").value; if ("constant" !== n.kind || "constant" !== i.kind) t = !0; else { const t = i.value, r = n.value; if (!r) continue; e.addDash(r, t) } } return t } addFeatureDashes(e, t) { const r = this.zoom; for (const n of this.layers) { const i = n.paint.get("line-dasharray").value, o = n.layout.get("line-cap").value; if ("constant" === i.kind && "constant" === o.kind) continue; let s, a; if ("constant" === i.kind) { if (s = i.value, !s) continue } else s = i.evaluate({ zoom: r }, e); a = "constant" === o.kind ? o.value : o.evaluate({ zoom: r }, e), t.addDash(s, a), e.patterns[n.id] = t.getKey(s, a) } } update(e, t, r, n) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, r, n) } addFeatures(e, t, r, n, i) { for (const o of this.patternFeatures) this.addFeature(o, o.geometry, o.index, t, r, n) } isEmpty() { return 0 === this.layoutVertexArray.length } uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload } upload(e) { this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, vh)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, _h), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0 } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()) } lineFeatureClips(e) { if (e.properties && e.properties.hasOwnProperty("mapbox_clip_start") && e.properties.hasOwnProperty("mapbox_clip_end")) return { start: +e.properties.mapbox_clip_start, end: +e.properties.mapbox_clip_end } } addFeature(e, t, r, n, i, o) { const s = this.layers[0].layout, a = s.get("line-join").evaluate(e, {}), c = s.get("line-cap").evaluate(e, {}), l = s.get("line-miter-limit"), u = s.get("line-round-limit"); this.lineClips = this.lineFeatureClips(e); for (const h of t) this.addLine(h, e, a, c, l, u); this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, r, i, o, n) } addLine(e, t, r, n, i, o) { if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) { this.lineClipsArray.push(this.lineClips); for (let t = 0; t < e.length - 1; t++)this.totalDistance += e[t].dist(e[t + 1]); this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance) } const s = "Polygon" === xh[t.type]; let a = e.length; for (; a >= 2 && e[a - 1].equals(e[a - 2]);)a--; let c = 0; for (; c < a - 1 && e[c].equals(e[c + 1]);)c++; if (a < (s ? 3 : 2)) return; "bevel" === r && (i = 1.05); const l = this.overscaling <= 16 ? 15 * ia / (512 * this.overscaling) : 0, u = this.segments.prepareSegment(10 * a, this.layoutVertexArray, this.indexArray); let h, d, p, f, m; this.e1 = this.e2 = -1, s && (h = e[a - 2], m = e[c].sub(h)._unit()._perp()); for (let g = c; g < a; g++) { if (p = g === a - 1 ? s ? e[c + 1] : void 0 : e[g + 1], p && e[g].equals(p)) continue; m && (f = m), h && (d = h), h = e[g], m = p ? p.sub(h)._unit()._perp() : f, f = f || m; let t = f.add(m); 0 === t.x && 0 === t.y || t._unit(); const _ = f.x * m.x + f.y * m.y, y = t.x * m.x + t.y * m.y, v = 0 !== y ? 1 / y : 1 / 0, x = 2 * Math.sqrt(2 - 2 * y), b = y < bh && d && p, w = f.x * m.y - f.y * m.x > 0; if (b && g > c) { const e = h.dist(d); if (e > 2 * l) { const t = h.sub(h.sub(d)._mult(l / e)._round()); this.updateDistance(d, t), this.addCurrentVertex(t, f, 0, 0, u), d = t } } const T = d && p; let k = T ? r : s ? "butt" : n; if (T && "round" === k && (v < o ? k = "miter" : v <= 2 && (k = "fakeround")), "miter" === k && v > i && (k = "bevel"), "bevel" === k && (v > 2 && (k = "flipbevel"), v < i && (k = "miter")), d && this.updateDistance(d, h), "miter" === k) t._mult(v), this.addCurrentVertex(h, t, 0, 0, u); else if ("flipbevel" === k) { if (v > 100) t = m.mult(-1); else { const e = v * f.add(m).mag() / f.sub(m).mag(); t._perp()._mult(e * (w ? -1 : 1)) } this.addCurrentVertex(h, t, 0, 0, u), this.addCurrentVertex(h, t.mult(-1), 0, 0, u) } else if ("bevel" === k || "fakeround" === k) { const e = -Math.sqrt(v * v - 1), t = w ? e : 0, r = w ? 0 : e; if (d && this.addCurrentVertex(h, f, t, r, u), "fakeround" === k) { const e = Math.round(180 * x / Math.PI / 20); for (let t = 1; t < e; t++) { let r = t / e; if (.5 !== r) { const e = r - .5; r += r * e * (r - 1) * ((1.0904 + _ * (_ * (3.55645 - 1.43519 * _) - 3.2452)) * e * e + (.848013 + _ * (.215638 * _ - 1.06021))) } const n = m.sub(f)._mult(r)._add(f)._unit()._mult(w ? -1 : 1); this.addHalfVertex(h, n.x, n.y, !1, w, 0, u) } } p && this.addCurrentVertex(h, m, -t, -r, u) } else if ("butt" === k) this.addCurrentVertex(h, t, 0, 0, u); else if ("square" === k) { const e = d ? 1 : -1; d || this.addCurrentVertex(h, t, e, e, u), this.addCurrentVertex(h, t, 0, 0, u), d && this.addCurrentVertex(h, t, e, e, u) } else "round" === k && (d && (this.addCurrentVertex(h, f, 0, 0, u), this.addCurrentVertex(h, f, 1, 1, u, !0)), p && (this.addCurrentVertex(h, m, -1, -1, u, !0), this.addCurrentVertex(h, m, 0, 0, u))); if (b && g < a - 1) { const e = h.dist(p); if (e > 2 * l) { const t = h.add(p.sub(h)._mult(l / e)._round()); this.updateDistance(h, t), this.addCurrentVertex(t, m, 0, 0, u), h = t } } } } addCurrentVertex(e, t, r, n, i, o = !1) { const s = t.y * n - t.x, a = -t.y - t.x * n; this.addHalfVertex(e, t.x + t.y * r, t.y - t.x * r, o, !1, r, i), this.addHalfVertex(e, s, a, o, !0, -n, i) } addHalfVertex({ x: e, y: t }, r, n, i, o, s, a) { this.layoutVertexArray.emplaceBack((e << 1) + (i ? 1 : 0), (t << 1) + (o ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === s ? 0 : s < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end); const c = a.vertexLength++; this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, c), a.primitiveLength++), o ? this.e2 = c : this.e1 = c } updateScaledDistance() { if (this.lineClips) { const e = this.totalDistance / (this.lineClips.end - this.lineClips.start); this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = e * this.lineClips.start + this.distance } else this.lineSoFar = this.distance } updateDistance(e, t) { this.distance += e.dist(t), this.updateScaledDistance() } } Zi(wh, "LineBucket", { omit: ["layers", "patternFeatures"] }); const Th = new Mo({ "line-cap": new Ao(Ke.layout_line["line-cap"]), "line-join": new Ao(Ke.layout_line["line-join"]), "line-miter-limit": new Io(Ke.layout_line["line-miter-limit"]), "line-round-limit": new Io(Ke.layout_line["line-round-limit"]), "line-sort-key": new Ao(Ke.layout_line["line-sort-key"]) }); var kh = { paint: new Mo({ "line-opacity": new Ao(Ke.paint_line["line-opacity"]), "line-color": new Ao(Ke.paint_line["line-color"]), "line-translate": new Io(Ke.paint_line["line-translate"]), "line-translate-anchor": new Io(Ke.paint_line["line-translate-anchor"]), "line-width": new Ao(Ke.paint_line["line-width"]), "line-gap-width": new Ao(Ke.paint_line["line-gap-width"]), "line-offset": new Ao(Ke.paint_line["line-offset"]), "line-blur": new Ao(Ke.paint_line["line-blur"]), "line-dasharray": new Ao(Ke.paint_line["line-dasharray"]), "line-pattern": new Ao(Ke.paint_line["line-pattern"]), "line-gradient": new Lo(Ke.paint_line["line-gradient"]), "line-trim-offset": new Io(Ke.paint_line["line-trim-offset"]) }), layout: Th }; const Ch = new class extends Ao { possiblyEvaluate(e, t) { return t = new xo(Math.floor(t.zoom), { now: t.now, fadeDuration: t.fadeDuration, transition: t.transition }), super.possiblyEvaluate(e, t) } evaluate(e, t, r, n) { return t = I({}, t, { zoom: Math.floor(t.zoom) }), super.evaluate(e, t, r, n) } }(kh.paint.properties["line-width"].specification); function Eh(e, t) { return t > 0 ? t + 2 * e : e } Ch.useIntegerZoom = !0; const Sh = Oo([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Ph = Oo([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), Ih = Oo([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4); Oo([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4); const Ah = Oo([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]), Lh = Oo([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }]); Oo([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]); const Mh = Oo([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Bh = Oo([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4); Oo([{ name: "triangle", components: 3, type: "Uint16" }]), Oo([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), Oo([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), Oo([{ type: "Float32", name: "offsetX" }]), Oo([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]); var Rh = 24; const Dh = 128; function Fh(e, t) { const { expression: r } = t; if ("constant" === r.kind) return { kind: "constant", layoutSize: r.evaluate(new xo(e + 1)) }; if ("source" === r.kind) return { kind: "source" }; { const { zoomStops: t, interpolationType: n } = r; let i = 0; for (; i < t.length && t[i] <= e;)i++; i = Math.max(0, i - 1); let o = i; for (; o < t.length && t[o] < e + 1;)o++; o = Math.min(t.length - 1, o); const s = t[i], a = t[o]; return "composite" === r.kind ? { kind: "composite", minZoom: s, maxZoom: a, interpolationType: n } : { kind: "camera", minZoom: s, maxZoom: a, minSize: r.evaluate(new xo(s)), maxSize: r.evaluate(new xo(a)), interpolationType: n } } } function Oh(e, { uSize: t, uSizeT: r }, { lowerSize: n, upperSize: i }) { return "source" === e.kind ? n / Dh : "composite" === e.kind ? Ir(n / Dh, i / Dh, r) : t } function zh(e, t) { let r = 0, n = 0; if ("constant" === e.kind) n = e.layoutSize; else if ("source" !== e.kind) { const { interpolationType: i, minZoom: o, maxZoom: s } = e, a = i ? k(Kr.interpolationFactor(i, t, o, s), 0, 1) : 0; "camera" === e.kind ? n = Ir(e.minSize, e.maxSize, a) : r = a } return { uSizeT: r, uSize: n } } var Uh = Object.freeze({ __proto__: null, getSizeData: Fh, evaluateSizeForFeature: Oh, evaluateSizeForZoom: zh, SIZE_PACK_FACTOR: Dh }); function Nh(e, t, r) { return e.sections.forEach((e => { e.text = function (e, t, r) { const n = t.layout.get("text-transform").evaluate(r, {}); return "uppercase" === n ? e = e.toLocaleUpperCase() : "lowercase" === n && (e = e.toLocaleLowerCase()), vo.applyArabicShaping && (e = vo.applyArabicShaping(e)), e }(e.text, t, r) })), e } const Gh = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂", "←": "↑", "→": "↓" }; function Vh(e) { return "︶" === e || "﹈" === e || "︸" === e || "﹄" === e || "﹂" === e || "︾" === e || "︼" === e || "︺" === e || "︘" === e || "﹀" === e || "︐" === e || "︓" === e || "︔" === e || "｀" === e || "￣" === e || "︑" === e || "︒" === e } function qh(e) { return "︵" === e || "﹇" === e || "︷" === e || "﹃" === e || "﹁" === e || "︽" === e || "︻" === e || "︹" === e || "︗" === e || "︿" === e } var jh = {/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */read: function (e, t, r, n, i) { var o, s, a = 8 * i - n - 1, c = (1 << a) - 1, l = c >> 1, u = -7, h = r ? i - 1 : 0, d = r ? -1 : 1, p = e[t + h]; for (h += d, o = p & (1 << -u) - 1, p >>= -u, u += a; u > 0; o = 256 * o + e[t + h], h += d, u -= 8); for (s = o & (1 << -u) - 1, o >>= -u, u += n; u > 0; s = 256 * s + e[t + h], h += d, u -= 8); if (0 === o) o = 1 - l; else { if (o === c) return s ? NaN : 1 / 0 * (p ? -1 : 1); s += Math.pow(2, n), o -= l } return (p ? -1 : 1) * s * Math.pow(2, o - n) }, write: function (e, t, r, n, i, o) { var s, a, c, l = 8 * o - i - 1, u = (1 << l) - 1, h = u >> 1, d = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = n ? 0 : o - 1, f = n ? 1 : -1, m = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = u) : (s = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -s)) < 1 && (s--, c *= 2), (t += s + h >= 1 ? d / c : d * Math.pow(2, 1 - h)) * c >= 2 && (s++, c /= 2), s + h >= u ? (a = 0, s = u) : s + h >= 1 ? (a = (t * c - 1) * Math.pow(2, i), s += h) : (a = t * Math.pow(2, h - 1) * Math.pow(2, i), s = 0)); i >= 8; e[r + p] = 255 & a, p += f, a /= 256, i -= 8); for (s = s << i | a, l += i; l > 0; e[r + p] = 255 & s, p += f, s /= 256, l -= 8); e[r + p - f] |= 128 * m } }, Xh = Zh, Wh = jh; function Zh(e) { this.buf = ArrayBuffer.isView && ArrayBuffer.isView(e) ? e : new Uint8Array(e || 0), this.pos = 0, this.type = 0, this.length = this.buf.length } Zh.Varint = 0, Zh.Fixed64 = 1, Zh.Bytes = 2, Zh.Fixed32 = 5; var Hh = 4294967296, Qh = 1 / Hh, $h = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8"); function Jh(e) { return e.type === Zh.Bytes ? e.readVarint() + e.pos : e.pos + 1 } function Kh(e, t, r) { return r ? 4294967296 * t + (e >>> 0) : 4294967296 * (t >>> 0) + (e >>> 0) } function Yh(e, t, r) { var n = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2)); r.realloc(n); for (var i = r.pos - 1; i >= e; i--)r.buf[i + n] = r.buf[i] } function ed(e, t) { for (var r = 0; r < e.length; r++)t.writeVarint(e[r]) } function td(e, t) { for (var r = 0; r < e.length; r++)t.writeSVarint(e[r]) } function rd(e, t) { for (var r = 0; r < e.length; r++)t.writeFloat(e[r]) } function nd(e, t) { for (var r = 0; r < e.length; r++)t.writeDouble(e[r]) } function id(e, t) { for (var r = 0; r < e.length; r++)t.writeBoolean(e[r]) } function od(e, t) { for (var r = 0; r < e.length; r++)t.writeFixed32(e[r]) } function sd(e, t) { for (var r = 0; r < e.length; r++)t.writeSFixed32(e[r]) } function ad(e, t) { for (var r = 0; r < e.length; r++)t.writeFixed64(e[r]) } function cd(e, t) { for (var r = 0; r < e.length; r++)t.writeSFixed64(e[r]) } function ld(e, t) { return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + 16777216 * e[t + 3] } function ud(e, t, r) { e[r] = t, e[r + 1] = t >>> 8, e[r + 2] = t >>> 16, e[r + 3] = t >>> 24 } function hd(e, t) { return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + (e[t + 3] << 24) } Zh.prototype = { destroy: function () { this.buf = null }, readFields: function (e, t, r) { for (r = r || this.length; this.pos < r;) { var n = this.readVarint(), i = n >> 3, o = this.pos; this.type = 7 & n, e(i, t, this), this.pos === o && this.skip(n) } return t }, readMessage: function (e, t) { return this.readFields(e, t, this.readVarint() + this.pos) }, readFixed32: function () { var e = ld(this.buf, this.pos); return this.pos += 4, e }, readSFixed32: function () { var e = hd(this.buf, this.pos); return this.pos += 4, e }, readFixed64: function () { var e = ld(this.buf, this.pos) + ld(this.buf, this.pos + 4) * Hh; return this.pos += 8, e }, readSFixed64: function () { var e = ld(this.buf, this.pos) + hd(this.buf, this.pos + 4) * Hh; return this.pos += 8, e }, readFloat: function () { var e = Wh.read(this.buf, this.pos, !0, 23, 4); return this.pos += 4, e }, readDouble: function () { var e = Wh.read(this.buf, this.pos, !0, 52, 8); return this.pos += 8, e }, readVarint: function (e) { var t, r, n = this.buf; return t = 127 & (r = n[this.pos++]), r < 128 ? t : (t |= (127 & (r = n[this.pos++])) << 7, r < 128 ? t : (t |= (127 & (r = n[this.pos++])) << 14, r < 128 ? t : (t |= (127 & (r = n[this.pos++])) << 21, r < 128 ? t : function (e, t, r) { var n, i, o = r.buf; if (n = (112 & (i = o[r.pos++])) >> 4, i < 128) return Kh(e, n, t); if (n |= (127 & (i = o[r.pos++])) << 3, i < 128) return Kh(e, n, t); if (n |= (127 & (i = o[r.pos++])) << 10, i < 128) return Kh(e, n, t); if (n |= (127 & (i = o[r.pos++])) << 17, i < 128) return Kh(e, n, t); if (n |= (127 & (i = o[r.pos++])) << 24, i < 128) return Kh(e, n, t); if (n |= (1 & (i = o[r.pos++])) << 31, i < 128) return Kh(e, n, t); throw new Error("Expected varint not more than 10 bytes") }(t |= (15 & (r = n[this.pos])) << 28, e, this)))) }, readVarint64: function () { return this.readVarint(!0) }, readSVarint: function () { var e = this.readVarint(); return e % 2 == 1 ? (e + 1) / -2 : e / 2 }, readBoolean: function () { return Boolean(this.readVarint()) }, readString: function () { var e = this.readVarint() + this.pos, t = this.pos; return this.pos = e, e - t >= 12 && $h ? function (e, t, r) { return $h.decode(e.subarray(t, r)) }(this.buf, t, e) : function (e, t, r) { for (var n = "", i = t; i < r;) { var o, s, a, c = e[i], l = null, u = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1; if (i + u > r) break; 1 === u ? c < 128 && (l = c) : 2 === u ? 128 == (192 & (o = e[i + 1])) && (l = (31 & c) << 6 | 63 & o) <= 127 && (l = null) : 3 === u ? (s = e[i + 2], 128 == (192 & (o = e[i + 1])) && 128 == (192 & s) && ((l = (15 & c) << 12 | (63 & o) << 6 | 63 & s) <= 2047 || l >= 55296 && l <= 57343) && (l = null)) : 4 === u && (s = e[i + 2], a = e[i + 3], 128 == (192 & (o = e[i + 1])) && 128 == (192 & s) && 128 == (192 & a) && ((l = (15 & c) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & a) <= 65535 || l >= 1114112) && (l = null)), null === l ? (l = 65533, u = 1) : l > 65535 && (l -= 65536, n += String.fromCharCode(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), n += String.fromCharCode(l), i += u } return n }(this.buf, t, e) }, readBytes: function () { var e = this.readVarint() + this.pos, t = this.buf.subarray(this.pos, e); return this.pos = e, t }, readPackedVarint: function (e, t) { if (this.type !== Zh.Bytes) return e.push(this.readVarint(t)); var r = Jh(this); for (e = e || []; this.pos < r;)e.push(this.readVarint(t)); return e }, readPackedSVarint: function (e) { if (this.type !== Zh.Bytes) return e.push(this.readSVarint()); var t = Jh(this); for (e = e || []; this.pos < t;)e.push(this.readSVarint()); return e }, readPackedBoolean: function (e) { if (this.type !== Zh.Bytes) return e.push(this.readBoolean()); var t = Jh(this); for (e = e || []; this.pos < t;)e.push(this.readBoolean()); return e }, readPackedFloat: function (e) { if (this.type !== Zh.Bytes) return e.push(this.readFloat()); var t = Jh(this); for (e = e || []; this.pos < t;)e.push(this.readFloat()); return e }, readPackedDouble: function (e) { if (this.type !== Zh.Bytes) return e.push(this.readDouble()); var t = Jh(this); for (e = e || []; this.pos < t;)e.push(this.readDouble()); return e }, readPackedFixed32: function (e) { if (this.type !== Zh.Bytes) return e.push(this.readFixed32()); var t = Jh(this); for (e = e || []; this.pos < t;)e.push(this.readFixed32()); return e }, readPackedSFixed32: function (e) { if (this.type !== Zh.Bytes) return e.push(this.readSFixed32()); var t = Jh(this); for (e = e || []; this.pos < t;)e.push(this.readSFixed32()); return e }, readPackedFixed64: function (e) { if (this.type !== Zh.Bytes) return e.push(this.readFixed64()); var t = Jh(this); for (e = e || []; this.pos < t;)e.push(this.readFixed64()); return e }, readPackedSFixed64: function (e) { if (this.type !== Zh.Bytes) return e.push(this.readSFixed64()); var t = Jh(this); for (e = e || []; this.pos < t;)e.push(this.readSFixed64()); return e }, skip: function (e) { var t = 7 & e; if (t === Zh.Varint) for (; this.buf[this.pos++] > 127;); else if (t === Zh.Bytes) this.pos = this.readVarint() + this.pos; else if (t === Zh.Fixed32) this.pos += 4; else { if (t !== Zh.Fixed64) throw new Error("Unimplemented type: " + t); this.pos += 8 } }, writeTag: function (e, t) { this.writeVarint(e << 3 | t) }, realloc: function (e) { for (var t = this.length || 16; t < this.pos + e;)t *= 2; if (t !== this.length) { var r = new Uint8Array(t); r.set(this.buf), this.buf = r, this.length = t } }, finish: function () { return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length) }, writeFixed32: function (e) { this.realloc(4), ud(this.buf, e, this.pos), this.pos += 4 }, writeSFixed32: function (e) { this.realloc(4), ud(this.buf, e, this.pos), this.pos += 4 }, writeFixed64: function (e) { this.realloc(8), ud(this.buf, -1 & e, this.pos), ud(this.buf, Math.floor(e * Qh), this.pos + 4), this.pos += 8 }, writeSFixed64: function (e) { this.realloc(8), ud(this.buf, -1 & e, this.pos), ud(this.buf, Math.floor(e * Qh), this.pos + 4), this.pos += 8 }, writeVarint: function (e) { (e = +e || 0) > 268435455 || e < 0 ? function (e, t) { var r, n; if (e >= 0 ? (r = e % 4294967296 | 0, n = e / 4294967296 | 0) : (n = ~(-e / 4294967296), 4294967295 ^ (r = ~(-e % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), e >= 0x10000000000000000 || e < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes"); t.realloc(10), function (e, t, r) { r.buf[r.pos++] = 127 & e | 128, e >>>= 7, r.buf[r.pos++] = 127 & e | 128, e >>>= 7, r.buf[r.pos++] = 127 & e | 128, e >>>= 7, r.buf[r.pos++] = 127 & e | 128, r.buf[r.pos] = 127 & (e >>>= 7) }(r, 0, t), function (e, t) { var r = (7 & e) << 4; t.buf[t.pos++] |= r | ((e >>>= 3) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e))))) }(n, t) }(e, this) : (this.realloc(4), this.buf[this.pos++] = 127 & e | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = e >>> 7 & 127)))) }, writeSVarint: function (e) { this.writeVarint(e < 0 ? 2 * -e - 1 : 2 * e) }, writeBoolean: function (e) { this.writeVarint(Boolean(e)) }, writeString: function (e) { e = String(e), this.realloc(4 * e.length), this.pos++; var t = this.pos; this.pos = function (e, t, r) { for (var n, i, o = 0; o < t.length; o++) { if ((n = t.charCodeAt(o)) > 55295 && n < 57344) { if (!i) { n > 56319 || o + 1 === t.length ? (e[r++] = 239, e[r++] = 191, e[r++] = 189) : i = n; continue } if (n < 56320) { e[r++] = 239, e[r++] = 191, e[r++] = 189, i = n; continue } n = i - 55296 << 10 | n - 56320 | 65536, i = null } else i && (e[r++] = 239, e[r++] = 191, e[r++] = 189, i = null); n < 128 ? e[r++] = n : (n < 2048 ? e[r++] = n >> 6 | 192 : (n < 65536 ? e[r++] = n >> 12 | 224 : (e[r++] = n >> 18 | 240, e[r++] = n >> 12 & 63 | 128), e[r++] = n >> 6 & 63 | 128), e[r++] = 63 & n | 128) } return r }(this.buf, e, this.pos); var r = this.pos - t; r >= 128 && Yh(t, r, this), this.pos = t - 1, this.writeVarint(r), this.pos += r }, writeFloat: function (e) { this.realloc(4), Wh.write(this.buf, e, this.pos, !0, 23, 4), this.pos += 4 }, writeDouble: function (e) { this.realloc(8), Wh.write(this.buf, e, this.pos, !0, 52, 8), this.pos += 8 }, writeBytes: function (e) { var t = e.length; this.writeVarint(t), this.realloc(t); for (var r = 0; r < t; r++)this.buf[this.pos++] = e[r] }, writeRawMessage: function (e, t) { this.pos++; var r = this.pos; e(t, this); var n = this.pos - r; n >= 128 && Yh(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n }, writeMessage: function (e, t, r) { this.writeTag(e, Zh.Bytes), this.writeRawMessage(t, r) }, writePackedVarint: function (e, t) { t.length && this.writeMessage(e, ed, t) }, writePackedSVarint: function (e, t) { t.length && this.writeMessage(e, td, t) }, writePackedBoolean: function (e, t) { t.length && this.writeMessage(e, id, t) }, writePackedFloat: function (e, t) { t.length && this.writeMessage(e, rd, t) }, writePackedDouble: function (e, t) { t.length && this.writeMessage(e, nd, t) }, writePackedFixed32: function (e, t) { t.length && this.writeMessage(e, od, t) }, writePackedSFixed32: function (e, t) { t.length && this.writeMessage(e, sd, t) }, writePackedFixed64: function (e, t) { t.length && this.writeMessage(e, ad, t) }, writePackedSFixed64: function (e, t) { t.length && this.writeMessage(e, cd, t) }, writeBytesField: function (e, t) { this.writeTag(e, Zh.Bytes), this.writeBytes(t) }, writeFixed32Field: function (e, t) { this.writeTag(e, Zh.Fixed32), this.writeFixed32(t) }, writeSFixed32Field: function (e, t) { this.writeTag(e, Zh.Fixed32), this.writeSFixed32(t) }, writeFixed64Field: function (e, t) { this.writeTag(e, Zh.Fixed64), this.writeFixed64(t) }, writeSFixed64Field: function (e, t) { this.writeTag(e, Zh.Fixed64), this.writeSFixed64(t) }, writeVarintField: function (e, t) { this.writeTag(e, Zh.Varint), this.writeVarint(t) }, writeSVarintField: function (e, t) { this.writeTag(e, Zh.Varint), this.writeSVarint(t) }, writeStringField: function (e, t) { this.writeTag(e, Zh.Bytes), this.writeString(t) }, writeFloatField: function (e, t) { this.writeTag(e, Zh.Fixed32), this.writeFloat(t) }, writeDoubleField: function (e, t) { this.writeTag(e, Zh.Fixed64), this.writeDouble(t) }, writeBooleanField: function (e, t) { this.writeVarintField(e, Boolean(t)) } }; const dd = 3; function pd(e, t, r) { t.glyphs = [], 1 === e && r.readMessage(fd, t) } function fd(e, t, r) { if (3 === e) { const { id: e, bitmap: n, width: i, height: o, left: s, top: a, advance: c } = r.readMessage(md, {}); t.glyphs.push({ id: e, bitmap: new Rl({ width: i + 2 * dd, height: o + 2 * dd }, n), metrics: { width: i, height: o, left: s, top: a, advance: c } }) } else 4 === e ? t.ascender = r.readSVarint() : 5 === e && (t.descender = r.readSVarint()) } function md(e, t, r) { 1 === e ? t.id = r.readVarint() : 2 === e ? t.bitmap = r.readBytes() : 3 === e ? t.width = r.readVarint() : 4 === e ? t.height = r.readVarint() : 5 === e ? t.left = r.readSVarint() : 6 === e ? t.top = r.readSVarint() : 7 === e && (t.advance = r.readVarint()) } const gd = dd; function _d(e) { let t = 0, r = 0; for (const s of e) t += s.w * s.h, r = Math.max(r, s.w); e.sort(((e, t) => t.h - e.h)); const n = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / .95)), r), h: 1 / 0 }]; let i = 0, o = 0; for (const s of e) for (let e = n.length - 1; e >= 0; e--) { const t = n[e]; if (!(s.w > t.w || s.h > t.h)) { if (s.x = t.x, s.y = t.y, o = Math.max(o, s.y + s.h), i = Math.max(i, s.x + s.w), s.w === t.w && s.h === t.h) { const t = n.pop(); e < n.length && (n[e] = t) } else s.h === t.h ? (t.x += s.w, t.w -= s.w) : s.w === t.w ? (t.y += s.h, t.h -= s.h) : (n.push({ x: t.x + s.w, y: t.y, w: t.w - s.w, h: s.h }), t.y += s.h, t.h -= s.h); break } } return { w: i, h: o, fill: t / (i * o) || 0 } } const yd = 1; class vd { constructor(e, { pixelRatio: t, version: r, stretchX: n, stretchY: i, content: o }) { this.paddedRect = e, this.pixelRatio = t, this.stretchX = n, this.stretchY = i, this.content = o, this.version = r } get tl() { return [this.paddedRect.x + yd, this.paddedRect.y + yd] } get br() { return [this.paddedRect.x + this.paddedRect.w - yd, this.paddedRect.y + this.paddedRect.h - yd] } get displaySize() { return [(this.paddedRect.w - 2 * yd) / this.pixelRatio, (this.paddedRect.h - 2 * yd) / this.pixelRatio] } } class xd { constructor(e, t) { const r = {}, n = {}; this.haveRenderCallbacks = []; const i = []; this.addImages(e, r, i), this.addImages(t, n, i); const { w: o, h: s } = _d(i), a = new Dl({ width: o || 1, height: s || 1 }); for (const c in e) { const t = e[c], n = r[c].paddedRect; Dl.copy(t.data, a, { x: 0, y: 0 }, { x: n.x + yd, y: n.y + yd }, t.data) } for (const c in t) { const e = t[c], r = n[c].paddedRect, i = r.x + yd, o = r.y + yd, s = e.data.width, l = e.data.height; Dl.copy(e.data, a, { x: 0, y: 0 }, { x: i, y: o }, e.data), Dl.copy(e.data, a, { x: 0, y: l - 1 }, { x: i, y: o - 1 }, { width: s, height: 1 }), Dl.copy(e.data, a, { x: 0, y: 0 }, { x: i, y: o + l }, { width: s, height: 1 }), Dl.copy(e.data, a, { x: s - 1, y: 0 }, { x: i - 1, y: o }, { width: 1, height: l }), Dl.copy(e.data, a, { x: 0, y: 0 }, { x: i + s, y: o }, { width: 1, height: l }) } this.image = a, this.iconPositions = r, this.patternPositions = n } addImages(e, t, r) { for (const n in e) { const i = e[n], o = { x: 0, y: 0, w: i.data.width + 2 * yd, h: i.data.height + 2 * yd }; r.push(o), t[n] = new vd(o, i), i.hasRenderCallback && this.haveRenderCallbacks.push(n) } } patchUpdatedImages(e, t) { this.haveRenderCallbacks = this.haveRenderCallbacks.filter((t => e.hasImage(t))), e.dispatchRenderCallbacks(this.haveRenderCallbacks); for (const r in e.updatedImages) this.patchUpdatedImage(this.iconPositions[r], e.getImage(r), t), this.patchUpdatedImage(this.patternPositions[r], e.getImage(r), t) } patchUpdatedImage(e, t, r) { if (!e || !t) return; if (e.version === t.version) return; e.version = t.version; const [n, i] = e.tl; r.update(t.data, void 0, { x: n, y: i }) } } Zi(vd, "ImagePosition"), Zi(xd, "ImageAtlas"); const bd = { horizontal: 1, vertical: 2, horizontalOnly: 3 }, wd = -17; class Td { constructor() { this.scale = 1, this.fontStack = "", this.imageName = null } static forText(e, t) { const r = new Td; return r.scale = e || 1, r.fontStack = t, r } static forImage(e) { const t = new Td; return t.imageName = e, t } } class kd { constructor() { this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null } static fromFeature(e, t) { const r = new kd; for (let n = 0; n < e.sections.length; n++) { const i = e.sections[n]; i.image ? r.addImageSection(i) : r.addTextSection(i, t) } return r } length() { return this.text.length } getSection(e) { return this.sections[this.sectionIndex[e]] } getSections() { return this.sections } getSectionIndex(e) { return this.sectionIndex[e] } getCharCode(e) { return this.text.charCodeAt(e) } verticalizePunctuation(e) { this.text = function (e, t) { let r = ""; for (let n = 0; n < e.length; n++) { const i = e.charCodeAt(n + 1) || null, o = e.charCodeAt(n - 1) || null; r += !t && (i && no(i) && !Gh[e[n + 1]] || o && no(o) && !Gh[e[n - 1]]) || !Gh[e[n]] ? e[n] : Gh[e[n]] } return r }(this.text, e) } trim() { let e = 0; for (let r = 0; r < this.text.length && Ed[this.text.charCodeAt(r)]; r++)e++; let t = this.text.length; for (let r = this.text.length - 1; r >= 0 && r >= e && Ed[this.text.charCodeAt(r)]; r--)t--; this.text = this.text.substring(e, t), this.sectionIndex = this.sectionIndex.slice(e, t) } substring(e, t) { const r = new kd; return r.text = this.text.substring(e, t), r.sectionIndex = this.sectionIndex.slice(e, t), r.sections = this.sections, r } toString() { return this.text } getMaxScale() { return this.sectionIndex.reduce(((e, t) => Math.max(e, this.sections[t].scale)), 0) } addTextSection(e, t) { this.text += e.text, this.sections.push(Td.forText(e.scale, e.fontStack || t)); const r = this.sections.length - 1; for (let n = 0; n < e.text.length; ++n)this.sectionIndex.push(r) } addImageSection(e) { const t = e.image ? e.image.name : ""; if (0 === t.length) return void G("Can't add FormattedSection with an empty image."); const r = this.getNextImageSectionCharCode(); r ? (this.text += String.fromCharCode(r), this.sections.push(Td.forImage(t)), this.sectionIndex.push(this.sections.length - 1)) : G("Reached maximum number of images 6401") } getNextImageSectionCharCode() { return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID) } } function Cd(e, t, r, n, i, o, s, a, c, l, u, h, d, p, f) { const m = kd.fromFeature(e, i); h === bd.vertical && m.verticalizePunctuation(d); let g = []; const _ = function (e, t, r, n, i, o) { if (!e) return []; const s = [], a = function (e, t, r, n, i, o) { let s = 0; for (let a = 0; a < e.length(); a++) { const r = e.getSection(a); s += Pd(e.getCharCode(a), r, n, i, t, o) } return s / Math.max(1, Math.ceil(s / r)) }(e, t, r, n, i, o), c = e.text.indexOf("​") >= 0; let l = 0; for (let h = 0; h < e.length(); h++) { const r = e.getSection(h), d = e.getCharCode(h); if (Ed[d] || (l += Pd(d, r, n, i, t, o)), h < e.length() - 1) { const t = !((u = d) < 11904 || !(Ki["Bopomofo Extended"](u) || Ki.Bopomofo(u) || Ki["CJK Compatibility Forms"](u) || Ki["CJK Compatibility Ideographs"](u) || Ki["CJK Compatibility"](u) || Ki["CJK Radicals Supplement"](u) || Ki["CJK Strokes"](u) || Ki["CJK Symbols and Punctuation"](u) || Ki["CJK Unified Ideographs Extension A"](u) || Ki["CJK Unified Ideographs"](u) || Ki["Enclosed CJK Letters and Months"](u) || Ki["Halfwidth and Fullwidth Forms"](u) || Ki.Hiragana(u) || Ki["Ideographic Description Characters"](u) || Ki["Kangxi Radicals"](u) || Ki["Katakana Phonetic Extensions"](u) || Ki.Katakana(u) || Ki["Vertical Forms"](u) || Ki["Yi Radicals"](u) || Ki["Yi Syllables"](u))); (Sd[d] || t || r.imageName) && s.push(Ld(h + 1, l, a, s, Ad(d, e.getCharCode(h + 1), t && c), !1)) } } var u; return Md(Ld(e.length(), l, a, s, 0, !0)) }(m, l, o, t, n, p), { processBidirectionalText: y, processStyledBidirectionalText: v } = vo; if (y && 1 === m.sections.length) { const e = y(m.toString(), _); for (const t of e) { const e = new kd; e.text = t, e.sections = m.sections; for (let r = 0; r < t.length; r++)e.sectionIndex.push(0); g.push(e) } } else if (v) { const e = v(m.text, m.sectionIndex, _); for (const t of e) { const e = new kd; e.text = t[0], e.sectionIndex = t[1], e.sections = m.sections, g.push(e) } } else g = function (e, t) { const r = [], n = e.text; let i = 0; for (const o of t) r.push(e.substring(i, o)), i = o; return i < n.length && r.push(e.substring(i, n.length)), r }(m, _); const x = [], b = { positionedLines: x, text: m.toString(), top: u[1], bottom: u[1], left: u[0], right: u[0], writingMode: h, iconsInText: !1, verticalizable: !1, hasBaseline: !1 }; return function (e, t, r, n, i, o, s, a, c, l, u, h) { let d = 0, p = 0, f = 0; const m = "right" === a ? 1 : "left" === a ? 0 : .5; let g = !1; for (const w of i) { const e = w.getSections(); for (const r of e) { if (r.imageName) continue; const e = t[r.fontStack]; if (e && (g = void 0 !== e.ascender && void 0 !== e.descender, !g)) break } if (!g) break } let _ = 0; for (const w of i) { w.trim(); const i = w.getMaxScale(), s = (i - 1) * Rh, a = { positionedGlyphs: [], lineOffset: 0 }; e.positionedLines[_] = a; const v = a.positionedGlyphs; let x = 0; if (!w.length()) { p += o, ++_; continue } let b = 0, T = 0; for (let o = 0; o < w.length(); o++) { const s = w.getSection(o), a = w.getSectionIndex(o), f = w.getCharCode(o); let m = s.scale, _ = null, k = null, C = null, E = Rh, S = 0; const P = !(c === bd.horizontal || !u && !ro(f) || u && (Ed[f] || (y = f, Ki.Arabic(y) || Ki["Arabic Supplement"](y) || Ki["Arabic Extended-A"](y) || Ki["Arabic Presentation Forms-A"](y) || Ki["Arabic Presentation Forms-B"](y)))); if (s.imageName) { const t = n[s.imageName]; if (!t) continue; C = s.imageName, e.iconsInText = e.iconsInText || !0, k = t.paddedRect; const r = t.displaySize; m = m * Rh / h, _ = { width: r[0], height: r[1], left: yd, top: -gd, advance: P ? r[1] : r[0], localGlyph: !1 }, S = g ? -_.height * m : wd + i * Rh - r[1] * m, E = _.advance; const o = (P ? r[0] : r[1]) * m - Rh * i; o > 0 && o > x && (x = o) } else { const e = r[s.fontStack]; if (!e) continue; e[f] && (k = e[f]); const n = t[s.fontStack]; if (!n) continue; const o = n.glyphs[f]; if (!o) continue; if (_ = o.metrics, E = 8203 !== f ? Rh : 0, g) { const e = void 0 !== n.ascender ? Math.abs(n.ascender) : 0, t = void 0 !== n.descender ? Math.abs(n.descender) : 0, r = (e + t) * m; b < r && (b = r, T = (e - t) / 2 * m), S = -e * m } else S = wd + (i - m) * Rh } P ? (e.verticalizable = !0, v.push({ glyph: f, imageName: C, x: d, y: p + S, vertical: P, scale: m, localGlyph: _.localGlyph, fontStack: s.fontStack, sectionIndex: a, metrics: _, rect: k }), d += E * m + l) : (v.push({ glyph: f, imageName: C, x: d, y: p + S, vertical: P, scale: m, localGlyph: _.localGlyph, fontStack: s.fontStack, sectionIndex: a, metrics: _, rect: k }), d += _.advance * m + l) } 0 !== v.length && (f = Math.max(d - l, f), g ? Rd(v, m, x, T, o * i / 2) : Rd(v, m, x, 0, o / 2)), d = 0; const k = o * i + x; a.lineOffset = Math.max(x, s), p += k, ++_ } var y; const v = p, { horizontalAlign: x, verticalAlign: b } = Bd(s); (function (e, t, r, n, i, o) { const s = (t - r) * i, a = -o * n; for (const c of e) for (const e of c.positionedGlyphs) e.x += s, e.y += a })(e.positionedLines, m, x, b, f, v), e.top += -b * v, e.bottom = e.top + v, e.left += -x * f, e.right = e.left + f, e.hasBaseline = g }(b, t, r, n, g, s, a, c, h, l, d, f), !function (e) { for (const t of e) if (0 !== t.positionedGlyphs.length) return !1; return !0 }(x) && b } const Ed = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, Sd = { 10: !0, 32: !0, 38: !0, 40: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }; function Pd(e, t, r, n, i, o) { if (t.imageName) { const e = n[t.imageName]; return e ? e.displaySize[0] * t.scale * Rh / o + i : 0 } { const n = r[t.fontStack], o = n && n.glyphs[e]; return o ? o.metrics.advance * t.scale + i : 0 } } function Id(e, t, r, n) { const i = Math.pow(e - t, 2); return n ? e < t ? i / 2 : 2 * i : i + Math.abs(r) * r } function Ad(e, t, r) { let n = 0; return 10 === e && (n -= 1e4), r && (n += 150), 40 !== e && 65288 !== e || (n += 50), 41 !== t && 65289 !== t || (n += 50), n } function Ld(e, t, r, n, i, o) { let s = null, a = Id(t, r, i, o); for (const c of n) { const e = Id(t - c.x, r, i, o) + c.badness; e <= a && (s = c, a = e) } return { index: e, x: t, priorBreak: s, badness: a } } function Md(e) { return e ? Md(e.priorBreak).concat(e.index) : [] } function Bd(e) { let t = .5, r = .5; switch (e) { case "right": case "top-right": case "bottom-right": t = 1; break; case "left": case "top-left": case "bottom-left": t = 0 }switch (e) { case "bottom": case "bottom-right": case "bottom-left": r = 1; break; case "top": case "top-right": case "top-left": r = 0 }return { horizontalAlign: t, verticalAlign: r } } function Rd(e, t, r, n, i) { if (!(t || r || n || i)) return; const o = e.length - 1, s = e[o], a = (s.x + s.metrics.advance * s.scale) * t; for (let c = 0; c <= o; c++)e[c].x -= a, e[c].y += r + n + i } function Dd(e, t, r) { const { horizontalAlign: n, verticalAlign: i } = Bd(r), o = t[0] - e.displaySize[0] * n, s = t[1] - e.displaySize[1] * i; return { image: e, top: s, bottom: s + e.displaySize[1], left: o, right: o + e.displaySize[0] } } function Fd(e, t, r, n, i, o) { const s = e.image; let a; if (s.content) { const e = s.content, t = s.pixelRatio || 1; a = [e[0] / t, e[1] / t, s.displaySize[0] - e[2] / t, s.displaySize[1] - e[3] / t] } const c = t.left * o, l = t.right * o; let u, h, d, p; "width" === r || "both" === r ? (p = i[0] + c - n[3], h = i[0] + l + n[1]) : (p = i[0] + (c + l - s.displaySize[0]) / 2, h = p + s.displaySize[0]); const f = t.top * o, m = t.bottom * o; return "height" === r || "both" === r ? (u = i[1] + f - n[0], d = i[1] + m + n[2]) : (u = i[1] + (f + m - s.displaySize[1]) / 2, d = u + s.displaySize[1]), { image: s, top: u, right: h, bottom: d, left: p, collisionPadding: a } } class Od extends f { constructor(e, t, r, n, i) { super(e, t), this.angle = n, this.z = r, void 0 !== i && (this.segment = i) } clone() { return new Od(this.x, this.y, this.z, this.angle, this.segment) } } function zd(e, t, r, n, i) { if (void 0 === t.segment) return !0; let o = t, s = t.segment + 1, a = 0; for (; a > -r / 2;) { if (s--, s < 0) return !1; a -= e[s].dist(o), o = e[s] } a += e[s].dist(e[s + 1]), s++; const c = []; let l = 0; for (; a < r / 2;) { const t = e[s], r = e[s + 1]; if (!r) return !1; let o = e[s - 1].angleTo(t) - t.angleTo(r); for (o = Math.abs((o + 3 * Math.PI) % (2 * Math.PI) - Math.PI), c.push({ distance: a, angleDelta: o }), l += o; a - c[0].distance > n;)l -= c.shift().angleDelta; if (l > i) return !1; s++, a += t.dist(r) } return !0 } function Ud(e) { let t = 0; for (let r = 0; r < e.length - 1; r++)t += e[r].dist(e[r + 1]); return t } function Nd(e, t, r) { return e ? .6 * t * r : 0 } function Gd(e, t) { return Math.max(e ? e.right - e.left : 0, t ? t.right - t.left : 0) } function Vd(e, t, r, n, i, o) { const s = Nd(r, i, o), a = Gd(r, n) * o; let c = 0; const l = Ud(e) / 2; for (let u = 0; u < e.length - 1; u++) { const r = e[u], n = e[u + 1], i = r.dist(n); if (c + i > l) { const o = (l - c) / i, h = Ir(r.x, n.x, o), d = Ir(r.y, n.y, o), p = new Od(h, d, 0, n.angleTo(r), u); return !s || zd(e, p, a, s, t) ? p : void 0 } c += i } } function qd(e, t, r, n, i, o, s, a, c) { const l = Nd(n, o, s), u = Gd(n, i), h = u * s, d = 0 === e[0].x || e[0].x === c || 0 === e[0].y || e[0].y === c; return t - h < t / 4 && (t = h + t / 4), jd(e, d ? t / 2 * a % t : (u / 2 + 2 * o) * s * a % t, t, l, r, h, d, !1, c) } function jd(e, t, r, n, i, o, s, a, c) { const l = o / 2, u = Ud(e); let h = 0, d = t - r, p = []; for (let f = 0; f < e.length - 1; f++) { const t = e[f], s = e[f + 1], a = t.dist(s), m = s.angleTo(t); for (; d + r < h + a;) { d += r; const g = (d - h) / a, _ = Ir(t.x, s.x, g), y = Ir(t.y, s.y, g); if (_ >= 0 && _ < c && y >= 0 && y < c && d - l >= 0 && d + l <= u) { const t = new Od(_, y, 0, m, f); t._round(), n && !zd(e, t, o, n, i) || p.push(t) } } h += a } return a || p.length || s || (p = jd(e, h / 2, r, n, i, o, s, !0, c)), p } function Xd(e, t, r, n, i) { const o = []; for (let s = 0; s < e.length; s++) { const a = e[s]; let c; for (let e = 0; e < a.length - 1; e++) { let s = a[e], l = a[e + 1]; s.x < t && l.x < t || (s.x < t ? s = new f(t, s.y + (t - s.x) / (l.x - s.x) * (l.y - s.y))._round() : l.x < t && (l = new f(t, s.y + (t - s.x) / (l.x - s.x) * (l.y - s.y))._round()), s.y < r && l.y < r || (s.y < r ? s = new f(s.x + (r - s.y) / (l.y - s.y) * (l.x - s.x), r)._round() : l.y < r && (l = new f(s.x + (r - s.y) / (l.y - s.y) * (l.x - s.x), r)._round()), s.x >= n && l.x >= n || (s.x >= n ? s = new f(n, s.y + (n - s.x) / (l.x - s.x) * (l.y - s.y))._round() : l.x >= n && (l = new f(n, s.y + (n - s.x) / (l.x - s.x) * (l.y - s.y))._round()), s.y >= i && l.y >= i || (s.y >= i ? s = new f(s.x + (i - s.y) / (l.y - s.y) * (l.x - s.x), i)._round() : l.y >= i && (l = new f(s.x + (i - s.y) / (l.y - s.y) * (l.x - s.x), i)._round()), c && s.equals(c[c.length - 1]) || (c = [s], o.push(c)), c.push(l))))) } } return o } Zi(Od, "Anchor"); const Wd = 1e20; function Zd(e, t, r, n, i, o, s, a, c) { for (let l = t; l < t + n; l++)Hd(e, r * o + l, o, i, s, a, c); for (let l = r; l < r + i; l++)Hd(e, l * o + t, 1, n, s, a, c) } function Hd(e, t, r, n, i, o, s) { o[0] = 0, s[0] = -Wd, s[1] = Wd, i[0] = e[t]; for (let a = 1, c = 0, l = 0; a < n; a++) { i[a] = e[t + a * r]; const n = a * a; do { const e = o[c]; l = (i[a] - i[e] + n - e * e) / (a - e) / 2 } while (l <= s[c] && --c > -1); c++, o[c] = a, s[c] = l, s[c + 1] = Wd } for (let a = 0, c = 0; a < n; a++) { for (; s[c + 1] < a;)c++; const n = o[c], l = a - n; e[t + a * r] = i[n] + l * l } } const Qd = 2, $d = { none: 0, ideographs: 1, all: 2 }; class Jd { constructor(e, t, r) { this.requestManager = e, this.localGlyphMode = t, this.localFontFamily = r, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} } } setURL(e) { this.url = e } getGlyphs(e, t) { const r = []; for (const n in e) for (const t of e[n]) r.push({ stack: n, id: t }); S(r, (({ stack: e, id: t }, r) => { let n = this.entries[e]; n || (n = this.entries[e] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 }); let i = n.glyphs[t]; if (void 0 !== i) return void r(null, { stack: e, id: t, glyph: i }); if (i = this._tinySDF(n, e, t), i) return n.glyphs[t] = i, void r(null, { stack: e, id: t, glyph: i }); const o = Math.floor(t / 256); if (256 * o > 65535) return void r(new Error("glyphs > 65535 not supported")); if (n.ranges[o]) return void r(null, { stack: e, id: t, glyph: i }); let s = n.requests[o]; s || (s = n.requests[o] = [], Jd.loadGlyphRange(e, o, this.url, this.requestManager, ((e, t) => { if (t) { n.ascender = t.ascender, n.descender = t.descender; for (const e in t.glyphs) this._doesCharSupportLocalGlyph(+e) || (n.glyphs[+e] = t.glyphs[+e]); n.ranges[o] = !0 } for (const r of s) r(e, t); delete n.requests[o] }))), s.push(((n, i) => { n ? r(n) : i && r(null, { stack: e, id: t, glyph: i.glyphs[t] || null }) })) }), ((e, r) => { if (e) t(e); else if (r) { const e = {}; for (const { stack: t, id: n, glyph: i } of r) void 0 === e[t] && (e[t] = {}), void 0 === e[t].glyphs && (e[t].glyphs = {}), e[t].glyphs[n] = i && { id: i.id, bitmap: i.bitmap.clone(), metrics: i.metrics }, e[t].ascender = this.entries[t].ascender, e[t].descender = this.entries[t].descender; t(null, e) } })) } _doesCharSupportLocalGlyph(e) { return this.localGlyphMode !== $d.none && (this.localGlyphMode === $d.all ? !!this.localFontFamily : !!this.localFontFamily && (Ki["CJK Unified Ideographs"](e) || Ki["Hangul Syllables"](e) || Ki.Hiragana(e) || Ki.Katakana(e) || Ki["CJK Symbols and Punctuation"](e))) } _tinySDF(e, t, r) { const n = this.localFontFamily; if (!n || !this._doesCharSupportLocalGlyph(r)) return; let i = e.tinySDF; if (!i) { let r = "400"; /bold/i.test(t) ? r = "900" : /medium/i.test(t) ? r = "500" : /light/i.test(t) && (r = "200"), i = e.tinySDF = new Jd.TinySDF({ fontFamily: n, fontWeight: r, fontSize: 24 * Qd, buffer: 3 * Qd, radius: 8 * Qd }), i.fontWeight = r } if (this.localGlyphs[i.fontWeight][r]) return this.localGlyphs[i.fontWeight][r]; const o = String.fromCharCode(r), { data: s, width: a, height: c, glyphWidth: l, glyphHeight: u, glyphLeft: h, glyphTop: d, glyphAdvance: p } = i.draw(o); return this.localGlyphs[i.fontWeight][r] = { id: r, bitmap: new Rl({ width: a, height: c }, s), metrics: { width: l / Qd, height: u / Qd, left: h / Qd, top: d / Qd - 27, advance: p / Qd, localGlyph: !0 } } } } Jd.loadGlyphRange = function (e, t, r, n, i) { const o = 256 * t, s = o + 255, a = n.transformRequest(n.normalizeGlyphsURL(r).replace("{fontstack}", e).replace("{range}", `${o}-${s}`), se.Glyphs); ue(a, ((e, t) => { if (e) i(e); else if (t) { const e = {}, r = function (e) { return new Xh(e).readFields(pd, {}) }(t); for (const t of r.glyphs) e[t.id] = t; i(null, { glyphs: e, ascender: r.ascender, descender: r.descender }) } })) }, Jd.TinySDF = class { constructor({ fontSize: e = 24, buffer: t = 3, radius: r = 8, cutoff: n = .25, fontFamily: i = "sans-serif", fontWeight: o = "normal", fontStyle: s = "normal" } = {}) { this.buffer = t, this.cutoff = n, this.radius = r; const a = this.size = e + 4 * t, c = this._createCanvas(a), l = this.ctx = c.getContext("2d", { willReadFrequently: !0 }); l.font = `${s} ${o} ${e}px ${i}`, l.textBaseline = "alphabetic", l.textAlign = "left", l.fillStyle = "black", this.gridOuter = new Float64Array(a * a), this.gridInner = new Float64Array(a * a), this.f = new Float64Array(a), this.z = new Float64Array(a + 1), this.v = new Uint16Array(a) } _createCanvas(e) { const t = document.createElement("canvas"); return t.width = t.height = e, t } draw(e) { const { width: t, actualBoundingBoxAscent: r, actualBoundingBoxDescent: n, actualBoundingBoxLeft: i, actualBoundingBoxRight: o } = this.ctx.measureText(e), s = Math.ceil(r), a = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o - i))), c = Math.min(this.size - this.buffer, s + Math.ceil(n)), l = a + 2 * this.buffer, u = c + 2 * this.buffer, h = Math.max(l * u, 0), d = new Uint8ClampedArray(h), p = { data: d, width: l, height: u, glyphWidth: a, glyphHeight: c, glyphTop: s, glyphLeft: 0, glyphAdvance: t }; if (0 === a || 0 === c) return p; const { ctx: f, buffer: m, gridInner: g, gridOuter: _ } = this; f.clearRect(m, m, a, c), f.fillText(e, m, m + s); const y = f.getImageData(m, m, a, c); _.fill(Wd, 0, h), g.fill(0, 0, h); for (let v = 0; v < c; v++)for (let e = 0; e < a; e++) { const t = y.data[4 * (v * a + e) + 3] / 255; if (0 === t) continue; const r = (v + m) * l + e + m; if (1 === t) _[r] = 0, g[r] = Wd; else { const e = .5 - t; _[r] = e > 0 ? e * e : 0, g[r] = e < 0 ? e * e : 0 } } Zd(_, 0, 0, l, u, l, this.f, this.v, this.z), Zd(g, m, m, a, c, l, this.f, this.v, this.z); for (let v = 0; v < h; v++) { const e = Math.sqrt(_[v]) - Math.sqrt(g[v]); d[v] = Math.round(255 - 255 * (e / this.radius + this.cutoff)) } return p } }; const Kd = yd; function Yd(e, t, r, n) { const i = [], o = e.image, s = o.pixelRatio, a = o.paddedRect.w - 2 * Kd, c = o.paddedRect.h - 2 * Kd, l = e.right - e.left, u = e.bottom - e.top, h = o.stretchX || [[0, a]], d = o.stretchY || [[0, c]], p = (e, t) => e + t[1] - t[0], m = h.reduce(p, 0), g = d.reduce(p, 0), _ = a - m, y = c - g; let v = 0, x = m, b = 0, w = g, T = 0, k = _, C = 0, E = y; if (o.content && n) { const e = o.content; v = ep(h, 0, e[0]), b = ep(d, 0, e[1]), x = ep(h, e[0], e[2]), w = ep(d, e[1], e[3]), T = e[0] - v, C = e[1] - b, k = e[2] - e[0] - x, E = e[3] - e[1] - w } const S = (n, i, a, c) => { const h = rp(n.stretch - v, x, l, e.left), d = np(n.fixed - T, k, n.stretch, m), p = rp(i.stretch - b, w, u, e.top), _ = np(i.fixed - C, E, i.stretch, g), y = rp(a.stretch - v, x, l, e.left), S = np(a.fixed - T, k, a.stretch, m), P = rp(c.stretch - b, w, u, e.top), I = np(c.fixed - C, E, c.stretch, g), A = new f(h, p), L = new f(y, p), M = new f(y, P), B = new f(h, P), R = new f(d / s, _ / s), D = new f(S / s, I / s), F = t * Math.PI / 180; if (F) { const e = Math.sin(F), t = Math.cos(F), r = [t, -e, e, t]; A._matMult(r), L._matMult(r), B._matMult(r), M._matMult(r) } const O = n.stretch + n.fixed, z = i.stretch + i.fixed; return { tl: A, tr: L, bl: B, br: M, tex: { x: o.paddedRect.x + Kd + O, y: o.paddedRect.y + Kd + z, w: a.stretch + a.fixed - O, h: c.stretch + c.fixed - z }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: R, pixelOffsetBR: D, minFontScaleX: k / s / l, minFontScaleY: E / s / u, isSDF: r } }; if (n && (o.stretchX || o.stretchY)) { const e = tp(h, _, m), t = tp(d, y, g); for (let r = 0; r < e.length - 1; r++) { const n = e[r], o = e[r + 1]; for (let e = 0; e < t.length - 1; e++)i.push(S(n, t[e], o, t[e + 1])) } } else i.push(S({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: a + 1 }, { fixed: 0, stretch: c + 1 })); return i } function ep(e, t, r) { let n = 0; for (const i of e) n += Math.max(t, Math.min(r, i[1])) - Math.max(t, Math.min(r, i[0])); return n } function tp(e, t, r) { const n = [{ fixed: -Kd, stretch: 0 }]; for (const [i, o] of e) { const e = n[n.length - 1]; n.push({ fixed: i - e.stretch, stretch: e.stretch }), n.push({ fixed: i - e.stretch, stretch: e.stretch + (o - i) }) } return n.push({ fixed: t + Kd, stretch: r }), n } function rp(e, t, r, n) { return e / t * r + n } function np(e, t, r, n) { return e - t * r / n } function ip(e, t, r, n) { const i = t + e.positionedLines[n].lineOffset; return 0 === n ? r + i / 2 : r + (i + (t + e.positionedLines[n - 1].lineOffset)) / 2 } class op { constructor(e = [], t = sp) { if (this.data = e, this.length = this.data.length, this.compare = t, this.length > 0) for (let r = (this.length >> 1) - 1; r >= 0; r--)this._down(r) } push(e) { this.data.push(e), this.length++, this._up(this.length - 1) } pop() { if (0 === this.length) return; const e = this.data[0], t = this.data.pop(); return this.length--, this.length > 0 && (this.data[0] = t, this._down(0)), e } peek() { return this.data[0] } _up(e) { const { data: t, compare: r } = this, n = t[e]; for (; e > 0;) { const i = e - 1 >> 1, o = t[i]; if (r(n, o) >= 0) break; t[e] = o, e = i } t[e] = n } _down(e) { const { data: t, compare: r } = this, n = this.length >> 1, i = t[e]; for (; e < n;) { let n = 1 + (e << 1), o = t[n]; const s = n + 1; if (s < this.length && r(t[s], o) < 0 && (n = s, o = t[s]), r(o, i) >= 0) break; t[e] = o, e = n } t[e] = i } } function sp(e, t) { return e < t ? -1 : e > t ? 1 : 0 } function ap(e, t = 1, r = !1) { let n = 1 / 0, i = 1 / 0, o = -1 / 0, s = -1 / 0; const a = e[0]; for (let p = 0; p < a.length; p++) { const e = a[p]; (!p || e.x < n) && (n = e.x), (!p || e.y < i) && (i = e.y), (!p || e.x > o) && (o = e.x), (!p || e.y > s) && (s = e.y) } const c = Math.min(o - n, s - i); let l = c / 2; const u = new op([], cp); if (0 === c) return new f(n, i); for (let p = n; p < o; p += c)for (let t = i; t < s; t += c)u.push(new lp(p + l, t + l, l, e)); let h = function (e) { let t = 0, r = 0, n = 0; const i = e[0]; for (let o = 0, s = i.length, a = s - 1; o < s; a = o++) { const e = i[o], s = i[a], c = e.x * s.y - s.x * e.y; r += (e.x + s.x) * c, n += (e.y + s.y) * c, t += 3 * c } return new lp(r / t, n / t, 0, e) }(e), d = u.length; for (; u.length;) { const n = u.pop(); (n.d > h.d || !h.d) && (h = n, r && console.log("found best %d after %d probes", Math.round(1e4 * n.d) / 1e4, d)), n.max - h.d <= t || (l = n.h / 2, u.push(new lp(n.p.x - l, n.p.y - l, l, e)), u.push(new lp(n.p.x + l, n.p.y - l, l, e)), u.push(new lp(n.p.x - l, n.p.y + l, l, e)), u.push(new lp(n.p.x + l, n.p.y + l, l, e)), d += 4) } return r && (console.log(`num probes: ${d}`), console.log(`best distance: ${h.d}`)), h.p } function cp(e, t) { return t.max - e.max } function lp(e, t, r, n) { this.p = new f(e, t), this.h = r, this.d = function (e, t) { let r = !1, n = 1 / 0; for (let i = 0; i < t.length; i++) { const o = t[i]; for (let t = 0, i = o.length, s = i - 1; t < i; s = t++) { const i = o[t], a = o[s]; i.y > e.y != a.y > e.y && e.x < (a.x - i.x) * (e.y - i.y) / (a.y - i.y) + i.x && (r = !r), n = Math.min(n, fl(e, i, a)) } } return (r ? 1 : -1) * Math.sqrt(n) }(this.p, n), this.max = this.d + this.h * Math.SQRT2 } const up = 7, hp = Number.POSITIVE_INFINITY, dp = Math.sqrt(2); function pp(e, [t, r]) { let n = 0, i = 0; if (r === hp) { t < 0 && (t = 0); const r = t / dp; switch (e) { case "top-right": case "top-left": i = r - up; break; case "bottom-right": case "bottom-left": i = -r + up; break; case "bottom": i = -t + up; break; case "top": i = t - up }switch (e) { case "top-right": case "bottom-right": n = -r; break; case "top-left": case "bottom-left": n = r; break; case "left": n = t; break; case "right": n = -t } } else { switch (t = Math.abs(t), r = Math.abs(r), e) { case "top-right": case "top-left": case "top": i = r - up; break; case "bottom-right": case "bottom-left": case "bottom": i = -r + up }switch (e) { case "top-right": case "bottom-right": case "right": n = -t; break; case "top-left": case "bottom-left": case "left": n = t } } return [n, i] } function fp(e, t, r, n, i, o, s, a, c, l) { e.createArrays(), e.tilePixelRatio = ia / (512 * e.overscaling), e.compareText = {}, e.iconsNeedLinear = !1; const u = e.layers[0].layout, h = e.layers[0]._unevaluatedLayout._values, d = {}; if ("composite" === e.textSizeData.kind) { const { minZoom: t, maxZoom: r } = e.textSizeData; d.compositeTextSizes = [h["text-size"].possiblyEvaluate(new xo(t), a), h["text-size"].possiblyEvaluate(new xo(r), a)] } if ("composite" === e.iconSizeData.kind) { const { minZoom: t, maxZoom: r } = e.iconSizeData; d.compositeIconSizes = [h["icon-size"].possiblyEvaluate(new xo(t), a), h["icon-size"].possiblyEvaluate(new xo(r), a)] } d.layoutTextSize = h["text-size"].possiblyEvaluate(new xo(c + 1), a), d.layoutIconSize = h["icon-size"].possiblyEvaluate(new xo(c + 1), a), d.textMaxSize = h["text-size"].possiblyEvaluate(new xo(18), a); const p = "map" === u.get("text-rotation-alignment") && "point" !== u.get("symbol-placement"), f = u.get("text-size"); for (const m of e.features) { const o = u.get("text-font").evaluate(m, {}, a).join(","), c = f.evaluate(m, {}, a), h = d.layoutTextSize.evaluate(m, {}, a), g = (d.layoutIconSize.evaluate(m, {}, a), { horizontal: {}, vertical: void 0 }), _ = m.text; let y, v = [0, 0]; if (_) { const n = _.toString(), s = u.get("text-letter-spacing").evaluate(m, {}, a) * Rh, l = u.get("text-line-height").evaluate(m, {}, a) * Rh, d = eo(n) ? s : 0, f = u.get("text-anchor").evaluate(m, {}, a), y = u.get("text-variable-anchor"); if (!y) { const e = u.get("text-radial-offset").evaluate(m, {}, a); v = e ? pp(f, [e * Rh, hp]) : u.get("text-offset").evaluate(m, {}, a).map((e => e * Rh)) } let x = p ? "center" : u.get("text-justify").evaluate(m, {}, a); const b = "point" === u.get("symbol-placement"), w = b ? u.get("text-max-width").evaluate(m, {}, a) * Rh : 1 / 0, T = s => { e.allowVerticalPlacement && Yi(n) && (g.vertical = Cd(_, t, r, i, o, w, l, f, s, d, v, bd.vertical, !0, h, c)) }; if (!p && y) { const e = "auto" === x ? y.map((e => mp(e))) : [x]; let n = !1; for (let s = 0; s < e.length; s++) { const a = e[s]; if (!g.horizontal[a]) if (n) g.horizontal[a] = g.horizontal[0]; else { const e = Cd(_, t, r, i, o, w, l, "center", a, d, v, bd.horizontal, !1, h, c); e && (g.horizontal[a] = e, n = 1 === e.positionedLines.length) } } T("left") } else { if ("auto" === x && (x = mp(f)), b || u.get("text-writing-mode").indexOf("horizontal") >= 0 || !Yi(n)) { const e = Cd(_, t, r, i, o, w, l, f, x, d, v, bd.horizontal, !1, h, c); e && (g.horizontal[x] = e) } T(b ? "left" : x) } } let x = !1; if (m.icon && m.icon.name) { const t = n[m.icon.name]; t && (y = Dd(i[m.icon.name], u.get("icon-offset").evaluate(m, {}, a), u.get("icon-anchor").evaluate(m, {}, a)), x = t.sdf, void 0 === e.sdfIcons ? e.sdfIcons = t.sdf : e.sdfIcons !== t.sdf && G("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t.pixelRatio !== e.pixelRatio || 0 !== u.get("icon-rotate").constantOr(1)) && (e.iconsNeedLinear = !0)) } const b = xp(g.horizontal) || g.vertical; e.iconsInText || (e.iconsInText = !!b && b.iconsInText), (b || y) && gp(e, m, g, y, n, d, h, 0, v, x, s, a, l) } o && e.generateCollisionDebugBuffers(c, e.collisionBoxArray) } function mp(e) { switch (e) { case "right": case "top-right": case "bottom-right": return "right"; case "left": case "top-left": case "bottom-left": return "left" }return "center" } function gp(e, t, r, n, i, o, s, a, c, l, u, h, d) { let p = o.textMaxSize.evaluate(t, {}, h); void 0 === p && (p = s); const f = e.layers[0].layout, m = f.get("icon-offset").evaluate(t, {}, h), g = xp(r.horizontal) || r.vertical, _ = "globe" === d.name, v = Rh, x = s / v, b = e.tilePixelRatio * p / v, w = (A = e.overscaling, e.zoom > 18 && A > 2 && (A >>= 1), Math.max(ia / (512 * A), 1) * f.get("symbol-spacing")), T = f.get("text-padding") * e.tilePixelRatio, k = f.get("icon-padding") * e.tilePixelRatio, C = y(f.get("text-max-angle")), E = "map" === f.get("text-rotation-alignment") && "point" !== f.get("symbol-placement"), S = "map" === f.get("icon-rotation-alignment") && "point" !== f.get("symbol-placement"), P = f.get("symbol-placement"), I = w / 2; var A; const L = f.get("icon-text-fit"); let M; n && "none" !== L && (e.allowVerticalPlacement && r.vertical && (M = Fd(n, r.vertical, L, f.get("icon-text-fit-padding"), m, x)), g && (n = Fd(n, g, L, f.get("icon-text-fit-padding"), m, x))); const B = (s, a, p) => { if (a.x < 0 || a.x >= ia || a.y < 0 || a.y >= ia) return; let f = null; if (_) { const { x: e, y: t, z: r } = d.projectTilePoint(a.x, a.y, p); f = { anchor: new Od(e, t, r, 0, void 0), up: d.upVector(p, a.x, a.y) } } !function (e, t, r, n, i, o, s, a, c, l, u, h, d, p, f, m, g, _, y, v, x, b, w, T, k) { const C = e.addToLineVertexArray(t, n); let E, S, P, I, A, L, M, B = 0, R = 0, D = 0, F = 0, O = -1, z = -1; const U = {}; let N = Ts(""); const V = r ? r.anchor : t; let q = 0, j = 0; if (void 0 === c._unevaluatedLayout.getValue("text-radial-offset") ? [q, j] = c.layout.get("text-offset").evaluate(x, {}, k).map((e => e * Rh)) : (q = c.layout.get("text-radial-offset").evaluate(x, {}, k) * Rh, j = hp), e.allowVerticalPlacement && i.vertical) { const e = i.vertical; if (f) L = wp(e), a && (M = wp(a)); else { const r = c.layout.get("text-rotate").evaluate(x, {}, k) + 90; P = bp(l, V, t, u, h, d, e, p, r, m), a && (I = bp(l, V, t, u, h, d, a, _, r)) } } if (o) { const n = c.layout.get("icon-rotate").evaluate(x, {}, k), i = "none" !== c.layout.get("icon-text-fit"), s = Yd(o, n, w, i), p = a ? Yd(a, n, w, i) : void 0; S = bp(l, V, t, u, h, d, o, _, n), B = 4 * s.length; const f = e.iconSizeData; let m = null; "source" === f.kind ? (m = [Dh * c.layout.get("icon-size").evaluate(x, {}, k)], m[0] > yp && G(`${e.layerIds[0]}: Value for "icon-size" is >= ${_p}. Reduce your "icon-size".`)) : "composite" === f.kind && (m = [Dh * b.compositeIconSizes[0].evaluate(x, {}, k), Dh * b.compositeIconSizes[1].evaluate(x, {}, k)], (m[0] > yp || m[1] > yp) && G(`${e.layerIds[0]}: Value for "icon-size" is >= ${_p}. Reduce your "icon-size".`)), e.addSymbols(e.icon, s, m, v, y, x, !1, r, t, C.lineStartIndex, C.lineLength, -1, T, k), O = e.icon.placedSymbolArray.length - 1, p && (R = 4 * p.length, e.addSymbols(e.icon, p, m, v, y, x, bd.vertical, r, t, C.lineStartIndex, C.lineLength, -1, T, k), z = e.icon.placedSymbolArray.length - 1) } for (const G in i.horizontal) { const n = i.horizontal[G]; E || (N = Ts(n.text), f ? A = wp(n) : E = bp(l, V, t, u, h, d, n, p, c.layout.get("text-rotate").evaluate(x, {}, k), m)); const o = 1 === n.positionedLines.length; if (D += vp(e, r, t, n, s, c, f, x, m, C, i.vertical ? bd.horizontal : bd.horizontalOnly, o ? Object.keys(i.horizontal) : [G], U, O, b, T, k), o) break } i.vertical && (F += vp(e, r, t, i.vertical, s, c, f, x, m, C, bd.vertical, ["vertical"], U, z, b, T, k)); let X = -1; const W = (e, t) => e ? Math.max(e, t) : t; X = W(A, X), X = W(L, X), X = W(M, X); const Z = X > -1 ? 1 : 0; e.glyphOffsetArray.length >= tf.MAX_GLYPHS && G("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== x.sortKey && e.addToSortKeyRanges(e.symbolInstances.length, x.sortKey), e.symbolInstances.emplaceBack(V.x, V.y, V.z, t.x, t.y, U.right >= 0 ? U.right : -1, U.center >= 0 ? U.center : -1, U.left >= 0 ? U.left : -1, U.vertical >= 0 ? U.vertical : -1, O, z, N, void 0 !== E ? E : e.collisionBoxArray.length, void 0 !== E ? E + 1 : e.collisionBoxArray.length, void 0 !== P ? P : e.collisionBoxArray.length, void 0 !== P ? P + 1 : e.collisionBoxArray.length, void 0 !== S ? S : e.collisionBoxArray.length, void 0 !== S ? S + 1 : e.collisionBoxArray.length, I || e.collisionBoxArray.length, I ? I + 1 : e.collisionBoxArray.length, u, D, F, B, R, Z, 0, q, j, X) }(e, a, f, s, r, n, i, M, e.layers[0], e.collisionBoxArray, t.index, t.sourceLayerIndex, e.index, T, E, c, 0, k, S, m, t, o, l, u, h) }; if ("line" === P) for (const y of Xd(t.geometry, 0, 0, ia, ia)) { const t = qd(y, w, C, r.vertical || g, n, v, b, e.overscaling, ia); for (const r of t) g && Tp(e, g.text, I, r) || B(y, r, h) } else if ("line-center" === P) { for (const y of t.geometry) if (y.length > 1) { const e = Vd(y, C, r.vertical || g, n, v, b); e && B(y, e, h) } } else if ("Polygon" === t.type) for (const y of yu(t.geometry, 0)) { const e = ap(y, 16); B(y[0], new Od(e.x, e.y, 0, 0, void 0), h) } else if ("LineString" === t.type) for (const y of t.geometry) B(y, new Od(y[0].x, y[0].y, 0, 0, void 0), h); else if ("Point" === t.type) for (const y of t.geometry) for (const e of y) B([e], new Od(e.x, e.y, 0, 0, void 0), h) } const _p = 255, yp = _p * Dh; function vp(e, t, r, n, i, o, s, a, c, l, u, h, d, p, m, g, _) { const y = function (e, t, r, n, i, o, s, a) { const c = []; if (0 === t.positionedLines.length) return c; const l = n.layout.get("text-rotate").evaluate(o, {}) * Math.PI / 180, u = function (e) { const t = e[0], r = e[1], n = t * r; return n > 0 ? [t, -r] : n < 0 ? [-t, r] : 0 === t ? [r, t] : [r, -t] }(r); let h = Math.abs(t.top - t.bottom); for (const f of t.positionedLines) h -= f.lineOffset; const d = t.positionedLines.length, p = h / d; let m = t.top - r[1]; for (let g = 0; g < d; ++g) { const e = t.positionedLines[g]; m = ip(t, p, m, g); for (const n of e.positionedGlyphs) { if (!n.rect) continue; const e = n.rect || {}; let o = gd + 1, h = !0, d = 1, p = 0; if (n.imageName) { const e = s[n.imageName]; if (!e) continue; if (e.sdf) { G("SDF images are not supported in formatted text and will be ignored."); continue } h = !1, d = e.pixelRatio, o = yd / d } const g = (i || a) && n.vertical, _ = n.metrics.advance * n.scale / 2, y = n.metrics, v = n.rect; if (null === v) continue; a && t.verticalizable && (p = n.imageName ? _ - n.metrics.width * n.scale / 2 : 0); const x = i ? [n.x + _, n.y] : [0, 0]; let b = [0, 0], w = [0, 0], T = !1; i || (g ? (w = [n.x + _ + u[0], n.y + u[1] - p], T = !0) : b = [n.x + _ + r[0], n.y + r[1] - p]); const k = v.w * n.scale / (d * (n.localGlyph ? Qd : 1)), C = v.h * n.scale / (d * (n.localGlyph ? Qd : 1)); let E, S, P, I; if (g) { const e = n.y - m, t = new f(-_, _ - e), r = -Math.PI / 2, i = new f(...w); E = new f(-_ + b[0], b[1]), E._rotateAround(r, t)._add(i), E.x += -e + _, E.y -= (y.left - o) * n.scale; const s = n.imageName ? y.advance * n.scale : Rh * n.scale, a = String.fromCharCode(n.glyph); Vh(a) ? E.x += (1 - o) * n.scale : qh(a) ? E.x += s - y.height * n.scale + (-o - 1) * n.scale : E.x += n.imageName || y.width + 2 * o === v.w && y.height + 2 * o === v.h ? (s - C) / 2 : (s - (y.height + 2 * o) * n.scale) / 2, S = new f(E.x, E.y - k), P = new f(E.x + C, E.y), I = new f(E.x + C, E.y - k) } else { const e = (y.left - o) * n.scale - _ + b[0], t = (-y.top - o) * n.scale + b[1], r = e + k, i = t + C; E = new f(e, t), S = new f(r, t), P = new f(e, i), I = new f(r, i) } if (l) { let e; e = i ? new f(0, 0) : T ? new f(u[0], u[1]) : new f(r[0], r[1]), E._rotateAround(l, e), S._rotateAround(l, e), P._rotateAround(l, e), I._rotateAround(l, e) } const A = new f(0, 0), L = new f(0, 0); c.push({ tl: E, tr: S, bl: P, br: I, tex: e, writingMode: t.writingMode, glyphOffset: x, sectionIndex: n.sectionIndex, isSDF: h, pixelOffsetTL: A, pixelOffsetBR: L, minFontScaleX: 0, minFontScaleY: 0 }) } } return c }(0, n, c, o, s, a, i, e.allowVerticalPlacement), v = e.textSizeData; let x = null; "source" === v.kind ? (x = [Dh * o.layout.get("text-size").evaluate(a, {}, _)], x[0] > yp && G(`${e.layerIds[0]}: Value for "text-size" is >= ${_p}. Reduce your "text-size".`)) : "composite" === v.kind && (x = [Dh * m.compositeTextSizes[0].evaluate(a, {}, _), Dh * m.compositeTextSizes[1].evaluate(a, {}, _)], (x[0] > yp || x[1] > yp) && G(`${e.layerIds[0]}: Value for "text-size" is >= ${_p}. Reduce your "text-size".`)), e.addSymbols(e.text, y, x, c, s, a, u, t, r, l.lineStartIndex, l.lineLength, p, g, _); for (const f of h) d[f] = e.text.placedSymbolArray.length - 1; return 4 * y.length } function xp(e) { for (const t in e) return e[t]; return null } function bp(e, t, r, n, i, o, s, a, c, l) { let u = s.top, h = s.bottom, d = s.left, p = s.right; const m = s.collisionPadding; if (m && (d -= m[0], u -= m[1], p += m[2], h += m[3]), c) { const e = new f(d, u), t = new f(p, u), r = new f(d, h), n = new f(p, h), i = y(c); let o = new f(0, 0); l && (o = new f(l[0], l[1])), e._rotateAround(i, o), t._rotateAround(i, o), r._rotateAround(i, o), n._rotateAround(i, o), d = Math.min(e.x, t.x, r.x, n.x), p = Math.max(e.x, t.x, r.x, n.x), u = Math.min(e.y, t.y, r.y, n.y), h = Math.max(e.y, t.y, r.y, n.y) } return e.emplaceBack(t.x, t.y, t.z, r.x, r.y, d, u, p, h, a, n, i, o), e.length - 1 } function wp(e) { e.collisionPadding && (e.top -= e.collisionPadding[1], e.bottom += e.collisionPadding[3]); const t = e.bottom - e.top; return t > 0 ? Math.max(10, t) : null } function Tp(e, t, r, n) { const i = e.compareText; if (t in i) { const e = i[t]; for (let t = e.length - 1; t >= 0; t--)if (n.dist(e[t]) < r) return !0 } else i[t] = []; return i[t].push(n), !1 } function kp(e, t) { const r = e.fovAboveCenter, n = e.elevation ? e.elevation.getMinElevationBelowMSL() * t : 0, i = (e._camera.position[2] * e.worldSize - n) / Math.cos(e._pitch), o = Math.sin(r) * i / Math.sin(Math.max(Math.PI / 2 - e._pitch - r, .01)), s = Math.sin(e._pitch) * o + i; return Math.min(1.01 * s, i * (1 / e._horizonShift)) } function Cp(e, t) { if (!t.isReprojectedInTileSpace) return { scale: 1 << e.z, x: e.x, y: e.y, x2: e.x + 1, y2: e.y + 1, projection: t }; const r = Math.pow(2, -e.z), n = e.x * r, i = (e.x + 1) * r, o = e.y * r, s = (e.y + 1) * r, a = qc(n), c = qc(i), l = jc(o), u = jc(s), h = t.project(a, l), d = t.project(c, l), p = t.project(c, u), f = t.project(a, u); let m = Math.min(h.x, d.x, p.x, f.x), g = Math.min(h.y, d.y, p.y, f.y), _ = Math.max(h.x, d.x, p.x, f.x), y = Math.max(h.y, d.y, p.y, f.y); const v = r / 16; function x(e, r, n, i, o, s) { const a = (n + o) / 2, c = (i + s) / 2, l = t.project(qc(a), jc(c)), u = Math.max(0, m - l.x, g - l.y, l.x - _, l.y - y); m = Math.min(m, l.x), _ = Math.max(_, l.x), g = Math.min(g, l.y), y = Math.max(y, l.y), u > v && (x(e, l, n, i, a, c), x(l, r, a, c, o, s)) } x(h, d, n, o, i, o), x(d, p, i, o, i, s), x(p, f, i, s, n, s), x(f, h, n, s, n, o), m -= v, g -= v, _ += v, y += v; const b = 1 / Math.max(_ - m, y - g); return { scale: b, x: m * b, y: g * b, x2: _ * b, y2: y * b, projection: t } } const Ep = ua(new Float32Array(16)); class Sp { constructor(e) { this.spec = e, this.name = e.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7] } project(e, t) { return { x: 0, y: 0, z: 0 } } unproject(e, t) { return new zc(0, 0) } projectTilePoint(e, t, r) { return { x: e, y: t, z: 0 } } locationPoint(e, t, r = !0) { return e._coordinatePoint(e.locationCoordinate(t), r) } pixelsPerMeter(e, t) { return Vc(1, e) * t } pixelSpaceConversion(e, t, r) { return 1 } farthestPixelDistance(e) { return kp(e, e.pixelsPerMeter) } pointCoordinate(e, t, r, n) { const i = e.horizonLineFromTop(!1), o = new f(t, Math.max(i, r)); return e.rayIntersectionCoordinate(e.pointRayIntersection(o, n)) } pointCoordinate3D(e, t, r) { const n = new f(t, r); if (e.elevation) return e.elevation.pointCoordinate(n); { const t = this.pointCoordinate(e, n.x, n.y, 0); return [t.x, t.y, t.z] } } isPointAboveHorizon(e, t) { if (e.elevation) return !this.pointCoordinate3D(e, t.x, t.y); const r = e.horizonLineFromTop(); return t.y < r } createInversionMatrix(e, t) { return Ep } createTileMatrix(e, t, r) { let n, i, o; const s = r.canonical, a = ua(new Float64Array(16)); if (this.isReprojectedInTileSpace) { const c = Cp(s, this); n = 1, i = c.x + r.wrap * c.scale, o = c.y, fa(a, a, [n / c.scale, n / c.scale, e.pixelsPerMeter / t]) } else n = t / e.zoomScale(s.z), i = (s.x + Math.pow(2, s.z) * r.wrap) * n, o = s.y * n; return pa(a, a, [i, o, 0]), fa(a, a, [n / ia, n / ia, 1]), a } upVector(e, t, r) { return [0, 0, 1] } upVectorScale(e, t, r) { return { metersToTile: 1 } } } class Pp extends Sp { constructor(e) { super(e), this.range = [4, 7], this.center = e.center || [-96, 37.5]; const [t, r] = this.parallels = e.parallels || [29.5, 45.5], n = Math.sin(y(t)); this.n = (n + Math.sin(y(r))) / 2, this.c = 1 + n * (2 * this.n - n), this.r0 = Math.sqrt(this.c) / this.n } project(e, t) { const { n: r, c: n, r0: i } = this, o = y(e - this.center[0]), s = y(t), a = Math.sqrt(n - 2 * r * Math.sin(s)) / r; return { x: a * Math.sin(o * r), y: a * Math.cos(o * r) - i, z: 0 } } unproject(e, t) { const { n: r, c: n, r0: i } = this, o = i + t; let s = Math.atan2(e, Math.abs(o)) * Math.sign(o); o * r < 0 && (s -= Math.PI * Math.sign(e) * Math.sign(o)); const a = y(this.center[0]) * r; s = E(s, -Math.PI - a, Math.PI - a); const c = k(v(s / r) + this.center[0], -180, 180), l = Math.asin(k((n - (e * e + o * o) * r * r) / (2 * r), -1, 1)), u = k(v(l), -Wc, Wc); return new zc(c, u) } } const Ip = 1.340264, Ap = -.081106, Lp = 893e-6, Mp = .003796, Bp = Math.sqrt(3) / 2; class Rp extends Sp { project(e, t) { t = t / 180 * Math.PI, e = e / 180 * Math.PI; const r = Math.asin(Bp * Math.sin(t)), n = r * r, i = n * n * n; return { x: .5 * (e * Math.cos(r) / (Bp * (Ip + 3 * Ap * n + i * (7 * Lp + 9 * Mp * n))) / Math.PI + .5), y: 1 - .5 * (r * (Ip + Ap * n + i * (Lp + Mp * n)) / Math.PI + 1), z: 0 } } unproject(e, t) { e = (2 * e - .5) * Math.PI; let r = t = (2 * (1 - t) - 1) * Math.PI, n = r * r, i = n * n * n; for (let l, u, h, d = 0; d < 12 && (u = r * (Ip + Ap * n + i * (Lp + Mp * n)) - t, h = Ip + 3 * Ap * n + i * (7 * Lp + 9 * Mp * n), l = u / h, r = k(r - l, -Math.PI / 3, Math.PI / 3), n = r * r, i = n * n * n, !(Math.abs(l) < 1e-12)); ++d); const o = Bp * e * (Ip + 3 * Ap * n + i * (7 * Lp + 9 * Mp * n)) / Math.cos(r), s = Math.asin(Math.sin(r) / Bp), a = k(180 * o / Math.PI, -180, 180), c = k(180 * s / Math.PI, -Wc, Wc); return new zc(a, c) } } class Dp extends Sp { constructor(e) { super(e), this.wrap = !0, this.supportsWorldCopies = !0 } project(e, t) { return { x: .5 + e / 360, y: .5 - t / 360, z: 0 } } unproject(e, t) { const r = 360 * (e - .5), n = k(360 * (.5 - t), -Wc, Wc); return new zc(r, n) } } const Fp = Math.PI / 2; function Op(e) { return Math.tan((Fp + e) / 2) } class zp extends Sp { constructor(e) { super(e), this.center = e.center || [0, 30]; const [t, r] = this.parallels = e.parallels || [30, 30]; let n = y(t), i = y(r); this.southernCenter = n + i < 0, this.southernCenter && (n = -n, i = -i); const o = Math.cos(n), s = Op(n); this.n = n === i ? Math.sin(n) : Math.log(o / Math.cos(i)) / Math.log(Op(i) / s), this.f = o * Math.pow(Op(n), this.n) / this.n } project(e, t) { t = y(t), this.southernCenter && (t = -t), e = y(e - this.center[0]); const r = 1e-6, { n: n, f: i } = this; i > 0 ? t < -Fp + r && (t = -Fp + r) : t > Fp - r && (t = Fp - r); const o = i / Math.pow(Op(t), n); let s = o * Math.sin(n * e), a = i - o * Math.cos(n * e); return s = .5 * (s / Math.PI + .5), a = .5 * (a / Math.PI + .5), { x: s, y: this.southernCenter ? a : 1 - a, z: 0 } } unproject(e, t) { e = (2 * e - .5) * Math.PI, this.southernCenter && (t = 1 - t), t = (2 * (1 - t) - .5) * Math.PI; const { n: r, f: n } = this, i = n - t, o = Math.sign(i), s = Math.sign(r) * Math.sqrt(e * e + i * i); let a = Math.atan2(e, Math.abs(i)) * o; i * r < 0 && (a -= Math.PI * Math.sign(e) * o); const c = k(v(a / r) + this.center[0], -180, 180), l = k(v(2 * Math.atan(Math.pow(n / s, 1 / r)) - Fp), -Wc, Wc); return new zc(c, this.southernCenter ? -l : l) } } class Up extends Sp { constructor(e) { super(e), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null } project(e, t) { return { x: Nc(e), y: Gc(t), z: 0 } } unproject(e, t) { const r = qc(e), n = jc(t); return new zc(r, n) } } const Np = y(Wc); class Gp extends Sp { project(e, t) { const r = (t = y(t)) * t, n = r * r; return { x: .5 * ((e = y(e)) * (.8707 - .131979 * r + n * (n * (.003971 * r - .001529 * n) - .013791)) / Math.PI + .5), y: 1 - .5 * (t * (1.007226 + r * (.015085 + n * (.028874 * r - .044475 - .005916 * n))) / Math.PI + 1), z: 0 } } unproject(e, t) { e = (2 * e - .5) * Math.PI; let r = t = (2 * (1 - t) - 1) * Math.PI, n = 25, i = 0, o = r * r; do { o = r * r; const e = o * o; i = (r * (1.007226 + o * (.015085 + e * (.028874 * o - .044475 - .005916 * e))) - t) / (1.007226 + o * (.045255 + e * (.259866 * o - .311325 - .005916 * 11 * e))), r = k(r - i, -Np, Np) } while (Math.abs(i) > 1e-6 && --n > 0); o = r * r; const s = k(v(e / (.8707 + o * (o * (o * o * o * (.003971 - .001529 * o) - .013791) - .131979))), -180, 180), a = v(r); return new zc(s, a) } } const Vp = y(Wc); class qp extends Sp { project(e, t) { t = y(t), e = y(e); const r = Math.cos(t), n = 2 / Math.PI, i = Math.acos(r * Math.cos(e / 2)), o = Math.sin(i) / i, s = .5 * (e * n + 2 * r * Math.sin(e / 2) / o) || 0, a = .5 * (t + Math.sin(t) / o) || 0; return { x: .5 * (s / Math.PI + .5), y: 1 - .5 * (a / Math.PI + 1), z: 0 } } unproject(e, t) { let r = e = (2 * e - .5) * Math.PI, n = t = (2 * (1 - t) - 1) * Math.PI, i = 25; const o = 1e-6; let s = 0, a = 0; do { const i = Math.cos(n), o = Math.sin(n), c = 2 * o * i, l = o * o, u = i * i, h = Math.cos(r / 2), d = Math.sin(r / 2), p = 2 * h * d, f = d * d, m = 1 - u * h * h, g = m ? 1 / m : 0, _ = m ? Math.acos(i * h) * Math.sqrt(1 / m) : 0, y = .5 * (2 * _ * i * d + 2 * r / Math.PI) - e, v = .5 * (_ * o + n) - t, x = .5 * g * (u * f + _ * i * h * l) + 1 / Math.PI, b = g * (p * c / 4 - _ * o * d), w = .125 * g * (c * d - _ * o * u * p), T = .5 * g * (l * h + _ * f * i) + .5, C = b * w - T * x; s = (v * b - y * T) / C, a = (y * w - v * x) / C, r = k(r - s, -Math.PI, Math.PI), n = k(n - a, -Vp, Vp) } while ((Math.abs(s) > o || Math.abs(a) > o) && --i > 0); return new zc(v(r), v(n)) } } class jp extends Sp { constructor(e) { super(e), this.center = e.center || [0, 0], this.parallels = e.parallels || [0, 0], this.cosPhi = Math.max(.01, Math.cos(y(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0 } project(e, t) { const { scale: r, cosPhi: n } = this; return { x: y(e) * n * r + .5, y: -Math.sin(y(t)) / n * r + .5, z: 0 } } unproject(e, t) { const { scale: r, cosPhi: n } = this, i = -(t - .5) / r, o = k(v((e - .5) / r) / n, -180, 180), s = Math.asin(k(i * n, -1, 1)), a = k(v(s), -Wc, Wc); return new zc(o, a) } } class Xp extends Up { constructor(e) { super(e), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5] } projectTilePoint(e, t, r) { const n = kc(e, t, r); return Ra(n, n, Sc(mc(r))), { x: n[0], y: n[1], z: n[2] } } locationPoint(e, t) { const r = Tc(t.lat, t.lng), n = La([], r), i = e.elevation ? e.elevation.getAtPointOrZero(e.locationCoordinate(t), e._centerAltitude) : e._centerAltitude; Aa(r, r, n, Vc(1, 0) * ia * i); const o = ua(new Float64Array(16)); return da(o, e.pixelMatrix, e.globeMatrix), Ra(r, r, o), new f(r[0], r[1]) } pixelsPerMeter(e, t) { return Vc(1, 0) * t } pixelSpaceConversion(e, t, r) { const n = Vc(1, e) * t, i = Ir(Vc(1, 45) * t, n, r); return this.pixelsPerMeter(e, t) / i } createTileMatrix(e, t, r) { const n = Pc(mc(r.canonical)); return da(new Float64Array(16), e.globeMatrix, n) } createInversionMatrix(e, t) { const { center: r } = e, n = Sc(mc(t)); return ga(n, n, y(r.lng)), ma(n, n, y(r.lat)), fa(n, n, [e._pixelsPerMercatorPixel, e._pixelsPerMercatorPixel, 1]), Float32Array.from(n) } pointCoordinate(e, t, r, n) { return dc(e, t, r, !0) || new Hc(0, 0) } pointCoordinate3D(e, t, r) { const n = this.pointCoordinate(e, t, r, 0); return [n.x, n.y, n.z] } isPointAboveHorizon(e, t) { return !dc(e, t.x, t.y, !1) } farthestPixelDistance(e) { const t = function (e, t) { const r = e.cameraToCenterDistance, n = e._centerAltitude * t, i = e._camera, o = e._camera.forward(), s = ka([], Ia([], o, -r), [0, 0, n]), a = e.worldSize / (2 * Math.PI), c = [0, 0, -a], l = e.width / e.height, u = Math.tan(e.fovAboveCenter), h = Ia([], i.up(), u), d = Ia([], i.right(), u * l), p = La([], ka([], ka([], o, h), d)), f = []; let m; if (new Ka(s, p).closestPointOnSphere(c, a, f)) { const t = ka([], f, c), r = Oa([], t, s); m = Math.cos(e.fovAboveCenter) * wa(r) } else { const e = Oa([], s, c), t = Oa([], c, s); La(t, t); const r = wa(e) - a; m = Math.sqrt(r * (r + 2 * a)); const n = Math.acos(m / (a + r)) - Math.acos(Ma(o, t)); m *= Math.cos(n) } return 1.01 * m }(e, this.pixelsPerMeter(e.center.lat, e.worldSize)), r = Ac(e.zoom); if (r > 0) { const n = kp(e, Vc(1, e.center.lat) * e.worldSize), i = e.worldSize / (2 * Math.PI), o = Math.max(e.width, e.height) / e.worldSize * Math.PI; return Ir(t, n + i * (1 - Math.cos(o)), Math.pow(r, 10)) } return t } upVector(e, t, r) { return kc(t, r, e, 1) } upVectorScale(e) { return { metersToTile: hc(Cc(mc(e))) } } } function Wp(e) { const t = e.parallels, r = !!t && Math.abs(t[0] + t[1]) < .01; switch (e.name) { case "mercator": return new Up(e); case "equirectangular": return new Dp(e); case "naturalEarth": return new Gp(e); case "equalEarth": return new Rp(e); case "winkelTripel": return new qp(e); case "albers": return r ? new jp(e) : new Pp(e); case "lambertConformalConic": return r ? new jp(e) : new zp(e); case "globe": return new Xp(e) }throw new Error(`Invalid projection name: ${e.name}`) } const Zp = Gu.types, Hp = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }]; function Qp(e, t, r, n, i, o, s, a, c, l, u, h, d) { const p = a ? Math.min(yp, Math.round(a[0])) : 0, f = a ? Math.min(yp, Math.round(a[1])) : 0; e.emplaceBack(t, r, Math.round(32 * n), Math.round(32 * i), o, s, (p << 1) + (c ? 1 : 0), f, 16 * l, 16 * u, 256 * h, 256 * d) } function $p(e, t, r, n, i, o, s) { e.emplaceBack(t, r, n, i, o, s) } function Jp(e, t, r, n, i) { e.emplaceBack(t, r, n, i), e.emplaceBack(t, r, n, i), e.emplaceBack(t, r, n, i), e.emplaceBack(t, r, n, i) } function Kp(e) { for (const t of e.sections) if (so(t.text)) return !0; return !1 } class Yp { constructor(e) { this.layoutVertexArray = new Zo, this.indexArray = new ts, this.programConfigurations = e, this.segments = new na, this.dynamicLayoutVertexArray = new qo, this.opacityVertexArray = new Qo, this.placedSymbolArray = new ps, this.globeExtVertexArray = new Ho } isEmpty() { return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length } upload(e, t, r, n) { this.isEmpty() || (r && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Sh.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, t), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, Ih.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, Hp, !0), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, Ph.members, !0)), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(e)) } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy()) } } Zi(Yp, "SymbolBuffers"); class ef { constructor(e, t, r) { this.layoutVertexArray = new e, this.layoutAttributes = t, this.indexArray = new r, this.segments = new na, this.collisionVertexArray = new Yo, this.collisionVertexArrayExt = new es } upload(e) { this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, Ah.members, !0), this.collisionVertexBufferExt = e.createVertexBuffer(this.collisionVertexArrayExt, Lh.members, !0) } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy()) } } Zi(ef, "CollisionBuffers"); class tf { constructor(e) { this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((e => e.id)), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = ua([]), this.placementViewportMatrix = ua([]); const t = this.layers[0]._unevaluatedLayout._values; this.textSizeData = Fh(this.zoom, t["text-size"]), this.iconSizeData = Fh(this.zoom, t["icon-size"]); const r = this.layers[0].layout, n = r.get("symbol-sort-key"), i = r.get("symbol-z-order"); this.canOverlap = r.get("text-allow-overlap") || r.get("icon-allow-overlap") || r.get("text-ignore-placement") || r.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i && void 0 !== n.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i || "auto" === i && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r.get("text-writing-mode").map((e => bd[e])), this.stateDependentLayerIds = this.layers.filter((e => e.isStateDependent())).map((e => e.id)), this.sourceID = e.sourceID, this.projection = e.projection } createArrays() { this.text = new Yp(new Zs(this.layers, this.zoom, (e => /^text/.test(e)))), this.icon = new Yp(new Zs(this.layers, this.zoom, (e => /^icon/.test(e)))), this.glyphOffsetArray = new gs, this.lineVertexArray = new _s, this.symbolInstances = new ms } calculateGlyphDependencies(e, t, r, n, i) { for (let o = 0; o < e.length; o++)if (t[e.charCodeAt(o)] = !0, n && i) { const r = Gh[e.charAt(o)]; r && (t[r.charCodeAt(0)] = !0) } } populate(e, t, r, n) { const i = this.layers[0], o = i.layout, s = "globe" === this.projection.name, a = o.get("text-font"), c = o.get("text-field"), l = o.get("icon-image"), u = ("constant" !== c.value.kind || c.value.value instanceof Mt && !c.value.value.isEmpty() || c.value.value.toString().length > 0) && ("constant" !== a.value.kind || a.value.value.length > 0), h = "constant" !== l.value.kind || !!l.value.value || Object.keys(l.parameters).length > 0, d = o.get("symbol-sort-key"); if (this.features = [], !u && !h) return; const p = t.iconDependencies, f = t.glyphDependencies, m = t.availableImages, g = new xo(this.zoom); for (const { feature: _, id: y, index: v, sourceLayerIndex: x } of e) { const e = i._featureFilter.needGeometry, t = nl(_, e); if (!i._featureFilter.filter(g, t, r)) continue; if (e || (t.geometry = rl(_, r, n)), s && 1 !== _.type && r.z <= 5) { const e = t.geometry, n = .98078528056, i = (e, t) => Ma(kc(e.x, e.y, r, 1), kc(t.x, t.y, r, 1)) < n; for (let t = 0; t < e.length; t++)e[t] = Kc(e[t], i) } let c, l; if (u) { const e = i.getValueAndResolveTokens("text-field", t, r, m), n = Mt.factory(e); Kp(n) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === _o() || this.hasRTLText && vo.isParsed()) && (c = Nh(n, i, t)) } if (h) { const e = i.getValueAndResolveTokens("icon-image", t, r, m); l = e instanceof Bt ? e : Bt.fromString(e) } if (!c && !l) continue; const b = this.sortFeaturesByKey ? d.evaluate(t, {}, r) : void 0; if (this.features.push({ id: y, text: c, icon: l, index: v, sourceLayerIndex: x, geometry: t.geometry, properties: _.properties, type: Zp[_.type], sortKey: b }), l && (p[l.name] = !0), c) { const e = a.evaluate(t, {}, r).join(","), n = "map" === o.get("text-rotation-alignment") && "point" !== o.get("symbol-placement"); this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(bd.vertical) >= 0; for (const t of c.sections) if (t.image) p[t.image.name] = !0; else { const r = Yi(c.toString()), i = t.fontStack || e, o = f[i] = f[i] || {}; this.calculateGlyphDependencies(t.text, o, n, this.allowVerticalPlacement, r) } } } "line" === o.get("symbol-placement") && (this.features = function (e) { const t = {}, r = {}, n = []; let i = 0; function o(t) { n.push(e[t]), i++ } function s(e, t, i) { const o = r[e]; return delete r[e], r[t] = o, n[o].geometry[0].pop(), n[o].geometry[0] = n[o].geometry[0].concat(i[0]), o } function a(e, r, i) { const o = t[r]; return delete t[r], t[e] = o, n[o].geometry[0].shift(), n[o].geometry[0] = i[0].concat(n[o].geometry[0]), o } function c(e, t, r) { const n = r ? t[0][t[0].length - 1] : t[0][0]; return `${e}:${n.x}:${n.y}` } for (let l = 0; l < e.length; l++) { const u = e[l], h = u.geometry, d = u.text ? u.text.toString() : null; if (!d) { o(l); continue } const p = c(d, h), f = c(d, h, !0); if (p in r && f in t && r[p] !== t[f]) { const e = a(p, f, h), i = s(p, f, n[e].geometry); delete t[p], delete r[f], r[c(d, n[i].geometry, !0)] = i, n[e].geometry = null } else p in r ? s(p, f, h) : f in t ? a(p, f, h) : (o(l), t[p] = i - 1, r[f] = i - 1) } return n.filter((e => e.geometry)) }(this.features)), this.sortFeaturesByKey && this.features.sort(((e, t) => e.sortKey - t.sortKey)) } update(e, t, r, n) { this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e, t, this.layers, r, n), this.icon.programConfigurations.updatePaintArrays(e, t, this.layers, r, n)) } isEmpty() { return 0 === this.symbolInstances.length && !this.hasRTLText } uploadPending() { return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload } upload(e) { !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0 } destroyDebugData() { this.textCollisionBox.destroy(), this.iconCollisionBox.destroy() } getProjection() { return this.projectionInstance || (this.projectionInstance = Wp(this.projection)), this.projectionInstance } destroy() { this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData() } addToLineVertexArray(e, t) { const r = this.lineVertexArray.length; if (void 0 !== e.segment) for (const { x: n, y: i } of t) this.lineVertexArray.emplaceBack(n, i); return { lineStartIndex: r, lineLength: this.lineVertexArray.length - r } } addSymbols(e, t, r, n, i, o, s, a, c, l, u, h, d, p) { const f = e.indexArray, m = e.layoutVertexArray, g = e.globeExtVertexArray, _ = e.segments.prepareSegment(4 * t.length, m, f, this.canOverlap ? o.sortKey : void 0), y = this.glyphOffsetArray.length, v = _.vertexLength, x = this.allowVerticalPlacement && s === bd.vertical ? Math.PI / 2 : 0, b = o.text && o.text.sections; for (let T = 0; T < t.length; T++) { const { tl: n, tr: i, bl: s, br: l, tex: u, pixelOffsetTL: h, pixelOffsetBR: y, minFontScaleX: v, minFontScaleY: w, glyphOffset: k, isSDF: C, sectionIndex: E } = t[T], S = _.vertexLength, P = k[1]; if (Qp(m, c.x, c.y, n.x, P + n.y, u.x, u.y, r, C, h.x, h.y, v, w), Qp(m, c.x, c.y, i.x, P + i.y, u.x + u.w, u.y, r, C, y.x, h.y, v, w), Qp(m, c.x, c.y, s.x, P + s.y, u.x, u.y + u.h, r, C, h.x, y.y, v, w), Qp(m, c.x, c.y, l.x, P + l.y, u.x + u.w, u.y + u.h, r, C, y.x, y.y, v, w), a) { const { x: t, y: r, z: n } = a.anchor, [i, o, s] = a.up; $p(g, t, r, n, i, o, s), $p(g, t, r, n, i, o, s), $p(g, t, r, n, i, o, s), $p(g, t, r, n, i, o, s), Jp(e.dynamicLayoutVertexArray, t, r, n, x) } else Jp(e.dynamicLayoutVertexArray, c.x, c.y, c.z, x); f.emplaceBack(S, S + 1, S + 2), f.emplaceBack(S + 1, S + 2, S + 3), _.vertexLength += 4, _.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(k[0]), T !== t.length - 1 && E === t[T + 1].sectionIndex || e.programConfigurations.populatePaintArrays(m.length, o, o.index, {}, d, p, b && b[E]) } const w = a ? a.anchor : c; e.placedSymbolArray.emplaceBack(w.x, w.y, w.z, c.x, c.y, y, this.glyphOffsetArray.length - y, v, l, u, c.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], s, 0, !1, 0, h, 0) } _commitLayoutVertex(e, t, r, n, i, o, s) { e.emplaceBack(t, r, n, i, o, Math.round(s.x), Math.round(s.y)) } _addCollisionDebugVertices(e, t, r, n, i, o, s) { const a = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray), c = a.vertexLength, l = s.tileAnchorX, u = s.tileAnchorY; for (let d = 0; d < 4; d++)r.collisionVertexArray.emplaceBack(0, 0, 0, 0); r.collisionVertexArrayExt.emplaceBack(t, -e.padding, -e.padding), r.collisionVertexArrayExt.emplaceBack(t, e.padding, -e.padding), r.collisionVertexArrayExt.emplaceBack(t, e.padding, e.padding), r.collisionVertexArrayExt.emplaceBack(t, -e.padding, e.padding), this._commitLayoutVertex(r.layoutVertexArray, n, i, o, l, u, new f(e.x1, e.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, o, l, u, new f(e.x2, e.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, o, l, u, new f(e.x2, e.y2)), this._commitLayoutVertex(r.layoutVertexArray, n, i, o, l, u, new f(e.x1, e.y2)), a.vertexLength += 4; const h = r.indexArray; h.emplaceBack(c, c + 1), h.emplaceBack(c + 1, c + 2), h.emplaceBack(c + 2, c + 3), h.emplaceBack(c + 3, c), a.primitiveLength += 4 } _addTextDebugCollisionBoxes(e, t, r, n, i, o) { for (let s = n; s < i; s++) { const n = r.get(s), i = this.getSymbolInstanceTextSize(e, o, t, s); this._addCollisionDebugVertices(n, i, this.textCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, o) } } _addIconDebugCollisionBoxes(e, t, r, n, i, o) { for (let s = n; s < i; s++) { const n = r.get(s), i = this.getSymbolInstanceIconSize(e, t, o.placedIconSymbolIndex); this._addCollisionDebugVertices(n, i, this.iconCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, o) } } generateCollisionDebugBuffers(e, t) { this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new ef(Jo, Mh.members, as), this.iconCollisionBox = new ef(Jo, Mh.members, as); const r = zh(this.iconSizeData, e), n = zh(this.textSizeData, e); for (let i = 0; i < this.symbolInstances.length; i++) { const o = this.symbolInstances.get(i); this._addTextDebugCollisionBoxes(n, e, t, o.textBoxStartIndex, o.textBoxEndIndex, o), this._addTextDebugCollisionBoxes(n, e, t, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o), this._addIconDebugCollisionBoxes(r, e, t, o.iconBoxStartIndex, o.iconBoxEndIndex, o), this._addIconDebugCollisionBoxes(r, e, t, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex, o) } } getSymbolInstanceTextSize(e, t, r, n) { const i = this.text.placedSymbolArray.get(t.rightJustifiedTextSymbolIndex >= 0 ? t.rightJustifiedTextSymbolIndex : t.centerJustifiedTextSymbolIndex >= 0 ? t.centerJustifiedTextSymbolIndex : t.leftJustifiedTextSymbolIndex >= 0 ? t.leftJustifiedTextSymbolIndex : t.verticalPlacedTextSymbolIndex >= 0 ? t.verticalPlacedTextSymbolIndex : n), o = Oh(this.textSizeData, e, i) / Rh; return this.tilePixelRatio * o } getSymbolInstanceIconSize(e, t, r) { const n = this.icon.placedSymbolArray.get(r), i = Oh(this.iconSizeData, e, n); return this.tilePixelRatio * i } _commitDebugCollisionVertexUpdate(e, t, r) { e.emplaceBack(t, -r, -r), e.emplaceBack(t, r, -r), e.emplaceBack(t, r, r), e.emplaceBack(t, -r, r) } _updateTextDebugCollisionBoxes(e, t, r, n, i, o) { for (let s = n; s < i; s++) { const n = r.get(s), i = this.getSymbolInstanceTextSize(e, o, t, s); this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i, n.padding) } } _updateIconDebugCollisionBoxes(e, t, r, n, i, o) { for (let s = n; s < i; s++) { const n = r.get(s), i = this.getSymbolInstanceIconSize(e, t, o); this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i, n.padding) } } updateCollisionDebugBuffers(e, t) { if (!this.hasDebugData()) return; this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear(); const r = zh(this.iconSizeData, e), n = zh(this.textSizeData, e); for (let i = 0; i < this.symbolInstances.length; i++) { const o = this.symbolInstances.get(i); this._updateTextDebugCollisionBoxes(n, e, t, o.textBoxStartIndex, o.textBoxEndIndex, o), this._updateTextDebugCollisionBoxes(n, e, t, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o), this._updateIconDebugCollisionBoxes(r, e, t, o.iconBoxStartIndex, o.iconBoxEndIndex, o.placedIconSymbolIndex), this._updateIconDebugCollisionBoxes(r, e, t, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex, o.placedIconSymbolIndex) } this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt) } _deserializeCollisionBoxesForSymbol(e, t, r, n, i, o, s, a, c) { const l = {}; if (t < r) { const { x1: r, y1: n, x2: i, y2: o, padding: s, projectedAnchorX: a, projectedAnchorY: c, projectedAnchorZ: u, tileAnchorX: h, tileAnchorY: d, featureIndex: p } = e.get(t); l.textBox = { x1: r, y1: n, x2: i, y2: o, padding: s, projectedAnchorX: a, projectedAnchorY: c, projectedAnchorZ: u, tileAnchorX: h, tileAnchorY: d }, l.textFeatureIndex = p } if (n < i) { const { x1: t, y1: r, x2: i, y2: o, padding: s, projectedAnchorX: a, projectedAnchorY: c, projectedAnchorZ: u, tileAnchorX: h, tileAnchorY: d, featureIndex: p } = e.get(n); l.verticalTextBox = { x1: t, y1: r, x2: i, y2: o, padding: s, projectedAnchorX: a, projectedAnchorY: c, projectedAnchorZ: u, tileAnchorX: h, tileAnchorY: d }, l.verticalTextFeatureIndex = p } if (o < s) { const { x1: t, y1: r, x2: n, y2: i, padding: s, projectedAnchorX: a, projectedAnchorY: c, projectedAnchorZ: u, tileAnchorX: h, tileAnchorY: d, featureIndex: p } = e.get(o); l.iconBox = { x1: t, y1: r, x2: n, y2: i, padding: s, projectedAnchorX: a, projectedAnchorY: c, projectedAnchorZ: u, tileAnchorX: h, tileAnchorY: d }, l.iconFeatureIndex = p } if (a < c) { const { x1: t, y1: r, x2: n, y2: i, padding: o, projectedAnchorX: s, projectedAnchorY: c, projectedAnchorZ: u, tileAnchorX: h, tileAnchorY: d, featureIndex: p } = e.get(a); l.verticalIconBox = { x1: t, y1: r, x2: n, y2: i, padding: o, projectedAnchorX: s, projectedAnchorY: c, projectedAnchorZ: u, tileAnchorX: h, tileAnchorY: d }, l.verticalIconFeatureIndex = p } return l } deserializeCollisionBoxes(e) { this.collisionArrays = []; for (let t = 0; t < this.symbolInstances.length; t++) { const r = this.symbolInstances.get(t); this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex)) } } hasTextData() { return this.text.segments.get().length > 0 } hasIconData() { return this.icon.segments.get().length > 0 } hasDebugData() { return this.textCollisionBox && this.iconCollisionBox } hasTextCollisionBoxData() { return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0 } hasIconCollisionBoxData() { return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0 } addIndicesForPlacedSymbol(e, t) { const r = e.placedSymbolArray.get(t), n = r.vertexStartIndex + 4 * r.numGlyphs; for (let i = r.vertexStartIndex; i < n; i += 4)e.indexArray.emplaceBack(i, i + 1, i + 2), e.indexArray.emplaceBack(i + 1, i + 2, i + 3) } getSortedSymbolIndexes(e) { if (this.sortedAngle === e && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes; const t = Math.sin(e), r = Math.cos(e), n = [], i = [], o = []; for (let s = 0; s < this.symbolInstances.length; ++s) { o.push(s); const e = this.symbolInstances.get(s); n.push(0 | Math.round(t * e.tileAnchorX + r * e.tileAnchorY)), i.push(e.featureIndex) } return o.sort(((e, t) => n[e] - n[t] || i[t] - i[e])), o } addToSortKeyRanges(e, t) { const r = this.sortKeyRanges[this.sortKeyRanges.length - 1]; r && r.sortKey === t ? r.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: t, symbolInstanceStart: e, symbolInstanceEnd: e + 1 }) } sortFeatures(e) { if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) { this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = []; for (const e of this.symbolInstanceIndexes) { const t = this.symbolInstances.get(e); this.featureSortOrder.push(t.featureIndex); const { rightJustifiedTextSymbolIndex: r, centerJustifiedTextSymbolIndex: n, leftJustifiedTextSymbolIndex: i, verticalPlacedTextSymbolIndex: o, placedIconSymbolIndex: s, verticalPlacedIconSymbolIndex: a } = t; r >= 0 && this.addIndicesForPlacedSymbol(this.text, r), n >= 0 && n !== r && this.addIndicesForPlacedSymbol(this.text, n), i >= 0 && i !== n && i !== r && this.addIndicesForPlacedSymbol(this.text, i), o >= 0 && this.addIndicesForPlacedSymbol(this.text, o), s >= 0 && this.addIndicesForPlacedSymbol(this.icon, s), a >= 0 && this.addIndicesForPlacedSymbol(this.icon, a) } this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray) } } } Zi(tf, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), tf.MAX_GLYPHS = 65535, tf.addDynamicAttributes = Jp; const rf = new Mo({ "symbol-placement": new Io(Ke.layout_symbol["symbol-placement"]), "symbol-spacing": new Io(Ke.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Io(Ke.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Ao(Ke.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Io(Ke.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Io(Ke.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Io(Ke.layout_symbol["icon-ignore-placement"]), "icon-optional": new Io(Ke.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Io(Ke.layout_symbol["icon-rotation-alignment"]), "icon-size": new Ao(Ke.layout_symbol["icon-size"]), "icon-text-fit": new Io(Ke.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Io(Ke.layout_symbol["icon-text-fit-padding"]), "icon-image": new Ao(Ke.layout_symbol["icon-image"]), "icon-rotate": new Ao(Ke.layout_symbol["icon-rotate"]), "icon-padding": new Io(Ke.layout_symbol["icon-padding"]), "icon-keep-upright": new Io(Ke.layout_symbol["icon-keep-upright"]), "icon-offset": new Ao(Ke.layout_symbol["icon-offset"]), "icon-anchor": new Ao(Ke.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Io(Ke.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Io(Ke.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Io(Ke.layout_symbol["text-rotation-alignment"]), "text-field": new Ao(Ke.layout_symbol["text-field"]), "text-font": new Ao(Ke.layout_symbol["text-font"]), "text-size": new Ao(Ke.layout_symbol["text-size"]), "text-max-width": new Ao(Ke.layout_symbol["text-max-width"]), "text-line-height": new Ao(Ke.layout_symbol["text-line-height"]), "text-letter-spacing": new Ao(Ke.layout_symbol["text-letter-spacing"]), "text-justify": new Ao(Ke.layout_symbol["text-justify"]), "text-radial-offset": new Ao(Ke.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Io(Ke.layout_symbol["text-variable-anchor"]), "text-anchor": new Ao(Ke.layout_symbol["text-anchor"]), "text-max-angle": new Io(Ke.layout_symbol["text-max-angle"]), "text-writing-mode": new Io(Ke.layout_symbol["text-writing-mode"]), "text-rotate": new Ao(Ke.layout_symbol["text-rotate"]), "text-padding": new Io(Ke.layout_symbol["text-padding"]), "text-keep-upright": new Io(Ke.layout_symbol["text-keep-upright"]), "text-transform": new Ao(Ke.layout_symbol["text-transform"]), "text-offset": new Ao(Ke.layout_symbol["text-offset"]), "text-allow-overlap": new Io(Ke.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Io(Ke.layout_symbol["text-ignore-placement"]), "text-optional": new Io(Ke.layout_symbol["text-optional"]) }); var nf = { paint: new Mo({ "icon-opacity": new Ao(Ke.paint_symbol["icon-opacity"]), "icon-color": new Ao(Ke.paint_symbol["icon-color"]), "icon-halo-color": new Ao(Ke.paint_symbol["icon-halo-color"]), "icon-halo-width": new Ao(Ke.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Ao(Ke.paint_symbol["icon-halo-blur"]), "icon-translate": new Io(Ke.paint_symbol["icon-translate"]), "icon-translate-anchor": new Io(Ke.paint_symbol["icon-translate-anchor"]), "text-opacity": new Ao(Ke.paint_symbol["text-opacity"]), "text-color": new Ao(Ke.paint_symbol["text-color"], { runtimeType: ut, getOverride: e => e.textColor, hasOverride: e => !!e.textColor }), "text-halo-color": new Ao(Ke.paint_symbol["text-halo-color"]), "text-halo-width": new Ao(Ke.paint_symbol["text-halo-width"]), "text-halo-blur": new Ao(Ke.paint_symbol["text-halo-blur"]), "text-translate": new Io(Ke.paint_symbol["text-translate"]), "text-translate-anchor": new Io(Ke.paint_symbol["text-translate-anchor"]) }), layout: rf }; class of { constructor(e) { this.type = e.property.overrides ? e.property.overrides.runtimeType : st, this.defaultValue = e } evaluate(e) { if (e.formattedSection) { const t = this.defaultValue.property.overrides; if (t && t.hasOverride(e.formattedSection)) return t.getOverride(e.formattedSection) } return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default } eachChild(e) { this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression) } outputDefined() { return !1 } serialize() { return null } } Zi(of, "FormatSectionOverride", { omit: ["defaultValue"] }); class sf extends ea { constructor(e) { super(e, nf) } recalculate(e, t) { super.recalculate(e, t), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")); const r = this.layout.get("text-writing-mode"); if (r) { const e = []; for (const t of r) e.indexOf(t) < 0 && e.push(t); this.layout._values["text-writing-mode"] = e } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"]; this._setPaintOverrides() } getValueAndResolveTokens(e, t, r, n) { const i = this.layout.get(e).evaluate(t, {}, r, n), o = this._unevaluatedLayout._values[e]; return o.isDataDriven() || Hn(o.value) || !i ? i : function (e, t) { return t.replace(/{([^{}]+)}/g, ((t, r) => r in e ? String(e[r]) : "")) }(t.properties, i) } createBucket(e) { return new tf(e) } queryRadius() { return 0 } queryIntersectsFeature() { return !1 } _setPaintOverrides() { for (const e of nf.paint.overridableProperties) { if (!sf.hasPaintOverride(this.layout, e)) continue; const t = this.paint.get(e), r = new of(t), n = new Zn(r, t.property.specification); let i = null; i = "constant" === t.value.kind || "source" === t.value.kind ? new $n("source", n) : new Jn("composite", n, t.value.zoomStops, t.value._interpolationType), this.paint._values[e] = new So(t.property, i, t.parameters) } } _handleOverridablePaintPropertyUpdate(e, t, r) { return !(!this.layout || t.isDataDriven() || r.isDataDriven()) && sf.hasPaintOverride(this.layout, e) } static hasPaintOverride(e, t) { const r = e.get("text-field"), n = nf.paint.properties[t]; let i = !1; const o = e => { for (const t of e) if (n.overrides && n.overrides.hasOverride(t)) return void (i = !0) }; if ("constant" === r.value.kind && r.value.value instanceof Mt) o(r.value.value.sections); else if ("source" === r.value.kind) { const e = t => { i || (t instanceof Ut && Ft(t.value) === ft ? o(t.value.sections) : t instanceof jt ? o(t.sections) : t.eachChild(e)) }, t = r.value; t._styleExpression && e(t._styleExpression.expression) } return i } getProgramConfiguration(e) { return new Ws(this, e) } } var af = { paint: new Mo({ "background-color": new Io(Ke.paint_background["background-color"]), "background-pattern": new Io(Ke.paint_background["background-pattern"]), "background-opacity": new Io(Ke.paint_background["background-opacity"]) }) }, cf = { paint: new Mo({ "raster-opacity": new Io(Ke.paint_raster["raster-opacity"]), "raster-hue-rotate": new Io(Ke.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Io(Ke.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Io(Ke.paint_raster["raster-brightness-max"]), "raster-saturation": new Io(Ke.paint_raster["raster-saturation"]), "raster-contrast": new Io(Ke.paint_raster["raster-contrast"]), "raster-resampling": new Io(Ke.paint_raster["raster-resampling"]), "raster-fade-duration": new Io(Ke.paint_raster["raster-fade-duration"]) }) }; class lf extends ea { constructor(e) { super(e, {}), this.implementation = e } is3D() { return "3d" === this.implementation.renderingMode } hasOffscreenPass() { return void 0 !== this.implementation.prerender } isLayerDraped() { return void 0 !== this.implementation.renderToTile } shouldRedrape() { return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles() } recalculate() { } updateTransitions() { } hasTransition() { return !1 } serialize() { } onAdd(e) { this.implementation.onAdd && this.implementation.onAdd(e, e.painter.context.gl) } onRemove(e) { this.implementation.onRemove && this.implementation.onRemove(e, e.painter.context.gl) } } var uf = { paint: new Mo({ "sky-type": new Io(Ke.paint_sky["sky-type"]), "sky-atmosphere-sun": new Io(Ke.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new Io(Ke.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new Io(Ke.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new Io(Ke.paint_sky["sky-gradient-radius"]), "sky-gradient": new Lo(Ke.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new Io(Ke.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new Io(Ke.paint_sky["sky-atmosphere-color"]), "sky-opacity": new Io(Ke.paint_sky["sky-opacity"]) }) }; function hf(e, t, r) { const n = [0, 0, 1], i = ja([]); return Wa(i, i, r ? -y(e) + Math.PI : y(e)), Xa(i, i, -y(t)), Da(n, n, i), La(n, n) } const df = { circle: class extends ea { constructor(e) { super(e, kl) } createBucket(e) { return new sl(e) } queryRadius(e) { const t = e; return vl("circle-radius", this, t) + vl("circle-stroke-width", this, t) + xl(this.paint.get("circle-translate")) } queryIntersectsFeature(e, t, r, n, i, o, s, a) { const c = wl(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), o.angle, e.pixelToTileUnitsFactor), l = this.paint.get("circle-radius").evaluate(t, r) + this.paint.get("circle-stroke-width").evaluate(t, r); return Cl(e, n, o, s, a, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), c, l) } getProgramIds() { return ["circle"] } getProgramConfiguration(e) { return new Ws(this, e) } }, heatmap: class extends ea { createBucket(e) { return new Al(e) } constructor(e) { super(e, Fl), this._updateColorRamp() } _handleSpecialPaintPropertyUpdate(e) { "heatmap-color" === e && this._updateColorRamp() } _updateColorRamp() { this.colorRamp = Ol({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null } resize() { this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null) } queryRadius(e) { return vl("heatmap-radius", this, e) } queryIntersectsFeature(e, t, r, n, i, o, s, a) { const c = this.paint.get("heatmap-radius").evaluate(t, r); return Cl(e, n, o, s, a, !0, !0, new f(0, 0), c) } hasOffscreenPass() { return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility } getProgramIds() { return ["heatmap", "heatmapTexture"] } getProgramConfiguration(e) { return new Ws(this, e) } }, hillshade: class extends ea { constructor(e) { super(e, zl) } hasOffscreenPass() { return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility } getProgramIds() { return ["hillshade", "hillshadePrepare"] } }, fill: class extends ea { constructor(e) { super(e, ku) } getProgramIds() { const e = this.paint.get("fill-pattern"), t = e && e.constantOr(1), r = [t ? "fillPattern" : "fill"]; return this.paint.get("fill-antialias") && r.push(t && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r } getProgramConfiguration(e) { return new Ws(this, e) } recalculate(e, t) { super.recalculate(e, t); const r = this.paint._values["fill-outline-color"]; "constant" === r.value.kind && void 0 === r.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]) } createBucket(e) { return new wu(e) } queryRadius() { return xl(this.paint.get("fill-translate")) } queryIntersectsFeature(e, t, r, n, i, o) { return !e.queryGeometry.isAboveHorizon && ll(bl(e.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), o.angle, e.pixelToTileUnitsFactor), n) } isTileClipped() { return !0 } }, "fill-extrusion": class extends ea { constructor(e) { super(e, sh) } createBucket(e) { return new $u(e) } queryRadius() { return xl(this.paint.get("fill-extrusion-translate")) } is3D() { return !0 } getProgramIds() { return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"] } getProgramConfiguration(e) { return new Ws(this, e) } queryIntersectsFeature(e, t, r, n, i, o, s, a, c) { const l = wl(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), o.angle, e.pixelToTileUnitsFactor), u = this.paint.get("fill-extrusion-height").evaluate(t, r), h = this.paint.get("fill-extrusion-base").evaluate(t, r), d = [0, 0], p = a && o.elevation, m = o.elevation ? o.elevation.exaggeration() : 1, g = e.tile.getBucket(this); if (p && g instanceof $u) { const e = g.centroidVertexArray, t = c + 1; t < e.length && (d[0] = e.geta_centroid_pos0(t), d[1] = e.geta_centroid_pos1(t)) } if (0 === d[0] && 1 === d[1]) return !1; "globe" === o.projection.name && (n = ih([n], [new f(0, 0), new f(ia, ia)], e.tileID.canonical).map((e => e.polygon)).flat()); const _ = p ? a : null, [y, v] = function (e, t, r, n, i, o, s, a, c, l, u) { return "globe" === e.projection.name ? function (e, t, r, n, i, o, s, a, c, l, u) { const h = [], d = [], p = e.projection.upVectorScale(u, e.center.lat, e.worldSize).metersToTile, f = [0, 0, 0, 1], m = [0, 0, 0, 1], g = (e, t, r, n) => { e[0] = t, e[1] = r, e[2] = n, e[3] = 1 }, _ = nh(); r > 0 && (r += _), n += _; for (const y of t) { const t = [], _ = []; for (const h of y) { const d = h.x + i.x, y = h.y + i.y, v = e.projection.projectTilePoint(d, y, u), x = e.projection.upVector(u, h.x, h.y); let b = r, w = n; if (s) { const e = mh(d, y, r, n, s, a, c, l); b += e.base, w += e.top } 0 !== r ? g(f, v.x + x[0] * p * b, v.y + x[1] * p * b, v.z + x[2] * p * b) : g(f, v.x, v.y, v.z), g(m, v.x + x[0] * p * w, v.y + x[1] * p * w, v.z + x[2] * p * w), Ra(f, f, o), Ra(m, m, o), t.push(new dh(f[0], f[1], f[2])), _.push(new dh(m[0], m[1], m[2])) } h.push(t), d.push(_) } return [h, d] }(e, t, r, n, i, o, s, a, c, l, u) : s ? function (e, t, r, n, i, o, s, a, c) { const l = [], u = [], h = [0, 0, 0, 1]; for (const d of e) { const e = [], p = []; for (const l of d) { const u = l.x + n.x, d = l.y + n.y, f = mh(u, d, t, r, o, s, a, c); h[0] = u, h[1] = d, h[2] = f.base, h[3] = 1, Va(h, h, i), h[3] = Math.max(h[3], 1e-5); const m = new dh(h[0] / h[3], h[1] / h[3], h[2] / h[3]); h[0] = u, h[1] = d, h[2] = f.top, h[3] = 1, Va(h, h, i), h[3] = Math.max(h[3], 1e-5); const g = new dh(h[0] / h[3], h[1] / h[3], h[2] / h[3]); e.push(m), p.push(g) } l.push(e), u.push(p) } return [l, u] }(t, r, n, i, o, s, a, c, l) : function (e, t, r, n, i) { const o = [], s = [], a = i[8] * t, c = i[9] * t, l = i[10] * t, u = i[11] * t, h = i[8] * r, d = i[9] * r, p = i[10] * r, f = i[11] * r; for (const m of e) { const e = [], t = []; for (const r of m) { const o = r.x + n.x, s = r.y + n.y, m = i[0] * o + i[4] * s + i[12], g = i[1] * o + i[5] * s + i[13], _ = i[2] * o + i[6] * s + i[14], y = i[3] * o + i[7] * s + i[15], v = m + a, x = g + c, b = _ + l, w = Math.max(y + u, 1e-5), T = m + h, k = g + d, C = _ + p, E = Math.max(y + f, 1e-5); e.push(new dh(v / w, x / w, b / w)), t.push(new dh(T / E, k / E, C / E)) } o.push(e), s.push(t) } return [o, s] }(t, r, n, i, o) }(o, n, h, u, l, s, _, d, m, o.center.lat, e.tileID.canonical), x = e.queryGeometry; return function (e, t, r) { let n = 1 / 0; ll(r, t) && (n = fh(r, t[0])); for (let i = 0; i < t.length; i++) { const o = t[i], s = e[i]; for (let e = 0; e < o.length - 1; e++) { const t = o[e], i = [t, o[e + 1], s[e + 1], s[e], t]; al(r, i) && (n = Math.min(n, fh(r, i))) } } return n !== 1 / 0 && n }(y, v, x.isPointQuery() ? x.screenBounds : x.screenGeometry) } }, line: class extends ea { constructor(e) { super(e, kh), this.gradientVersion = 0 } _handleSpecialPaintPropertyUpdate(e) { if ("line-gradient" === e) { const e = this._transitionablePaint._values["line-gradient"].value.expression; this.stepInterpolant = e._styleExpression && e._styleExpression.expression instanceof Pr, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER } } gradientExpression() { return this._transitionablePaint._values["line-gradient"].value.expression } widthExpression() { return this._transitionablePaint._values["line-width"].value.expression } recalculate(e, t) { super.recalculate(e, t), this.paint._values["line-floorwidth"] = Ch.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e) } createBucket(e) { return new wh(e) } getProgramIds() { return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"] } getProgramConfiguration(e) { return new Ws(this, e) } queryRadius(e) { const t = e, r = Eh(vl("line-width", this, t), vl("line-gap-width", this, t)), n = vl("line-offset", this, t); return r / 2 + Math.abs(n) + xl(this.paint.get("line-translate")) } queryIntersectsFeature(e, t, r, n, i, o) { if (e.queryGeometry.isAboveHorizon) return !1; const s = bl(e.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), o.angle, e.pixelToTileUnitsFactor), a = e.pixelToTileUnitsFactor / 2 * Eh(this.paint.get("line-width").evaluate(t, r), this.paint.get("line-gap-width").evaluate(t, r)), c = this.paint.get("line-offset").evaluate(t, r); return c && (n = function (e, t) { const r = [], n = new f(0, 0); for (let i = 0; i < e.length; i++) { const o = e[i], s = []; for (let e = 0; e < o.length; e++) { const r = o[e], i = o[e + 1], a = 0 === e ? n : r.sub(o[e - 1])._unit()._perp(), c = e === o.length - 1 ? n : i.sub(r)._unit()._perp(), l = a._add(c)._unit(); l._mult(1 / (l.x * c.x + l.y * c.y)), s.push(l._mult(t)._add(r)) } r.push(s) } return r }(n, c * e.pixelToTileUnitsFactor)), function (e, t, r) { for (let n = 0; n < t.length; n++) { const i = t[n]; if (e.length >= 3) for (let t = 0; t < i.length; t++)if (gl(e, i[t])) return !0; if (ul(e, i, r)) return !0 } return !1 }(s, n, a) } isTileClipped() { return !0 } }, symbol: sf, background: class extends ea { constructor(e) { super(e, af) } getProgramIds() { return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"] } }, raster: class extends ea { constructor(e) { super(e, cf) } getProgramIds() { return ["raster"] } }, sky: class extends ea { constructor(e) { super(e, uf), this._updateColorRamp() } _handleSpecialPaintPropertyUpdate(e) { "sky-gradient" === e ? this._updateColorRamp() : "sky-atmosphere-sun" !== e && "sky-atmosphere-halo-color" !== e && "sky-atmosphere-color" !== e && "sky-atmosphere-sun-intensity" !== e || (this._skyboxInvalidated = !0) } _updateColorRamp() { this.colorRamp = Ol({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null) } needsSkyboxCapture(e) { if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0; if (!this.paint.get("sky-atmosphere-sun")) { const t = e.style.light.properties.get("position"); return this._lightPosition.azimuthal !== t.azimuthal || this._lightPosition.polar !== t.polar } return !1 } getCenter(e, t) { if ("atmosphere" === this.paint.get("sky-type")) { const r = this.paint.get("sky-atmosphere-sun"), n = !r, i = e.style.light, o = i.properties.get("position"); return n && "viewport" === i.properties.get("anchor") && G("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n ? hf(o.azimuthal, 90 - o.polar, t) : hf(r[0], 90 - r[1], t) } const r = this.paint.get("sky-gradient-center"); return hf(r[0], 90 - r[1], t) } is3D() { return !1 } isSky() { return !0 } markSkyboxValid(e) { this._skyboxInvalidated = !1, this._lightPosition = e.style.light.properties.get("position") } hasOffscreenPass() { return !0 } getProgramIds() { const e = this.paint.get("sky-type"); return "atmosphere" === e ? ["skyboxCapture", "skybox"] : "gradient" === e ? ["skyboxGradient"] : null } } }; class pf { constructor(e, t, r, n) { this.context = e, this.format = r, this.texture = e.gl.createTexture(), this.update(t, n) } update(e, r, n) { const { width: i, height: o } = e, { context: s } = this, { gl: a } = s, { HTMLImageElement: c, HTMLCanvasElement: l, HTMLVideoElement: u, ImageData: h, ImageBitmap: d } = t; if (a.bindTexture(a.TEXTURE_2D, this.texture), s.pixelStoreUnpackFlipY.set(!1), s.pixelStoreUnpack.set(1), s.pixelStoreUnpackPremultiplyAlpha.set(this.format === a.RGBA && (!r || !1 !== r.premultiply)), n || this.size && this.size[0] === i && this.size[1] === o) { const { x: t, y: r } = n || { x: 0, y: 0 }; e instanceof c || e instanceof l || e instanceof u || e instanceof h || d && e instanceof d ? a.texSubImage2D(a.TEXTURE_2D, 0, t, r, a.RGBA, a.UNSIGNED_BYTE, e) : a.texSubImage2D(a.TEXTURE_2D, 0, t, r, i, o, a.RGBA, a.UNSIGNED_BYTE, e.data) } else this.size = [i, o], e instanceof c || e instanceof l || e instanceof u || e instanceof h || d && e instanceof d ? a.texImage2D(a.TEXTURE_2D, 0, this.format, this.format, a.UNSIGNED_BYTE, e) : a.texImage2D(a.TEXTURE_2D, 0, this.format, i, o, 0, this.format, a.UNSIGNED_BYTE, e.data); this.useMipmap = Boolean(r && r.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && a.generateMipmap(a.TEXTURE_2D) } bind(e, t) { const { context: r } = this, { gl: n } = r; n.bindTexture(n.TEXTURE_2D, this.texture), e !== this.filter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, e), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, this.useMipmap ? e === n.NEAREST ? n.NEAREST_MIPMAP_NEAREST : n.LINEAR_MIPMAP_NEAREST : e), this.filter = e), t !== this.wrap && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, t), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, t), this.wrap = t) } isSizePowerOfTwo() { return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0 } destroy() { const { gl: e } = this.context; e.deleteTexture(this.texture), this.texture = null } } class ff { constructor(e) { this._callback = e, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => { this._triggered = !1, this._callback() }) } trigger() { this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => { this._triggered = !1, this._callback() }), 0)) } remove() { this._channel = void 0, this._callback = () => { } } } class mf { constructor() { this.tasks = {}, this.taskQueue = [], D(["process"], this), this.invoker = new ff(this.process), this.nextId = 0 } add(e, t) { const r = this.nextId++, n = function ({ type: e, isSymbolTile: t, zoom: r }) { return r = r || 0, "message" === e ? 0 : "maybePrepare" !== e || t ? "parseTile" !== e || t ? "parseTile" === e && t ? 300 - r : "maybePrepare" === e && t ? 400 - r : 500 : 200 - r : 100 - r }(t); if (0 === n) { j(); try { e() } finally { } return { cancel: () => { } } } return this.tasks[r] = { fn: e, metadata: t, priority: n, id: r }, this.taskQueue.push(r), this.invoker.trigger(), { cancel: () => { delete this.tasks[r] } } } process() { j(); try { if (this.taskQueue = this.taskQueue.filter((e => !!this.tasks[e])), !this.taskQueue.length) return; const e = this.pick(); if (null === e) return; const t = this.tasks[e]; if (delete this.tasks[e], this.taskQueue.length && this.invoker.trigger(), !t) return; t.fn() } finally { } } pick() { let e = null, t = 1 / 0; for (let n = 0; n < this.taskQueue.length; n++) { const r = this.tasks[this.taskQueue[n]]; r.priority < t && (t = r.priority, e = n) } if (null === e) return null; const r = this.taskQueue[e]; return this.taskQueue.splice(e, 1), r } remove() { this.invoker.remove() } } class gf { constructor(e) { this._stringToNumber = {}, this._numberToString = []; for (let t = 0; t < e.length; t++) { const r = e[t]; this._stringToNumber[r] = t, this._numberToString[t] = r } } encode(e) { return this._stringToNumber[e] } decode(e) { return this._numberToString[e] } } const _f = ["tile", "layer", "source", "sourceLayer", "state"]; class yf { constructor(e, t, r, n, i) { this.type = "Feature", this._vectorTileFeature = e, this._z = t, this._x = r, this._y = n, this.properties = e.properties, this.id = i } get geometry() { return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry } set geometry(e) { this._geometry = e } toJSON() { const e = { type: "Feature", geometry: this.geometry, properties: this.properties }; void 0 !== this.id && (e.id = this.id); for (const t of _f) void 0 !== this[t] && (e[t] = this[t]); return e } } const vf = 32, xf = 33, bf = new Uint16Array(8184); for (let um = 0; um < 2046; um++) { let e = um + 2, t = 0, r = 0, n = 0, i = 0, o = 0, s = 0; for (1 & e ? n = i = o = vf : t = r = s = vf; (e >>= 1) > 1;) { const a = t + n >> 1, c = r + i >> 1; 1 & e ? (n = t, i = r, t = o, r = s) : (t = n, r = i, n = o, i = s), o = a, s = c } const a = 4 * um; bf[a + 0] = t, bf[a + 1] = r, bf[a + 2] = n, bf[a + 3] = i } const wf = new Uint16Array(xf * xf * 2), Tf = new Uint8Array(xf * xf), kf = new Uint16Array(xf * xf), Cf = .03125; function Ef(e) { return 0 === e ? -Cf : e === xf - 1 ? Cf : 0 } var Sf = Oo([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]); const Pf = { type: 2, extent: ia, loadGeometry: () => [[new f(0, 0), new f(ia + 1, 0), new f(ia + 1, ia + 1), new f(0, ia + 1), new f(0, 0)]] }; class If { constructor(e, t, r, n, i) { this.tileID = e, this.uid = L(), this.uses = 0, this.tileSize = t, this.tileZoom = r, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = i, this.expiredRequestCount = 0, this.state = "loading", n && n.transform && (this.projection = n.transform.projection) } registerFadeDuration(e) { const t = e + this.timeAdded; t < We.now() || this.fadeEndTime && t < this.fadeEndTime || (this.fadeEndTime = t) } wasRequested() { return "errored" === this.state || "loaded" === this.state || "reloading" === this.state } get tileTransform() { return this._tileTransform || (this._tileTransform = Cp(this.tileID.canonical, this.projection)), this._tileTransform } loadVectorData(e, t, r) { if (this.unloadVectorData(), this.state = "loaded", e) { e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = function (e, t) { const r = {}; if (!t) return r; for (const n of e) { const e = n.layerIds.map((e => t.getLayer(e))).filter(Boolean); if (0 !== e.length) { n.layers = e, n.stateDependentLayerIds && (n.stateDependentLayers = n.stateDependentLayerIds.map((t => e.filter((e => e.id === t))[0]))); for (const t of e) r[t.id] = n } } return r }(e.buckets, t.style), this.hasSymbolBuckets = !1; for (const e in this.buckets) { const t = this.buckets[e]; if (t instanceof tf) { if (this.hasSymbolBuckets = !0, !r) break; t.justReloaded = !0 } } if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const e in this.buckets) { const t = this.buckets[e]; if (t instanceof tf && t.hasRTLText) { this.hasRTLText = !0, vo.isLoading() || vo.isLoaded() || "deferred" !== _o() || yo(); break } } this.queryPadding = 0; for (const e in this.buckets) { const r = this.buckets[e]; this.queryPadding = Math.max(this.queryPadding, t.style.getLayer(e).queryRadius(r)) } e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage), e.lineAtlas && (this.lineAtlas = e.lineAtlas) } else this.collisionBoxArray = new hs } unloadVectorData() { if (this.hasData()) { for (const e in this.buckets) this.buckets[e].destroy(); this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded" } } getBucket(e) { return this.buckets[e.id] } upload(e) { for (const r in this.buckets) { const t = this.buckets[r]; t.uploadPending() && t.upload(e) } const t = e.gl; this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new pf(e, this.imageAtlas.image, t.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new pf(e, this.glyphAtlasImage, t.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new pf(e, this.lineAtlas.image, t.ALPHA), this.lineAtlas.uploaded = !0) } prepare(e) { this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture) } queryRenderedFeatures(e, t, r, n, i, o, s, a) { return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ tileResult: n, pixelPosMatrix: s, transform: o, params: i, tileTransform: this.tileTransform }, e, t, r) : {} } querySourceFeatures(e, t) { const r = this.latestFeatureIndex; if (!r || !r.rawTileData) return; const n = r.loadVTLayers(), i = t ? t.sourceLayer : "", o = n._geojsonTileLayer || n[i]; if (!o) return; const s = ui(t && t.filter), { z: a, x: c, y: l } = this.tileID.canonical, u = { z: a, x: c, y: l }; for (let h = 0; h < o.length; h++) { const t = o.feature(h); if (s.needGeometry) { const e = nl(t, !0); if (!s.filter(new xo(this.tileID.overscaledZ), e, this.tileID.canonical)) continue } else if (!s.filter(new xo(this.tileID.overscaledZ), t)) continue; const n = r.getId(t, i), d = new yf(t, a, c, l, n); d.tile = u, e.push(d) } } hasData() { return "loaded" === this.state || "reloading" === this.state || "expired" === this.state } patternsLoaded() { return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length } setExpiryData(e) { const t = this.expirationTime; if (e.cacheControl) { const t = X(e.cacheControl); t["max-age"] && (this.expirationTime = Date.now() + 1e3 * t["max-age"]) } else e.expires && (this.expirationTime = new Date(e.expires).getTime()); if (this.expirationTime) { const e = Date.now(); let r = !1; if (this.expirationTime > e) r = !1; else if (t) if (this.expirationTime < t) r = !0; else { const n = this.expirationTime - t; n ? this.expirationTime = e + Math.max(n, 3e4) : r = !0 } else r = !0; r ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0 } } getExpiryTimeout() { if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1) } setFeatureState(e, t) { if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(e).length || !t) return; const r = this.latestFeatureIndex.loadVTLayers(), n = t.style.listImages(); for (const i in this.buckets) { if (!t.style.hasLayer(i)) continue; const o = this.buckets[i], s = o.layers[0].sourceLayer || "_geojsonTileLayer", a = r[s], c = e[s]; if (!a || !c || 0 === Object.keys(c).length) continue; if (o.update(c, a, n, this.imageAtlas && this.imageAtlas.patternPositions || {}), o instanceof wh || o instanceof wu) { const e = t.style._getSourceCache(o.layers[0].source); t._terrain && t._terrain.enabled && e && o.programConfigurations.needsUpload && t._terrain._clearRenderCacheForTile(e.id, this.tileID) } const l = t && t.style && t.style.getLayer(i); l && (this.queryPadding = Math.max(this.queryPadding, l.queryRadius(o))) } } holdingForFade() { return void 0 !== this.symbolFadeHoldUntil } symbolFadeFinished() { return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < We.now() } clearFadeHold() { this.symbolFadeHoldUntil = void 0 } setHoldDuration(e) { this.symbolFadeHoldUntil = We.now() + e } setTexture(e, t) { const r = t.context, n = r.gl; this.texture = this.texture || t.getTileTexture(e.width), this.texture ? this.texture.update(e, { useMipmap: !0 }) : (this.texture = new pf(r, e, n.RGBA, { useMipmap: !0 }), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE)) } setDependencies(e, t) { const r = {}; for (const n of t) r[n] = !0; this.dependencies[e] = r } hasDependency(e, t) { for (const r of e) { const e = this.dependencies[r]; if (e) for (const r of t) if (e[r]) return !0 } return !1 } clearQueryDebugViz() { } _makeDebugTileBoundsBuffers(e, t) { if (!t || "mercator" === t.name || this._tileDebugBuffer) return; const r = rl(Pf, this.tileID.canonical, this.tileTransform)[0], n = new Uo, i = new cs; for (let o = 0; o < r.length; o++) { const { x: e, y: t } = r[o]; n.emplaceBack(e, t), i.emplaceBack(o) } i.emplaceBack(0), this._tileDebugIndexBuffer = e.createIndexBuffer(i), this._tileDebugBuffer = e.createVertexBuffer(n, Ja.members), this._tileDebugSegments = na.simpleSegment(0, 0, n.length, i.length) } _makeTileBoundsBuffers(e, t) { if (this._tileBoundsBuffer || !t || "mercator" === t.name) return; const r = rl(Pf, this.tileID.canonical, this.tileTransform)[0]; let n, i; if (this.isRaster) { const e = function (e, t) { const r = Cp(e, t), n = Math.pow(2, e.z); for (let l = 0; l < xf; l++)for (let i = 0; i < xf; i++) { const o = qc((e.x + (i + Ef(i)) / vf) / n), s = jc((e.y + (l + Ef(l)) / vf) / n), a = t.project(o, s), c = l * xf + i; wf[2 * c + 0] = Math.round((a.x * r.scale - r.x) * ia), wf[2 * c + 1] = Math.round((a.y * r.scale - r.y) * ia) } Tf.fill(0), kf.fill(0); for (let l = 2045; l >= 0; l--) { const e = 4 * l, t = bf[e + 0], r = bf[e + 1], n = bf[e + 2], i = bf[e + 3], o = t + n >> 1, s = r + i >> 1, a = o + s - r, c = s + t - o, u = r * xf + t, h = i * xf + n, d = s * xf + o, p = Math.hypot((wf[2 * u + 0] + wf[2 * h + 0]) / 2 - wf[2 * d + 0], (wf[2 * u + 1] + wf[2 * h + 1]) / 2 - wf[2 * d + 1]) >= 16; Tf[d] = Tf[d] || (p ? 1 : 0), l < 1022 && (Tf[d] = Tf[d] || Tf[(r + c >> 1) * xf + (t + a >> 1)] || Tf[(i + c >> 1) * xf + (n + a >> 1)]) } const i = new Go, o = new ts; let s = 0; function a(e, t) { const r = t * xf + e; return 0 === kf[r] && (i.emplaceBack(wf[2 * r + 0], wf[2 * r + 1], e * ia / vf, t * ia / vf), kf[r] = ++s), kf[r] - 1 } function c(e, t, r, n, i, s) { const l = e + r >> 1, u = t + n >> 1; if (Math.abs(e - i) + Math.abs(t - s) > 1 && Tf[u * xf + l]) c(i, s, e, t, l, u), c(r, n, i, s, l, u); else { const c = a(e, t), l = a(r, n), u = a(i, s); o.emplaceBack(c, l, u) } } return c(0, 0, vf, vf, vf, 0), c(vf, vf, 0, 0, 0, vf), { vertices: i, indices: o } }(this.tileID.canonical, t); n = e.vertices, i = e.indices } else { n = new Go, i = new ts; for (const { x: t, y: i } of r) n.emplaceBack(t, i, 0, 0); const e = Gl(n.int16, void 0, 4); for (let t = 0; t < e.length; t += 3)i.emplaceBack(e[t], e[t + 1], e[t + 2]) } this._tileBoundsBuffer = e.createVertexBuffer(n, Sf.members), this._tileBoundsIndexBuffer = e.createIndexBuffer(i), this._tileBoundsSegments = na.simpleSegment(0, 0, n.length, i.length) } _makeGlobeTileDebugBuffers(e, t) { const r = t.projection; if (!r || "globe" !== r.name || t.freezeTileCoverage) return; const n = this.tileID.canonical, i = Sc(_c(n, t)), o = Ac(t.zoom); let s; o > 0 && (s = ha(new Float64Array(16), t.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(e, n, t, i, s, o), this._makeGlobeTileDebugTextBuffer(e, n, t, i, s, o) } _globePoint(e, t, r, n, i, o, s) { let a = kc(e, t, r); if (o) { const i = 1 << r.z, c = Nc(n.center.lng), l = Gc(n.center.lat), u = (r.x + .5) / i - c; let h = 0; u > .5 ? h = -1 : u < -.5 && (h = 1); let d = (e / ia + r.x) / i + h, p = (t / ia + r.y) / i; d = (d - c) * n._pixelsPerMercatorPixel + c, p = (p - l) * n._pixelsPerMercatorPixel + l; const f = [d * n.worldSize, p * n.worldSize, 0]; Ra(f, f, o), a = gc(a, f, s) } return Ra(a, a, i) } _makeGlobeTileDebugBorderBuffer(e, t, r, n, i, o) { const s = new Uo, a = new cs, c = new No, l = (e, l, u, h, d) => { const p = (u - e) / (d - 1), f = (h - l) / (d - 1), m = s.length; for (let g = 0; g < d; g++) { const u = e + g * p, h = l + g * f; s.emplaceBack(u, h); const d = this._globePoint(u, h, t, r, n, i, o); c.emplaceBack(d[0], d[1], d[2]), a.emplaceBack(m + g) } }, u = ia; l(0, 0, u, 0, 16), l(u, 0, u, u, 16), l(u, u, 0, u, 16), l(0, u, 0, 0, 16), this._tileDebugIndexBuffer = e.createIndexBuffer(a), this._tileDebugBuffer = e.createVertexBuffer(s, Ja.members), this._globeTileDebugBorderBuffer = e.createVertexBuffer(c, $a.members), this._tileDebugSegments = na.simpleSegment(0, 0, s.length, a.length) } _makeGlobeTileDebugTextBuffer(e, t, r, n, i, o) { const s = ia / 4, a = new Uo, c = new ts, l = new No, u = 25; c.reserve(32), a.reserve(u), l.reserve(u); const h = (e, t) => u * e + t; for (let d = 0; d < u; d++) { const e = d * s; for (let c = 0; c < u; c++) { const u = c * s; a.emplaceBack(u, e); const h = this._globePoint(u, e, t, r, n, i, o); l.emplaceBack(h[0], h[1], h[2]) } } for (let d = 0; d < 4; d++)for (let e = 0; e < 4; e++) { const t = h(d, e), r = h(d, e + 1), n = h(d + 1, e), i = h(d + 1, e + 1); c.emplaceBack(t, r, n), c.emplaceBack(n, r, i) } this._tileDebugTextIndexBuffer = e.createIndexBuffer(c), this._tileDebugTextBuffer = e.createVertexBuffer(a, Ja.members), this._globeTileDebugTextBuffer = e.createVertexBuffer(l, $a.members), this._tileDebugTextSegments = na.simpleSegment(0, 0, u, 32) } } class Af { constructor() { this.state = {}, this.stateChanges = {}, this.deletedStates = {} } updateState(e, t, r) { const n = String(t); if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][n] = this.stateChanges[e][n] || {}, I(this.stateChanges[e][n], r), null === this.deletedStates[e]) { this.deletedStates[e] = {}; for (const t in this.state[e]) t !== n && (this.deletedStates[e][t] = null) } else if (this.deletedStates[e] && null === this.deletedStates[e][n]) { this.deletedStates[e][n] = {}; for (const t in this.state[e][n]) r[t] || (this.deletedStates[e][n][t] = null) } else for (const i in r) this.deletedStates[e] && this.deletedStates[e][n] && null === this.deletedStates[e][n][i] && delete this.deletedStates[e][n][i] } removeFeatureState(e, t, r) { if (null === this.deletedStates[e]) return; const n = String(t); if (this.deletedStates[e] = this.deletedStates[e] || {}, r && void 0 !== t) null !== this.deletedStates[e][n] && (this.deletedStates[e][n] = this.deletedStates[e][n] || {}, this.deletedStates[e][n][r] = null); else if (void 0 !== t) if (this.stateChanges[e] && this.stateChanges[e][n]) for (r in this.deletedStates[e][n] = {}, this.stateChanges[e][n]) this.deletedStates[e][n][r] = null; else this.deletedStates[e][n] = null; else this.deletedStates[e] = null } getState(e, t) { const r = String(t), n = I({}, (this.state[e] || {})[r], (this.stateChanges[e] || {})[r]); if (null === this.deletedStates[e]) return {}; if (this.deletedStates[e]) { const r = this.deletedStates[e][t]; if (null === r) return {}; for (const e in r) delete n[e] } return n } initializeTileState(e, t) { e.setFeatureState(this.state, t) } coalesceChanges(e, t) { const r = {}; for (const n in this.stateChanges) { this.state[n] = this.state[n] || {}; const e = {}; for (const t in this.stateChanges[n]) this.state[n][t] || (this.state[n][t] = {}), I(this.state[n][t], this.stateChanges[n][t]), e[t] = this.state[n][t]; r[n] = e } for (const n in this.deletedStates) { this.state[n] = this.state[n] || {}; const e = {}; if (null === this.deletedStates[n]) for (const t in this.state[n]) e[t] = {}, this.state[n][t] = {}; else for (const t in this.deletedStates[n]) { if (null === this.deletedStates[n][t]) this.state[n][t] = {}; else if (this.state[n][t]) for (const e of Object.keys(this.deletedStates[n][t])) delete this.state[n][t][e]; e[t] = this.state[n][t] } r[n] = r[n] || {}, I(r[n], e) } if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r).length) for (const n in e) e[n].setFeatureState(r, t) } } class Lf { constructor(e) { this.size = e, this.minimums = [], this.maximums = [], this.leaves = [] } getElevation(e, t) { const r = this.toIdx(e, t); return { min: this.minimums[r], max: this.maximums[r] } } isLeaf(e, t) { return this.leaves[this.toIdx(e, t)] } toIdx(e, t) { return t * this.size + e } } function Mf(e, t, r, n) { let i = 0, o = Number.MAX_VALUE; for (let s = 0; s < 3; s++)if (Math.abs(n[s]) < 1e-15) { if (r[s] < e[s] || r[s] > t[s]) return null } else { const a = 1 / n[s]; let c = (e[s] - r[s]) * a, l = (t[s] - r[s]) * a; if (c > l) { const e = c; c = l, l = e } if (c > i && (i = c), l < o && (o = l), i > o) return null } return i } function Bf(e, t, r, n, i, o, s, a, c, l, u) { const h = n - e, d = i - t, p = o - r, f = s - e, m = a - t, g = c - r, _ = u[1] * g - u[2] * m, y = u[2] * f - u[0] * g, v = u[0] * m - u[1] * f, x = h * _ + d * y + p * v; if (Math.abs(x) < 1e-15) return null; const b = 1 / x, w = l[0] - e, T = l[1] - t, k = l[2] - r, C = (w * _ + T * y + k * v) * b; if (C < 0 || C > 1) return null; const E = T * p - k * d, S = k * h - w * p, P = w * d - T * h, I = (u[0] * E + u[1] * S + u[2] * P) * b; return I < 0 || C + I > 1 ? null : (f * E + m * S + g * P) * b } function Rf(e, t, r) { return (e - t) / (r - t) } function Df(e, t, r, n, i, o, s, a, c) { const l = 1 << r, u = o - n, h = s - i, d = (e + 1) / l * u + n, p = (t + 0) / l * h + i, f = (t + 1) / l * h + i; a[0] = (e + 0) / l * u + n, a[1] = p, c[0] = d, c[1] = f } class Ff { constructor(e) { if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = e, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return; const t = function (e) { const t = Math.ceil(Math.log2(e.dim / 8)), r = []; let n = Math.ceil(Math.pow(2, t)); const i = 1 / n, o = (e, t, r, n, i) => { const o = n ? 1 : 0, s = (e + 1) * r - o, a = t * r, c = (t + 1) * r - o; i[0] = e * r, i[1] = a, i[2] = s, i[3] = c }; let s = new Lf(n); const a = []; for (let c = 0; c < n * n; c++) { o(c % n, Math.floor(c / n), i, !1, a); const t = zf(a[0], a[1], e), r = zf(a[2], a[1], e), l = zf(a[2], a[3], e), u = zf(a[0], a[3], e); s.minimums.push(Math.min(t, r, l, u)), s.maximums.push(Math.max(t, r, l, u)), s.leaves.push(1) } for (r.push(s), n /= 2; n >= 1; n /= 2) { const e = r[r.length - 1]; s = new Lf(n); for (let t = 0; t < n * n; t++) { o(t % n, Math.floor(t / n), 2, !0, a); const r = e.getElevation(a[0], a[1]), i = e.getElevation(a[2], a[1]), c = e.getElevation(a[2], a[3]), l = e.getElevation(a[0], a[3]), u = e.isLeaf(a[0], a[1]), h = e.isLeaf(a[2], a[1]), d = e.isLeaf(a[2], a[3]), p = e.isLeaf(a[0], a[3]), f = Math.min(r.min, i.min, c.min, l.min), m = Math.max(r.max, i.max, c.max, l.max), g = u && h && d && p; s.maximums.push(m), s.minimums.push(f), s.leaves.push(m - f <= 5 && g ? 1 : 0) } r.push(s) } return r }(this.dem), r = t.length - 1, n = t[r]; this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]), this._construct(t, 0, 0, r, 0) } raycastRoot(e, t, r, n, i, o, s = 1) { return Mf([e, t, -100], [r, n, this.maximums[0] * s], i, o) } raycast(e, t, r, n, i, o, s = 1) { if (!this.nodeCount) return null; const a = this.raycastRoot(e, t, r, n, i, o, s); if (null == a) return null; const c = [], l = [], u = [], h = [], d = [{ idx: 0, t: a, nodex: 0, nodey: 0, depth: 0 }]; for (; d.length > 0;) { const { idx: a, t: p, nodex: f, nodey: m, depth: g } = d.pop(); if (this.leaves[a]) { Df(f, m, g, e, t, r, n, u, h); const a = 1 << g, c = (f + 0) / a, l = (f + 1) / a, d = (m + 0) / a, _ = (m + 1) / a, y = zf(c, d, this.dem) * s, v = zf(l, d, this.dem) * s, x = zf(l, _, this.dem) * s, b = zf(c, _, this.dem) * s, w = Bf(u[0], u[1], y, h[0], u[1], v, h[0], h[1], x, i, o), T = Bf(h[0], h[1], x, u[0], h[1], b, u[0], u[1], y, i, o), k = Math.min(null !== w ? w : Number.MAX_VALUE, null !== T ? T : Number.MAX_VALUE); if (k !== Number.MAX_VALUE) return k; { const e = Aa([], i, o, p); if (Of(y, v, b, x, Rf(e[0], u[0], h[0]), Rf(e[1], u[1], h[1])) >= e[2]) return p } continue } let _ = 0; for (let d = 0; d < this._siblingOffset.length; d++) { Df((f << 1) + this._siblingOffset[d][0], (m << 1) + this._siblingOffset[d][1], g + 1, e, t, r, n, u, h), u[2] = -100, h[2] = this.maximums[this.childOffsets[a] + d] * s; const p = Mf(u, h, i, o); if (null != p) { const e = p; c[d] = e; let t = !1; for (let r = 0; r < _ && !t; r++)e >= c[l[r]] && (l.splice(r, 0, d), t = !0); t || (l[_] = d), _++ } } for (let e = 0; e < _; e++) { const t = l[e]; d.push({ idx: this.childOffsets[a] + t, t: c[t], nodex: (f << 1) + this._siblingOffset[t][0], nodey: (m << 1) + this._siblingOffset[t][1], depth: g + 1 }) } } return null } _addNode(e, t, r) { return this.minimums.push(e), this.maximums.push(t), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++ } _construct(e, t, r, n, i) { if (1 === e[n].isLeaf(t, r)) return; this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount); const o = n - 1, s = e[o]; let a = 0, c = 0; for (let l = 0; l < this._siblingOffset.length; l++) { const e = 2 * t + this._siblingOffset[l][0], n = 2 * r + this._siblingOffset[l][1], i = s.getElevation(e, n), o = s.isLeaf(e, n), u = this._addNode(i.min, i.max, o); o && (a |= 1 << l), c || (c = u) } for (let l = 0; l < this._siblingOffset.length; l++)a & 1 << l || this._construct(e, 2 * t + this._siblingOffset[l][0], 2 * r + this._siblingOffset[l][1], o, c + l) } } function Of(e, t, r, n, i, o) { return Ir(Ir(e, r, o), Ir(t, n, o), i) } function zf(e, t, r) { const n = r.dim, i = k(e * n - .5, 0, n - 1), o = k(t * n - .5, 0, n - 1), s = Math.floor(i), a = Math.floor(o), c = Math.min(s + 1, n - 1), l = Math.min(a + 1, n - 1); return Of(r.get(s, a), r.get(c, a), r.get(s, l), r.get(c, l), i - s, o - a) } const Uf = { mapbox: [6553.6, 25.6, .1, 1e4], terrarium: [256, 1, 1 / 256, 32768] }; class Nf { get tree() { return this._tree || this._buildQuadTree(), this._tree } constructor(e, t, r, n = !1, i = !1) { if (this.uid = e, t.height !== t.width) throw new RangeError("DEM tiles must be square"); if (r && "mapbox" !== r && "terrarium" !== r) return G(`"${r}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`); this.stride = t.height; const o = this.dim = t.height - 2, s = new Uint32Array(t.data.buffer); if (this.pixels = new Uint8Array(t.data.buffer), this.encoding = r || "mapbox", this.borderReady = n, !n) { for (let e = 0; e < o; e++)s[this._idx(-1, e)] = s[this._idx(0, e)], s[this._idx(o, e)] = s[this._idx(o - 1, e)], s[this._idx(e, -1)] = s[this._idx(e, 0)], s[this._idx(e, o)] = s[this._idx(e, o - 1)]; s[this._idx(-1, -1)] = s[this._idx(0, 0)], s[this._idx(o, -1)] = s[this._idx(o - 1, 0)], s[this._idx(-1, o)] = s[this._idx(0, o - 1)], s[this._idx(o, o)] = s[this._idx(o - 1, o - 1)], i && this._buildQuadTree() } } _buildQuadTree() { this._tree = new Ff(this) } get(e, t, r = !1) { r && (e = k(e, -1, this.dim), t = k(t, -1, this.dim)); const n = 4 * this._idx(e, t); return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(this.pixels[n], this.pixels[n + 1], this.pixels[n + 2]) } static getUnpackVector(e) { return Uf[e] } get unpackVector() { return Uf[this.encoding] } _idx(e, t) { if (e < -1 || e >= this.dim + 1 || t < -1 || t >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data"); return (t + 1) * this.stride + (e + 1) } _unpackMapbox(e, t, r) { return (256 * e * 256 + 256 * t + r) / 10 - 1e4 } _unpackTerrarium(e, t, r) { return 256 * e + t + r / 256 - 32768 } static pack(e, t) { const r = [0, 0, 0, 0], n = Nf.getUnpackVector(t); let i = Math.floor((e + n[3]) / n[2]); return r[2] = i % 256, i = Math.floor(i / 256), r[1] = i % 256, i = Math.floor(i / 256), r[0] = i, r } getPixels() { return new Dl({ width: this.stride, height: this.stride }, this.pixels) } backfillBorder(e, t, r) { if (this.dim !== e.dim) throw new Error("dem dimension mismatch"); let n = t * this.dim, i = t * this.dim + this.dim, o = r * this.dim, s = r * this.dim + this.dim; switch (t) { case -1: n = i - 1; break; case 1: i = n + 1 }switch (r) { case -1: o = s - 1; break; case 1: s = o + 1 }const a = -t * this.dim, c = -r * this.dim; for (let l = o; l < s; l++)for (let t = n; t < i; t++) { const r = 4 * this._idx(t, l), n = 4 * this._idx(t + a, l + c); this.pixels[r + 0] = e.pixels[n + 0], this.pixels[r + 1] = e.pixels[n + 1], this.pixels[r + 2] = e.pixels[n + 2], this.pixels[r + 3] = e.pixels[n + 3] } } onDeserialize() { this._tree && (this._tree.dem = this) } } Zi(Nf, "DEMData"), Zi(Ff, "DemMinMaxQuadTree", { omit: ["dem"] }); class Gf { constructor(e, t) { this.max = e, this.onRemove = t, this.reset() } reset() { for (const e in this.data) for (const t of this.data[e]) t.timeout && clearTimeout(t.timeout), this.onRemove(t.value); return this.data = {}, this.order = [], this } add(e, t, r) { const n = e.wrapped().key; void 0 === this.data[n] && (this.data[n] = []); const i = { value: t, timeout: void 0 }; if (void 0 !== r && (i.timeout = setTimeout((() => { this.remove(e, i) }), r)), this.data[n].push(i), this.order.push(n), this.order.length > this.max) { const e = this._getAndRemoveByKey(this.order[0]); e && this.onRemove(e) } return this } has(e) { return e.wrapped().key in this.data } getAndRemove(e) { return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null } _getAndRemoveByKey(e) { const t = this.data[e].shift(); return t.timeout && clearTimeout(t.timeout), 0 === this.data[e].length && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), t.value } getByKey(e) { const t = this.data[e]; return t ? t[0].value : null } get(e) { return this.has(e) ? this.data[e.wrapped().key][0].value : null } remove(e, t) { if (!this.has(e)) return this; const r = e.wrapped().key, n = void 0 === t ? 0 : this.data[r].indexOf(t), i = this.data[r][n]; return this.data[r].splice(n, 1), i.timeout && clearTimeout(i.timeout), 0 === this.data[r].length && delete this.data[r], this.onRemove(i.value), this.order.splice(this.order.indexOf(r), 1), this } setMaxSize(e) { for (this.max = e; this.order.length > this.max;) { const e = this._getAndRemoveByKey(this.order[0]); e && this.onRemove(e) } return this } filter(e) { const t = []; for (const r in this.data) for (const n of this.data[r]) e(n.value) || t.push(n); for (const r of t) this.remove(r.value.tileID, r) } } class Vf { constructor(e, t, r) { this.func = e, this.mask = t, this.range = r } } Vf.ReadOnly = !1, Vf.ReadWrite = !0, Vf.disabled = new Vf(519, Vf.ReadOnly, [0, 1]); const qf = 7680; class jf { constructor(e, t, r, n, i, o) { this.test = e, this.ref = t, this.mask = r, this.fail = n, this.depthFail = i, this.pass = o } } jf.disabled = new jf({ func: 519, mask: 0 }, 0, 0, qf, qf, qf); class Xf { constructor(e, t, r) { this.blendFunction = e, this.blendColor = t, this.mask = r } } Xf.Replace = [1, 0], Xf.disabled = new Xf(Xf.Replace, It.transparent, [!1, !1, !1, !1]), Xf.unblended = new Xf(Xf.Replace, It.transparent, [!0, !0, !0, !0]), Xf.alphaBlended = new Xf([1, 771], It.transparent, [!0, !0, !0, !0]); const Wf = 1029, Zf = 2305; class Hf { constructor(e, t, r) { this.enable = e, this.mode = t, this.frontFace = r } } Hf.disabled = new Hf(!1, Wf, Zf), Hf.backCCW = new Hf(!0, Wf, Zf), Hf.backCW = new Hf(!0, Wf, 2304), Hf.frontCW = new Hf(!0, 1028, 2304), Hf.frontCCW = new Hf(!0, 1028, Zf); class Qf extends Je { constructor(e, t, r) { super(), this.id = e, this._onlySymbols = r, t.on("data", (e => { "source" === e.dataType && "metadata" === e.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === e.dataType && "content" === e.sourceDataType && (this.reload(), this.transform && this.update(this.transform)) })), t.on("error", (() => { this._sourceErrored = !0 })), this._source = t, this._tiles = {}, this._cache = new Gf(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = t.minTileCacheSize, this._maxTileCacheSize = t.maxTileCacheSize, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Af, this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType } onAdd(e) { this.map = e, this._minTileCacheSize = void 0 === this._minTileCacheSize && e ? e._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && e ? e._maxTileCacheSize : this._maxTileCacheSize } loaded() { if (this._sourceErrored) return !0; if (!this._sourceLoaded) return !1; if (!this._source.loaded()) return !1; for (const e in this._tiles) { const t = this._tiles[e]; if ("loaded" !== t.state && "errored" !== t.state) return !1 } return !0 } getSource() { return this._source } pause() { this._paused = !0 } resume() { if (!this._paused) return; const e = this._shouldReloadOnResume; this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform) } _loadTile(e, t) { return e.isSymbolTile = this._onlySymbols, this._source.loadTile(e, t) } _unloadTile(e) { if (this._source.unloadTile) return this._source.unloadTile(e, (() => { })) } _abortTile(e) { if (this._source.abortTile) return this._source.abortTile(e, (() => { })) } serialize() { return this._source.serialize() } prepare(e) { this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null); for (const t in this._tiles) { const r = this._tiles[t]; r.upload(e), r.prepare(this.map.style.imageManager) } } getIds() { return P(this._tiles).map((e => e.tileID)).sort($f).map((e => e.key)) } getRenderableIds(e) { const t = []; for (const r in this._tiles) this._isIdRenderable(+r, e) && t.push(this._tiles[r]); return e ? t.sort(((e, t) => { const r = e.tileID, n = t.tileID, i = new f(r.canonical.x, r.canonical.y)._rotate(this.transform.angle), o = new f(n.canonical.x, n.canonical.y)._rotate(this.transform.angle); return r.overscaledZ - n.overscaledZ || o.y - i.y || o.x - i.x })).map((e => e.tileID.key)) : t.map((e => e.tileID)).sort($f).map((e => e.key)) } hasRenderableParent(e) { const t = this.findLoadedParent(e, 0); return !!t && this._isIdRenderable(t.tileID.key) } _isIdRenderable(e, t) { return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (t || !this._tiles[e].holdingForFade()) } reload() { if (this._paused) this._shouldReloadOnResume = !0; else { this._cache.reset(); for (const e in this._tiles) "errored" !== this._tiles[e].state && this._reloadTile(+e, "reloading") } } _reloadTile(e, t) { const r = this._tiles[e]; r && ("loading" !== r.state && (r.state = t), this._loadTile(r, this._tileLoaded.bind(this, r, e, t))) } _tileLoaded(e, t, r, n) { if (n) if (e.state = "errored", 404 !== n.status) this._source.fire(new $e(n, { tile: e })); else if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) { const e = this.map.painter.terrain; this.update(this.transform, e.getScaledDemTileSize(), !0), e.resetTileLookupCache(this.id) } else this.update(this.transform); else e.timeAdded = We.now(), "expired" === r && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(t, e), "raster-dem" === this._source.type && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), this._source.fire(new Qe("data", { dataType: "source", tile: e, coord: e.tileID, sourceCacheId: this.id })) } _backfillDEM(e) { const t = this.getRenderableIds(); for (let n = 0; n < t.length; n++) { const i = t[n]; if (e.neighboringTiles && e.neighboringTiles[i]) { const t = this.getTileByID(i); r(e, t), r(t, e) } } function r(e, t) { if (!e.dem || e.dem.borderReady) return; e.needsHillshadePrepare = !0, e.needsDEMTextureUpload = !0; let r = t.tileID.canonical.x - e.tileID.canonical.x; const n = t.tileID.canonical.y - e.tileID.canonical.y, i = Math.pow(2, e.tileID.canonical.z), o = t.tileID.key; 0 === r && 0 === n || Math.abs(n) > 1 || (Math.abs(r) > 1 && (1 === Math.abs(r + i) ? r += i : 1 === Math.abs(r - i) && (r -= i)), t.dem && e.dem && (e.dem.backfillBorder(t.dem, r, n), e.neighboringTiles && e.neighboringTiles[o] && (e.neighboringTiles[o].backfilled = !0))) } } getTile(e) { return this.getTileByID(e.key) } getTileByID(e) { return this._tiles[e] } _retainLoadedChildren(e, t, r, n) { for (const i in this._tiles) { let o = this._tiles[i]; if (n[i] || !o.hasData() || o.tileID.overscaledZ <= t || o.tileID.overscaledZ > r) continue; let s = o.tileID; for (; o && o.tileID.overscaledZ > t + 1;) { const e = o.tileID.scaledTo(o.tileID.overscaledZ - 1); o = this._tiles[e.key], o && o.hasData() && (s = e) } let a = s; for (; a.overscaledZ > t;)if (a = a.scaledTo(a.overscaledZ - 1), e[a.key]) { n[s.key] = s; break } } } findLoadedParent(e, t) { if (e.key in this._loadedParentTiles) { const r = this._loadedParentTiles[e.key]; return r && r.tileID.overscaledZ >= t ? r : null } for (let r = e.overscaledZ - 1; r >= t; r--) { const t = e.scaledTo(r), n = this._getLoadedTile(t); if (n) return n } } _getLoadedTile(e) { const t = this._tiles[e.key]; return t && t.hasData() ? t : this._cache.getByKey(this._source.reparseOverscaled ? e.wrapped().key : e.canonical.key) } updateCacheSize(e, t) { t = t || this._source.tileSize; const r = Math.ceil(e.width / t) + 1, n = Math.ceil(e.height / t) + 1, i = Math.floor(r * n * 5), o = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, i) : i, s = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o) : o; this._cache.setMaxSize(s) } handleWrapJump(e) { const t = Math.round((e - (void 0 === this._prevLng ? e : this._prevLng)) / 360); if (this._prevLng = e, t) { const e = {}; for (const r in this._tiles) { const n = this._tiles[r]; n.tileID = n.tileID.unwrapTo(n.tileID.wrap + t), e[n.tileID.key] = n } this._tiles = e; for (const t in this._timers) clearTimeout(this._timers[t]), delete this._timers[t]; for (const t in this._tiles) this._setTileReloadTimer(+t, this._tiles[t]) } } update(e, t, r) { if (this.transform = e, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return; if (this.usedForTerrain && !r) return; let n; this.updateCacheSize(e, t), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((e => new uh(e.canonical.z, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y))) : (n = e.coveringTiles({ tileSize: t || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !r, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.hasTile && (n = n.filter((e => this._source.hasTile(e))))) : n = []; const i = this._updateRetainedTiles(n); if (Jf(this._source.type) && 0 !== n.length) { const e = {}, t = {}, r = Object.keys(i); for (const n of r) { const r = i[n], o = this._tiles[n]; if (!o || o.fadeEndTime && o.fadeEndTime <= We.now()) continue; const s = this.findLoadedParent(r, Math.max(r.overscaledZ - Qf.maxOverzooming, this._source.minzoom)); s && (this._addTile(s.tileID), e[s.tileID.key] = s.tileID), t[n] = r } const o = n[n.length - 1].overscaledZ; for (const n in this._tiles) { const e = this._tiles[n]; if (i[n] || !e.hasData()) continue; let r = e.tileID; for (; r.overscaledZ > o;) { r = r.scaledTo(r.overscaledZ - 1); const o = this._tiles[r.key]; if (o && o.hasData() && t[r.key]) { i[n] = e.tileID; break } } } for (const n in e) i[n] || (this._coveredTiles[n] = !0, i[n] = e[n]) } for (const s in i) this._tiles[s].clearFadeHold(); const o = function (e, t) { const r = []; for (const n in e) n in t || r.push(n); return r }(this._tiles, i); for (const s of o) { const e = this._tiles[s]; e.hasSymbolBuckets && !e.holdingForFade() ? e.setHoldDuration(this.map._fadeDuration) : e.hasSymbolBuckets && !e.symbolFadeFinished() || this._removeTile(+s) } this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate() } releaseSymbolFadeTiles() { for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(+e) } _updateRetainedTiles(e) { const t = {}; if (0 === e.length) return t; const r = {}, n = e.reduce(((e, t) => Math.min(e, t.overscaledZ)), 1 / 0), i = e[0].overscaledZ, o = Math.max(i - Qf.maxOverzooming, this._source.minzoom), s = Math.max(i + Qf.maxUnderzooming, this._source.minzoom), a = {}; for (const c of e) { const e = this._addTile(c); t[c.key] = c, e.hasData() || n < this._source.maxzoom && (a[c.key] = c) } this._retainLoadedChildren(a, n, s, t); for (const c of e) { let e = this._tiles[c.key]; if (e.hasData()) continue; if (c.canonical.z >= this._source.maxzoom) { const e = c.children(this._source.maxzoom)[0], r = this.getTile(e); if (r && r.hasData()) { t[e.key] = e; continue } } else { const e = c.children(this._source.maxzoom); if (t[e[0].key] && t[e[1].key] && t[e[2].key] && t[e[3].key]) continue } let n = e.wasRequested(); for (let i = c.overscaledZ - 1; i >= o; --i) { const o = c.scaledTo(i); if (r[o.key]) break; if (r[o.key] = !0, e = this.getTile(o), !e && n && (e = this._addTile(o)), e && (t[o.key] = o, n = e.wasRequested(), e.hasData())) break } } return t } _updateLoadedParentTileCache() { this._loadedParentTiles = {}; for (const e in this._tiles) { const t = []; let r, n = this._tiles[e].tileID; for (; n.overscaledZ > 0;) { if (n.key in this._loadedParentTiles) { r = this._loadedParentTiles[n.key]; break } t.push(n.key); const e = n.scaledTo(n.overscaledZ - 1); if (r = this._getLoadedTile(e), r) break; n = e } for (const e of t) this._loadedParentTiles[e] = r } } _addTile(e) { let t = this._tiles[e.key]; if (t) return t; t = this._cache.getAndRemove(e), t && (this._setTileReloadTimer(e.key, t), t.tileID = e, this._state.initializeTileState(t, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, t))); const r = Boolean(t); if (!r) { const r = this.map ? this.map.painter : null; t = new If(e, this._source.tileSize * e.overscaleFactor(), this.transform.tileZoom, r, this._isRaster), this._loadTile(t, this._tileLoaded.bind(this, t, e.key, t.state)) } return t ? (t.uses++, this._tiles[e.key] = t, r || this._source.fire(new Qe("dataloading", { tile: t, coord: t.tileID, dataType: "source" })), t) : null } _setTileReloadTimer(e, t) { e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]); const r = t.getExpiryTimeout(); r && (this._timers[e] = setTimeout((() => { this._reloadTile(e, "expired"), delete this._timers[e] }), r)) } _removeTile(e) { const t = this._tiles[e]; t && (t.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), t.uses > 0 || (t.hasData() && "reloading" !== t.state ? this._cache.add(t.tileID, t, t.getExpiryTimeout()) : (t.aborted = !0, this._abortTile(t), this._unloadTile(t)))) } clearTiles() { this._shouldReloadOnResume = !1, this._paused = !1; for (const e in this._tiles) this._removeTile(+e); this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id) } tilesIn(e, t, r) { const n = [], i = this.transform; if (!i) return n; const o = "globe" === i.projection.name, s = Nc(i.center.lng); for (const a in this._tiles) { const c = this._tiles[a]; if (r && c.clearQueryDebugViz(), c.holdingForFade()) continue; let l; if (o) { const e = c.tileID.canonical; if (0 === e.z) { const t = [Math.abs(k(s, ...Kf(e, -1)) - s), Math.abs(k(s, ...Kf(e, 1)) - s)]; l = [0, 2 * t.indexOf(Math.min(...t)) - 1] } else { const t = [Math.abs(k(s, ...Kf(e, -1)) - s), Math.abs(k(s, ...Kf(e, 0)) - s), Math.abs(k(s, ...Kf(e, 1)) - s)]; l = [t.indexOf(Math.min(...t)) - 1] } } else l = [0]; for (const r of l) { const o = e.containsTile(c, i, t, r); o && n.push(o) } } return n } getVisibleCoordinates(e) { const t = this.getRenderableIds(e).map((e => this._tiles[e].tileID)); for (const r of t) r.projMatrix = this.transform.calculateProjMatrix(r.toUnwrapped()); return t } hasTransition() { if (this._source.hasTransition()) return !0; if (Jf(this._source.type)) for (const e in this._tiles) { const t = this._tiles[e]; if (void 0 !== t.fadeEndTime && t.fadeEndTime >= We.now()) return !0 } return !1 } setFeatureState(e, t, r) { this._state.updateState(e = e || "_geojsonTileLayer", t, r) } removeFeatureState(e, t, r) { this._state.removeFeatureState(e = e || "_geojsonTileLayer", t, r) } getFeatureState(e, t) { return this._state.getState(e = e || "_geojsonTileLayer", t) } setDependencies(e, t, r) { const n = this._tiles[e]; n && n.setDependencies(t, r) } reloadTilesForDependencies(e, t) { for (const r in this._tiles) this._tiles[r].hasDependency(e, t) && this._reloadTile(+r, "reloading"); this._cache.filter((r => !r.hasDependency(e, t))) } _preloadTiles(e, t) { const r = new Map, n = Array.isArray(e) ? e : [e], i = this.map.painter.terrain, o = this.usedForTerrain && i ? i.getScaledDemTileSize() : this._source.tileSize; for (const s of n) { const e = s.coveringTiles({ tileSize: o, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }); for (const t of e) r.set(t.key, t); this.usedForTerrain && s.updateElevation(!1) } S(Array.from(r.values()), ((e, t) => { const r = new If(e, this._source.tileSize * e.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster); this._loadTile(r, (e => { "raster-dem" === this._source.type && r.dem && this._backfillDEM(r), t(e, r) })) }), t) } } function $f(e, t) { const r = Math.abs(2 * e.wrap) - +(e.wrap < 0), n = Math.abs(2 * t.wrap) - +(t.wrap < 0); return e.overscaledZ - t.overscaledZ || n - r || t.canonical.y - e.canonical.y || t.canonical.x - e.canonical.x } function Jf(e) { return "raster" === e || "image" === e || "video" === e || "custom" === e } function Kf(e, t) { const r = 1 << e.z; return [e.x / r + t, (e.x + 1) / r + t] } Qf.maxOverzooming = 10, Qf.maxUnderzooming = 3; class Yf { constructor(e, t, r) { this._demTile = e, this._dem = this._demTile.dem, this._scale = t, this._offset = r } static create(e, t, r) { const n = r || e.findDEMTileFor(t); if (!n || !n.dem) return; const i = n.dem, o = n.tileID, s = 1 << t.canonical.z - o.canonical.z; return new Yf(n, n.tileSize / ia / s, [(t.canonical.x / s - o.canonical.x) * i.dim, (t.canonical.y / s - o.canonical.y) * i.dim]) } tileCoordToPixel(e, t) { const r = t * this._scale + this._offset[1], n = Math.floor(e * this._scale + this._offset[0]), i = Math.floor(r); return new f(n, i) } getElevationAt(e, t, r, n) { const i = e * this._scale + this._offset[0], o = t * this._scale + this._offset[1], s = Math.floor(i), a = Math.floor(o), c = this._dem; return n = !!n, r ? Ir(Ir(c.get(s, a, n), c.get(s, a + 1, n), o - a), Ir(c.get(s + 1, a, n), c.get(s + 1, a + 1, n), o - a), i - s) : c.get(s, a, n) } getElevationAtPixel(e, t, r) { return this._dem.get(e, t, !!r) } getMeterToDEM(e) { return (1 << this._demTile.tileID.canonical.z) * Vc(1, e) * this._dem.stride } } class em { constructor(e, t) { this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new qi(ia, 16, 0), this.featureIndexArray = new vs, this.promoteId = t } insert(e, t, r, n, i, o = 0) { const s = this.featureIndexArray.length; this.featureIndexArray.emplaceBack(r, n, i, o); const a = this.grid; for (let c = 0; c < t.length; c++) { const e = t[c], r = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; for (let t = 0; t < e.length; t++) { const n = e[t]; r[0] = Math.min(r[0], n.x), r[1] = Math.min(r[1], n.y), r[2] = Math.max(r[2], n.x), r[3] = Math.max(r[3], n.y) } r[0] < ia && r[1] < ia && r[2] >= 0 && r[3] >= 0 && a.insert(s, r[0], r[1], r[2], r[3]) } } loadVTLayers() { if (!this.vtLayers) { this.vtLayers = new Nu(new Xh(this.rawTileData)).layers, this.sourceLayerCoder = new gf(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {}; for (const e in this.vtLayers) this.vtFeatures[e] = [] } return this.vtLayers } query(e, t, r, n) { this.loadVTLayers(); const i = e.params || {}, o = ui(i.filter), s = e.tileResult, a = e.transform, c = s.bufferedTilespaceBounds, l = this.grid.query(c.min.x, c.min.y, c.max.x, c.max.y, ((e, t, r, n) => _l(s.bufferedTilespaceGeometry, e, t, r, n))); l.sort(rm); let u = null; a.elevation && l.length > 0 && (u = Yf.create(a.elevation, this.tileID)); const h = {}; let d; for (let p = 0; p < l.length; p++) { const a = l[p]; if (a === d) continue; d = a; const c = this.featureIndexArray.get(a); let f = null; this.loadMatchingFeature(h, c, o, i.layers, i.availableImages, t, r, n, ((t, r, n, i = 0) => (f || (f = rl(t, this.tileID.canonical, e.tileTransform)), r.queryIntersectsFeature(s, t, n, f, this.z, e.transform, e.pixelPosMatrix, u, i)))) } return h } loadMatchingFeature(e, t, r, n, i, o, s, a, c) { const { featureIndex: l, bucketIndex: u, sourceLayerIndex: h, layoutVertexArrayOffset: d } = t, p = this.bucketLayerIDs[u]; if (n && !function (e, t) { for (let r = 0; r < e.length; r++)if (t.indexOf(e[r]) >= 0) return !0; return !1 }(n, p)) return; const f = this.sourceLayerCoder.decode(h), m = this.vtLayers[f].feature(l); if (r.needGeometry) { const e = nl(m, !0); if (!r.filter(new xo(this.tileID.overscaledZ), e, this.tileID.canonical)) return } else if (!r.filter(new xo(this.tileID.overscaledZ), m)) return; const g = this.getId(m, f); for (let _ = 0; _ < p.length; _++) { const t = p[_]; if (n && n.indexOf(t) < 0) continue; const r = o[t]; if (!r) continue; let u = {}; void 0 !== g && a && (u = a.getState(r.sourceLayer || "_geojsonTileLayer", g)); const h = I({}, s[t]); h.paint = tm(h.paint, r.paint, m, u, i), h.layout = tm(h.layout, r.layout, m, u, i); const f = !c || c(m, r, u, d); if (!f) continue; const y = new yf(m, this.z, this.x, this.y, g); y.layer = h; let v = e[t]; void 0 === v && (v = e[t] = []), v.push({ featureIndex: l, feature: y, intersectionZ: f }) } } lookupSymbolFeatures(e, t, r, n, i, o, s, a) { const c = {}; this.loadVTLayers(); const l = ui(i); for (const u of e) this.loadMatchingFeature(c, { bucketIndex: r, sourceLayerIndex: n, featureIndex: u, layoutVertexArrayOffset: 0 }, l, o, s, a, t); return c } loadFeature(e) { const { featureIndex: t, sourceLayerIndex: r } = e; this.loadVTLayers(); const n = this.sourceLayerCoder.decode(r), i = this.vtFeatures[n]; if (i[t]) return i[t]; const o = this.vtLayers[n].feature(t); return i[t] = o, o } hasLayer(e) { for (const t of this.bucketLayerIDs) for (const r of t) if (e === r) return !0; return !1 } getId(e, t) { let r = e.id; if (this.promoteId) { const n = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[t]; null != n && (r = e.properties[n]), "boolean" == typeof r && (r = Number(r)) } return r } } function tm(e, t, r, n, i) { return O(e, ((e, o) => { const s = t instanceof Po ? t.get(o) : null; return s && s.evaluate ? s.evaluate(r, n, i) : s })) } function rm(e, t) { return t - e } Zi(em, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] }); class nm { constructor(e, t) { this.width = e, this.height = t, this.nextRow = 0, this.image = new Rl({ width: e, height: t }), this.positions = {}, this.uploaded = !1 } getDash(e, t) { const r = this.getKey(e, t); return this.positions[r] } trim() { const e = this.width, t = this.height = B(this.nextRow); this.image.resize({ width: e, height: t }) } getKey(e, t) { return e.join(",") + t } getDashRanges(e, t, r) { const n = []; let i = e.length % 2 == 1 ? -e[e.length - 1] * r : 0, o = e[0] * r, s = !0; n.push({ left: i, right: o, isDash: s, zeroLength: 0 === e[0] }); let a = e[0]; for (let c = 1; c < e.length; c++) { s = !s; const t = e[c]; i = a * r, a += t, o = a * r, n.push({ left: i, right: o, isDash: s, zeroLength: 0 === t }) } return n } addRoundDash(e, t, r) { const n = t / 2; for (let i = -r; i <= r; i++) { const t = this.width * (this.nextRow + r + i); let o = 0, s = e[o]; for (let a = 0; a < this.width; a++) { a / s.right > 1 && (s = e[++o]); const c = Math.abs(a - s.left), l = Math.abs(a - s.right), u = Math.min(c, l); let h; const d = i / r * (n + 1); if (s.isDash) { const e = n - Math.abs(d); h = Math.sqrt(u * u + e * e) } else h = n - Math.sqrt(u * u + d * d); this.image.data[t + a] = Math.max(0, Math.min(255, h + 128)) } } } addRegularDash(e, t) { for (let a = e.length - 1; a >= 0; --a) { const t = e[a], r = e[a + 1]; t.zeroLength ? e.splice(a, 1) : r && r.isDash === t.isDash && (r.left = t.left, e.splice(a, 1)) } const r = e[0], n = e[e.length - 1]; r.isDash === n.isDash && (r.left = n.left - this.width, n.right = r.right + this.width); const i = this.width * this.nextRow; let o = 0, s = e[o]; for (let a = 0; a < this.width; a++) { a / s.right > 1 && (s = e[++o]); const r = Math.abs(a - s.left), n = Math.abs(a - s.right), c = Math.min(r, n); this.image.data[i + a] = Math.max(0, Math.min(255, (s.isDash ? c : -c) + t + 128)) } } addDash(e, t) { const r = this.getKey(e, t); if (this.positions[r]) return this.positions[r]; const n = "round" === t, i = n ? 7 : 0, o = 2 * i + 1; if (this.nextRow + o > this.height) return G("LineAtlas out of space"), null; 0 === e.length && e.push(1); let s = 0; for (let l = 0; l < e.length; l++)e[l] < 0 && (G("Negative value is found in line dasharray, replacing values with 0"), e[l] = 0), s += e[l]; if (0 !== s) { const r = this.width / s, o = this.getDashRanges(e, this.width, r); n ? this.addRoundDash(o, r, i) : this.addRegularDash(o, "square" === t ? .5 * r : 0) } const a = this.nextRow + i; this.nextRow += o; const c = { tl: [a, i], br: [s, 0] }; return this.positions[r] = c, c } } Zi(nm, "LineAtlas"); const im = 1 * Qd; class om { constructor(e) { const t = {}, r = []; for (const s in e) { const n = e[s], i = t[s] = {}; for (const e in n.glyphs) { const t = n.glyphs[+e]; if (!t || 0 === t.bitmap.width || 0 === t.bitmap.height) continue; const o = t.metrics.localGlyph ? im : 1, s = { x: 0, y: 0, w: t.bitmap.width + 2 * o, h: t.bitmap.height + 2 * o }; r.push(s), i[e] = s } } const { w: n, h: i } = _d(r), o = new Rl({ width: n || 1, height: i || 1 }); for (const s in e) { const r = e[s]; for (const e in r.glyphs) { const n = r.glyphs[+e]; if (!n || 0 === n.bitmap.width || 0 === n.bitmap.height) continue; const i = t[s][e], a = n.metrics.localGlyph ? im : 1; Rl.copy(n.bitmap, o, { x: 0, y: 0 }, { x: i.x + a, y: i.y + a }, n.bitmap) } } this.image = o, this.positions = t } } Zi(om, "GlyphAtlas"); class sm { constructor(e) { this.tileID = new uh(e.tileID.overscaledZ, e.tileID.wrap, e.tileID.canonical.z, e.tileID.canonical.x, e.tileID.canonical.y), this.tileZoom = e.tileZoom, this.uid = e.uid, this.zoom = e.zoom, this.canonical = e.tileID.canonical, this.pixelRatio = e.pixelRatio, this.tileSize = e.tileSize, this.source = e.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = e.showCollisionBoxes, this.collectResourceTiming = !!e.collectResourceTiming, this.returnDependencies = !!e.returnDependencies, this.promoteId = e.promoteId, this.enableTerrain = !!e.enableTerrain, this.isSymbolTile = e.isSymbolTile, this.tileTransform = Cp(e.tileID.canonical, e.projection), this.projection = e.projection } parse(e, t, r, n, i) { this.status = "parsing", this.data = e, this.collisionBoxArray = new hs; const o = new gf(Object.keys(e.layers).sort()), s = new em(this.tileID, this.promoteId); s.bucketLayerIDs = []; const a = {}, c = new nm(256, 256), l = { featureIndex: s, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: c, availableImages: r }, u = t.familiesBySource[this.source]; for (const x in u) { const t = e.layers[x]; if (!t) continue; let n = !1, i = !1; for (const e of u[x]) "symbol" === e[0].type ? n = !0 : i = !0; if (!0 === this.isSymbolTile && !n) continue; if (!1 === this.isSymbolTile && !i) continue; 1 === t.version && G(`Vector tile source "${this.source}" layer "${x}" does not use vector tile spec v2 and therefore may have some rendering errors.`); const c = o.encode(x), h = []; for (let e = 0; e < t.length; e++) { const r = t.feature(e), n = s.getId(r, x); h.push({ feature: r, id: n, index: e, sourceLayerIndex: c }) } for (const e of u[x]) { const t = e[0]; void 0 !== this.isSymbolTile && "symbol" === t.type !== this.isSymbolTile || t.minzoom && this.zoom < Math.floor(t.minzoom) || t.maxzoom && this.zoom >= t.maxzoom || "none" !== t.visibility && (am(e, this.zoom, r), (a[t.id] = t.createBucket({ index: s.bucketLayerIDs.length, layers: e, zoom: this.zoom, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: c, sourceID: this.source, enableTerrain: this.enableTerrain, projection: this.projection.spec, availableImages: r })).populate(h, l, this.tileID.canonical, this.tileTransform), s.bucketLayerIDs.push(e.map((e => e.id)))) } } let h, d, p, f; c.trim(); const m = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, g = O(l.glyphDependencies, (e => Object.keys(e).map(Number))); Object.keys(g).length ? n.send("getGlyphs", { uid: this.uid, stacks: g }, ((e, t) => { h || (h = e, d = t, v.call(this)) }), void 0, !1, m) : d = {}; const _ = Object.keys(l.iconDependencies); _.length ? n.send("getImages", { icons: _, source: this.source, tileID: this.tileID, type: "icons" }, ((e, t) => { h || (h = e, p = t, v.call(this)) }), void 0, !1, m) : p = {}; const y = Object.keys(l.patternDependencies); function v() { if (h) return i(h); if (d && p && f) { const e = new om(d), t = new xd(p, f); for (const n in a) { const i = a[n]; i instanceof tf ? (am(i.layers, this.zoom, r), fp(i, d, e.positions, p, t.iconPositions, this.showCollisionBoxes, r, this.tileID.canonical, this.tileZoom, this.projection)) : i.hasPattern && (i instanceof wh || i instanceof wu || i instanceof $u) && (am(i.layers, this.zoom, r), i.addFeatures(l, this.tileID.canonical, t.patternPositions, r, this.tileTransform)) } this.status = "done", i(null, { buckets: P(a).filter((e => !e.isEmpty())), featureIndex: s, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: e.image, lineAtlas: c, imageAtlas: t, glyphMap: this.returnDependencies ? d : null, iconMap: this.returnDependencies ? p : null, glyphPositions: this.returnDependencies ? e.positions : null }) } } y.length ? n.send("getImages", { icons: y, source: this.source, tileID: this.tileID, type: "patterns" }, ((e, t) => { h || (h = e, f = t, v.call(this)) }), void 0, !1, m) : f = {}, v.call(this) } } function am(e, t, r) { const n = new xo(t); for (const i of e) i.recalculate(n, r) } class cm { constructor(e) { this.entries = {}, this.scheduler = e } request(e, t, r, n) { const i = this.entries[e] = this.entries[e] || { callbacks: [] }; if (i.result) { const [e, r] = i.result; return this.scheduler ? this.scheduler.add((() => { n(e, r) }), t) : n(e, r), () => { } } return i.callbacks.push(n), i.cancel || (i.cancel = r(((r, n) => { i.result = [r, n]; for (const e of i.callbacks) this.scheduler ? this.scheduler.add((() => { e(r, n) }), t) : e(r, n); setTimeout((() => delete this.entries[e]), 3e3) }))), () => { i.result || (i.callbacks = i.callbacks.filter((e => e !== n)), i.callbacks.length || (i.cancel(), delete this.entries[e])) } } } function lm(e, t, r) { const n = JSON.stringify(e.request); return e.data && (this.deduped.entries[n] = { result: [null, e.data] }), this.deduped.request(n, { type: "parseTile", isSymbolTile: e.isSymbolTile, zoom: e.tileZoom }, (t => { const n = ue(e.request, ((e, n, i, o) => { e ? t(e) : n && t(null, { vectorTile: r ? void 0 : new Nu(new Xh(n)), rawData: n, cacheControl: i, expires: o }) })); return () => { n.cancel(), t() } }), t) } e.ARRAY_TYPE = aa, e.AUTH_ERR_MSG = ge, e.Aabb = tc, e.Actor = class { constructor(e, r, n) { this.target = e, this.parent = r, this.mapId = n, this.callbacks = {}, this.cancelCallbacks = {}, D(["receive"], this), this.target.addEventListener("message", this.receive, !1), this.globalScope = j() ? e : t, this.scheduler = new mf } send(e, t, r, n, i = !1, o) { const s = Math.round(1e18 * Math.random()).toString(36).substring(0, 10); r && (r.metadata = o, this.callbacks[s] = r); const a = Z(this.globalScope) ? void 0 : []; return this.target.postMessage({ id: s, type: e, hasCallback: !!r, targetMapId: n, mustQueue: i, sourceMapId: this.mapId, data: $i(t, a) }, a), { cancel: () => { r && delete this.callbacks[s], this.target.postMessage({ id: s, type: "<cancel>", targetMapId: n, sourceMapId: this.mapId }) } } } receive(e) { const t = e.data, r = t.id; if (r && (!t.targetMapId || this.mapId === t.targetMapId)) if ("<cancel>" === t.type) { const e = this.cancelCallbacks[r]; delete this.cancelCallbacks[r], e && e.cancel() } else if (t.mustQueue || j()) { const e = this.callbacks[r]; this.cancelCallbacks[r] = this.scheduler.add((() => this.processTask(r, t)), e && e.metadata || { type: "message" }) } else this.processTask(r, t) } processTask(e, t) { if ("<response>" === t.type) { const r = this.callbacks[e]; delete this.callbacks[e], r && (t.error ? r(Ji(t.error)) : r(null, Ji(t.data))) } else { const r = Z(this.globalScope) ? void 0 : [], n = t.hasCallback ? (t, n) => { delete this.cancelCallbacks[e], this.target.postMessage({ id: e, type: "<response>", sourceMapId: this.mapId, error: t ? $i(t) : null, data: $i(n, r) }, r) } : e => { }, i = Ji(t.data); if (this.parent[t.type]) this.parent[t.type](t.sourceMapId, i, n); else if (this.parent.getWorkerSource) { const e = t.type.split("."); this.parent.getWorkerSource(t.sourceMapId, e[0], i.source)[e[1]](i, n) } else n(new Error(`Could not find function ${t.type}`)) } } remove() { this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1) } }, e.CanonicalTileID = ch, e.Color = It, e.ColorMode = Xf, e.CullFaceMode = Hf, e.DEMData = Nf, e.DataConstantProperty = Io, e.DedupedRequest = cm, e.DepthMode = Vf, e.EXTENT = ia, e.Elevation = class { isDataAvailableAtPoint(e) { const t = this._source(); if (this.isUsingMockSource() || !t || e.y < 0 || e.y > 1) return !1; const r = t.getSource().maxzoom, n = 1 << r, i = Math.floor(e.x), o = Math.floor((e.x - i) * n), s = Math.floor(e.y * n), a = this.findDEMTileFor(new uh(r, i, r, o, s)); return !(!a || !a.dem) } getAtPointOrZero(e, t = 0) { return this.getAtPoint(e, t) || 0 } getAtPoint(e, t, r = !0) { if (this.isUsingMockSource()) return null; null == t && (t = null); const n = this._source(); if (!n) return t; if (e.y < 0 || e.y > 1) return t; const i = n.getSource().maxzoom, o = 1 << i, s = Math.floor(e.x), a = e.x - s, c = new uh(i, s, i, Math.floor(a * o), Math.floor(e.y * o)), l = this.findDEMTileFor(c); if (!l || !l.dem) return t; const u = l.dem, h = 1 << l.tileID.canonical.z, d = (a * h - l.tileID.canonical.x) * u.dim, p = (e.y * h - l.tileID.canonical.y) * u.dim, f = Math.floor(d), m = Math.floor(p); return (r ? this.exaggeration() : 1) * Ir(Ir(u.get(f, m), u.get(f, m + 1), p - m), Ir(u.get(f + 1, m), u.get(f + 1, m + 1), p - m), d - f) } getAtTileOffset(e, t, r) { const n = 1 << e.canonical.z; return this.getAtPointOrZero(new Hc(e.wrap + (e.canonical.x + t / ia) / n, (e.canonical.y + r / ia) / n)) } getAtTileOffsetFunc(e, t, r, n) { return i => { const o = this.getAtTileOffset(e, i.x, i.y), s = n.upVector(e.canonical, i.x, i.y); return Ia(s, s, o * n.upVectorScale(e.canonical, t, r).metersToTile), s } } getForTilePoints(e, t, r, n) { if (this.isUsingMockSource()) return !1; const i = Yf.create(this, e, n); return !!i && (t.forEach((e => { e[2] = this.exaggeration() * i.getElevationAt(e[0], e[1], r) })), !0) } getMinMaxForTile(e) { if (this.isUsingMockSource()) return null; const t = this.findDEMTileFor(e); if (!t || !t.dem) return null; const r = t.dem.tree, n = t.tileID, i = 1 << e.canonical.z - n.canonical.z; let o = e.canonical.x / i - n.canonical.x, s = e.canonical.y / i - n.canonical.y, a = 0; for (let c = 0; c < e.canonical.z - n.canonical.z && !r.leaves[a]; c++) { o *= 2, s *= 2; const e = 2 * Math.floor(s) + Math.floor(o); a = r.childOffsets[a] + e, o %= 1, s %= 1 } return { min: this.exaggeration() * r.minimums[a], max: this.exaggeration() * r.maximums[a] } } getMinElevationBelowMSL() { throw new Error("Pure virtual method called.") } raycast(e, t, r) { throw new Error("Pure virtual method called.") } pointCoordinate(e) { throw new Error("Pure virtual method called.") } _source() { throw new Error("Pure virtual method called.") } isUsingMockSource() { throw new Error("Pure virtual method called.") } exaggeration() { throw new Error("Pure virtual method called.") } findDEMTileFor(e) { throw new Error("Pure virtual method called.") } get visibleDemTiles() { throw new Error("Getter must be implemented in subclass.") } }, e.ErrorEvent = $e, e.EvaluationParameters = xo, e.Event = Qe, e.Evented = Je, e.FillExtrusionBucket = $u, e.Frustum = ec, e.FrustumCorners = Ya, e.GLOBE_RADIUS = ic, e.GLOBE_SCALE_MATCH_LATITUDE = 45, e.GLOBE_ZOOM_THRESHOLD_MAX = nc, e.GLOBE_ZOOM_THRESHOLD_MIN = rc, e.GlobeSharedBuffers = class { constructor(e) { this._createGrid(e), this._createPoles(e) } destroy() { this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy(); for (const e of this._poleSegments) e.destroy(); for (const e of this._gridSegments) e.withSkirts.destroy(), e.withoutSkirts.destroy(); if (this._wireframeIndexBuffer) { this._wireframeIndexBuffer.destroy(); for (const e of this._wireframeSegments) e.destroy() } } _fillGridMeshWithLods(e, t) { const r = new Uo, n = new ts, i = [], o = e + 1 + 2, s = t[0] + 1, a = t[0] + 1 + (1 + t.length), c = (e, t, r) => { let n = e === o - 1 ? e - 2 : 0 === e ? e : e - 1; return n += r ? 24575 : 0, [n, t] }; for (let l = 0; l < o; ++l)r.emplaceBack(...c(l, 0, !0)); for (let l = 0; l < s; ++l)for (let e = 0; e < o; ++e)r.emplaceBack(...c(e, l, (0 === e || e === o - 1) && !0)); for (let l = 0; l < t.length; ++l) { const e = t[l]; for (let t = 0; t < o; ++t)r.emplaceBack(...c(t, e, !0)) } for (let l = 0; l < t.length; ++l) { const e = n.length, s = t[l] + 1 + 2, c = new ts; for (let r = 0; r < s - 1; r++) { const e = r === s - 2, i = e ? o * (a - t.length + l - r) : o; for (let t = 0; t < o - 1; t++) { const s = r * o + t; 0 === r || e || 0 === t || t === o - 2 ? (c.emplaceBack(s + 1, s, s + i), c.emplaceBack(s + i, s + i + 1, s + 1)) : (n.emplaceBack(s + 1, s, s + i), n.emplaceBack(s + i, s + i + 1, s + 1)) } } const u = na.simpleSegment(0, e, r.length, n.length - e); for (let t = 0; t < c.uint16.length; t += 3)n.emplaceBack(c.uint16[t], c.uint16[t + 1], c.uint16[t + 2]); const h = na.simpleSegment(0, e, r.length, n.length - e); i.push({ withoutSkirts: u, withSkirts: h }) } return { vertices: r, indices: n, segments: i } } _createGrid(e) { const t = this._fillGridMeshWithLods(sc, ac); this._gridSegments = t.segments, this._gridBuffer = e.createVertexBuffer(t.vertices, Ja.members), this._gridIndexBuffer = e.createIndexBuffer(t.indices, !0) } _createPoles(e) { const t = new ts; for (let i = 0; i <= sc; i++)t.emplaceBack(0, i + 1, i + 2); this._poleIndexBuffer = e.createIndexBuffer(t, !0); const r = new os, n = new os; this._poleSegments = []; for (let i = 0, o = 0; i < rc; i++) { const e = 360 / (1 << i); r.emplaceBack(0, -ic, 0, .5, 0), n.emplaceBack(0, -ic, 0, .5, 1); for (let t = 0; t <= sc; t++) { const i = t / sc, o = Ir(0, e, i), [s, a, c] = wc(Rc, Dc, o, ic); r.emplaceBack(s, a, c, i, 0), n.emplaceBack(s, a, c, i, 1) } this._poleSegments.push(na.simpleSegment(o, 0, 66, 64)), o += 66 } this._poleNorthVertexBuffer = e.createVertexBuffer(r, Qa, !1), this._poleSouthVertexBuffer = e.createVertexBuffer(n, Qa, !1) } getGridBuffers(e, t) { return [this._gridBuffer, this._gridIndexBuffer, t ? this._gridSegments[e].withSkirts : this._gridSegments[e].withoutSkirts] } getPoleBuffers(e) { return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[e]] } getWirefameBuffers(e, t) { if (!this._wireframeSegments) { const t = new as, r = sc, n = r + 1 + 2, i = 1; this._wireframeSegments = []; for (let e = 0, o = 0; e < ac.length; e++) { const s = ac[e]; for (let e = i; e < s + i; e++)for (let o = i; o < r + i; o++) { const r = e * n + o; t.emplaceBack(r, r + 1), t.emplaceBack(r, r + n), t.emplaceBack(r, r + n + 1) } const a = s * r * 3; this._wireframeSegments.push(na.simpleSegment(0, o, (s + 1) * n, a)), o += a } this._wireframeIndexBuffer = e.createIndexBuffer(t) } return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments[t]] } }, e.GlyphManager = Jd, e.ImagePosition = vd, e.LivePerformanceUtils = ze, e.LngLat = zc, e.LngLatBounds = oa, e.LocalGlyphMode = $d, e.MAX_MERCATOR_LATITUDE = Wc, e.MercatorCoordinate = Hc, e.ONE_EM = Rh, e.OverscaledTileID = uh, e.PerformanceMarkers = Oe, e.Properties = Mo, e.RGBAImage = Dl, e.Ray = Ka, e.RequestManager = class { constructor(e, t, r) { this._transformRequestFn = e, this._customAccessToken = t, this._silenceAuthErrors = !!r, this._createSkuToken() } _createSkuToken() { const e = function () { let e = ""; for (let t = 0; t < 10; t++)e += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())]; return { token: ["1", h, e].join(""), tokenExpiresAt: Date.now() + 432e5 } }(); this._skuToken = e.token, this._skuTokenExpiresAt = e.tokenExpiresAt } _isSkuTokenExpired() { return Date.now() > this._skuTokenExpiresAt } transformRequest(e, t) { return this._transformRequestFn && this._transformRequestFn(e, t) || { url: e } } normalizeStyleURL(e, t) { if (!_e(e)) return e; const r = Te(e); return r.path = `/styles/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || t) } normalizeGlyphsURL(e, t) { if (!_e(e)) return e; const r = Te(e); return r.path = `/fonts/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || t) } normalizeSourceURL(e, t, r, n) { if (!_e(e)) return e; const i = Te(e); return i.path = `/v4/${i.authority}.json`, i.params.push("secure"), r && i.params.push(`language=${r}`), n && i.params.push(`worldview=${n}`), this._makeAPIURL(i, this._customAccessToken || t) } normalizeSpriteURL(e, t, r, n) { const i = Te(e); return _e(e) ? (i.path = `/styles/v1${i.path}/sprite${t}${r}`, this._makeAPIURL(i, this._customAccessToken || n)) : (i.path += `${t}${r}`, ke(i)) } normalizeTileURL(e, t, r) { if (this._isSkuTokenExpired() && this._createSkuToken(), e && !_e(e)) return e; const n = Te(e); n.path = n.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${t || r && "raster" !== n.authority && 512 === r ? "@2x" : ""}${o.supported ? ".webp" : "$1"}`), "raster" === n.authority ? n.path = `/${i.RASTER_URL_PREFIX}${n.path}` : (n.path = n.path.replace(/^.+\/v4\//, "/"), n.path = `/${i.TILE_URL_VERSION}${n.path}`); const s = this._customAccessToken || function (e) { for (const t of e) { const e = t.match(/^access_token=(.*)$/); if (e) return e[1] } return null }(n.params) || i.ACCESS_TOKEN; return i.REQUIRE_ACCESS_TOKEN && s && this._skuToken && n.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n, s) } canonicalizeTileURL(e, t) { const r = Te(e); if (!r.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r.path.match(/\.[\w]+$/)) return e; let n = "mapbox://"; r.path.match(/^\/raster\/v1\//) ? n += `raster/${r.path.replace(`/${i.RASTER_URL_PREFIX}/`, "")}` : n += `tiles/${r.path.replace(`/${i.TILE_URL_VERSION}/`, "")}`; let o = r.params; return t && (o = o.filter((e => !e.match(/^access_token=/)))), o.length && (n += `?${o.join("&")}`), n } canonicalizeTileset(e, t) { const r = !!t && _e(t), n = []; for (const i of e.tiles || []) ye(i) ? n.push(this.canonicalizeTileURL(i, r)) : n.push(i); return n } _makeAPIURL(e, t) { const r = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", n = Te(i.API_URL); if (e.protocol = n.protocol, e.authority = n.authority, "http" === e.protocol) { const t = e.params.indexOf("secure"); t >= 0 && e.params.splice(t, 1) } if ("/" !== n.path && (e.path = `${n.path}${e.path}`), !i.REQUIRE_ACCESS_TOKEN) return ke(e); if (t = t || i.ACCESS_TOKEN, !this._silenceAuthErrors) { if (!t) throw new Error(`An API access token is required to use Mapbox GL. ${r}`); if ("s" === t[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r}`) } return e.params = e.params.filter((e => -1 === e.indexOf("access_token"))), e.params.push(`access_token=${t || ""}`), ke(e) } }, e.ResourceType = se, e.SegmentVector = na, e.SourceCache = Qf, e.StencilMode = jf, e.StructArrayLayout1ui2 = cs, e.StructArrayLayout2f1f2i16 = Ko, e.StructArrayLayout2i4 = Uo, e.StructArrayLayout2ui4 = as, e.StructArrayLayout3f12 = es, e.StructArrayLayout3ui6 = ts, e.StructArrayLayout4i8 = Go, e.StructArrayLayout5f20 = os, e.Texture = pf, e.Tile = If, e.Transitionable = To, e.Uniform1f = Rs, e.Uniform1i = class extends Bs { constructor(e) { super(e), this.current = 0 } set(e, t, r) { this.fetchUniformLocation(e, t) && this.current !== r && (this.current = r, this.gl.uniform1i(this.location, r)) } }, e.Uniform2f = class extends Bs { constructor(e) { super(e), this.current = [0, 0] } set(e, t, r) { this.fetchUniformLocation(e, t) && (r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r, this.gl.uniform2f(this.location, r[0], r[1]))) } }, e.Uniform3f = class extends Bs { constructor(e) { super(e), this.current = [0, 0, 0] } set(e, t, r) { this.fetchUniformLocation(e, t) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r, this.gl.uniform3f(this.location, r[0], r[1], r[2]))) } }, e.Uniform4f = Ds, e.UniformColor = Fs, e.UniformMatrix2f = class extends Bs { constructor(e) { super(e), this.current = Us } set(e, t, r) { if (this.fetchUniformLocation(e, t)) for (let n = 0; n < 4; n++)if (r[n] !== this.current[n]) { this.current = r, this.gl.uniformMatrix2fv(this.location, !1, r); break } } }, e.UniformMatrix3f = class extends Bs { constructor(e) { super(e), this.current = zs } set(e, t, r) { if (this.fetchUniformLocation(e, t)) for (let n = 0; n < 9; n++)if (r[n] !== this.current[n]) { this.current = r, this.gl.uniformMatrix3fv(this.location, !1, r); break } } }, e.UniformMatrix4f = class extends Bs { constructor(e) { super(e), this.current = Os } set(e, t, r) { if (this.fetchUniformLocation(e, t)) { if (r[12] !== this.current[12] || r[0] !== this.current[0]) return this.current = r, void this.gl.uniformMatrix4fv(this.location, !1, r); for (let e = 1; e < 16; e++)if (r[e] !== this.current[e]) { this.current = r, this.gl.uniformMatrix4fv(this.location, !1, r); break } } } }, e.UnwrappedTileID = lh, e.ValidationError = ti, e.VectorTileFeature = Gu, e.VectorTileWorkerSource = class extends Je { constructor(e, t, r, n, i) { super(), this.actor = e, this.layerIndex = t, this.availableImages = r, this.loadVectorData = i || lm, this.loading = {}, this.loaded = {}, this.deduped = new cm(e.scheduler), this.isSpriteLoaded = n, this.scheduler = e.scheduler } loadTile(e, t) { const r = e.uid, n = e && e.request, i = n && n.collectResourceTiming, o = this.loading[r] = new sm(e); o.abort = this.loadVectorData(e, ((s, a) => { const c = !this.loading[r]; if (delete this.loading[r], c || s || !a) return o.status = "done", c || (this.loaded[r] = o), t(s); const l = a.rawData, u = {}; a.expires && (u.expires = a.expires), a.cacheControl && (u.cacheControl = a.cacheControl), o.vectorTile = a.vectorTile || new Nu(new Xh(l)); const h = () => { o.parse(o.vectorTile, this.layerIndex, this.availableImages, this.actor, ((e, r) => { if (e || !r) return t(e); const o = {}; if (i) { const e = Ge(n); e.length > 0 && (o.resourceTiming = JSON.parse(JSON.stringify(e))) } t(null, I({ rawTileData: l.slice(0) }, r, u, o)) })) }; this.isSpriteLoaded ? h() : this.once("isSpriteLoaded", (() => { this.scheduler ? this.scheduler.add(h, { type: "parseTile", isSymbolTile: e.isSymbolTile, zoom: e.tileZoom }) : h() })), this.loaded = this.loaded || {}, this.loaded[r] = o })) } reloadTile(e, t) { const r = this.loaded, n = e.uid, i = this; if (r && r[n]) { const o = r[n]; o.showCollisionBoxes = e.showCollisionBoxes, o.enableTerrain = !!e.enableTerrain, o.projection = e.projection, o.tileTransform = Cp(e.tileID.canonical, e.projection); const s = (e, r) => { const n = o.reloadCallback; n && (delete o.reloadCallback, o.parse(o.vectorTile, i.layerIndex, this.availableImages, i.actor, n)), t(e, r) }; "parsing" === o.status ? o.reloadCallback = s : "done" === o.status && (o.vectorTile ? o.parse(o.vectorTile, this.layerIndex, this.availableImages, this.actor, s) : s()) } } abortTile(e, t) { const r = e.uid, n = this.loading[r]; n && (n.abort && n.abort(), delete this.loading[r]), t() } removeTile(e, t) { const r = this.loaded, n = e.uid; r && r[n] && delete r[n], t() } }, e.WritingMode = bd, e.ZoomDependentExpression = Jn, e.add = ka, e.addDynamicAttributes = Jp, e.adjoint = function (e, t) { var r = t[0], n = t[1], i = t[2], o = t[3], s = t[4], a = t[5], c = t[6], l = t[7], u = t[8]; return e[0] = s * u - a * l, e[1] = i * l - n * u, e[2] = n * a - i * s, e[3] = a * c - o * u, e[4] = r * u - i * c, e[5] = i * o - r * a, e[6] = o * l - s * c, e[7] = n * c - r * l, e[8] = r * s - n * o, e }, e.asyncAll = S, e.bezier = w, e.bindAll = D, e.boundsAttributes = Sf, e.bufferConvexPolygon = function (e, t) { const r = []; for (let n = 0; n < e.length; n++) { const i = E(n - 1, -1, e.length - 1), o = E(n + 1, -1, e.length - 1), s = e[n], a = e[o], c = e[i].sub(s).unit(), l = a.sub(s).unit(), u = l.angleWithSep(c.x, c.y), h = c.add(l).unit().mult(-1 * t / Math.sin(u / 2)); r.push(s.add(h)) } return r }, e.cacheEntryPossiblyAdded = function (e) { oe++, oe > K && (e.getActor().send("enforceCacheSizeLimit", J), oe = 0) }, e.calculateGlobeLabelMatrix = function (e, t) { const { x: r, y: n } = e.point, i = Ic(r, n, e.worldSize / e._pixelsPerMercatorPixel, 0, 0); return da(i, i, Pc(mc(t))) }, e.calculateGlobeMatrix = function (e) { const { x: t, y: r } = e.point, { lng: n, lat: i } = e._center; return Ic(t, r, e.worldSize, n, i) }, e.calculateGlobeMercatorMatrix = function (e) { const t = e.pixelsPerMeter, r = t / Vc(1, e.center.lat), n = ua(new Float64Array(16)); return pa(n, n, [e.point.x, e.point.y, 0]), fa(n, n, [r, r, t]), Float32Array.from(n) }, e.circumferenceAtLatitude = Uc, e.clamp = k, e.clearTileCache = function (e) { if (!re()) return; const r = t.caches.delete($); e && r.catch(e).then((() => e())) }, e.clipLine = Xd, e.clone = function (e) { var t = new aa(16); return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t }, e.clone$1 = U, e.collisionCircleLayout = Bh, e.config = i, e.conjugate = function (e, t) { return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e }, e.create = function () { var e = new aa(16); return aa != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0), e[0] = 1, e[5] = 1, e[10] = 1, e[15] = 1, e }, e.create$1 = ca, e.createExpression = Qn, e.createLayout = Oo, e.createStyleLayer = function (e) { return "custom" === e.type ? new lf(e) : new df[e.type](e) }, e.cross = Ba, e.degToRad = y, e.distance = function (e, t) { return Math.hypot(t[0] - e[0], t[1] - e[1], t[2] - e[2]) }, e.div = function (e, t, r) { return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e }, e.dot = Ma, e.earthRadius = Fc, e.ease = T, e.easeCubicInOut = b, e.ecefToLatLng = function ([e, t, r]) { const n = Math.hypot(e, t, r), i = Math.atan2(e, r), o = .5 * Math.PI - Math.acos(-t / n); return new zc(v(i), v(o)) }, e.emitValidationErrors = Vi, e.endsWith = F, e.enforceCacheSizeLimit = function (e) { ne(), ee && ee.then((t => { t.keys().then((r => { for (let n = 0; n < r.length - e; n++)t.delete(r[n]) })) })) }, e.evaluateSizeForFeature = Oh, e.evaluateSizeForZoom = zh, e.evaluateVariableOffset = pp, e.evented = go, e.exactEquals = function (e, t) { return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] }, e.exactEquals$1 = function (e, t) { return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] }, e.exported = We, e.exported$1 = o, e.extend = I, e.extend$1 = Ye, e.fillExtrusionHeightLift = nh, e.filterObject = z, e.fromMat4 = function (e, t) { return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[4], e[4] = t[5], e[5] = t[6], e[6] = t[8], e[7] = t[9], e[8] = t[10], e }, e.fromQuat = function (e, t) { var r = t[0], n = t[1], i = t[2], o = t[3], s = r + r, a = n + n, c = i + i, l = r * s, u = n * s, h = n * a, d = i * s, p = i * a, f = i * c, m = o * s, g = o * a, _ = o * c; return e[0] = 1 - h - f, e[1] = u + _, e[2] = d - g, e[3] = 0, e[4] = u - _, e[5] = 1 - l - f, e[6] = p + m, e[7] = 0, e[8] = d + g, e[9] = p - m, e[10] = 1 - l - h, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e }, e.fromRotation = function (e, t) { var r = Math.sin(t), n = Math.cos(t); return e[0] = n, e[1] = r, e[2] = 0, e[3] = -r, e[4] = n, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e }, e.fromScaling = _a, e.furthestTileCorner = function (e) { const t = Math.round((e + 45 + 360) % 360 / 90) % 4; return x[t] }, e.getAABBPointSquareDist = function (e, t, r) { let n = 0; for (let i = 0; i < 2; ++i) { const o = r ? r[i] : 0; e[i] > o && (n += (e[i] - o) * (e[i] - o)), t[i] < o && (n += (o - t[i]) * (o - t[i])) } return n }, e.getAnchorAlignment = Bd, e.getAnchorJustification = mp, e.getBounds = function (e) { let t = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0; for (const o of e) t = Math.min(t, o.x), r = Math.min(r, o.y), n = Math.max(n, o.x), i = Math.max(i, o.y); return { min: new f(t, r), max: new f(n, i) } }, e.getColumn = Q, e.getGridMatrix = function (e, t, r, n) { const i = t.getNorth(), o = t.getSouth(), s = t.getWest(), a = t.getEast(), c = 1 << e.z, l = a - s, u = i - o, h = l / sc, d = -u / ac[r], p = [0, h, 0, d, 0, 0, i, s, 0]; if (e.z > 0) { const e = 180 / n; la(p, p, [e / l + 1, 0, 0, 0, e / u + 1, 0, -.5 * e / h, .5 * e / d, 1]) } return p[2] = c, p[5] = e.x, p[8] = e.y, p }, e.getImage = me, e.getJSON = function (e, t) { return le(I(e, { type: "json" }), t) }, e.getLatitudinalLod = function (e) { const t = Wc - 5; e = k(e, -t, t) / t * 90; const r = Math.pow(Math.abs(Math.sin(y(e))), 3); return Math.round(r * (ac.length - 1)) }, e.getMapSessionAPI = De, e.getPerformanceMeasurement = Ge, e.getProjection = Wp, e.getRTLTextPluginStatus = _o, e.getReferrer = ce, e.getTilePoint = function (e, { x: t, y: r }, n = 0) { return new f(((t - n) * e.scale - e.x) * ia, (r * e.scale - e.y) * ia) }, e.getTileVec3 = function (e, t, r = 0) { return Ta(((t.x - r) * e.scale - e.x) * ia, (t.y * e.scale - e.y) * ia, Xc(t.z, t.y)) }, e.getVideo = function (e, r) { const n = t.document.createElement("video"); n.muted = !0, n.onloadstart = function () { r(null, n) }; for (let i = 0; i < e.length; i++) { const r = t.document.createElement("source"); he(e[i]) || (n.crossOrigin = "Anonymous"), r.src = e[i], n.appendChild(r) } return { cancel: () => { } } }, e.globeCenterToScreenPoint = function (e) { const t = [0, 0, 0], r = ua(new Float64Array(16)); return da(r, e.pixelMatrix, e.globeMatrix), Ra(t, t, r), new f(t[0], t[1]) }, e.globeDenormalizeECEF = Pc, e.globeECEFOrigin = function (e, t) { const r = [0, 0, 0]; return Ra(r, r, Sc(mc(t.canonical))), Ra(r, r, e), r }, e.globeMetersToEcef = hc, e.globeNormalizeECEF = Sc, e.globePixelsToTileUnits = function (e, t) { return ia / (512 * Math.pow(2, e)) * Cc(mc(t)) }, e.globePoleMatrixForTile = function (e, t, r) { const n = ua(new Float64Array(16)), i = (t / (1 << e) - .5) * Math.PI * 2; return ga(n, r.globeMatrix, i), Float32Array.from(n) }, e.globeTileBounds = mc, e.globeTiltAtLngLat = Lc, e.globeToMercatorTransition = Ac, e.globeUseCustomAntiAliasing = function (e, t, r) { const n = Ac(r.zoom), i = e.style.map._antialias, o = !!t.extStandardDerivatives, s = t.extStandardDerivativesForceOff || e.terrain && e.terrain.exaggeration() > 0; return 0 === n && !i && !s && o }, e.identity = ua, e.identity$1 = ja, e.ieee754 = jh, e.invert = ha, e.isFullscreen = function () { return !!t.document.fullscreenElement || !!t.document.webkitFullscreenElement }, e.isLngLatBehindGlobe = Mc, e.isMapAuthenticated = function (e) { return Fe.has(e) }, e.isMapboxURL = _e, e.isSafariWithAntialiasingBug = function (e) { const t = e.navigator ? e.navigator.userAgent : null; return !!Z(e) && t && (t.match("Version/15.4") || t.match("Version/15.5") || t.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/)) }, e.latFromMercatorY = jc, e.latLngToECEF = Tc, e.len = Ua, e.length = wa, e.length$1 = function (e) { return Math.hypot(e[0], e[1], e[2], e[3]) }, e.lngFromMercatorX = qc, e.loadVectorTile = lm, e.makeRequest = le, e.mapValue = function (e, t, r, n, i) { return k((e - t) / (r - t) * (i - n) + n, n, i) }, e.mercatorScale = Zc, e.mercatorXfromLng = Nc, e.mercatorYfromLat = Gc, e.mercatorZfromAltitude = Vc, e.mul = va, e.mul$1 = za, e.multiply = da, e.multiply$1 = la, e.multiply$2 = Ea, e.nextPowerOfTwo = B, e.normalize = La, e.normalize$1 = Za, e.normalize$2 = Ga, e.number = Ir, e.ortho = function (e, t, r, n, i, o, s) { var a = 1 / (t - r), c = 1 / (n - i), l = 1 / (o - s); return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * l, e[11] = 0, e[12] = (t + r) * a, e[13] = (i + n) * c, e[14] = (s + o) * l, e[15] = 1, e }, e.perspective = function (e, t, r, n, i) { var o, s = 1 / Math.tan(t / 2); return e[0] = s / r, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = s, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, null != i && i !== 1 / 0 ? (e[10] = (i + n) * (o = 1 / (n - i)), e[14] = 2 * i * n * o) : (e[10] = -1, e[14] = -2 * n), e }, e.pick = function (e, t) { const r = {}; for (let n = 0; n < t.length; n++) { const i = t[n]; i in e && (r[i] = e[i]) } return r }, e.plugin = vo, e.pointGeometry = f, e.polesInViewport = function (e) { const t = ua(new Float64Array(16)); da(t, e.pixelMatrix, e.globeMatrix); const r = [0, cc, 0], n = [0, lc, 0]; return Ra(r, r, t), Ra(n, n, t), [r[0] > 0 && r[0] <= e.width && r[1] > 0 && r[1] <= e.height && !Mc(e, new zc(e.center.lat, 90)), n[0] > 0 && n[0] <= e.width && n[1] > 0 && n[1] <= e.height && !Mc(e, new zc(e.center.lat, -90))] }, e.polygonContainsPoint = gl, e.polygonIntersectsBox = _l, e.polygonIntersectsPolygon = al, e.polygonizeBounds = function (e, t, r = 0, n = !0) { const i = new f(r, r), o = e.sub(i), s = t.add(i), a = [o, new f(s.x, o.y), s, new f(o.x, s.y)]; return n && a.push(o.clone()), a }, e.posAttributes = Ja, e.postMapLoadEvent = Le, e.postPerformanceEvent = Be, e.postTurnstileEvent = Ie, e.potpack = _d, e.prevPowerOfTwo = function (e) { return e <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(e) / Math.LN2)) }, e.radToDeg = v, e.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], e.registerForPluginStateChange = function (e) { return e({ pluginStatus: ho, pluginURL: po }), go.on("pluginStateChange", e), e }, e.removeAuthState = function (e) { Fe.delete(e) }, e.renderColorRamp = Ol, e.resample = $c, e.rotateX = ma, e.rotateX$1 = Xa, e.rotateY = ga, e.rotateY$1 = Wa, e.rotateZ = function (e, t, r) { var n = Math.sin(r), i = Math.cos(r), o = t[0], s = t[1], a = t[2], c = t[3], l = t[4], u = t[5], h = t[6], d = t[7]; return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = o * i + l * n, e[1] = s * i + u * n, e[2] = a * i + h * n, e[3] = c * i + d * n, e[4] = l * i - o * n, e[5] = u * i - s * n, e[6] = h * i - a * n, e[7] = d * i - c * n, e }, e.rotateZ$1 = function (e, t, r) { r *= .5; var n = t[0], i = t[1], o = t[2], s = t[3], a = Math.sin(r), c = Math.cos(r); return e[0] = n * c + i * a, e[1] = i * c - n * a, e[2] = o * c + s * a, e[3] = s * c - o * a, e }, e.scale = fa, e.scale$1 = Na, e.scale$2 = Ia, e.scaleAndAdd = Aa, e.set = function (e, t, r, n) { return e[0] = t, e[1] = r, e[2] = n, e }, e.setCacheLimits = function (e, t) { J = e, K = t }, e.setColumn = function (e, t, r) { e[4 * t + 0] = r[0], e[4 * t + 1] = r[1], e[4 * t + 2] = r[2], e[4 * t + 3] = r[3] }, e.setRTLTextPlugin = function (e, t, r = !1) { if (ho === ao || ho === co || ho === lo) throw new Error("setRTLTextPlugin cannot be called multiple times."); po = We.resolveURL(e), ho = ao, uo = t, mo(), r || yo() }, e.smoothstep = C, e.spec = Ke, e.squaredLength = function (e) { var t = e[0], r = e[1], n = e[2]; return t * t + r * r + n * n }, e.storeAuthState = function (e, t) { t ? Fe.add(e) : Fe.delete(e) }, e.sub = Oa, e.subtract = Ca, e.symbolSize = Uh, e.tileAABB = function (e, t, r, n, i, o, s, a, c) { if ("globe" === c.name) return vc(e, t, new ch(r, n, i)); const l = Cp({ z: r, x: n, y: i }, c); return new tc([(o + l.x / l.scale) * t, t * (l.y / l.scale), s], [(o + l.x2 / l.scale) * t, t * (l.y2 / l.scale), a]) }, e.tileCornersToBounds = xc, e.tileTransform = Cp, e.transformMat3 = function (e, t, r) { var n = t[0], i = t[1], o = t[2]; return e[0] = n * r[0] + i * r[3] + o * r[6], e[1] = n * r[1] + i * r[4] + o * r[7], e[2] = n * r[2] + i * r[5] + o * r[8], e }, e.transformMat4 = Ra, e.transformMat4$1 = Va, e.transformQuat = Da, e.transitionTileAABBinECEF = _c, e.translate = pa, e.transpose = function (e, t) { if (e === t) { var r = t[1], n = t[2], i = t[5]; e[1] = t[3], e[2] = t[6], e[3] = r, e[5] = t[7], e[6] = n, e[7] = i } else e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8]; return e }, e.triggerPluginCompletionEvent = fo, e.uniqueId = L, e.updateGlobeVertexNormal = function (e, t, r, n, i) { const o = 5 * t + 2; e.float32[o + 0] = r, e.float32[o + 1] = n, e.float32[o + 2] = i }, e.validateCustomStyleLayer = function (e) { const t = [], r = e.id; return void 0 === r && t.push({ message: `layers.${r}: missing required property "id"` }), void 0 === e.render && t.push({ message: `layers.${r}: missing required method "render"` }), e.renderingMode && "2d" !== e.renderingMode && "3d" !== e.renderingMode && t.push({ message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"` }), t }, e.validateFilter = e => Gi(wi(e)), e.validateFog = e => Gi(Ri(e)), e.validateLayer = e => Gi(Si(e)), e.validateLight = e => Gi(Mi(e)), e.validateSource = e => Gi(Ai(e)), e.validateStyle = zi, e.validateTerrain = e => Gi(Bi(e)), e.values = P, e.version = r, e.warnOnce = G, e.window = t, e.wrap = E })), n(["./shared"], (function (e) { function t(e) { if ("number" == typeof e || "boolean" == typeof e || "string" == typeof e || null == e) return JSON.stringify(e); if (Array.isArray(e)) { let r = "["; for (const n of e) r += `${t(n)},`; return `${r}]` } let r = "{"; for (const n of Object.keys(e).sort()) r += `${n}:${t(e[n])},`; return `${r}}` } function r(r) { let n = ""; for (const i of e.refProperties) n += `/${t(r[i])}`; return n } class n { constructor(e) { this.keyCache = {}, e && this.replace(e) } replace(e) { this._layerConfigs = {}, this._layers = {}, this.update(e, []) } update(t, n) { for (const r of t) this._layerConfigs[r.id] = r, (this._layers[r.id] = e.createStyleLayer(r)).compileFilter(), this.keyCache[r.id] && delete this.keyCache[r.id]; for (const e of n) delete this.keyCache[e], delete this._layerConfigs[e], delete this._layers[e]; this.familiesBySource = {}; const i = function (e, t) { const n = {}; for (let o = 0; o < e.length; o++) { const i = t && t[e[o].id] || r(e[o]); t && (t[e[o].id] = i); let s = n[i]; s || (s = n[i] = []), s.push(e[o]) } const i = []; for (const r in n) i.push(n[r]); return i }(e.values(this._layerConfigs), this.keyCache); for (const e of i) { const t = e.map((e => this._layers[e.id])), r = t[0]; if ("none" === r.visibility) continue; const n = r.source || ""; let i = this.familiesBySource[n]; i || (i = this.familiesBySource[n] = {}); const o = r.sourceLayer || "_geojsonTileLayer"; let s = i[o]; s || (s = i[o] = []), s.push(t) } } } class i { loadTile(t, r) { const { uid: n, encoding: i, rawImageData: o, padding: s, buildQuadTree: a } = t, c = e.window.ImageBitmap && o instanceof e.window.ImageBitmap ? this.getImageData(o, s) : o; r(null, new e.DEMData(n, c, i, s < 1, a)) } getImageData(e, t) { this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e.width, e.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: !0 })), this.offscreenCanvas.width = e.width, this.offscreenCanvas.height = e.height, this.offscreenCanvasContext.drawImage(e, 0, 0, e.width, e.height); const r = this.offscreenCanvasContext.getImageData(-t, -t, e.width + 2 * t, e.height + 2 * t); return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), r } } var o = function e(t, r) { var n, i = t && t.type; if ("FeatureCollection" === i) for (n = 0; n < t.features.length; n++)e(t.features[n], r); else if ("GeometryCollection" === i) for (n = 0; n < t.geometries.length; n++)e(t.geometries[n], r); else if ("Feature" === i) e(t.geometry, r); else if ("Polygon" === i) s(t.coordinates, r); else if ("MultiPolygon" === i) for (n = 0; n < t.coordinates.length; n++)s(t.coordinates[n], r); return t }; function s(e, t) { if (0 !== e.length) { a(e[0], t); for (var r = 1; r < e.length; r++)a(e[r], !t) } } function a(e, t) { for (var r = 0, n = 0, i = 0, o = e.length, s = o - 1; i < o; s = i++) { var a = (e[i][0] - e[s][0]) * (e[s][1] + e[i][1]), c = r + a; n += Math.abs(r) >= Math.abs(a) ? r - c + a : a - c + r, r = c } r + n >= 0 != !!t && e.reverse() } const c = e.VectorTileFeature.prototype.toGeoJSON; class l { constructor(t) { this._feature = t, this.extent = e.EXTENT, this.type = t.type, this.properties = t.tags, "id" in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10)) } loadGeometry() { if (1 === this._feature.type) { const t = []; for (const r of this._feature.geometry) t.push([new e.pointGeometry(r[0], r[1])]); return t } { const t = []; for (const r of this._feature.geometry) { const n = []; for (const t of r) n.push(new e.pointGeometry(t[0], t[1])); t.push(n) } return t } } toGeoJSON(e, t, r) { return c.call(this, e, t, r) } } class u { constructor(t) { this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t.length, this._features = t } feature(e) { return new l(this._features[e]) } } var h = {}, d = { get exports() { return h }, set exports(e) { h = e } }, p = m, f = e.ieee754; function m(e) { this.buf = ArrayBuffer.isView && ArrayBuffer.isView(e) ? e : new Uint8Array(e || 0), this.pos = 0, this.type = 0, this.length = this.buf.length } m.Varint = 0, m.Fixed64 = 1, m.Bytes = 2, m.Fixed32 = 5; var g = 4294967296, _ = 1 / g, y = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8"); function v(e) { return e.type === m.Bytes ? e.readVarint() + e.pos : e.pos + 1 } function x(e, t, r) { return r ? 4294967296 * t + (e >>> 0) : 4294967296 * (t >>> 0) + (e >>> 0) } function b(e, t, r) { var n = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2)); r.realloc(n); for (var i = r.pos - 1; i >= e; i--)r.buf[i + n] = r.buf[i] } function w(e, t) { for (var r = 0; r < e.length; r++)t.writeVarint(e[r]) } function T(e, t) { for (var r = 0; r < e.length; r++)t.writeSVarint(e[r]) } function k(e, t) { for (var r = 0; r < e.length; r++)t.writeFloat(e[r]) } function C(e, t) { for (var r = 0; r < e.length; r++)t.writeDouble(e[r]) } function E(e, t) { for (var r = 0; r < e.length; r++)t.writeBoolean(e[r]) } function S(e, t) { for (var r = 0; r < e.length; r++)t.writeFixed32(e[r]) } function P(e, t) { for (var r = 0; r < e.length; r++)t.writeSFixed32(e[r]) } function I(e, t) { for (var r = 0; r < e.length; r++)t.writeFixed64(e[r]) } function A(e, t) { for (var r = 0; r < e.length; r++)t.writeSFixed64(e[r]) } function L(e, t) { return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + 16777216 * e[t + 3] } function M(e, t, r) { e[r] = t, e[r + 1] = t >>> 8, e[r + 2] = t >>> 16, e[r + 3] = t >>> 24 } function B(e, t) { return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + (e[t + 3] << 24) } m.prototype = { destroy: function () { this.buf = null }, readFields: function (e, t, r) { for (r = r || this.length; this.pos < r;) { var n = this.readVarint(), i = n >> 3, o = this.pos; this.type = 7 & n, e(i, t, this), this.pos === o && this.skip(n) } return t }, readMessage: function (e, t) { return this.readFields(e, t, this.readVarint() + this.pos) }, readFixed32: function () { var e = L(this.buf, this.pos); return this.pos += 4, e }, readSFixed32: function () { var e = B(this.buf, this.pos); return this.pos += 4, e }, readFixed64: function () { var e = L(this.buf, this.pos) + L(this.buf, this.pos + 4) * g; return this.pos += 8, e }, readSFixed64: function () { var e = L(this.buf, this.pos) + B(this.buf, this.pos + 4) * g; return this.pos += 8, e }, readFloat: function () { var e = f.read(this.buf, this.pos, !0, 23, 4); return this.pos += 4, e }, readDouble: function () { var e = f.read(this.buf, this.pos, !0, 52, 8); return this.pos += 8, e }, readVarint: function (e) { var t, r, n = this.buf; return t = 127 & (r = n[this.pos++]), r < 128 ? t : (t |= (127 & (r = n[this.pos++])) << 7, r < 128 ? t : (t |= (127 & (r = n[this.pos++])) << 14, r < 128 ? t : (t |= (127 & (r = n[this.pos++])) << 21, r < 128 ? t : function (e, t, r) { var n, i, o = r.buf; if (n = (112 & (i = o[r.pos++])) >> 4, i < 128) return x(e, n, t); if (n |= (127 & (i = o[r.pos++])) << 3, i < 128) return x(e, n, t); if (n |= (127 & (i = o[r.pos++])) << 10, i < 128) return x(e, n, t); if (n |= (127 & (i = o[r.pos++])) << 17, i < 128) return x(e, n, t); if (n |= (127 & (i = o[r.pos++])) << 24, i < 128) return x(e, n, t); if (n |= (1 & (i = o[r.pos++])) << 31, i < 128) return x(e, n, t); throw new Error("Expected varint not more than 10 bytes") }(t |= (15 & (r = n[this.pos])) << 28, e, this)))) }, readVarint64: function () { return this.readVarint(!0) }, readSVarint: function () { var e = this.readVarint(); return e % 2 == 1 ? (e + 1) / -2 : e / 2 }, readBoolean: function () { return Boolean(this.readVarint()) }, readString: function () { var e = this.readVarint() + this.pos, t = this.pos; return this.pos = e, e - t >= 12 && y ? function (e, t, r) { return y.decode(e.subarray(t, r)) }(this.buf, t, e) : function (e, t, r) { for (var n = "", i = t; i < r;) { var o, s, a, c = e[i], l = null, u = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1; if (i + u > r) break; 1 === u ? c < 128 && (l = c) : 2 === u ? 128 == (192 & (o = e[i + 1])) && (l = (31 & c) << 6 | 63 & o) <= 127 && (l = null) : 3 === u ? (s = e[i + 2], 128 == (192 & (o = e[i + 1])) && 128 == (192 & s) && ((l = (15 & c) << 12 | (63 & o) << 6 | 63 & s) <= 2047 || l >= 55296 && l <= 57343) && (l = null)) : 4 === u && (s = e[i + 2], a = e[i + 3], 128 == (192 & (o = e[i + 1])) && 128 == (192 & s) && 128 == (192 & a) && ((l = (15 & c) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & a) <= 65535 || l >= 1114112) && (l = null)), null === l ? (l = 65533, u = 1) : l > 65535 && (l -= 65536, n += String.fromCharCode(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), n += String.fromCharCode(l), i += u } return n }(this.buf, t, e) }, readBytes: function () { var e = this.readVarint() + this.pos, t = this.buf.subarray(this.pos, e); return this.pos = e, t }, readPackedVarint: function (e, t) { if (this.type !== m.Bytes) return e.push(this.readVarint(t)); var r = v(this); for (e = e || []; this.pos < r;)e.push(this.readVarint(t)); return e }, readPackedSVarint: function (e) { if (this.type !== m.Bytes) return e.push(this.readSVarint()); var t = v(this); for (e = e || []; this.pos < t;)e.push(this.readSVarint()); return e }, readPackedBoolean: function (e) { if (this.type !== m.Bytes) return e.push(this.readBoolean()); var t = v(this); for (e = e || []; this.pos < t;)e.push(this.readBoolean()); return e }, readPackedFloat: function (e) { if (this.type !== m.Bytes) return e.push(this.readFloat()); var t = v(this); for (e = e || []; this.pos < t;)e.push(this.readFloat()); return e }, readPackedDouble: function (e) { if (this.type !== m.Bytes) return e.push(this.readDouble()); var t = v(this); for (e = e || []; this.pos < t;)e.push(this.readDouble()); return e }, readPackedFixed32: function (e) { if (this.type !== m.Bytes) return e.push(this.readFixed32()); var t = v(this); for (e = e || []; this.pos < t;)e.push(this.readFixed32()); return e }, readPackedSFixed32: function (e) { if (this.type !== m.Bytes) return e.push(this.readSFixed32()); var t = v(this); for (e = e || []; this.pos < t;)e.push(this.readSFixed32()); return e }, readPackedFixed64: function (e) { if (this.type !== m.Bytes) return e.push(this.readFixed64()); var t = v(this); for (e = e || []; this.pos < t;)e.push(this.readFixed64()); return e }, readPackedSFixed64: function (e) { if (this.type !== m.Bytes) return e.push(this.readSFixed64()); var t = v(this); for (e = e || []; this.pos < t;)e.push(this.readSFixed64()); return e }, skip: function (e) { var t = 7 & e; if (t === m.Varint) for (; this.buf[this.pos++] > 127;); else if (t === m.Bytes) this.pos = this.readVarint() + this.pos; else if (t === m.Fixed32) this.pos += 4; else { if (t !== m.Fixed64) throw new Error("Unimplemented type: " + t); this.pos += 8 } }, writeTag: function (e, t) { this.writeVarint(e << 3 | t) }, realloc: function (e) { for (var t = this.length || 16; t < this.pos + e;)t *= 2; if (t !== this.length) { var r = new Uint8Array(t); r.set(this.buf), this.buf = r, this.length = t } }, finish: function () { return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length) }, writeFixed32: function (e) { this.realloc(4), M(this.buf, e, this.pos), this.pos += 4 }, writeSFixed32: function (e) { this.realloc(4), M(this.buf, e, this.pos), this.pos += 4 }, writeFixed64: function (e) { this.realloc(8), M(this.buf, -1 & e, this.pos), M(this.buf, Math.floor(e * _), this.pos + 4), this.pos += 8 }, writeSFixed64: function (e) { this.realloc(8), M(this.buf, -1 & e, this.pos), M(this.buf, Math.floor(e * _), this.pos + 4), this.pos += 8 }, writeVarint: function (e) { (e = +e || 0) > 268435455 || e < 0 ? function (e, t) { var r, n; if (e >= 0 ? (r = e % 4294967296 | 0, n = e / 4294967296 | 0) : (n = ~(-e / 4294967296), 4294967295 ^ (r = ~(-e % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), e >= 0x10000000000000000 || e < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes"); t.realloc(10), function (e, t, r) { r.buf[r.pos++] = 127 & e | 128, e >>>= 7, r.buf[r.pos++] = 127 & e | 128, e >>>= 7, r.buf[r.pos++] = 127 & e | 128, e >>>= 7, r.buf[r.pos++] = 127 & e | 128, r.buf[r.pos] = 127 & (e >>>= 7) }(r, 0, t), function (e, t) { var r = (7 & e) << 4; t.buf[t.pos++] |= r | ((e >>>= 3) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e))))) }(n, t) }(e, this) : (this.realloc(4), this.buf[this.pos++] = 127 & e | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = e >>> 7 & 127)))) }, writeSVarint: function (e) { this.writeVarint(e < 0 ? 2 * -e - 1 : 2 * e) }, writeBoolean: function (e) { this.writeVarint(Boolean(e)) }, writeString: function (e) { e = String(e), this.realloc(4 * e.length), this.pos++; var t = this.pos; this.pos = function (e, t, r) { for (var n, i, o = 0; o < t.length; o++) { if ((n = t.charCodeAt(o)) > 55295 && n < 57344) { if (!i) { n > 56319 || o + 1 === t.length ? (e[r++] = 239, e[r++] = 191, e[r++] = 189) : i = n; continue } if (n < 56320) { e[r++] = 239, e[r++] = 191, e[r++] = 189, i = n; continue } n = i - 55296 << 10 | n - 56320 | 65536, i = null } else i && (e[r++] = 239, e[r++] = 191, e[r++] = 189, i = null); n < 128 ? e[r++] = n : (n < 2048 ? e[r++] = n >> 6 | 192 : (n < 65536 ? e[r++] = n >> 12 | 224 : (e[r++] = n >> 18 | 240, e[r++] = n >> 12 & 63 | 128), e[r++] = n >> 6 & 63 | 128), e[r++] = 63 & n | 128) } return r }(this.buf, e, this.pos); var r = this.pos - t; r >= 128 && b(t, r, this), this.pos = t - 1, this.writeVarint(r), this.pos += r }, writeFloat: function (e) { this.realloc(4), f.write(this.buf, e, this.pos, !0, 23, 4), this.pos += 4 }, writeDouble: function (e) { this.realloc(8), f.write(this.buf, e, this.pos, !0, 52, 8), this.pos += 8 }, writeBytes: function (e) { var t = e.length; this.writeVarint(t), this.realloc(t); for (var r = 0; r < t; r++)this.buf[this.pos++] = e[r] }, writeRawMessage: function (e, t) { this.pos++; var r = this.pos; e(t, this); var n = this.pos - r; n >= 128 && b(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n }, writeMessage: function (e, t, r) { this.writeTag(e, m.Bytes), this.writeRawMessage(t, r) }, writePackedVarint: function (e, t) { t.length && this.writeMessage(e, w, t) }, writePackedSVarint: function (e, t) { t.length && this.writeMessage(e, T, t) }, writePackedBoolean: function (e, t) { t.length && this.writeMessage(e, E, t) }, writePackedFloat: function (e, t) { t.length && this.writeMessage(e, k, t) }, writePackedDouble: function (e, t) { t.length && this.writeMessage(e, C, t) }, writePackedFixed32: function (e, t) { t.length && this.writeMessage(e, S, t) }, writePackedSFixed32: function (e, t) { t.length && this.writeMessage(e, P, t) }, writePackedFixed64: function (e, t) { t.length && this.writeMessage(e, I, t) }, writePackedSFixed64: function (e, t) { t.length && this.writeMessage(e, A, t) }, writeBytesField: function (e, t) { this.writeTag(e, m.Bytes), this.writeBytes(t) }, writeFixed32Field: function (e, t) { this.writeTag(e, m.Fixed32), this.writeFixed32(t) }, writeSFixed32Field: function (e, t) { this.writeTag(e, m.Fixed32), this.writeSFixed32(t) }, writeFixed64Field: function (e, t) { this.writeTag(e, m.Fixed64), this.writeFixed64(t) }, writeSFixed64Field: function (e, t) { this.writeTag(e, m.Fixed64), this.writeSFixed64(t) }, writeVarintField: function (e, t) { this.writeTag(e, m.Varint), this.writeVarint(t) }, writeSVarintField: function (e, t) { this.writeTag(e, m.Varint), this.writeSVarint(t) }, writeStringField: function (e, t) { this.writeTag(e, m.Bytes), this.writeString(t) }, writeFloatField: function (e, t) { this.writeTag(e, m.Fixed32), this.writeFloat(t) }, writeDoubleField: function (e, t) { this.writeTag(e, m.Fixed64), this.writeDouble(t) }, writeBooleanField: function (e, t) { this.writeVarintField(e, Boolean(t)) } }; var R = D; function D(e, t) { this.x = e, this.y = t } D.prototype = { clone: function () { return new D(this.x, this.y) }, add: function (e) { return this.clone()._add(e) }, sub: function (e) { return this.clone()._sub(e) }, multByPoint: function (e) { return this.clone()._multByPoint(e) }, divByPoint: function (e) { return this.clone()._divByPoint(e) }, mult: function (e) { return this.clone()._mult(e) }, div: function (e) { return this.clone()._div(e) }, rotate: function (e) { return this.clone()._rotate(e) }, rotateAround: function (e, t) { return this.clone()._rotateAround(e, t) }, matMult: function (e) { return this.clone()._matMult(e) }, unit: function () { return this.clone()._unit() }, perp: function () { return this.clone()._perp() }, round: function () { return this.clone()._round() }, mag: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, equals: function (e) { return this.x === e.x && this.y === e.y }, dist: function (e) { return Math.sqrt(this.distSqr(e)) }, distSqr: function (e) { var t = e.x - this.x, r = e.y - this.y; return t * t + r * r }, angle: function () { return Math.atan2(this.y, this.x) }, angleTo: function (e) { return Math.atan2(this.y - e.y, this.x - e.x) }, angleWith: function (e) { return this.angleWithSep(e.x, e.y) }, angleWithSep: function (e, t) { return Math.atan2(this.x * t - this.y * e, this.x * e + this.y * t) }, _matMult: function (e) { var t = e[2] * this.x + e[3] * this.y; return this.x = e[0] * this.x + e[1] * this.y, this.y = t, this }, _add: function (e) { return this.x += e.x, this.y += e.y, this }, _sub: function (e) { return this.x -= e.x, this.y -= e.y, this }, _mult: function (e) { return this.x *= e, this.y *= e, this }, _div: function (e) { return this.x /= e, this.y /= e, this }, _multByPoint: function (e) { return this.x *= e.x, this.y *= e.y, this }, _divByPoint: function (e) { return this.x /= e.x, this.y /= e.y, this }, _unit: function () { return this._div(this.mag()), this }, _perp: function () { var e = this.y; return this.y = this.x, this.x = -e, this }, _rotate: function (e) { var t = Math.cos(e), r = Math.sin(e), n = r * this.x + t * this.y; return this.x = t * this.x - r * this.y, this.y = n, this }, _rotateAround: function (e, t) { var r = Math.cos(e), n = Math.sin(e), i = t.y + n * (this.x - t.x) + r * (this.y - t.y); return this.x = t.x + r * (this.x - t.x) - n * (this.y - t.y), this.y = i, this }, _round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } }, D.convert = function (e) { return e instanceof D ? e : Array.isArray(e) ? new D(e[0], e[1]) : e }; var F = {}, O = R, z = U; function U(e, t, r, n, i) { this.properties = {}, this.extent = r, this.type = 0, this._pbf = e, this._geometry = -1, this._keys = n, this._values = i, e.readFields(N, this, t) } function N(e, t, r) { 1 == e ? t.id = r.readVarint() : 2 == e ? function (e, t) { for (var r = e.readVarint() + e.pos; e.pos < r;) { var n = t._keys[e.readVarint()], i = t._values[e.readVarint()]; t.properties[n] = i } }(r, t) : 3 == e ? t.type = r.readVarint() : 4 == e && (t._geometry = r.pos) } function G(e) { for (var t, r, n = 0, i = 0, o = e.length, s = o - 1; i < o; s = i++)n += ((r = e[s]).x - (t = e[i]).x) * (t.y + r.y); return n } U.types = ["Unknown", "Point", "LineString", "Polygon"], U.prototype.loadGeometry = function () { var e = this._pbf; e.pos = this._geometry; for (var t, r = e.readVarint() + e.pos, n = 1, i = 0, o = 0, s = 0, a = []; e.pos < r;) { if (i <= 0) { var c = e.readVarint(); n = 7 & c, i = c >> 3 } if (i--, 1 === n || 2 === n) o += e.readSVarint(), s += e.readSVarint(), 1 === n && (t && a.push(t), t = []), t.push(new O(o, s)); else { if (7 !== n) throw new Error("unknown command " + n); t && t.push(t[0].clone()) } } return t && a.push(t), a }, U.prototype.bbox = function () { var e = this._pbf; e.pos = this._geometry; for (var t = e.readVarint() + e.pos, r = 1, n = 0, i = 0, o = 0, s = 1 / 0, a = -1 / 0, c = 1 / 0, l = -1 / 0; e.pos < t;) { if (n <= 0) { var u = e.readVarint(); r = 7 & u, n = u >> 3 } if (n--, 1 === r || 2 === r) (i += e.readSVarint()) < s && (s = i), i > a && (a = i), (o += e.readSVarint()) < c && (c = o), o > l && (l = o); else if (7 !== r) throw new Error("unknown command " + r) } return [s, c, a, l] }, U.prototype.toGeoJSON = function (e, t, r) { var n, i, o = this.extent * Math.pow(2, r), s = this.extent * e, a = this.extent * t, c = this.loadGeometry(), l = U.types[this.type]; function u(e) { for (var t = 0; t < e.length; t++) { var r = e[t]; e[t] = [360 * (r.x + s) / o - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + a) / o) * Math.PI / 180)) - 90] } } switch (this.type) { case 1: var h = []; for (n = 0; n < c.length; n++)h[n] = c[n][0]; u(c = h); break; case 2: for (n = 0; n < c.length; n++)u(c[n]); break; case 3: for (c = function (e) { var t = e.length; if (t <= 1) return [e]; for (var r, n, i = [], o = 0; o < t; o++) { var s = G(e[o]); 0 !== s && (void 0 === n && (n = s < 0), n === s < 0 ? (r && i.push(r), r = [e[o]]) : r.push(e[o])) } return r && i.push(r), i }(c), n = 0; n < c.length; n++)for (i = 0; i < c[n].length; i++)u(c[n][i]) }1 === c.length ? c = c[0] : l = "Multi" + l; var d = { type: "Feature", geometry: { type: l, coordinates: c }, properties: this.properties }; return "id" in this && (d.id = this.id), d }; var V = z, q = j; function j(e, t) { this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = e, this._keys = [], this._values = [], this._features = [], e.readFields(X, this, t), this.length = this._features.length } function X(e, t, r) { 15 === e ? t.version = r.readVarint() : 1 === e ? t.name = r.readString() : 5 === e ? t.extent = r.readVarint() : 2 === e ? t._features.push(r.pos) : 3 === e ? t._keys.push(r.readString()) : 4 === e && t._values.push(function (e) { for (var t = null, r = e.readVarint() + e.pos; e.pos < r;) { var n = e.readVarint() >> 3; t = 1 === n ? e.readString() : 2 === n ? e.readFloat() : 3 === n ? e.readDouble() : 4 === n ? e.readVarint64() : 5 === n ? e.readVarint() : 6 === n ? e.readSVarint() : 7 === n ? e.readBoolean() : null } return t }(r)) } j.prototype.feature = function (e) { if (e < 0 || e >= this._features.length) throw new Error("feature index out of bounds"); this._pbf.pos = this._features[e]; var t = this._pbf.readVarint() + this._pbf.pos; return new V(this._pbf, t, this.extent, this._keys, this._values) }; var W = q; function Z(e, t, r) { if (3 === e) { var n = new W(r, r.readVarint() + r.pos); n.length && (t[n.name] = n) } } F.VectorTile = function (e, t) { this.layers = e.readFields(Z, {}, t) }, F.VectorTileFeature = z, F.VectorTileLayer = q; var H = R, Q = F.VectorTileFeature, $ = J; function J(e, t) { this.options = t || {}, this.features = e, this.length = e.length } function K(e, t) { this.id = "number" == typeof e.id ? e.id : void 0, this.type = e.type, this.rawGeometry = 1 === e.type ? [e.geometry] : e.geometry, this.properties = e.tags, this.extent = t || 4096 } J.prototype.feature = function (e) { return new K(this.features[e], this.options.extent) }, K.prototype.loadGeometry = function () { var e = this.rawGeometry; this.geometry = []; for (var t = 0; t < e.length; t++) { for (var r = e[t], n = [], i = 0; i < r.length; i++)n.push(new H(r[i][0], r[i][1])); this.geometry.push(n) } return this.geometry }, K.prototype.bbox = function () { this.geometry || this.loadGeometry(); for (var e = this.geometry, t = 1 / 0, r = -1 / 0, n = 1 / 0, i = -1 / 0, o = 0; o < e.length; o++)for (var s = e[o], a = 0; a < s.length; a++) { var c = s[a]; t = Math.min(t, c.x), r = Math.max(r, c.x), n = Math.min(n, c.y), i = Math.max(i, c.y) } return [t, n, r, i] }, K.prototype.toGeoJSON = Q.prototype.toGeoJSON; var Y = p, ee = $; function te(e) { var t = new Y; return function (e, t) { for (var r in e.layers) t.writeMessage(3, re, e.layers[r]) }(e, t), t.finish() } function re(e, t) { var r; t.writeVarintField(15, e.version || 1), t.writeStringField(1, e.name || ""), t.writeVarintField(5, e.extent || 4096); var n = { keys: [], values: [], keycache: {}, valuecache: {} }; for (r = 0; r < e.length; r++)n.feature = e.feature(r), t.writeMessage(2, ne, n); var i = n.keys; for (r = 0; r < i.length; r++)t.writeStringField(3, i[r]); var o = n.values; for (r = 0; r < o.length; r++)t.writeMessage(4, ce, o[r]) } function ne(e, t) { var r = e.feature; void 0 !== r.id && t.writeVarintField(1, r.id), t.writeMessage(2, ie, e), t.writeVarintField(3, r.type), t.writeMessage(4, ae, r) } function ie(e, t) { var r = e.feature, n = e.keys, i = e.values, o = e.keycache, s = e.valuecache; for (var a in r.properties) { var c = r.properties[a], l = o[a]; if (null !== c) { void 0 === l && (n.push(a), o[a] = l = n.length - 1), t.writeVarint(l); var u = typeof c; "string" !== u && "boolean" !== u && "number" !== u && (c = JSON.stringify(c)); var h = u + ":" + c, d = s[h]; void 0 === d && (i.push(c), s[h] = d = i.length - 1), t.writeVarint(d) } } } function oe(e, t) { return (t << 3) + (7 & e) } function se(e) { return e << 1 ^ e >> 31 } function ae(e, t) { for (var r = e.loadGeometry(), n = e.type, i = 0, o = 0, s = r.length, a = 0; a < s; a++) { var c = r[a], l = 1; 1 === n && (l = c.length), t.writeVarint(oe(1, l)); for (var u = 3 === n ? c.length - 1 : c.length, h = 0; h < u; h++) { 1 === h && 1 !== n && t.writeVarint(oe(2, u - 1)); var d = c[h].x - i, p = c[h].y - o; t.writeVarint(se(d)), t.writeVarint(se(p)), i += d, o += p } 3 === n && t.writeVarint(oe(7, 1)) } } function ce(e, t) { var r = typeof e; "string" === r ? t.writeStringField(1, e) : "boolean" === r ? t.writeBooleanField(7, e) : "number" === r && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e)) } function le(e, t, r, n, i, o) { if (i - n <= r) return; const s = n + i >> 1; ue(e, t, s, n, i, o % 2), le(e, t, r, n, s - 1, o + 1), le(e, t, r, s + 1, i, o + 1) } function ue(e, t, r, n, i, o) { for (; i > n;) { if (i - n > 600) { const s = i - n + 1, a = r - n + 1, c = Math.log(s), l = .5 * Math.exp(2 * c / 3), u = .5 * Math.sqrt(c * l * (s - l) / s) * (a - s / 2 < 0 ? -1 : 1); ue(e, t, r, Math.max(n, Math.floor(r - a * l / s + u)), Math.min(i, Math.floor(r + (s - a) * l / s + u)), o) } const s = t[2 * r + o]; let a = n, c = i; for (he(e, t, n, r), t[2 * i + o] > s && he(e, t, n, i); a < c;) { for (he(e, t, a, c), a++, c--; t[2 * a + o] < s;)a++; for (; t[2 * c + o] > s;)c-- } t[2 * n + o] === s ? he(e, t, n, c) : (c++, he(e, t, c, i)), c <= r && (n = c + 1), r <= c && (i = c - 1) } } function he(e, t, r, n) { de(e, r, n), de(t, 2 * r, 2 * n), de(t, 2 * r + 1, 2 * n + 1) } function de(e, t, r) { const n = e[t]; e[t] = e[r], e[r] = n } function pe(e, t, r, n) { const i = e - r, o = t - n; return i * i + o * o } d.exports = te, h.fromVectorTileJs = te, h.fromGeojsonVt = function (e, t) { t = t || {}; var r = {}; for (var n in e) r[n] = new ee(e[n].features, t), r[n].name = n, r[n].version = t.version, r[n].extent = t.extent; return te({ layers: r }) }, h.GeoJSONWrapper = ee; const fe = e => e[0], me = e => e[1]; class ge { constructor(e, t = fe, r = me, n = 64, i = Float64Array) { this.nodeSize = n, this.points = e; const o = e.length < 65536 ? Uint16Array : Uint32Array, s = this.ids = new o(e.length), a = this.coords = new i(2 * e.length); for (let c = 0; c < e.length; c++)s[c] = c, a[2 * c] = t(e[c]), a[2 * c + 1] = r(e[c]); le(s, a, n, 0, s.length - 1, 0) } range(e, t, r, n) { return function (e, t, r, n, i, o, s) { const a = [0, e.length - 1, 0], c = []; let l, u; for (; a.length;) { const h = a.pop(), d = a.pop(), p = a.pop(); if (d - p <= s) { for (let s = p; s <= d; s++)l = t[2 * s], u = t[2 * s + 1], l >= r && l <= i && u >= n && u <= o && c.push(e[s]); continue } const f = Math.floor((p + d) / 2); l = t[2 * f], u = t[2 * f + 1], l >= r && l <= i && u >= n && u <= o && c.push(e[f]); const m = (h + 1) % 2; (0 === h ? r <= l : n <= u) && (a.push(p), a.push(f - 1), a.push(m)), (0 === h ? i >= l : o >= u) && (a.push(f + 1), a.push(d), a.push(m)) } return c }(this.ids, this.coords, e, t, r, n, this.nodeSize) } within(e, t, r) { return function (e, t, r, n, i, o) { const s = [0, e.length - 1, 0], a = [], c = i * i; for (; s.length;) { const l = s.pop(), u = s.pop(), h = s.pop(); if (u - h <= o) { for (let i = h; i <= u; i++)pe(t[2 * i], t[2 * i + 1], r, n) <= c && a.push(e[i]); continue } const d = Math.floor((h + u) / 2), p = t[2 * d], f = t[2 * d + 1]; pe(p, f, r, n) <= c && a.push(e[d]); const m = (l + 1) % 2; (0 === l ? r - i <= p : n - i <= f) && (s.push(h), s.push(d - 1), s.push(m)), (0 === l ? r + i >= p : n + i >= f) && (s.push(d + 1), s.push(u), s.push(m)) } return a }(this.ids, this.coords, e, t, r, this.nodeSize) } } const _e = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: e => e }, ye = Math.fround || (ve = new Float32Array(1), e => (ve[0] = +e, ve[0])); var ve; class xe { constructor(e) { this.options = Pe(Object.create(_e), e), this.trees = new Array(this.options.maxZoom + 1) } load(e) { const { log: t, minZoom: r, maxZoom: n, nodeSize: i } = this.options; t && console.time("total time"); const o = `prepare ${e.length} points`; t && console.time(o), this.points = e; let s = []; for (let a = 0; a < e.length; a++)e[a].geometry && s.push(we(e[a], a)); this.trees[n + 1] = new ge(s, Ie, Ae, i, Float32Array), t && console.timeEnd(o); for (let a = n; a >= r; a--) { const e = +Date.now(); s = this._cluster(s, a), this.trees[a] = new ge(s, Ie, Ae, i, Float32Array), t && console.log("z%d: %d clusters in %dms", a, s.length, +Date.now() - e) } return t && console.timeEnd("total time"), this } getClusters(e, t) { let r = ((e[0] + 180) % 360 + 360) % 360 - 180; const n = Math.max(-90, Math.min(90, e[1])); let i = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180; const o = Math.max(-90, Math.min(90, e[3])); if (e[2] - e[0] >= 360) r = -180, i = 180; else if (r > i) { const e = this.getClusters([r, n, 180, o], t), s = this.getClusters([-180, n, i, o], t); return e.concat(s) } const s = this.trees[this._limitZoom(t)], a = s.range(Ce(r), Ee(o), Ce(i), Ee(n)), c = []; for (const l of a) { const e = s.points[l]; c.push(e.numPoints ? Te(e) : this.points[e.index]) } return c } getChildren(e) { const t = this._getOriginId(e), r = this._getOriginZoom(e), n = "No cluster with the specified id.", i = this.trees[r]; if (!i) throw new Error(n); const o = i.points[t]; if (!o) throw new Error(n); const s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), a = i.within(o.x, o.y, s), c = []; for (const l of a) { const t = i.points[l]; t.parentId === e && c.push(t.numPoints ? Te(t) : this.points[t.index]) } if (0 === c.length) throw new Error(n); return c } getLeaves(e, t, r) { const n = []; return this._appendLeaves(n, e, t = t || 10, r = r || 0, 0), n } getTile(e, t, r) { const n = this.trees[this._limitZoom(e)], i = Math.pow(2, e), { extent: o, radius: s } = this.options, a = s / o, c = (r - a) / i, l = (r + 1 + a) / i, u = { features: [] }; return this._addTileFeatures(n.range((t - a) / i, c, (t + 1 + a) / i, l), n.points, t, r, i, u), 0 === t && this._addTileFeatures(n.range(1 - a / i, c, 1, l), n.points, i, r, i, u), t === i - 1 && this._addTileFeatures(n.range(0, c, a / i, l), n.points, -1, r, i, u), u.features.length ? u : null } getClusterExpansionZoom(e) { let t = this._getOriginZoom(e) - 1; for (; t <= this.options.maxZoom;) { const r = this.getChildren(e); if (t++, 1 !== r.length) break; e = r[0].properties.cluster_id } return t } _appendLeaves(e, t, r, n, i) { const o = this.getChildren(t); for (const s of o) { const t = s.properties; if (t && t.cluster ? i + t.point_count <= n ? i += t.point_count : i = this._appendLeaves(e, t.cluster_id, r, n, i) : i < n ? i++ : e.push(s), e.length === r) break } return i } _addTileFeatures(e, t, r, n, i, o) { for (const s of e) { const e = t[s], a = e.numPoints; let c, l, u; if (a) c = ke(e), l = e.x, u = e.y; else { const t = this.points[e.index]; c = t.properties, l = Ce(t.geometry.coordinates[0]), u = Ee(t.geometry.coordinates[1]) } const h = { type: 1, geometry: [[Math.round(this.options.extent * (l * i - r)), Math.round(this.options.extent * (u * i - n))]], tags: c }; let d; a ? d = e.id : this.options.generateId ? d = e.index : this.points[e.index].id && (d = this.points[e.index].id), void 0 !== d && (h.id = d), o.features.push(h) } } _limitZoom(e) { return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1)) } _cluster(e, t) { const r = [], { radius: n, extent: i, reduce: o, minPoints: s } = this.options, a = n / (i * Math.pow(2, t)); for (let c = 0; c < e.length; c++) { const n = e[c]; if (n.zoom <= t) continue; n.zoom = t; const i = this.trees[t + 1], l = i.within(n.x, n.y, a), u = n.numPoints || 1; let h = u; for (const e of l) { const r = i.points[e]; r.zoom > t && (h += r.numPoints || 1) } if (h > u && h >= s) { let e = n.x * u, s = n.y * u, a = o && u > 1 ? this._map(n, !0) : null; const d = (c << 5) + (t + 1) + this.points.length; for (const r of l) { const c = i.points[r]; if (c.zoom <= t) continue; c.zoom = t; const l = c.numPoints || 1; e += c.x * l, s += c.y * l, c.parentId = d, o && (a || (a = this._map(n, !0)), o(a, this._map(c))) } n.parentId = d, r.push(be(e / h, s / h, d, h, a)) } else if (r.push(n), h > 1) for (const e of l) { const n = i.points[e]; n.zoom <= t || (n.zoom = t, r.push(n)) } } return r } _getOriginId(e) { return e - this.points.length >> 5 } _getOriginZoom(e) { return (e - this.points.length) % 32 } _map(e, t) { if (e.numPoints) return t ? Pe({}, e.properties) : e.properties; const r = this.points[e.index].properties, n = this.options.map(r); return t && n === r ? Pe({}, n) : n } } function be(e, t, r, n, i) { return { x: ye(e), y: ye(t), zoom: 1 / 0, id: r, parentId: -1, numPoints: n, properties: i } } function we(e, t) { const [r, n] = e.geometry.coordinates; return { x: ye(Ce(r)), y: ye(Ee(n)), zoom: 1 / 0, index: t, parentId: -1 } } function Te(e) { return { type: "Feature", id: e.id, properties: ke(e), geometry: { type: "Point", coordinates: [(t = e.x, 360 * (t - .5)), Se(e.y)] } }; var t } function ke(e) { const t = e.numPoints, r = t >= 1e4 ? `${Math.round(t / 1e3)}k` : t >= 1e3 ? Math.round(t / 100) / 10 + "k" : t; return Pe(Pe({}, e.properties), { cluster: !0, cluster_id: e.id, point_count: t, point_count_abbreviated: r }) } function Ce(e) { return e / 360 + .5 } function Ee(e) { const t = Math.sin(e * Math.PI / 180), r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI; return r < 0 ? 0 : r > 1 ? 1 : r } function Se(e) { const t = (180 - 360 * e) * Math.PI / 180; return 360 * Math.atan(Math.exp(t)) / Math.PI - 90 } function Pe(e, t) { for (const r in t) e[r] = t[r]; return e } function Ie(e) { return e.x } function Ae(e) { return e.y } function Le(e, t, r, n) { for (var i, o = n, s = r - t >> 1, a = r - t, c = e[t], l = e[t + 1], u = e[r], h = e[r + 1], d = t + 3; d < r; d += 3) { var p = Me(e[d], e[d + 1], c, l, u, h); if (p > o) i = d, o = p; else if (p === o) { var f = Math.abs(d - s); f < a && (i = d, a = f) } } o > n && (i - t > 3 && Le(e, t, i, n), e[i + 2] = o, r - i > 3 && Le(e, i, r, n)) } function Me(e, t, r, n, i, o) { var s = i - r, a = o - n; if (0 !== s || 0 !== a) { var c = ((e - r) * s + (t - n) * a) / (s * s + a * a); c > 1 ? (r = i, n = o) : c > 0 && (r += s * c, n += a * c) } return (s = e - r) * s + (a = t - n) * a } function Be(e, t, r, n) { var i = { id: void 0 === e ? null : e, type: t, geometry: r, tags: n, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }; return function (e) { var t = e.geometry, r = e.type; if ("Point" === r || "MultiPoint" === r || "LineString" === r) Re(e, t); else if ("Polygon" === r || "MultiLineString" === r) for (var n = 0; n < t.length; n++)Re(e, t[n]); else if ("MultiPolygon" === r) for (n = 0; n < t.length; n++)for (var i = 0; i < t[n].length; i++)Re(e, t[n][i]) }(i), i } function Re(e, t) { for (var r = 0; r < t.length; r += 3)e.minX = Math.min(e.minX, t[r]), e.minY = Math.min(e.minY, t[r + 1]), e.maxX = Math.max(e.maxX, t[r]), e.maxY = Math.max(e.maxY, t[r + 1]) } function De(e, t, r, n) { if (t.geometry) { var i = t.geometry.coordinates, o = t.geometry.type, s = Math.pow(r.tolerance / ((1 << r.maxZoom) * r.extent), 2), a = [], c = t.id; if (r.promoteId ? c = t.properties[r.promoteId] : r.generateId && (c = n || 0), "Point" === o) Fe(i, a); else if ("MultiPoint" === o) for (var l = 0; l < i.length; l++)Fe(i[l], a); else if ("LineString" === o) Oe(i, a, s, !1); else if ("MultiLineString" === o) { if (r.lineMetrics) { for (l = 0; l < i.length; l++)Oe(i[l], a = [], s, !1), e.push(Be(c, "LineString", a, t.properties)); return } ze(i, a, s, !1) } else if ("Polygon" === o) ze(i, a, s, !0); else { if ("MultiPolygon" !== o) { if ("GeometryCollection" === o) { for (l = 0; l < t.geometry.geometries.length; l++)De(e, { id: c, geometry: t.geometry.geometries[l], properties: t.properties }, r, n); return } throw new Error("Input data is not a valid GeoJSON object.") } for (l = 0; l < i.length; l++) { var u = []; ze(i[l], u, s, !0), a.push(u) } } e.push(Be(c, o, a, t.properties)) } } function Fe(e, t) { t.push(Ue(e[0])), t.push(Ne(e[1])), t.push(0) } function Oe(e, t, r, n) { for (var i, o, s = 0, a = 0; a < e.length; a++) { var c = Ue(e[a][0]), l = Ne(e[a][1]); t.push(c), t.push(l), t.push(0), a > 0 && (s += n ? (i * l - c * o) / 2 : Math.sqrt(Math.pow(c - i, 2) + Math.pow(l - o, 2))), i = c, o = l } var u = t.length - 3; t[2] = 1, Le(t, 0, u, r), t[u + 2] = 1, t.size = Math.abs(s), t.start = 0, t.end = t.size } function ze(e, t, r, n) { for (var i = 0; i < e.length; i++) { var o = []; Oe(e[i], o, r, n), t.push(o) } } function Ue(e) { return e / 360 + .5 } function Ne(e) { var t = Math.sin(e * Math.PI / 180), r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI; return r < 0 ? 0 : r > 1 ? 1 : r } function Ge(e, t, r, n, i, o, s, a) { if (n /= t, o >= (r /= t) && s < n) return e; if (s < r || o >= n) return null; for (var c = [], l = 0; l < e.length; l++) { var u = e[l], h = u.geometry, d = u.type, p = 0 === i ? u.minX : u.minY, f = 0 === i ? u.maxX : u.maxY; if (p >= r && f < n) c.push(u); else if (!(f < r || p >= n)) { var m = []; if ("Point" === d || "MultiPoint" === d) Ve(h, m, r, n, i); else if ("LineString" === d) qe(h, m, r, n, i, !1, a.lineMetrics); else if ("MultiLineString" === d) Xe(h, m, r, n, i, !1); else if ("Polygon" === d) Xe(h, m, r, n, i, !0); else if ("MultiPolygon" === d) for (var g = 0; g < h.length; g++) { var _ = []; Xe(h[g], _, r, n, i, !0), _.length && m.push(_) } if (m.length) { if (a.lineMetrics && "LineString" === d) { for (g = 0; g < m.length; g++)c.push(Be(u.id, d, m[g], u.tags)); continue } "LineString" !== d && "MultiLineString" !== d || (1 === m.length ? (d = "LineString", m = m[0]) : d = "MultiLineString"), "Point" !== d && "MultiPoint" !== d || (d = 3 === m.length ? "Point" : "MultiPoint"), c.push(Be(u.id, d, m, u.tags)) } } } return c.length ? c : null } function Ve(e, t, r, n, i) { for (var o = 0; o < e.length; o += 3) { var s = e[o + i]; s >= r && s <= n && (t.push(e[o]), t.push(e[o + 1]), t.push(e[o + 2])) } } function qe(e, t, r, n, i, o, s) { for (var a, c, l = je(e), u = 0 === i ? Ze : He, h = e.start, d = 0; d < e.length - 3; d += 3) { var p = e[d], f = e[d + 1], m = e[d + 2], g = e[d + 3], _ = e[d + 4], y = 0 === i ? p : f, v = 0 === i ? g : _, x = !1; s && (a = Math.sqrt(Math.pow(p - g, 2) + Math.pow(f - _, 2))), y < r ? v > r && (c = u(l, p, f, g, _, r), s && (l.start = h + a * c)) : y > n ? v < n && (c = u(l, p, f, g, _, n), s && (l.start = h + a * c)) : We(l, p, f, m), v < r && y >= r && (c = u(l, p, f, g, _, r), x = !0), v > n && y <= n && (c = u(l, p, f, g, _, n), x = !0), !o && x && (s && (l.end = h + a * c), t.push(l), l = je(e)), s && (h += a) } var b = e.length - 3; p = e[b], f = e[b + 1], m = e[b + 2], (y = 0 === i ? p : f) >= r && y <= n && We(l, p, f, m), b = l.length - 3, o && b >= 3 && (l[b] !== l[0] || l[b + 1] !== l[1]) && We(l, l[0], l[1], l[2]), l.length && t.push(l) } function je(e) { var t = []; return t.size = e.size, t.start = e.start, t.end = e.end, t } function Xe(e, t, r, n, i, o) { for (var s = 0; s < e.length; s++)qe(e[s], t, r, n, i, o, !1) } function We(e, t, r, n) { e.push(t), e.push(r), e.push(n) } function Ze(e, t, r, n, i, o) { var s = (o - t) / (n - t); return e.push(o), e.push(r + (i - r) * s), e.push(1), s } function He(e, t, r, n, i, o) { var s = (o - r) / (i - r); return e.push(t + (n - t) * s), e.push(o), e.push(1), s } function Qe(e, t) { for (var r = [], n = 0; n < e.length; n++) { var i, o = e[n], s = o.type; if ("Point" === s || "MultiPoint" === s || "LineString" === s) i = $e(o.geometry, t); else if ("MultiLineString" === s || "Polygon" === s) { i = []; for (var a = 0; a < o.geometry.length; a++)i.push($e(o.geometry[a], t)) } else if ("MultiPolygon" === s) for (i = [], a = 0; a < o.geometry.length; a++) { for (var c = [], l = 0; l < o.geometry[a].length; l++)c.push($e(o.geometry[a][l], t)); i.push(c) } r.push(Be(o.id, s, i, o.tags)) } return r } function $e(e, t) { var r = []; r.size = e.size, void 0 !== e.start && (r.start = e.start, r.end = e.end); for (var n = 0; n < e.length; n += 3)r.push(e[n] + t, e[n + 1], e[n + 2]); return r } function Je(e, t) { if (e.transformed) return e; var r, n, i, o = 1 << e.z, s = e.x, a = e.y; for (r = 0; r < e.features.length; r++) { var c = e.features[r], l = c.geometry, u = c.type; if (c.geometry = [], 1 === u) for (n = 0; n < l.length; n += 2)c.geometry.push(Ke(l[n], l[n + 1], t, o, s, a)); else for (n = 0; n < l.length; n++) { var h = []; for (i = 0; i < l[n].length; i += 2)h.push(Ke(l[n][i], l[n][i + 1], t, o, s, a)); c.geometry.push(h) } } return e.transformed = !0, e } function Ke(e, t, r, n, i, o) { return [Math.round(r * (e * n - i)), Math.round(r * (t * n - o))] } function Ye(e, t, r, n, i) { for (var o = t === i.maxZoom ? 0 : i.tolerance / ((1 << t) * i.extent), s = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r, y: n, z: t, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a = 0; a < e.length; a++) { s.numFeatures++, et(s, e[a], o, i); var c = e[a].minX, l = e[a].minY, u = e[a].maxX, h = e[a].maxY; c < s.minX && (s.minX = c), l < s.minY && (s.minY = l), u > s.maxX && (s.maxX = u), h > s.maxY && (s.maxY = h) } return s } function et(e, t, r, n) { var i = t.geometry, o = t.type, s = []; if ("Point" === o || "MultiPoint" === o) for (var a = 0; a < i.length; a += 3)s.push(i[a]), s.push(i[a + 1]), e.numPoints++, e.numSimplified++; else if ("LineString" === o) tt(s, i, e, r, !1, !1); else if ("MultiLineString" === o || "Polygon" === o) for (a = 0; a < i.length; a++)tt(s, i[a], e, r, "Polygon" === o, 0 === a); else if ("MultiPolygon" === o) for (var c = 0; c < i.length; c++) { var l = i[c]; for (a = 0; a < l.length; a++)tt(s, l[a], e, r, !0, 0 === a) } if (s.length) { var u = t.tags || null; if ("LineString" === o && n.lineMetrics) { for (var h in u = {}, t.tags) u[h] = t.tags[h]; u.mapbox_clip_start = i.start / i.size, u.mapbox_clip_end = i.end / i.size } var d = { geometry: s, type: "Polygon" === o || "MultiPolygon" === o ? 3 : "LineString" === o || "MultiLineString" === o ? 2 : 1, tags: u }; null !== t.id && (d.id = t.id), e.features.push(d) } } function tt(e, t, r, n, i, o) { var s = n * n; if (n > 0 && t.size < (i ? s : n)) r.numPoints += t.length / 3; else { for (var a = [], c = 0; c < t.length; c += 3)(0 === n || t[c + 2] > s) && (r.numSimplified++, a.push(t[c]), a.push(t[c + 1])), r.numPoints++; i && function (e, t) { for (var r = 0, n = 0, i = e.length, o = i - 2; n < i; o = n, n += 2)r += (e[n] - e[o]) * (e[n + 1] + e[o + 1]); if (r > 0 === t) for (n = 0, i = e.length; n < i / 2; n += 2) { var s = e[n], a = e[n + 1]; e[n] = e[i - 2 - n], e[n + 1] = e[i - 1 - n], e[i - 2 - n] = s, e[i - 1 - n] = a } }(a, o), e.push(a) } } function rt(e, t) { var r = (t = this.options = function (e, t) { for (var r in t) e[r] = t[r]; return e }(Object.create(this.options), t)).debug; if (r && console.time("preprocess data"), t.maxZoom < 0 || t.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range"); if (t.promoteId && t.generateId) throw new Error("promoteId and generateId cannot be used together."); var n = function (e, t) { var r = []; if ("FeatureCollection" === e.type) for (var n = 0; n < e.features.length; n++)De(r, e.features[n], t, n); else De(r, "Feature" === e.type ? e : { geometry: e }, t); return r }(e, t); this.tiles = {}, this.tileCoords = [], r && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t.indexMaxZoom, t.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), n = function (e, t) { var r = t.buffer / t.extent, n = e, i = Ge(e, 1, -1 - r, r, 0, -1, 2, t), o = Ge(e, 1, 1 - r, 2 + r, 0, -1, 2, t); return (i || o) && (n = Ge(e, 1, -r, 1 + r, 0, -1, 2, t) || [], i && (n = Qe(i, 1).concat(n)), o && (n = n.concat(Qe(o, -1)))), n }(n, t), n.length && this.splitTile(n, 0, 0, 0), r && (n.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats))) } function nt(e, t, r) { return 32 * ((1 << e) * r + t) + e } function it(e, t) { const r = e.tileID.canonical; if (!this._geoJSONIndex) return t(null, null); const n = this._geoJSONIndex.getTile(r.z, r.x, r.y); if (!n) return t(null, null); const i = new u(n.features); let o = h(i); 0 === o.byteOffset && o.byteLength === o.buffer.byteLength || (o = new Uint8Array(o)), t(null, { vectorTile: i, rawData: o.buffer }) } rt.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }, rt.prototype.splitTile = function (e, t, r, n, i, o, s) { for (var a = [e, t, r, n], c = this.options, l = c.debug; a.length;) { n = a.pop(), r = a.pop(), t = a.pop(), e = a.pop(); var u = 1 << t, h = nt(t, r, n), d = this.tiles[h]; if (!d && (l > 1 && console.time("creation"), d = this.tiles[h] = Ye(e, t, r, n, c), this.tileCoords.push({ z: t, x: r, y: n }), l)) { l > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t, r, n, d.numFeatures, d.numPoints, d.numSimplified), console.timeEnd("creation")); var p = "z" + t; this.stats[p] = (this.stats[p] || 0) + 1, this.total++ } if (d.source = e, i) { if (t === c.maxZoom || t === i) continue; var f = 1 << i - t; if (r !== Math.floor(o / f) || n !== Math.floor(s / f)) continue } else if (t === c.indexMaxZoom || d.numPoints <= c.indexMaxPoints) continue; if (d.source = null, 0 !== e.length) { l > 1 && console.time("clipping"); var m, g, _, y, v, x, b = .5 * c.buffer / c.extent, w = .5 - b, T = .5 + b, k = 1 + b; m = g = _ = y = null, v = Ge(e, u, r - b, r + T, 0, d.minX, d.maxX, c), x = Ge(e, u, r + w, r + k, 0, d.minX, d.maxX, c), e = null, v && (m = Ge(v, u, n - b, n + T, 1, d.minY, d.maxY, c), g = Ge(v, u, n + w, n + k, 1, d.minY, d.maxY, c), v = null), x && (_ = Ge(x, u, n - b, n + T, 1, d.minY, d.maxY, c), y = Ge(x, u, n + w, n + k, 1, d.minY, d.maxY, c), x = null), l > 1 && console.timeEnd("clipping"), a.push(m || [], t + 1, 2 * r, 2 * n), a.push(g || [], t + 1, 2 * r, 2 * n + 1), a.push(_ || [], t + 1, 2 * r + 1, 2 * n), a.push(y || [], t + 1, 2 * r + 1, 2 * n + 1) } } }, rt.prototype.getTile = function (e, t, r) { var n = this.options, i = n.extent, o = n.debug; if (e < 0 || e > 24) return null; var s = 1 << e, a = nt(e, t = (t % s + s) % s, r); if (this.tiles[a]) return Je(this.tiles[a], i); o > 1 && console.log("drilling down to z%d-%d-%d", e, t, r); for (var c, l = e, u = t, h = r; !c && l > 0;)l--, u = Math.floor(u / 2), h = Math.floor(h / 2), c = this.tiles[nt(l, u, h)]; return c && c.source ? (o > 1 && console.log("found parent tile z%d-%d-%d", l, u, h), o > 1 && console.time("drilling down"), this.splitTile(c.source, l, u, h, e, t, r), o > 1 && console.timeEnd("drilling down"), this.tiles[a] ? Je(this.tiles[a], i) : null) : null }; class ot extends e.VectorTileWorkerSource { constructor(e, t, r, n, i) { super(e, t, r, n, it), i && (this.loadGeoJSON = i) } loadData(t, r) { const n = t && t.request, i = n && n.collectResourceTiming; this.loadGeoJSON(t, ((s, a) => { if (s || !a) return r(s); if ("object" != typeof a) return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`)); { o(a, !0); try { if (t.filter) { const r = e.createExpression(t.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 }); if ("error" === r.result) throw new Error(r.value.map((e => `${e.key}: ${e.message}`)).join(", ")); const n = a.features.filter((e => r.value.evaluate({ zoom: 0 }, e))); a = { type: "FeatureCollection", features: n } } this._geoJSONIndex = t.cluster ? new xe(function ({ superclusterOptions: t, clusterProperties: r }) { if (!r || !t) return t; const n = {}, i = {}, o = { accumulated: null, zoom: 0 }, s = { properties: null }, a = Object.keys(r); for (const c of a) { const [t, o] = r[c], s = e.createExpression(o), a = e.createExpression("string" == typeof t ? [t, ["accumulated"], ["get", c]] : t); n[c] = s.value, i[c] = a.value } return t.map = e => { s.properties = e; const t = {}; for (const r of a) t[r] = n[r].evaluate(o, s); return t }, t.reduce = (e, t) => { s.properties = t; for (const r of a) o.accumulated = e[r], e[r] = i[r].evaluate(o, s) }, t }(t)).load(a.features) : function (e, t) { return new rt(e, t) }(a, t.geojsonVtOptions) } catch (s) { return r(s) } this.loaded = {}; const c = {}; if (i) { const r = e.getPerformanceMeasurement(n); r && (c.resourceTiming = {}, c.resourceTiming[t.source] = JSON.parse(JSON.stringify(r))) } r(null, c) } })) } reloadTile(e, t) { const r = this.loaded; return r && r[e.uid] ? super.reloadTile(e, t) : this.loadTile(e, t) } loadGeoJSON(t, r) { if (t.request) e.getJSON(t.request, r); else { if ("string" != typeof t.data) return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`)); try { return r(null, JSON.parse(t.data)) } catch (e) { return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`)) } } } getClusterExpansionZoom(e, t) { try { t(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId)) } catch (e) { t(e) } } getClusterChildren(e, t) { try { t(null, this._geoJSONIndex.getChildren(e.clusterId)) } catch (e) { t(e) } } getClusterLeaves(e, t) { try { t(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset)) } catch (e) { t(e) } } } class st { constructor(t) { this.self = t, this.actor = new e.Actor(t, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e.getProjection({ name: "mercator" }), this.workerSourceTypes = { vector: e.VectorTileWorkerSource, geojson: ot }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e, t) => { if (this.workerSourceTypes[e]) throw new Error(`Worker source with name "${e}" already registered.`); this.workerSourceTypes[e] = t }, this.self.registerRTLTextPlugin = t => { if (e.plugin.isParsed()) throw new Error("RTL text plugin already registered."); e.plugin.applyArabicShaping = t.applyArabicShaping, e.plugin.processBidirectionalText = t.processBidirectionalText, e.plugin.processStyledBidirectionalText = t.processStyledBidirectionalText } } clearCaches(e, t, r) { delete this.layerIndexes[e], delete this.availableImages[e], delete this.workerSources[e], delete this.demWorkerSources[e], r() } checkIfReady(e, t, r) { r() } setReferrer(e, t) { this.referrer = t } spriteLoaded(t, r) { this.isSpriteLoaded[t] = r; for (const n in this.workerSources[t]) { const i = this.workerSources[t][n]; for (const t in i) i[t] instanceof e.VectorTileWorkerSource && (i[t].isSpriteLoaded = r, i[t].fire(new e.Event("isSpriteLoaded"))) } } setImages(e, t, r) { this.availableImages[e] = t; for (const n in this.workerSources[e]) { const r = this.workerSources[e][n]; for (const e in r) r[e].availableImages = t } r() } enableTerrain(e, t, r) { this.terrain = t, r() } setProjection(t, r) { this.projections[t] = e.getProjection(r) } setLayers(e, t, r) { this.getLayerIndex(e).replace(t), r() } updateLayers(e, t, r) { this.getLayerIndex(e).update(t.layers, t.removedIds), r() } loadTile(t, r, n) { const i = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r) : r; i.projection = this.projections[t] || this.defaultProjection, this.getWorkerSource(t, r.type, r.source).loadTile(i, n) } loadDEMTile(t, r, n) { const i = this.enableTerrain ? e.extend({ buildQuadTree: this.terrain }, r) : r; this.getDEMWorkerSource(t, r.source).loadTile(i, n) } reloadTile(t, r, n) { const i = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r) : r; i.projection = this.projections[t] || this.defaultProjection, this.getWorkerSource(t, r.type, r.source).reloadTile(i, n) } abortTile(e, t, r) { this.getWorkerSource(e, t.type, t.source).abortTile(t, r) } removeTile(e, t, r) { this.getWorkerSource(e, t.type, t.source).removeTile(t, r) } removeSource(e, t, r) { if (!this.workerSources[e] || !this.workerSources[e][t.type] || !this.workerSources[e][t.type][t.source]) return; const n = this.workerSources[e][t.type][t.source]; delete this.workerSources[e][t.type][t.source], void 0 !== n.removeSource ? n.removeSource(t, r) : r() } loadWorkerSource(e, t, r) { try { this.self.importScripts(t.url), r() } catch (e) { r(e.toString()) } } syncRTLPluginState(t, r, n) { try { e.plugin.setState(r); const t = e.plugin.getPluginURL(); if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != t) { this.self.importScripts(t); const r = e.plugin.isParsed(); n(r ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t}`), r) } } catch (e) { n(e.toString()) } } getAvailableImages(e) { let t = this.availableImages[e]; return t || (t = []), t } getLayerIndex(e) { let t = this.layerIndexes[e]; return t || (t = this.layerIndexes[e] = new n), t } getWorkerSource(e, t, r) { if (this.workerSources[e] || (this.workerSources[e] = {}), this.workerSources[e][t] || (this.workerSources[e][t] = {}), !this.workerSources[e][t][r]) { const n = { send: (t, r, n, i, o, s) => { this.actor.send(t, r, n, e, o, s) }, scheduler: this.actor.scheduler }; this.workerSources[e][t][r] = new this.workerSourceTypes[t](n, this.getLayerIndex(e), this.getAvailableImages(e), this.isSpriteLoaded[e]) } return this.workerSources[e][t][r] } getDEMWorkerSource(e, t) { return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][t] || (this.demWorkerSources[e][t] = new i), this.demWorkerSources[e][t] } enforceCacheSizeLimit(t, r) { e.enforceCacheSizeLimit(r) } getWorkerPerformanceMetrics(e, t, r) { r(void 0, void 0) } } return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new st(self)), st })), n(["./shared"], (function (e) { function t(e, r) { if (Array.isArray(e)) { if (!Array.isArray(r) || e.length !== r.length) return !1; for (let n = 0; n < e.length; n++)if (!t(e[n], r[n])) return !1; return !0 } if ("object" == typeof e && null !== e && null !== r) { if ("object" != typeof r) return !1; if (Object.keys(e).length !== Object.keys(r).length) return !1; for (const n in e) if (!t(e[n], r[n])) return !1; return !0 } return e === r } var r = n; function n(e) { return !function (e) { return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function () { if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1; var e, t, r = new Blob([""], { type: "text/javascript" }), n = URL.createObjectURL(r); try { t = new Worker(n), e = !0 } catch (t) { e = !1 } return t && t.terminate(), URL.revokeObjectURL(n), e }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function () { var e = document.createElement("canvas"); e.width = e.height = 1; var t = e.getContext("2d"); if (!t) return !1; var r = t.getImageData(0, 0, 1, 1); return r && r.width === e.width }() ? (void 0 === i[t = e && e.failIfMajorPerformanceCaveat] && (i[t] = function (e) { var t, r = function (e) { var t = document.createElement("canvas"), r = Object.create(n.webGLContextAttributes); return r.failIfMajorPerformanceCaveat = e, t.getContext("webgl", r) || t.getContext("experimental-webgl", r) }(e); if (!r) return !1; try { t = r.createShader(r.VERTEX_SHADER) } catch (e) { return !1 } return !(!t || r.isContextLost()) && (r.shaderSource(t, "void main() {}"), r.compileShader(t), !0 === r.getShaderParameter(t, r.COMPILE_STATUS)) }(t)), i[t] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support"; var t }(e) } var i = {}; function o(t, r, n) { const i = e.window.document.createElement(t); return void 0 !== r && (i.className = r), n && n.appendChild(i), i } function s(t, r, n) { const i = e.window.document.createElementNS("http://www.w3.org/2000/svg", t); for (const e of Object.keys(r)) i.setAttributeNS(null, e, r[e]); return n && n.appendChild(i), i } n.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 }; const a = e.window.document && e.window.document.documentElement.style, c = a && void 0 !== a.userSelect ? "userSelect" : "WebkitUserSelect"; let l; function u() { a && c && (l = a[c], a[c] = "none") } function h() { a && c && (a[c] = l) } function d(t) { t.preventDefault(), t.stopPropagation(), e.window.removeEventListener("click", d, !0) } function p() { e.window.addEventListener("click", d, !0), e.window.setTimeout((() => { e.window.removeEventListener("click", d, !0) }), 0) } function f(e, t) { const r = e.getBoundingClientRect(); return _(e, r, t) } function m(e, t) { const r = e.getBoundingClientRect(), n = []; for (let i = 0; i < t.length; i++)n.push(_(e, r, t[i])); return n } function g(t) { return void 0 !== e.window.InstallTrigger && 2 === t.button && t.ctrlKey && e.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : t.button } function _(t, r, n) { const i = t.offsetWidth === r.width ? 1 : t.offsetWidth / r.width; return new e.pointGeometry((n.clientX - r.left) * i, (n.clientY - r.top) * i) } function y(e, t) { var r = t[0], n = t[1], i = t[2], o = t[3], s = r * o - i * n; return s ? (e[0] = o * (s = 1 / s), e[1] = -n * s, e[2] = -i * s, e[3] = r * s, e) : null } function v(e) { const { userImage: t } = e; return !!(t && t.render && t.render()) && (e.data.replace(new Uint8Array(t.data.buffer)), !0) } class x extends e.Evented { constructor() { super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new e.RGBAImage({ width: 1, height: 1 }), this.dirty = !0 } isLoaded() { return this.loaded } setLoaded(e) { if (this.loaded !== e && (this.loaded = e, e)) { for (const { ids: e, callback: t } of this.requestors) this._notify(e, t); this.requestors = [] } } hasImage(e) { return !!this.getImage(e) } getImage(e) { return this.images[e] } addImage(e, t) { this._validate(e, t) && (this.images[e] = t) } _validate(t, r) { let n = !0; return this._validateStretch(r.stretchX, r.data && r.data.width) || (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "stretchX" value`))), n = !1), this._validateStretch(r.stretchY, r.data && r.data.height) || (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "stretchY" value`))), n = !1), this._validateContent(r.content, r) || (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "content" value`))), n = !1), n } _validateStretch(e, t) { if (!e) return !0; let r = 0; for (const n of e) { if (n[0] < r || n[1] < n[0] || t < n[1]) return !1; r = n[1] } return !0 } _validateContent(e, t) { return !(e && (4 !== e.length || e[0] < 0 || t.data.width < e[0] || e[1] < 0 || t.data.height < e[1] || e[2] < 0 || t.data.width < e[2] || e[3] < 0 || t.data.height < e[3] || e[2] < e[0] || e[3] < e[1])) } updateImage(e, t) { t.version = this.images[e].version + 1, this.images[e] = t, this.updatedImages[e] = !0 } removeImage(e) { const t = this.images[e]; delete this.images[e], delete this.patterns[e], t.userImage && t.userImage.onRemove && t.userImage.onRemove() } listImages() { return Object.keys(this.images) } getImages(e, t) { let r = !0; if (!this.isLoaded()) for (const n of e) this.images[n] || (r = !1); this.isLoaded() || r ? this._notify(e, t) : this.requestors.push({ ids: e, callback: t }) } _notify(t, r) { const n = {}; for (const i of t) { this.images[i] || this.fire(new e.Event("styleimagemissing", { id: i })); const t = this.images[i]; t ? n[i] = { data: t.data.clone(), pixelRatio: t.pixelRatio, sdf: t.sdf, version: t.version, stretchX: t.stretchX, stretchY: t.stretchY, content: t.content, hasRenderCallback: Boolean(t.userImage && t.userImage.render) } : e.warnOnce(`Image "${i}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`) } r(null, n) } getPixelSize() { const { width: e, height: t } = this.atlasImage; return { width: e, height: t } } getPattern(t) { const r = this.patterns[t], n = this.getImage(t); if (!n) return null; if (r && r.position.version === n.version) return r.position; if (r) r.position.version = n.version; else { const r = { w: n.data.width + 2, h: n.data.height + 2, x: 0, y: 0 }, i = new e.ImagePosition(r, n); this.patterns[t] = { bin: r, position: i } } return this._updatePatternAtlas(), this.patterns[t].position } bind(t) { const r = t.gl; this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new e.Texture(t, this.atlasImage, r.RGBA), this.atlasTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE) } _updatePatternAtlas() { const t = []; for (const e in this.patterns) t.push(this.patterns[e].bin); const { w: r, h: n } = e.potpack(t), i = this.atlasImage; i.resize({ width: r || 1, height: n || 1 }); for (const o in this.patterns) { const { bin: t } = this.patterns[o], r = t.x + 1, n = t.y + 1, s = this.images[o].data, a = s.width, c = s.height; e.RGBAImage.copy(s, i, { x: 0, y: 0 }, { x: r, y: n }, { width: a, height: c }), e.RGBAImage.copy(s, i, { x: 0, y: c - 1 }, { x: r, y: n - 1 }, { width: a, height: 1 }), e.RGBAImage.copy(s, i, { x: 0, y: 0 }, { x: r, y: n + c }, { width: a, height: 1 }), e.RGBAImage.copy(s, i, { x: a - 1, y: 0 }, { x: r - 1, y: n }, { width: 1, height: c }), e.RGBAImage.copy(s, i, { x: 0, y: 0 }, { x: r + a, y: n }, { width: 1, height: c }) } this.dirty = !0 } beginFrame() { this.callbackDispatchedThisFrame = {} } dispatchRenderCallbacks(e) { for (const t of e) { if (this.callbackDispatchedThisFrame[t]) continue; this.callbackDispatchedThisFrame[t] = !0; const e = this.images[t]; v(e) && this.updateImage(t, e) } } } const b = new e.Properties({ anchor: new e.DataConstantProperty(e.spec.light.anchor), position: new class { constructor() { this.specification = e.spec.light.position } possiblyEvaluate(t, r) { return function ([t, r, n]) { const i = e.degToRad(r + 90), o = e.degToRad(n); return { x: t * Math.cos(i) * Math.sin(o), y: t * Math.sin(i) * Math.sin(o), z: t * Math.cos(o), azimuthal: r, polar: n } }(t.expression.evaluate(r)) } interpolate(t, r, n) { return { x: e.number(t.x, r.x, n), y: e.number(t.y, r.y, n), z: e.number(t.z, r.z, n), azimuthal: e.number(t.azimuthal, r.azimuthal, n), polar: e.number(t.polar, r.polar, n) } } }, color: new e.DataConstantProperty(e.spec.light.color), intensity: new e.DataConstantProperty(e.spec.light.intensity) }), w = "-transition"; class T extends e.Evented { constructor(t) { super(), this._transitionable = new e.Transitionable(b), this.setLight(t), this._transitioning = this._transitionable.untransitioned() } getLight() { return this._transitionable.serialize() } setLight(t, r = {}) { if (!this._validate(e.validateLight, t, r)) for (const n in t) { const r = t[n]; e.endsWith(n, w) ? this._transitionable.setTransition(n.slice(0, -w.length), r) : this._transitionable.setValue(n, r) } } updateTransitions(e) { this._transitioning = this._transitionable.transitioned(e, this._transitioning) } hasTransition() { return this._transitioning.hasTransition() } recalculate(e) { this.properties = this._transitioning.possiblyEvaluate(e) } _validate(t, r, n) { return (!n || !1 !== n.validate) && e.emitValidationErrors(this, t.call(e.validateStyle, e.extend({ value: r, style: { glyphs: !0, sprite: !0 }, styleSpec: e.spec }))) } } const k = new e.Properties({ source: new e.DataConstantProperty(e.spec.terrain.source), exaggeration: new e.DataConstantProperty(e.spec.terrain.exaggeration) }), C = "-transition"; class E extends e.Evented { constructor(t, r) { super(), this._transitionable = new e.Transitionable(k), this.set(t), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = r } get() { return this._transitionable.serialize() } set(t) { for (const r in t) { const n = t[r]; e.endsWith(r, C) ? this._transitionable.setTransition(r.slice(0, -C.length), n) : this._transitionable.setValue(r, n) } } updateTransitions(e) { this._transitioning = this._transitionable.transitioned(e, this._transitioning) } hasTransition() { return this._transitioning.hasTransition() } recalculate(e) { this.properties = this._transitioning.possiblyEvaluate(e) } } const S = 45, P = 65; function I(t, r, n, i) { const o = e.smoothstep(S, P, n), [s, a] = A(t, i), c = e.length(r); let l = 1 - Math.min(1, Math.exp((c - s) / (a - s) * -6)); return l *= l * l, l = Math.min(1, 1.00747 * l), l * o * t.alpha } function A(e, t) { const r = .5 / Math.tan(.5 * t); return [e.range[0] + r, e.range[1] + r] } const L = new e.Properties({ range: new e.DataConstantProperty(e.spec.fog.range), color: new e.DataConstantProperty(e.spec.fog.color), "high-color": new e.DataConstantProperty(e.spec.fog["high-color"]), "space-color": new e.DataConstantProperty(e.spec.fog["space-color"]), "horizon-blend": new e.DataConstantProperty(e.spec.fog["horizon-blend"]), "star-intensity": new e.DataConstantProperty(e.spec.fog["star-intensity"]) }), M = "-transition"; class B extends e.Evented { constructor(t, r) { super(), this._transitionable = new e.Transitionable(L), this.set(t), this._transitioning = this._transitionable.untransitioned(), this._transform = r } get state() { const t = this._transform, r = "globe" === t.projection.name, n = e.globeToMercatorTransition(t.zoom), i = this.properties.get("range"), o = [.5, 3]; return { range: r ? [e.number(o[0], i[0], n), e.number(o[1], i[1], n)] : i, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a } } get() { return this._transitionable.serialize() } set(t, r = {}) { if (!this._validate(e.validateFog, t, r)) { for (const r of Object.keys(e.spec.fog)) t && void 0 === t[r] && (t[r] = e.spec.fog[r].default); for (const r in t) { const n = t[r]; e.endsWith(r, M) ? this._transitionable.setTransition(r.slice(0, -M.length), n) : this._transitionable.setValue(r, n) } } } getOpacity(t) { if (!this._transform.projection.supportsFog) return 0; const r = this.properties && this.properties.get("color") || 1; return ("globe" === this._transform.projection.name ? 1 : e.smoothstep(S, P, t)) * r.a } getOpacityAtLatLng(t, r) { return this._transform.projection.supportsFog ? function (t, r, n) { const i = e.MercatorCoordinate.fromLngLat(r), o = n.elevation ? n.elevation.getAtPointOrZero(i) : 0, s = [i.x, i.y, o]; return e.transformMat4(s, s, n.mercatorFogMatrix), I(t, s, n.pitch, n._fov) }(this.state, t, r) : 0 } getFovAdjustedRange(e) { return this._transform.projection.supportsFog ? A(this.state, e) : [0, 1] } updateTransitions(e) { this._transitioning = this._transitionable.transitioned(e, this._transitioning) } hasTransition() { return this._transitioning.hasTransition() } recalculate(e) { this.properties = this._transitioning.possiblyEvaluate(e) } _validate(t, r, n) { return (!n || !1 !== n.validate) && e.emitValidationErrors(this, t.call(e.validateStyle, e.extend({ value: r, style: { glyphs: !0, sprite: !0 }, styleSpec: e.spec }))) } } class R { constructor(t, r) { this.workerPool = t, this.actors = [], this.currentActor = 0, this.id = e.uniqueId(); const n = this.workerPool.acquire(this.id); for (let e = 0; e < n.length; e++) { const t = new R.Actor(n[e], r, this.id); t.name = `Worker ${e}`, this.actors.push(t) } this.ready = !1, this.broadcast("checkIfReady", null, (() => { this.ready = !0 })) } broadcast(t, r, n) { e.asyncAll(this.actors, ((e, n) => { e.send(t, r, n) }), n = n || function () { }) } getActor() { return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor] } remove() { this.actors.forEach((e => { e.remove() })), this.actors = [], this.workerPool.release(this.id) } } function D(t, r, n) { return r * (e.EXTENT / (t.tileSize * Math.pow(2, n - t.tileID.overscaledZ))) } R.Actor = e.Actor; class F { constructor(e, t, r, n) { this.screenBounds = e, this.cameraPoint = t, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = r, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, n) } static createFromScreenPoints(t, r) { let n, i; if (t instanceof e.pointGeometry || "number" == typeof t[0]) { const o = e.pointGeometry.convert(t); n = [o], i = r.isPointAboveHorizon(o) } else { const o = e.pointGeometry.convert(t[0]), s = e.pointGeometry.convert(t[1]); n = [o, s], i = e.polygonizeBounds(o, s).every((e => r.isPointAboveHorizon(e))) } return new F(n, r.getCameraPoint(), i, r) } isPointQuery() { return 1 === this.screenBounds.length } bufferedScreenGeometry(t) { return e.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t) } bufferedCameraGeometry(t) { const r = this.screenBounds[0], n = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1], i = e.polygonizeBounds(r, n, 0, !1); return this.cameraPoint.y > n.y && (this.cameraPoint.x > r.x && this.cameraPoint.x < n.x ? i.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= n.x ? i[2] = this.cameraPoint : this.cameraPoint.x <= r.x && (i[3] = this.cameraPoint)), e.bufferConvexPolygon(i, t) } bufferedCameraGeometryGlobe(t) { const r = this.screenBounds[0], n = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1], i = e.polygonizeBounds(r, n, t), o = this.cameraPoint.clone(); switch (3 * ((o.y > r.y) + (o.y > n.y)) + ((o.x > r.x) + (o.x > n.x))) { case 0: i[0] = o, i[4] = o.clone(); break; case 1: i.splice(1, 0, o); break; case 2: i[1] = o; break; case 3: i.splice(4, 0, o); break; case 5: i.splice(2, 0, o); break; case 6: i[3] = o; break; case 7: i.splice(3, 0, o); break; case 8: i[2] = o }return i } containsTile(t, r, n, i = 0) { const o = t.queryPadding / r._pixelsPerMercatorPixel + 1, s = n ? this._bufferedCameraMercator(o, r) : this._bufferedScreenMercator(o, r); let a = t.tileID.wrap + (s.unwrapped ? i : 0); const c = s.polygon.map((r => e.getTilePoint(t.tileTransform, r, a))); if (!e.polygonIntersectsBox(c, 0, 0, e.EXTENT, e.EXTENT)) return; a = t.tileID.wrap + (this.screenGeometryMercator.unwrapped ? i : 0); const l = this.screenGeometryMercator.polygon.map((r => e.getTileVec3(t.tileTransform, r, a))), u = l.map((t => new e.pointGeometry(t[0], t[1]))), h = r.getFreeCameraOptions().position || new e.MercatorCoordinate(0, 0, 0), d = e.getTileVec3(t.tileTransform, h, a), p = l.map((t => { const r = e.sub(t, t, d); return e.normalize(r, r), new e.Ray(d, r) })), f = D(t, 1, r.zoom) * r._pixelsPerMercatorPixel; return { queryGeometry: this, tilespaceGeometry: u, tilespaceRays: p, bufferedTilespaceGeometry: c, bufferedTilespaceBounds: (m = e.getBounds(c), m.min.x = e.clamp(m.min.x, 0, e.EXTENT), m.min.y = e.clamp(m.min.y, 0, e.EXTENT), m.max.x = e.clamp(m.max.x, 0, e.EXTENT), m.max.y = e.clamp(m.max.y, 0, e.EXTENT), m), tile: t, tileID: t.tileID, pixelToTileUnitsFactor: f }; var m } _bufferedScreenMercator(e, t) { const r = U(e); if (this._screenRaycastCache[r]) return this._screenRaycastCache[r]; { let n; return n = "globe" === t.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e), t) : { polygon: this.bufferedScreenGeometry(e).map((e => t.pointCoordinate3D(e))), unwrapped: !0 }, this._screenRaycastCache[r] = n, n } } _bufferedCameraMercator(e, t) { const r = U(e); if (this._cameraRaycastCache[r]) return this._cameraRaycastCache[r]; { let n; return n = "globe" === t.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e), t) : { polygon: this.bufferedCameraGeometry(e).map((e => t.pointCoordinate3D(e))), unwrapped: !0 }, this._cameraRaycastCache[r] = n, n } } _projectAndResample(t, r) { const n = function (t, r) { const n = e.multiply([], r.pixelMatrix, r.globeMatrix), i = [0, -e.GLOBE_RADIUS, 0, 1], o = [0, e.GLOBE_RADIUS, 0, 1], s = [0, 0, 0, 1]; e.transformMat4$1(i, i, n), e.transformMat4$1(o, o, n), e.transformMat4$1(s, s, n); const a = new e.pointGeometry(i[0] / i[3], i[1] / i[3]), c = new e.pointGeometry(o[0] / o[3], o[1] / o[3]), l = e.polygonContainsPoint(t, a) && i[3] < s[3], u = e.polygonContainsPoint(t, c) && o[3] < s[3]; if (!l && !u) return null; const h = function (e, t, r) { for (let n = 1; n < e.length; n++) { const i = z(t.pointCoordinate3D(e[n - 1]).x), o = z(t.pointCoordinate3D(e[n]).x); if (r < 0) { if (i < o) return { idx: n, t: -i / (o - 1 - i) } } else if (o < i) return { idx: n, t: (1 - i) / (o + 1 - i) } } return null }(t, r, l ? -1 : 1); if (!h) return null; const { idx: d, t: p } = h; let f = d > 1 ? O(t.slice(0, d), r) : [], m = d < t.length ? O(t.slice(d), r) : []; f = f.map((t => new e.pointGeometry(z(t.x), t.y))), m = m.map((t => new e.pointGeometry(z(t.x), t.y))); const g = [...f]; 0 === g.length && g.push(m[m.length - 1]); const _ = e.number(g[g.length - 1].y, (0 === m.length ? f[0] : m[0]).y, p); let y; return y = l ? [new e.pointGeometry(0, _), new e.pointGeometry(0, 0), new e.pointGeometry(1, 0), new e.pointGeometry(1, _)] : [new e.pointGeometry(1, _), new e.pointGeometry(1, 1), new e.pointGeometry(0, 1), new e.pointGeometry(0, _)], g.push(...y), 0 === m.length ? g.push(f[0]) : g.push(...m), { polygon: g.map((t => new e.MercatorCoordinate(t.x, t.y))), unwrapped: !1 } }(t, r); if (n) return n; const i = function (t, r) { let n = !1, i = -1 / 0, o = 0; for (let e = 0; e < t.length - 1; e++)t[e].x > i && (i = t[e].x, o = e); for (let e = 0; e < t.length - 1; e++) { const r = (o + e) % (t.length - 1), i = t[r], s = t[r + 1]; Math.abs(i.x - s.x) > .5 && (i.x < s.x ? (i.x += 1, 0 === r && (t[t.length - 1].x += 1)) : (s.x += 1, r + 1 === t.length - 1 && (t[0].x += 1)), n = !0) } const s = e.mercatorXfromLng(r.center.lng); return n && s < Math.abs(s - 1) && t.forEach((e => { e.x -= 1 })), { polygon: t, unwrapped: n } }(O(t, r).map((t => new e.pointGeometry(z(t.x), t.y))), r); return { polygon: i.polygon.map((t => new e.MercatorCoordinate(t.x, t.y))), unwrapped: i.unwrapped } } } function O(t, r) { return e.resample(t, (e => { const t = r.pointCoordinate3D(e); e.x = t.x, e.y = t.y }), 1 / 256) } function z(e) { return e < 0 ? 1 + e % 1 : e % 1 } function U(e) { return 100 * e | 0 } function N(t, r, n, i, o) { const s = function (n, i) { if (n) return o(n); if (i) { t.url && i.tiles && t.tiles && delete t.tiles; const n = e.pick(e.extend(i, t), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]); i.vector_layers && (n.vectorLayers = i.vector_layers, n.vectorLayerIds = n.vectorLayers.map((e => e.id))), n.tiles = r.canonicalizeTileset(n, t.url), o(null, n) } }; return t.url ? e.getJSON(r.transformRequest(r.normalizeSourceURL(t.url, null, n, i), e.ResourceType.Source), s) : e.exported.frame((() => s(null, t))) } class G { constructor(t, r, n) { this.bounds = e.LngLatBounds.convert(this.validateBounds(t)), this.minzoom = r || 0, this.maxzoom = n || 24 } validateBounds(e) { return Array.isArray(e) && 4 === e.length ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90] } contains(t) { const r = Math.pow(2, t.z), n = Math.floor(e.mercatorXfromLng(this.bounds.getWest()) * r), i = Math.floor(e.mercatorYfromLat(this.bounds.getNorth()) * r), o = Math.ceil(e.mercatorXfromLng(this.bounds.getEast()) * r), s = Math.ceil(e.mercatorYfromLat(this.bounds.getSouth()) * r); return t.x >= n && t.x < o && t.y >= i && t.y < s } } class V { constructor(e, t, r) { this.context = e; const n = e.gl; this.buffer = n.createBuffer(), this.dynamicDraw = Boolean(r), this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), n.bufferData(n.ELEMENT_ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? n.DYNAMIC_DRAW : n.STATIC_DRAW), this.dynamicDraw || t.destroy() } bind() { this.context.bindElementBuffer.set(this.buffer) } updateData(e) { const t = this.context.gl; this.context.unbindVAO(), this.bind(), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer) } destroy() { this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer) } } const q = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }; class j { constructor(e, t, r, n) { this.length = t.length, this.attributes = r, this.itemSize = t.bytesPerElement, this.dynamicDraw = n, this.context = e; const i = e.gl; this.buffer = i.createBuffer(), e.bindVertexBuffer.set(this.buffer), i.bufferData(i.ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? i.DYNAMIC_DRAW : i.STATIC_DRAW), this.dynamicDraw || t.destroy() } bind() { this.context.bindVertexBuffer.set(this.buffer) } updateData(e) { const t = this.context.gl; this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e.arrayBuffer) } enableAttributes(e, t) { for (let r = 0; r < this.attributes.length; r++) { const n = t.attributes[this.attributes[r].name]; void 0 !== n && e.enableVertexAttribArray(n) } } setVertexAttribPointers(e, t, r) { for (let n = 0; n < this.attributes.length; n++) { const i = this.attributes[n], o = t.attributes[i.name]; void 0 !== o && e.vertexAttribPointer(o, i.components, e[q[i.type]], !1, this.itemSize, i.offset + this.itemSize * (r || 0)) } } destroy() { this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer) } } class X { constructor(e) { this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1 } get() { return this.current } set(e) { } getDefault() { return this.default } setDefault() { this.set(this.default) } } class W extends X { getDefault() { return e.Color.transparent } set(e) { const t = this.current; (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1) } } class Z extends X { getDefault() { return 1 } set(e) { (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1) } } class H extends X { getDefault() { return 0 } set(e) { (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1) } } class Q extends X { getDefault() { return [!0, !0, !0, !0] } set(e) { const t = this.current; (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1) } } class $ extends X { getDefault() { return !0 } set(e) { (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1) } } class J extends X { getDefault() { return 255 } set(e) { (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1) } } class K extends X { getDefault() { return { func: this.gl.ALWAYS, ref: 0, mask: 255 } } set(e) { const t = this.current; (e.func !== t.func || e.ref !== t.ref || e.mask !== t.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1) } } class Y extends X { getDefault() { const e = this.gl; return [e.KEEP, e.KEEP, e.KEEP] } set(e) { const t = this.current; (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1) } } class ee extends X { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.current = e, this.dirty = !1 } } class te extends X { getDefault() { return [0, 1] } set(e) { const t = this.current; (e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1) } } class re extends X { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), this.current = e, this.dirty = !1 } } class ne extends X { getDefault() { return this.gl.LESS } set(e) { (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1) } } class ie extends X { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; e ? t.enable(t.BLEND) : t.disable(t.BLEND), this.current = e, this.dirty = !1 } } class oe extends X { getDefault() { const e = this.gl; return [e.ONE, e.ZERO] } set(e) { const t = this.current; (e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1) } } class se extends X { getDefault() { return e.Color.transparent } set(e) { const t = this.current; (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1) } } class ae extends X { getDefault() { return this.gl.FUNC_ADD } set(e) { (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1) } } class ce extends X { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; e ? t.enable(t.CULL_FACE) : t.disable(t.CULL_FACE), this.current = e, this.dirty = !1 } } class le extends X { getDefault() { return this.gl.BACK } set(e) { (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1) } } class ue extends X { getDefault() { return this.gl.CCW } set(e) { (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1) } } class he extends X { getDefault() { return null } set(e) { (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1) } } class de extends X { getDefault() { return this.gl.TEXTURE0 } set(e) { (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1) } } class pe extends X { getDefault() { const e = this.gl; return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight] } set(e) { const t = this.current; (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1) } } class fe extends X { getDefault() { return null } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; t.bindFramebuffer(t.FRAMEBUFFER, e), this.current = e, this.dirty = !1 } } class me extends X { getDefault() { return null } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; t.bindRenderbuffer(t.RENDERBUFFER, e), this.current = e, this.dirty = !1 } } class ge extends X { getDefault() { return null } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; t.bindTexture(t.TEXTURE_2D, e), this.current = e, this.dirty = !1 } } class _e extends X { getDefault() { return null } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; t.bindBuffer(t.ARRAY_BUFFER, e), this.current = e, this.dirty = !1 } } class ye extends X { getDefault() { return null } set(e) { const t = this.gl; t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1 } } class ve extends X { constructor(e) { super(e), this.vao = e.extVertexArrayObject } getDefault() { return null } set(e) { this.vao && (e !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e), this.current = e, this.dirty = !1) } } class xe extends X { getDefault() { return 4 } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; t.pixelStorei(t.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1 } } class be extends X { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1 } } class we extends X { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1 } } class Te extends X { constructor(e, t) { super(e), this.context = e, this.parent = t } getDefault() { return null } } class ke extends Te { setDirty() { this.dirty = !0 } set(e) { if (e === this.current && !this.dirty) return; this.context.bindFramebuffer.set(this.parent); const t = this.gl; t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1 } } class Ce extends Te { attachment() { return this.gl.DEPTH_ATTACHMENT } set(e) { if (e === this.current && !this.dirty) return; this.context.bindFramebuffer.set(this.parent); const t = this.gl; t.framebufferRenderbuffer(t.FRAMEBUFFER, this.attachment(), t.RENDERBUFFER, e), this.current = e, this.dirty = !1 } } class Ee extends Ce { attachment() { return this.gl.DEPTH_STENCIL_ATTACHMENT } } class Se { constructor(e, t, r, n) { this.context = e, this.width = t, this.height = r; const i = this.framebuffer = e.gl.createFramebuffer(); this.colorAttachment = new ke(e, i), n && (this.depthAttachment = new Ce(e, i)) } destroy() { const e = this.context.gl, t = this.colorAttachment.get(); if (t && e.deleteTexture(t), this.depthAttachment) { const t = this.depthAttachment.get(); t && e.deleteRenderbuffer(t) } e.deleteFramebuffer(this.framebuffer) } } class Pe { constructor(e, t = !1) { if (this.gl = e, this.isWebGL2 = t, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), t) { const t = e; this.extVertexArrayObject = { createVertexArrayOES: t.createVertexArray.bind(e), deleteVertexArrayOES: t.deleteVertexArray.bind(e), bindVertexArrayOES: t.bindVertexArray.bind(e) } } this.clearColor = new W(this), this.clearDepth = new Z(this), this.clearStencil = new H(this), this.colorMask = new Q(this), this.depthMask = new $(this), this.stencilMask = new J(this), this.stencilFunc = new K(this), this.stencilOp = new Y(this), this.stencilTest = new ee(this), this.depthRange = new te(this), this.depthTest = new re(this), this.depthFunc = new ne(this), this.blend = new ie(this), this.blendFunc = new oe(this), this.blendColor = new se(this), this.blendEquation = new ae(this), this.cullFace = new ce(this), this.cullFaceSide = new le(this), this.frontFace = new ue(this), this.program = new he(this), this.activeTexture = new de(this), this.viewport = new pe(this), this.bindFramebuffer = new fe(this), this.bindRenderbuffer = new me(this), this.bindTexture = new ge(this), this.bindVertexBuffer = new _e(this), this.bindElementBuffer = new ye(this), this.bindVertexArrayOES = this.extVertexArrayObject && new ve(this), this.pixelStoreUnpack = new xe(this), this.pixelStoreUnpackPremultiplyAlpha = new be(this), this.pixelStoreUnpackFlipY = new we(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = !1, this.extStandardDerivativesForceOff = !1, this.extDebugRendererInfo = e.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), t || (this.extTextureHalfFloat = e.getExtension("OES_texture_half_float")), (t || this.extTextureHalfFloat && e.getExtension("OES_texture_half_float_linear")) && (this.extRenderToTextureHalfFloat = e.getExtension("EXT_color_buffer_half_float")), this.extStandardDerivatives = t || e.getExtension("OES_standard_derivatives"), this.extTimerQuery = e.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE) } setDefault() { this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault() } setDirty() { this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0 } createIndexBuffer(e, t) { return new V(this, e, t) } createVertexBuffer(e, t, r) { return new j(this, e, t, r) } createRenderbuffer(e, t, r) { const n = this.gl, i = n.createRenderbuffer(); return this.bindRenderbuffer.set(i), n.renderbufferStorage(n.RENDERBUFFER, e, t, r), this.bindRenderbuffer.set(null), i } createFramebuffer(e, t, r) { return new Se(this, e, t, r) } clear({ color: e, depth: t, stencil: r }) { const n = this.gl; let i = 0; e && (i |= n.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), void 0 !== t && (i |= n.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t), this.depthMask.set(!0)), void 0 !== r && (i |= n.STENCIL_BUFFER_BIT, this.clearStencil.set(r), this.stencilMask.set(255)), n.clear(i) } setCullFace(e) { !1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace)) } setDepthMode(e) { e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1) } setStencilMode(e) { e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(!1) } setColorMode(r) { t(r.blendFunction, e.ColorMode.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(r.blendFunction), this.blendColor.set(r.blendColor)), this.colorMask.set(r.mask) } unbindVAO() { this.extVertexArrayObject && this.bindVertexArrayOES.set(null) } } class Ie extends e.Evented { constructor(t, r, n, i) { if (super(), this.id = t, this.dispatcher = n, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, e.extend(this, e.pick(r, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.extend({ type: "vector" }, r), this._collectResourceTiming = r.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512"); this.setEventedParent(i), this._tileWorkers = {}, this._deduped = new e.DedupedRequest } load(t) { this._loaded = !1, this.fire(new e.Event("dataloading", { dataType: "source" })); const r = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, n = this.map._worldview; this._tileJSONRequest = N(this._options, this.map._requestManager, r, n, ((i, o) => { this._tileJSONRequest = null, this._loaded = !0, i ? (r && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${r}`), n && 2 !== n.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${n}`), this.fire(new e.ErrorEvent(i))) : o && (e.extend(this, o), o.bounds && (this.tileBounds = new G(o.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(o.tiles, this.map._requestManager._customAccessToken), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }))), t && t(i) })) } loaded() { return this._loaded } hasTile(e) { return !this.tileBounds || this.tileBounds.contains(e.canonical) } onAdd(e) { this.map = e, this.load() } reload() { this.cancelTileJSONRequest(), this.load((() => this.map.style._clearSource(this.id))) } setTiles(e) { return this._options.tiles = e, this.reload(), this } setUrl(e) { return this.url = e, this._options.url = e, this.reload(), this } onRemove() { this.cancelTileJSONRequest() } serialize() { return e.extend({}, this._options) } loadTile(t, r) { const n = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme)), i = { request: this.map._requestManager.transformRequest(n, e.ResourceType.Tile), data: void 0, uid: t.uid, tileID: t.tileID, tileZoom: t.tileZoom, zoom: t.tileID.overscaledZ, tileSize: this.tileSize * t.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: e.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t.isSymbolTile }; if (i.request.collectResourceTiming = this._collectResourceTiming, t.actor && "expired" !== t.state) "loading" === t.state ? t.reloadCallback = r : t.request = t.actor.send("reloadTile", i, o.bind(this)); else if (t.actor = this._tileWorkers[n] = this._tileWorkers[n] || this.dispatcher.getActor(), this.dispatcher.ready) t.request = t.actor.send("loadTile", i, o.bind(this), void 0, !0); else { const r = e.loadVectorTile.call({ deduped: this._deduped }, i, ((e, r) => { e || !r ? o.call(this, e) : (i.data = { cacheControl: r.cacheControl, expires: r.expires, rawData: r.rawData.slice(0) }, t.actor && t.actor.send("loadTile", i, o.bind(this), void 0, !0)) }), !0); t.request = { cancel: r } } function o(n, i) { return delete t.request, t.aborted ? r(null) : n && 404 !== n.status ? r(n) : (i && i.resourceTiming && (t.resourceTiming = i.resourceTiming), this.map._refreshExpiredTiles && i && t.setExpiryData(i), t.loadVectorData(i, this.map.painter), e.cacheEntryPossiblyAdded(this.dispatcher), r(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), t.reloadCallback = null))) } } abortTile(e) { e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send("abortTile", { uid: e.uid, type: this.type, source: this.id }) } unloadTile(e) { e.unloadVectorData(), e.actor && e.actor.send("removeTile", { uid: e.uid, type: this.type, source: this.id }) } hasTransition() { return !1 } afterUpdate() { this._tileWorkers = {} } cancelTileJSONRequest() { this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null) } } class Ae extends e.Evented { constructor(t, r, n, i) { super(), this.id = t, this.dispatcher = n, this.setEventedParent(i), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = e.extend({ type: "raster" }, r), e.extend(this, e.pick(r, ["url", "scheme", "tileSize"])) } load(t) { this._loaded = !1, this.fire(new e.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = N(this._options, this.map._requestManager, null, null, ((r, n) => { this._tileJSONRequest = null, this._loaded = !0, r ? this.fire(new e.ErrorEvent(r)) : n && (e.extend(this, n), n.bounds && (this.tileBounds = new G(n.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(n.tiles), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" }))), t && t(r) })) } loaded() { return this._loaded } onAdd(e) { this.map = e, this.load() } reload() { this.cancelTileJSONRequest(), this.load((() => this.map.style._clearSource(this.id))) } setTiles(e) { return this._options.tiles = e, this.reload(), this } setUrl(e) { return this.url = e, this._options.url = e, this.reload(), this } onRemove() { this.cancelTileJSONRequest() } serialize() { return e.extend({}, this._options) } hasTile(e) { return !this.tileBounds || this.tileBounds.contains(e.canonical) } loadTile(t, r) { const n = e.exported.devicePixelRatio >= 2, i = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), n, this.tileSize); t.request = e.getImage(this.map._requestManager.transformRequest(i, e.ResourceType.Tile), ((n, i, o, s) => (delete t.request, t.aborted ? (t.state = "unloaded", r(null)) : n ? (t.state = "errored", r(n)) : i ? (this.map._refreshExpiredTiles && t.setExpiryData({ cacheControl: o, expires: s }), t.setTexture(i, this.map.painter), t.state = "loaded", e.cacheEntryPossiblyAdded(this.dispatcher), void r(null)) : r(null)))) } static loadTileData(e, t, r) { e.setTexture(t, r) } static unloadTileData(e, t) { e.texture && t.saveTileTexture(e.texture) } abortTile(e, t) { e.request && (e.request.cancel(), delete e.request), t() } unloadTile(e, t) { e.texture && this.map.painter.saveTileTexture(e.texture), t() } hasTransition() { return !1 } cancelTileJSONRequest() { this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null) } } let Le; function Me(t, r, n, i, o, s, a, c) { const l = [t, n, o, r, i, s, 1, 1, 1], u = [a, c, 1], h = e.adjoint([], l), [d, p, f] = e.transformMat3(u, u, e.transpose(h, h)); return e.multiply$1(l, [d, 0, 0, 0, p, 0, 0, 0, f], l) } class Be extends e.Evented { constructor(e, t, r, n) { super(), this.id = e, this.dispatcher = r, this.coordinates = t.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(n), this.options = t, this._dirty = !1 } load(t, r) { this._loaded = r || !1, this.fire(new e.Event("dataloading", { dataType: "source" })), this.url = this.options.url, this._imageRequest = e.getImage(this.map._requestManager.transformRequest(this.url, e.ResourceType.Image), ((r, n) => { if (this._imageRequest = null, this._loaded = !0, r) this.fire(new e.ErrorEvent(r)); else if (n) { const { HTMLImageElement: r } = e.window; this.image = n instanceof r ? e.exported.getImageData(n) : n, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, t && (this.coordinates = t), this._finishLoading() } })) } loaded() { return this._loaded } updateImage(e) { return this.image && e.url ? (this._imageRequest && e.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e.url, this.load(e.coordinates, this._loaded), this) : this } _finishLoading() { this.map && (this.setCoordinates(this.coordinates), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" }))) } onAdd(e) { this.map = e, this.load() } onRemove() { this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), this.texture && this.texture.destroy() } setCoordinates(t) { this.coordinates = t, this._boundsArray = void 0; const r = t.map(e.MercatorCoordinate.fromLngLat); return this.tileID = function (t) { let r = 1 / 0, n = 1 / 0, i = -1 / 0, o = -1 / 0; for (const e of t) r = Math.min(r, e.x), n = Math.min(n, e.y), i = Math.max(i, e.x), o = Math.max(o, e.y); const s = Math.max(i - r, o - n), a = Math.max(0, Math.floor(-Math.log(s) / Math.LN2)), c = Math.pow(2, a); return new e.CanonicalTileID(a, Math.floor((r + i) / 2 * c), Math.floor((n + o) / 2 * c)) }(r), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" })), this } _clear() { this._boundsArray = void 0 } _prepareData(t) { for (const e in this.tiles) { const t = this.tiles[e]; "loaded" !== t.state && (t.state = "loaded", t.texture = this.texture) } if (this._boundsArray) return; const r = e.tileTransform(this.tileID, this.map.transform.projection), [n, i, o, s] = this.coordinates.map((t => { const n = r.projection.project(t[0], t[1]); return e.getTilePoint(r, n)._round() })); this.perspectiveTransform = function (t, r, n, i, o, s, a, c, l, u) { const h = Me(0, 0, t, 0, 0, r, t, r), d = Me(n, i, o, s, a, c, l, u); return e.multiply$1(d, e.adjoint(h, h), d), [d[6] / d[8] * t / e.EXTENT, d[7] / d[8] * r / e.EXTENT] }(this.width, this.height, n.x, n.y, i.x, i.y, s.x, s.y, o.x, o.y); const a = this._boundsArray = new e.StructArrayLayout4i8; a.emplaceBack(n.x, n.y, 0, 0), a.emplaceBack(i.x, i.y, e.EXTENT, 0), a.emplaceBack(s.x, s.y, 0, e.EXTENT), a.emplaceBack(o.x, o.y, e.EXTENT, e.EXTENT), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = t.createVertexBuffer(a, e.boundsAttributes.members), this.boundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2) } prepare() { if (0 === Object.keys(this.tiles).length || !this.image) return; const t = this.map.painter.context, r = t.gl; this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new e.Texture(t, this.image, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE)), this._dirty = !1), this._prepareData(t) } loadTile(e, t) { this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}, t(null)) : (e.state = "errored", t(null)) } serialize() { return { type: "image", url: this.options.url, coordinates: this.coordinates } } hasTransition() { return !1 } } const Re = { vector: Ie, raster: Ae, "raster-dem": class extends Ae { constructor(t, r, n, i) { super(t, r, n, i), this.type = "raster-dem", this.maxzoom = 22, this._options = e.extend({ type: "raster-dem" }, r), this.encoding = r.encoding || "mapbox" } loadTile(t, r) { const n = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize); function i(e, n) { e && (t.state = "errored", r(e)), n && (t.dem = n, t.dem.onDeserialize(), t.needsHillshadePrepare = !0, t.needsDEMTextureUpload = !0, t.state = "loaded", r(null)) } t.request = e.getImage(this.map._requestManager.transformRequest(n, e.ResourceType.Tile), function (n, o, s, a) { if (delete t.request, t.aborted) t.state = "unloaded", r(null); else if (n) t.state = "errored", r(n); else if (o) { this.map._refreshExpiredTiles && t.setExpiryData({ cacheControl: s, expires: a }); const r = e.window.ImageBitmap && o instanceof e.window.ImageBitmap && (null == Le && (Le = e.window.OffscreenCanvas && new e.window.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof e.window.createImageBitmap), Le), n = 1 - (o.width - e.prevPowerOfTwo(o.width)) / 2; n < 1 || t.neighboringTiles || (t.neighboringTiles = this._getNeighboringTiles(t.tileID)); const c = r ? o : e.exported.getImageData(o, n), l = { uid: t.uid, coord: t.tileID, source: this.id, rawImageData: c, encoding: this.encoding, padding: n }; t.actor && "expired" !== t.state || (t.actor = this.dispatcher.getActor(), t.actor.send("loadDEMTile", l, i.bind(this), void 0, !0)) } }.bind(this)) } _getNeighboringTiles(t) { const r = t.canonical, n = Math.pow(2, r.z), i = (r.x - 1 + n) % n, o = 0 === r.x ? t.wrap - 1 : t.wrap, s = (r.x + 1 + n) % n, a = r.x + 1 === n ? t.wrap + 1 : t.wrap, c = {}; return c[new e.OverscaledTileID(t.overscaledZ, o, r.z, i, r.y).key] = { backfilled: !1 }, c[new e.OverscaledTileID(t.overscaledZ, a, r.z, s, r.y).key] = { backfilled: !1 }, r.y > 0 && (c[new e.OverscaledTileID(t.overscaledZ, o, r.z, i, r.y - 1).key] = { backfilled: !1 }, c[new e.OverscaledTileID(t.overscaledZ, t.wrap, r.z, r.x, r.y - 1).key] = { backfilled: !1 }, c[new e.OverscaledTileID(t.overscaledZ, a, r.z, s, r.y - 1).key] = { backfilled: !1 }), r.y + 1 < n && (c[new e.OverscaledTileID(t.overscaledZ, o, r.z, i, r.y + 1).key] = { backfilled: !1 }, c[new e.OverscaledTileID(t.overscaledZ, t.wrap, r.z, r.x, r.y + 1).key] = { backfilled: !1 }, c[new e.OverscaledTileID(t.overscaledZ, a, r.z, s, r.y + 1).key] = { backfilled: !1 }), c } unloadTile(e) { e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded" } }, geojson: class extends e.Evented { constructor(t, r, n, i) { super(), this.id = t, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = n.getActor(), this.setEventedParent(i), this._data = r.data, this._options = e.extend({}, r), this._collectResourceTiming = r.collectResourceTiming, void 0 !== r.maxzoom && (this.maxzoom = r.maxzoom), r.type && (this.type = r.type), r.attribution && (this.attribution = r.attribution), this.promoteId = r.promoteId; const o = e.EXTENT / this.tileSize; this.workerOptions = e.extend({ source: this.id, cluster: r.cluster || !1, geojsonVtOptions: { buffer: (void 0 !== r.buffer ? r.buffer : 128) * o, tolerance: (void 0 !== r.tolerance ? r.tolerance : .375) * o, extent: e.EXTENT, maxZoom: this.maxzoom, lineMetrics: r.lineMetrics || !1, generateId: r.generateId || !1 }, superclusterOptions: { maxZoom: void 0 !== r.clusterMaxZoom ? r.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, r.clusterMinPoints || 2), extent: e.EXTENT, radius: (void 0 !== r.clusterRadius ? r.clusterRadius : 50) * o, log: !1, generateId: r.generateId || !1 }, clusterProperties: r.clusterProperties, filter: r.filter }, r.workerOptions) } onAdd(e) { this.map = e, this.setData(this._data) } setData(e) { return this._data = e, this._updateWorkerData(), this } getClusterExpansionZoom(e, t) { return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e, source: this.id }, t), this } getClusterChildren(e, t) { return this.actor.send("geojson.getClusterChildren", { clusterId: e, source: this.id }, t), this } getClusterLeaves(e, t, r, n) { return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: e, limit: t, offset: r }, n), this } _updateWorkerData() { if (this._pendingLoad) return void (this._coalesce = !0); this.fire(new e.Event("dataloading", { dataType: "source" })), this._loaded = !1; const t = e.extend({}, this.workerOptions), r = this._data; "string" == typeof r ? (t.request = this.map._requestManager.transformRequest(e.exported.resolveURL(r), e.ResourceType.Source), t.request.collectResourceTiming = this._collectResourceTiming) : t.data = JSON.stringify(r), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t, ((t, r) => { if (this._loaded = !0, this._pendingLoad = null, t) this.fire(new e.ErrorEvent(t)); else { const t = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" }; this._collectResourceTiming && r && r.resourceTiming && r.resourceTiming[this.id] && (t.resourceTiming = r.resourceTiming[this.id]), this.fire(new e.Event("data", t)), this._metadataFired = !0 } this._coalesce && (this._updateWorkerData(), this._coalesce = !1) })) } loaded() { return this._loaded } loadTile(t, r) { const n = t.actor ? "reloadTile" : "loadTile"; t.actor = this.actor, t.request = this.actor.send(n, { type: this.type, uid: t.uid, tileID: t.tileID, tileZoom: t.tileZoom, zoom: t.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: e.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, ((e, i) => (delete t.request, t.unloadVectorData(), t.aborted ? r(null) : e ? r(e) : (t.loadVectorData(i, this.map.painter, "reloadTile" === n), r(null)))), void 0, "loadTile" === n) } abortTile(e) { e.request && (e.request.cancel(), delete e.request), e.aborted = !0 } unloadTile(e) { e.unloadVectorData(), this.actor.send("removeTile", { uid: e.uid, type: this.type, source: this.id }) } onRemove() { this._pendingLoad && this._pendingLoad.cancel() } serialize() { return e.extend({}, this._options, { type: this.type, data: this._data }) } hasTransition() { return !1 } }, video: class extends Be { constructor(e, t, r, n) { super(e, t, r, n), this.roundZoom = !0, this.type = "video", this.options = t } load() { this._loaded = !1; const t = this.options; this.urls = []; for (const r of t.urls) this.urls.push(this.map._requestManager.transformRequest(r, e.ResourceType.Source).url); e.getVideo(this.urls, ((t, r) => { this._loaded = !0, t ? this.fire(new e.ErrorEvent(t)) : r && (this.video = r, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", (() => { this.map.triggerRepaint() })), this.map && this.video.play(), this._finishLoading()) })) } pause() { this.video && this.video.pause() } play() { this.video && this.video.play() } seek(t) { if (this.video) { const r = this.video.seekable; t < r.start(0) || t > r.end(0) ? this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${r.start(0)} and ${r.end(0)}-second mark.`))) : this.video.currentTime = t } } getVideo() { return this.video } onAdd(e) { this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates))) } prepare() { if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return; const t = this.map.painter.context, r = t.gl; this.texture ? this.video.paused || (this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE), r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, r.RGBA, r.UNSIGNED_BYTE, this.video)) : (this.texture = new e.Texture(t, this.video, r.RGBA), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t) } serialize() { return { type: "video", urls: this.urls, coordinates: this.coordinates } } hasTransition() { return this.video && !this.video.paused } }, image: Be, canvas: class extends Be { constructor(t, r, n, i) { super(t, r, n, i), r.coordinates ? Array.isArray(r.coordinates) && 4 === r.coordinates.length && !r.coordinates.some((e => !Array.isArray(e) || 2 !== e.length || e.some((e => "number" != typeof e)))) || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'missing required property "coordinates"'))), r.animate && "boolean" != typeof r.animate && this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'optional "animate" property must be a boolean value'))), r.canvas ? "string" == typeof r.canvas || r.canvas instanceof e.window.HTMLCanvasElement || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'missing required property "canvas"'))), this.options = r, this.animate = void 0 === r.animate || r.animate } load() { this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof e.window.HTMLCanvasElement ? this.options.canvas : e.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () { this._playing = !0, this.map.triggerRepaint() }, this.pause = function () { this._playing && (this.prepare(), this._playing = !1) }, this._finishLoading()) } getCanvas() { return this.canvas } onAdd(e) { this.map = e, this.load(), this.canvas && this.animate && this.play() } onRemove() { this.pause() } prepare() { let t = !1; if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), this._hasInvalidDimensions()) return; if (0 === Object.keys(this.tiles).length) return; const r = this.map.painter.context; this.texture ? (t || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new e.Texture(r, this.canvas, r.gl.RGBA, { premultiply: !0 }), this._prepareData(r) } serialize() { return { type: "canvas", coordinates: this.coordinates } } hasTransition() { return this._playing } _hasInvalidDimensions() { for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0; return !1 } }, custom: class extends e.Evented { constructor(t, r, n, i) { super(), this.id = t, this.type = "custom", this._dataType = "raster", this._dispatcher = n, this._implementation = r, this.setEventedParent(i), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new e.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new G(this._implementation.bounds, this.minzoom, this.maxzoom)), r.update = this._update.bind(this), r.clearTiles = this._clearTiles.bind(this), r.coveringTiles = this._coveringTiles.bind(this), e.extend(this, e.pick(r, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"])) } serialize() { return e.pick(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]) } load() { this._loaded = !0, this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" })) } loaded() { return this._loaded } onAdd(t) { this._map = t, this._loaded = !1, this.fire(new e.Event("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(t), this.load() } onRemove(e) { this._implementation.onRemove && this._implementation.onRemove(e) } hasTile(e) { if (this._implementation.hasTile) { const { x: t, y: r, z: n } = e.canonical; return this._implementation.hasTile({ x: t, y: r, z: n }) } return !this.tileBounds || this.tileBounds.contains(e.canonical) } loadTile(t, r) { const { x: n, y: i, z: o } = t.tileID.canonical, s = new e.window.AbortController; t.request = Promise.resolve(this._implementation.loadTile({ x: n, y: i, z: o }, { signal: s.signal })).then(function (n) { return delete t.request, t.aborted ? (t.state = "unloaded", r(null)) : void 0 === n ? (t.state = "errored", r(null)) : null === n ? (this.loadTileData(t, { width: this.tileSize, height: this.tileSize, data: null }), t.state = "loaded", r(null)) : function (t) { return t instanceof e.window.ImageData || t instanceof e.window.HTMLCanvasElement || t instanceof e.window.ImageBitmap || t instanceof e.window.HTMLImageElement }(n) ? (this.loadTileData(t, n), t.state = "loaded", void r(null)) : (t.state = "errored", r(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`))) }.bind(this)).catch((e => { 20 !== e.code && (t.state = "errored", r(e)) })), t.request.cancel = () => s.abort() } loadTileData(e, t) { Ae.loadTileData(e, t, this._map.painter) } unloadTileData(e) { Ae.unloadTileData(e, this._map.painter) } unloadTile(e, t) { if (this.unloadTileData(e), this._implementation.unloadTile) { const { x: t, y: r, z: n } = e.tileID.canonical; this._implementation.unloadTile({ x: t, y: r, z: n }) } t() } abortTile(e, t) { e.request && e.request.cancel && (e.request.cancel(), delete e.request), t() } hasTransition() { return !1 } _coveringTiles() { return this._map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e => ({ x: e.canonical.x, y: e.canonical.y, z: e.canonical.z }))) } _clearTiles() { this._map.style._clearSource(this.id) } _update() { this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" })) } } }, De = function (t, r, n, i) { const o = new Re[r.type](t, r, n, i); if (o.id !== t) throw new Error(`Expected Source id to be ${t} instead of ${o.id}`); return e.bindAll(["load", "abort", "unload", "serialize", "prepare"], o), o }; function Fe(t, r) { const n = e.identity([]); return e.scale(n, n, [.5 * t.width, .5 * -t.height, 1]), e.translate(n, n, [1, -1, 0]), e.multiply(n, n, t.calculateProjMatrix(r.toUnwrapped())), Float32Array.from(n) } function Oe(e, t, r, n, i, o, s, a = !1) { const c = e.tilesIn(n, s, a); c.sort(Ue); const l = []; for (const h of c) l.push({ wrappedTileID: h.tile.tileID.wrapped().key, queryResults: h.tile.queryRenderedFeatures(t, r, e._state, h, i, o, Fe(e.transform, h.tile.tileID), a) }); const u = function (e) { const t = {}, r = {}; for (const n of e) { const e = n.queryResults, i = n.wrappedTileID, o = r[i] = r[i] || {}; for (const r in e) { const n = e[r], i = o[r] = o[r] || {}, s = t[r] = t[r] || []; for (const e of n) i[e.featureIndex] || (i[e.featureIndex] = !0, s.push(e)) } } return t }(l); for (const h in u) u[h].forEach((t => { const r = t.feature, n = r.layer; n && "background" !== n.type && "sky" !== n.type && (r.source = n.source, n["source-layer"] && (r.sourceLayer = n["source-layer"]), r.state = void 0 !== r.id ? e.getFeatureState(n["source-layer"], r.id) : {}) })); return u } function ze(e, t) { const r = e.getRenderableIds().map((t => e.getTileByID(t))), n = [], i = {}; for (let o = 0; o < r.length; o++) { const e = r[o], s = e.tileID.canonical.key; i[s] || (i[s] = !0, e.querySourceFeatures(n, t)) } return n } function Ue(e, t) { const r = e.tileID, n = t.tileID; return r.overscaledZ - n.overscaledZ || r.canonical.y - n.canonical.y || r.wrap - n.wrap || r.canonical.x - n.canonical.x } function Ne() { return null != To.workerClass ? new To.workerClass : new e.window.Worker(To.workerUrl) } const Ge = "mapboxgl_preloaded_worker_pool"; class Ve { constructor() { this.active = {} } acquire(e) { if (!this.workers) for (this.workers = []; this.workers.length < Ve.workerCount;)this.workers.push(new Ne); return this.active[e] = !0, this.workers.slice() } release(e) { delete this.active[e], 0 === this.numActive() && (this.workers.forEach((e => { e.terminate() })), this.workers = null) } isPreloaded() { return !!this.active[Ge] } numActive() { return Object.keys(this.active).length } } let qe; function je() { return qe || (qe = new Ve), qe } function Xe(t, r) { const n = {}; for (const e in t) "ref" !== e && (n[e] = t[e]); return e.refProperties.forEach((e => { e in r && (n[e] = r[e]) })), n } function We(e) { e = e.slice(); const t = Object.create(null); for (let r = 0; r < e.length; r++)t[e[r].id] = e[r]; for (let r = 0; r < e.length; r++)"ref" in e[r] && (e[r] = Xe(e[r], t[e[r].ref])); return e } Ve.workerCount = 2; const Ze = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setProjection: "setProjection" }; function He(e, t, r) { r.push({ command: Ze.addSource, args: [e, t[e]] }) } function Qe(e, t, r) { t.push({ command: Ze.removeSource, args: [e] }), r[e] = !0 } function $e(e, t, r, n) { Qe(e, r, n), He(e, t, r) } function Je(e, r, n) { let i; for (i in e[n]) if (e[n].hasOwnProperty(i) && "data" !== i && !t(e[n][i], r[n][i])) return !1; for (i in r[n]) if (r[n].hasOwnProperty(i) && "data" !== i && !t(e[n][i], r[n][i])) return !1; return !0 } function Ke(e, r, n, i, o, s) { let a; for (a in r = r || {}, e = e || {}) e.hasOwnProperty(a) && (t(e[a], r[a]) || n.push({ command: s, args: [i, a, r[a], o] })); for (a in r) r.hasOwnProperty(a) && !e.hasOwnProperty(a) && (t(e[a], r[a]) || n.push({ command: s, args: [i, a, r[a], o] })) } function Ye(e) { return e.id } function et(e, t) { return e[t.id] = t, e } class tt { constructor(e, t) { this.reset(e, t) } reset(e, t) { this.points = e || [], this._distances = [0]; for (let r = 1; r < this.points.length; r++)this._distances[r] = this._distances[r - 1] + this.points[r].dist(this.points[r - 1]); this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding } lerp(t) { if (1 === this.points.length) return this.points[0]; t = e.clamp(t, 0, 1); let r = 1, n = this._distances[r]; const i = t * this.paddedLength + this.padding; for (; n < i && r < this._distances.length;)n = this._distances[++r]; const o = r - 1, s = this._distances[o], a = n - s, c = a > 0 ? (i - s) / a : 0; return this.points[o].mult(1 - c).add(this.points[r].mult(c)) } } class rt { constructor(e, t, r) { const n = this.boxCells = [], i = this.circleCells = []; this.xCellCount = Math.ceil(e / r), this.yCellCount = Math.ceil(t / r); for (let o = 0; o < this.xCellCount * this.yCellCount; o++)n.push([]), i.push([]); this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t, this.boxUid = 0, this.circleUid = 0 } keysLength() { return this.boxKeys.length + this.circleKeys.length } insert(e, t, r, n, i) { this._forEachCell(t, r, n, i, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i) } insertCircle(e, t, r, n) { this._forEachCell(t - n, r - n, t + n, r + n, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t), this.circles.push(r), this.circles.push(n) } _insertBoxCell(e, t, r, n, i, o) { this.boxCells[i].push(o) } _insertCircleCell(e, t, r, n, i, o) { this.circleCells[i].push(o) } _query(e, t, r, n, i, o) { if (r < 0 || e > this.width || n < 0 || t > this.height) return !i && []; const s = []; if (e <= 0 && t <= 0 && this.width <= r && this.height <= n) { if (i) return !0; for (let e = 0; e < this.boxKeys.length; e++)s.push({ key: this.boxKeys[e], x1: this.bboxes[4 * e], y1: this.bboxes[4 * e + 1], x2: this.bboxes[4 * e + 2], y2: this.bboxes[4 * e + 3] }); for (let e = 0; e < this.circleKeys.length; e++) { const t = this.circles[3 * e], r = this.circles[3 * e + 1], n = this.circles[3 * e + 2]; s.push({ key: this.circleKeys[e], x1: t - n, y1: r - n, x2: t + n, y2: r + n }) } return o ? s.filter(o) : s } return this._forEachCell(e, t, r, n, this._queryCell, s, { hitTest: i, seenUids: { box: {}, circle: {} } }, o), i ? s.length > 0 : s } _queryCircle(e, t, r, n, i) { const o = e - r, s = e + r, a = t - r, c = t + r; if (s < 0 || o > this.width || c < 0 || a > this.height) return !n && []; const l = []; return this._forEachCell(o, a, s, c, this._queryCellCircle, l, { hitTest: n, circle: { x: e, y: t, radius: r }, seenUids: { box: {}, circle: {} } }, i), n ? l.length > 0 : l } query(e, t, r, n, i) { return this._query(e, t, r, n, !1, i) } hitTest(e, t, r, n, i) { return this._query(e, t, r, n, !0, i) } hitTestCircle(e, t, r, n) { return this._queryCircle(e, t, r, !0, n) } _queryCell(e, t, r, n, i, o, s, a) { const c = s.seenUids, l = this.boxCells[i]; if (null !== l) { const i = this.bboxes; for (const u of l) if (!c.box[u]) { c.box[u] = !0; const l = 4 * u; if (e <= i[l + 2] && t <= i[l + 3] && r >= i[l + 0] && n >= i[l + 1] && (!a || a(this.boxKeys[u]))) { if (s.hitTest) return o.push(!0), !0; o.push({ key: this.boxKeys[u], x1: i[l], y1: i[l + 1], x2: i[l + 2], y2: i[l + 3] }) } } } const u = this.circleCells[i]; if (null !== u) { const i = this.circles; for (const l of u) if (!c.circle[l]) { c.circle[l] = !0; const u = 3 * l; if (this._circleAndRectCollide(i[u], i[u + 1], i[u + 2], e, t, r, n) && (!a || a(this.circleKeys[l]))) { if (s.hitTest) return o.push(!0), !0; { const e = i[u], t = i[u + 1], r = i[u + 2]; o.push({ key: this.circleKeys[l], x1: e - r, y1: t - r, x2: e + r, y2: t + r }) } } } } } _queryCellCircle(e, t, r, n, i, o, s, a) { const c = s.circle, l = s.seenUids, u = this.boxCells[i]; if (null !== u) { const e = this.bboxes; for (const t of u) if (!l.box[t]) { l.box[t] = !0; const r = 4 * t; if (this._circleAndRectCollide(c.x, c.y, c.radius, e[r + 0], e[r + 1], e[r + 2], e[r + 3]) && (!a || a(this.boxKeys[t]))) return o.push(!0), !0 } } const h = this.circleCells[i]; if (null !== h) { const e = this.circles; for (const t of h) if (!l.circle[t]) { l.circle[t] = !0; const r = 3 * t; if (this._circlesCollide(e[r], e[r + 1], e[r + 2], c.x, c.y, c.radius) && (!a || a(this.circleKeys[t]))) return o.push(!0), !0 } } } _forEachCell(e, t, r, n, i, o, s, a) { const c = this._convertToXCellCoord(e), l = this._convertToYCellCoord(t), u = this._convertToXCellCoord(r), h = this._convertToYCellCoord(n); for (let d = c; d <= u; d++)for (let c = l; c <= h; c++)if (i.call(this, e, t, r, n, this.xCellCount * c + d, o, s, a)) return } _convertToXCellCoord(e) { return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale))) } _convertToYCellCoord(e) { return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale))) } _circlesCollide(e, t, r, n, i, o) { const s = n - e, a = i - t, c = r + o; return c * c > s * s + a * a } _circleAndRectCollide(e, t, r, n, i, o, s) { const a = (o - n) / 2, c = Math.abs(e - (n + a)); if (c > a + r) return !1; const l = (s - i) / 2, u = Math.abs(t - (i + l)); if (u > l + r) return !1; if (c <= a || u <= l) return !0; const h = c - a, d = u - l; return h * h + d * d <= r * r } } const nt = { unknown: 0, flipRequired: 1, flipNotRequired: 2 }, it = Math.tan(85 * Math.PI / 180); function ot(t, r, n, i, o, s, a) { const c = e.create(); if (n) if ("globe" === s.name) { const t = e.calculateGlobeLabelMatrix(o, r); e.multiply(c, c, t) } else { const t = y([], a); c[0] = t[0], c[1] = t[1], c[4] = t[2], c[5] = t[3], i || e.rotateZ(c, c, o.angle) } else e.multiply(c, o.labelPlaneMatrix, t); return c } function st(e, t, r, n, i, o, s) { const a = ot(e, t, r, n, i, o, s); return "globe" === o.name && r || (a[2] = a[6] = a[10] = a[14] = 0), a } function at(t, r, n, i, o, s, a) { if (n) { if ("globe" === s.name) { const c = ot(t, r, n, i, o, s, a); return e.invert(c, c), e.multiply(c, t, c), c } { const r = e.clone(t), n = e.identity([]); return n[0] = a[0], n[1] = a[1], n[4] = a[2], n[5] = a[3], e.multiply(r, r, n), i || e.rotateZ(r, r, -o.angle), r } } return o.glCoordMatrix } function ct(t, r, n, i) { const o = [t, r, n, 1]; n ? e.transformMat4$1(o, o, i) : vt(o, o, i); const s = o[3]; return o[0] /= s, o[1] /= s, o[2] /= s, o } function lt(e, t) { return Math.min(.5 + e / t * .5, 1.5) } function ut(e, t) { const r = e[0] / e[3], n = e[1] / e[3]; return r >= -t[0] && r <= t[0] && n >= -t[1] && n <= t[1] } function ht(t, r, n, i, o, s, a, c, l, u) { const h = n.transform, d = i ? t.textSizeData : t.iconSizeData, p = e.evaluateSizeForZoom(d, n.transform.zoom), f = "globe" === h.projection.name, m = [256 / n.width * 2 + 1, 256 / n.height * 2 + 1], g = i ? t.text.dynamicLayoutVertexArray : t.icon.dynamicLayoutVertexArray; g.clear(); let _ = null; f && (_ = i ? t.text.globeExtVertexArray : t.icon.globeExtVertexArray); const y = t.lineVertexArray, v = i ? t.text.placedSymbolArray : t.icon.placedSymbolArray, x = n.transform.width / n.transform.height; let b, w = !1; for (let T = 0; T < v.length; T++) { const i = v.get(T), { numGlyphs: f, writingMode: k } = i; if (k !== e.WritingMode.vertical || w || b === e.WritingMode.horizontal || (w = !0), b = k, (i.hidden || k === e.WritingMode.vertical) && !w) { yt(f, g); continue } w = !1; const C = new e.pointGeometry(i.tileAnchorX, i.tileAnchorY); let { x: E, y: S, z: P } = h.projection.projectTilePoint(C.x, C.y, u.canonical); if (l) { const [e, t, r] = l(C); E += e, S += t, P += r } const I = [E, S, P, 1]; if (e.transformMat4$1(I, I, r), !ut(I, m)) { yt(f, g); continue } const A = lt(n.transform.cameraToCenterDistance, I[3]), L = e.evaluateSizeForFeature(d, p, i), M = a ? L / A : L * A, B = ct(E, S, P, o); if (B[3] <= 0) { yt(f, g); continue } let R = {}; const D = a ? null : l, F = ft(i, M, !1, c, r, o, s, t.glyphOffsetArray, y, g, _, B, C, R, x, D, h.projection, u, a); w = F.useVertical, D && F.needsFlipping && (R = {}), (F.notEnoughRoom || w || F.needsFlipping && ft(i, M, !0, c, r, o, s, t.glyphOffsetArray, y, g, _, B, C, R, x, D, h.projection, u, a).notEnoughRoom) && yt(f, g) } i ? (t.text.dynamicLayoutVertexBuffer.updateData(g), _ && t.text.globeExtVertexBuffer.updateData(_)) : (t.icon.dynamicLayoutVertexBuffer.updateData(g), _ && t.icon.globeExtVertexBuffer.updateData(_)) } function dt(e, t, r, n, i, o, s, a, c, l, u, h, d, p, f, m) { const { lineStartIndex: g, glyphStartIndex: _, segment: y } = a, v = _ + a.numGlyphs, x = g + a.lineLength, b = t.getoffsetX(_), w = t.getoffsetX(v - 1), T = _t(e * b, r, n, i, o, s, y, g, x, c, l, u, h, d, !0, p, f, m); if (!T) return null; const k = _t(e * w, r, n, i, o, s, y, g, x, c, l, u, h, d, !0, p, f, m); return k ? { first: T, last: k } : null } function pt(t, r, n, i) { return t === e.WritingMode.horizontal && Math.abs(i) > Math.abs(n) ? { useVertical: !0 } : t === e.WritingMode.vertical ? i > 0 ? { needsFlipping: !0 } : null : r !== nt.unknown && function (e, t) { return 0 === e || Math.abs(t / e) > it }(n, i) ? r === nt.flipRequired ? { needsFlipping: !0 } : null : n < 0 ? { needsFlipping: !0 } : null } function ft(t, r, n, i, o, s, a, c, l, u, h, d, p, f, m, g, _, y, v) { const x = r / 24, b = t.lineOffsetX * x, w = t.lineOffsetY * x, { lineStartIndex: T, glyphStartIndex: k, numGlyphs: C, segment: E, writingMode: S, flipState: P } = t, I = T + t.lineLength, A = t => { if (h) { const [r, n, i] = t.up, o = u.length; e.updateGlobeVertexNormal(h, o + 0, r, n, i), e.updateGlobeVertexNormal(h, o + 1, r, n, i), e.updateGlobeVertexNormal(h, o + 2, r, n, i), e.updateGlobeVertexNormal(h, o + 3, r, n, i) } const [r, n, i] = t.point; e.addDynamicAttributes(u, r, n, i, t.angle) }; if (C > 1) { const e = dt(x, c, b, w, n, d, p, t, l, s, f, g, !1, _, y, v); if (!e) return { notEnoughRoom: !0 }; if (i && !n) { let [r, n, i] = e.first.point, [o, s, c] = e.last.point;[r, n] = ct(r, n, i, a), [o, s] = ct(o, s, c, a); const l = pt(S, P, (o - r) * m, s - n); if (t.flipState = l && l.needsFlipping ? nt.flipRequired : nt.flipNotRequired, l) return l } A(e.first); for (let t = k + 1; t < k + C - 1; t++) { const e = _t(x * c.getoffsetX(t), b, w, n, d, p, E, T, I, l, s, f, g, !1, !1, _, y, v); if (!e) return u.length -= 4 * (t - k), { notEnoughRoom: !0 }; A(e) } A(e.last) } else { if (i && !n) { const r = ct(p.x, p.y, 0, o), n = T + E + 1, i = new e.pointGeometry(l.getx(n), l.gety(n)), s = ct(i.x, i.y, 0, o), a = s[3] > 0 ? s : gt(p, i, r, 1, o, void 0, _, y.canonical), c = pt(S, P, (a[0] - r[0]) * m, a[1] - r[1]); if (t.flipState = c && c.needsFlipping ? nt.flipRequired : nt.flipNotRequired, c) return c } const r = _t(x * c.getoffsetX(k), b, w, n, d, p, E, T, I, l, s, f, g, !1, !1, _, y, v); if (!r) return { notEnoughRoom: !0 }; A(r) } return {} } function mt(e, t, r, n, i) { const { x: o, y: s, z: a } = n.projectTilePoint(e.x, e.y, t); if (!i) return ct(o, s, a, r); const [c, l, u] = i(e); return ct(o + c, s + l, a + u, r) } function gt(t, r, n, i, o, s, a, c) { const l = mt(t.sub(r)._unit()._add(t), c, o, a, s); return e.sub(l, n, l), e.normalize(l, l), e.scaleAndAdd(l, n, l, i) } function _t(t, r, n, i, o, s, a, c, l, u, h, d, p, f, m, g, _, y) { const v = i ? t - r : t + r; let x = v > 0 ? 1 : -1, b = 0; i && (x *= -1, b = Math.PI), x < 0 && (b += Math.PI); let w = c + a + (x > 0 ? 0 : 1) | 0, T = o, k = o, C = 0, E = 0; const S = Math.abs(v), P = [], I = []; let A = s, L = A; const M = () => gt(L, A, k, S - C + 1, h, p, g, _.canonical); for (; C + E <= S;) { if (w += x, w < c || w >= l) return null; if (k = T, L = A, P.push(k), f && I.push(L), A = new e.pointGeometry(u.getx(w), u.gety(w)), T = d[w], !T) { const e = mt(A, _.canonical, h, g, p); T = e[3] > 0 ? d[w] = e : M() } C += E, E = e.distance(k, T) } m && p && (d[w] && (T = M(), E = e.distance(k, T)), d[w] = T); const B = (S - C) / E, R = A.sub(L)._mult(B)._add(L), D = e.sub([], T, k), F = e.scaleAndAdd([], k, D, B); let O = [0, 0, 1], z = D[0], U = D[1]; if (y && (O = g.upVector(_.canonical, R.x, R.y), 0 !== O[0] || 0 !== O[1] || 1 !== O[2])) { const t = [O[2], 0, -O[0]], r = e.cross([], O, t); e.normalize(t, t), e.normalize(r, r), z = e.dot(D, t), U = e.dot(D, r) } if (n) { const t = e.cross([], O, D); e.normalize(t, t), e.scaleAndAdd(F, F, t, n * x) } const N = b + Math.atan2(U, z); return P.push(F), f && I.push(R), { point: F, angle: N, path: P, tilePath: I, up: O } } function yt(e, t) { const r = t.length, n = r + 4 * e; t.resize(n), t.float32.fill(-1 / 0, 4 * r, 4 * n) } function vt(e, t, r) { const n = t[0], i = t[1]; return e[0] = r[0] * n + r[4] * i + r[12], e[1] = r[1] * n + r[5] * i + r[13], e[3] = r[3] * n + r[7] * i + r[15], e } const xt = 100; class bt { constructor(e, t, r = new rt(e.width + 200, e.height + 200, 25), n = new rt(e.width + 200, e.height + 200, 25)) { this.transform = e, this.grid = r, this.ignoredGrid = n, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + xt, this.screenBottomBoundary = e.height + xt, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.fogState = t } placeCollisionBox(e, t, r, n, i, o, s, a) { let c = r.projectedAnchorX, l = r.projectedAnchorY, u = r.projectedAnchorZ; const h = r.elevation, d = r.tileID, p = e.getProjection(); if (h && d) { const [e, t, n] = p.upVector(d.canonical, r.tileAnchorX, r.tileAnchorY), i = p.upVectorScale(d.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile; c += e * h * i, l += t * h * i, u += n * h * i } const f = this.projectAndGetPerspectiveRatio(s, c, l, u, r.tileID, "globe" === p.name || !!h || this.transform.pitch > 0, p), m = o * f.perspectiveRatio, g = (r.x1 * t + n.x - r.padding) * m + f.point.x, _ = (r.y1 * t + n.y - r.padding) * m + f.point.y, y = (r.x2 * t + n.x + r.padding) * m + f.point.x, v = (r.y2 * t + n.y + r.padding) * m + f.point.y, x = f.perspectiveRatio <= .55 || f.occluded; return !this.isInsideGrid(g, _, y, v) || !i && this.grid.hitTest(g, _, y, v, a) || x ? { box: [], offscreen: !1, occluded: f.occluded } : { box: [g, _, y, v], offscreen: this.isOffscreen(g, _, y, v), occluded: !1 } } placeCollisionCircles(t, r, n, i, o, s, a, c, l, u, h, d, p, f, m) { const g = [], _ = this.transform.elevation, y = t.getProjection(), v = _ ? _.getAtTileOffsetFunc(m, this.transform.center.lat, this.transform.worldSize, y) : null, x = new e.pointGeometry(n.tileAnchorX, n.tileAnchorY); let { x: b, y: w, z: T } = y.projectTilePoint(x.x, x.y, m.canonical); if (v) { const [e, t, r] = v(x); b += e, w += t, T += r } const k = "globe" === y.name, C = this.projectAndGetPerspectiveRatio(a, b, w, T, m, k || !!_ || this.transform.pitch > 0, y), { perspectiveRatio: E } = C, S = (h ? s / E : s * E) / e.ONE_EM, P = ct(b, w, T, c), I = C.signedDistanceFromCamera > 0 ? dt(S, o, n.lineOffsetX * S, n.lineOffsetY * S, !1, P, x, n, i, c, {}, _ && !h ? v : null, h && !!_, y, m, h) : null; let A = !1, L = !1, M = !0; if (I && !C.occluded) { const t = .5 * p * E + f, n = new e.pointGeometry(-100, -100), i = new e.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary), o = new tt, { first: s, last: a } = I, c = s.path.length; let h = []; for (let e = c - 1; e >= 1; e--)h.push(s.path[e]); for (let e = 1; e < a.path.length; e++)h.push(a.path[e]); const m = 2.5 * t; l && (h = h.map((([e, t, r], n) => (v && !k && (r = v(n < c - 1 ? s.tilePath[c - 1 - n] : a.tilePath[n - c + 2])[2]), ct(e, t, r, l)))), h.some((e => e[3] <= 0)) && (h = [])); let _ = []; if (h.length > 0) { let t = 1 / 0, r = -1 / 0, o = 1 / 0, s = -1 / 0; for (const e of h) t = Math.min(t, e[0]), o = Math.min(o, e[1]), r = Math.max(r, e[0]), s = Math.max(s, e[1]); r >= n.x && t <= i.x && s >= n.y && o <= i.y && (_ = [h.map((t => new e.pointGeometry(t[0], t[1])))], (t < n.x || r > i.x || o < n.y || s > i.y) && (_ = e.clipLine(_, n.x, n.y, i.x, i.y))) } for (const e of _) { o.reset(e, .25 * t); let n = 0; n = o.length <= .5 * t ? 1 : Math.ceil(o.paddedLength / m) + 1; for (let e = 0; e < n; e++) { const i = e / Math.max(n - 1, 1), s = o.lerp(i), a = s.x + xt, c = s.y + xt; g.push(a, c, t, 0); const l = a - t, h = c - t, p = a + t, f = c + t; if (M = M && this.isOffscreen(l, h, p, f), L = L || this.isInsideGrid(l, h, p, f), !r && this.grid.hitTestCircle(a, c, t, d) && (A = !0, !u)) return { circles: [], offscreen: !1, collisionDetected: A, occluded: !1 } } } } return { circles: !u && A || !L ? [] : g, offscreen: M, collisionDetected: A, occluded: C.occluded } } queryRenderedSymbols(t) { if (0 === t.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {}; const r = []; let n = 1 / 0, i = 1 / 0, o = -1 / 0, s = -1 / 0; for (const u of t) { const t = new e.pointGeometry(u.x + xt, u.y + xt); n = Math.min(n, t.x), i = Math.min(i, t.y), o = Math.max(o, t.x), s = Math.max(s, t.y), r.push(t) } const a = this.grid.query(n, i, o, s).concat(this.ignoredGrid.query(n, i, o, s)), c = {}, l = {}; for (const u of a) { const t = u.key; if (void 0 === c[t.bucketInstanceId] && (c[t.bucketInstanceId] = {}), c[t.bucketInstanceId][t.featureIndex]) continue; const n = [new e.pointGeometry(u.x1, u.y1), new e.pointGeometry(u.x2, u.y1), new e.pointGeometry(u.x2, u.y2), new e.pointGeometry(u.x1, u.y2)]; e.polygonIntersectsPolygon(r, n) && (c[t.bucketInstanceId][t.featureIndex] = !0, void 0 === l[t.bucketInstanceId] && (l[t.bucketInstanceId] = []), l[t.bucketInstanceId].push(t.featureIndex)) } return l } insertCollisionBox(e, t, r, n, i) { (t ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: r, featureIndex: n, collisionGroupID: i }, e[0], e[1], e[2], e[3]) } insertCollisionCircles(e, t, r, n, i) { const o = t ? this.ignoredGrid : this.grid, s = { bucketInstanceId: r, featureIndex: n, collisionGroupID: i }; for (let a = 0; a < e.length; a += 4)o.insertCircle(s, e[a], e[a + 1], e[a + 2]) } projectAndGetPerspectiveRatio(t, r, n, i, o, s, a) { const c = [r, n, i, 1]; let l = !1; if (i || this.transform.pitch > 0) { if (e.transformMat4$1(c, c, t), this.fogState && o && "globe" !== a.name) { const t = function (t, r, n, i, o, s) { const a = s.calculateFogTileMatrix(o), c = [r, n, i]; return e.transformMat4(c, c, a), I(t, c, s.pitch, s._fov) }(this.fogState, r, n, i, o.toUnwrapped(), this.transform); l = t > .9 } } else vt(c, c, t); const u = c[3]; return { point: new e.pointGeometry((c[0] / u + 1) / 2 * this.transform.width + xt, (-c[1] / u + 1) / 2 * this.transform.height + xt), perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(a) / u * .5, 1.5), signedDistanceFromCamera: u, occluded: s && c[2] > u || l } } isOffscreen(e, t, r, n) { return r < xt || e >= this.screenRightBoundary || n < xt || t > this.screenBottomBoundary } isInsideGrid(e, t, r, n) { return r >= 0 && e < this.gridRightBoundary && n >= 0 && t < this.gridBottomBoundary } getViewportMatrix() { const t = e.identity([]); return e.translate(t, t, [-100, -100, 0]), t } } function wt(t, r, n) { const i = r.createTileMatrix(t, t.worldSize, n.toUnwrapped()); return e.multiply(new Float32Array(16), t.projMatrix, i) } function Tt(e, t, r) { if (t.projection.name === r.projection.name) return e.projMatrix; const n = r.clone(); return n.setProjection(t.projection), wt(n, t.getProjection(), e) } function kt(e, t, r) { return t.name === r.projection.name ? e.projMatrix : wt(r, t, e) } class Ct { constructor(e, t, r, n) { this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t : -t))) : n && r ? 1 : 0, this.placed = r } isHidden() { return 0 === this.opacity && !this.placed } } class Et { constructor(e, t, r, n, i, o = !1) { this.text = new Ct(e ? e.text : null, t, r, i), this.icon = new Ct(e ? e.icon : null, t, n, i), this.clipped = o } isHidden() { return this.text.isHidden() && this.icon.isHidden() } } class St { constructor(e, t, r, n = !1) { this.text = e, this.icon = t, this.skipFade = r, this.clipped = n } } class Pt { constructor() { this.invProjMatrix = e.create(), this.viewportMatrix = e.create(), this.circles = [] } } class It { constructor(e, t, r, n, i) { this.bucketInstanceId = e, this.featureIndex = t, this.sourceLayerIndex = r, this.bucketIndex = n, this.tileID = i } } class At { constructor(e) { this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {} } get(e) { if (this.crossSourceCollisions) return { ID: 0, predicate: null }; if (!this.collisionGroups[e]) { const t = ++this.maxGroupID; this.collisionGroups[e] = { ID: t, predicate: e => e.collisionGroupID === t } } return this.collisionGroups[e] } } function Lt(t, r, n, i, o) { const { horizontalAlign: s, verticalAlign: a } = e.getAnchorAlignment(t), c = -(s - .5) * r, l = -(a - .5) * n, u = e.evaluateVariableOffset(t, i); return new e.pointGeometry(c + u[0] * o, l + u[1] * o) } function Mt(t, r, n, i, o) { const s = new e.pointGeometry(t, r); return n && s._rotate(i ? o : -o), s } class Bt { constructor(e, t, r, n, i) { this.transform = e.clone(), this.projection = e.projection.name, this.collisionIndex = new bt(this.transform, i), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = t, this.retainedQueryData = {}, this.collisionGroups = new At(r), this.collisionCircleArrays = {}, this.prevPlacement = n, n && (n.prevPlacement = void 0), this.placedOrientations = {} } getBucketParts(t, r, n, i) { const o = n.getBucket(r), s = n.latestFeatureIndex; if (!o || !s || r.id !== o.layerIds[0]) return; const a = o.layers[0].layout, c = n.collisionBoxArray, l = Math.pow(2, this.transform.zoom - n.tileID.overscaledZ), u = n.tileSize / e.EXTENT, h = n.tileID.toUnwrapped(); this.transform.setProjection(o.projection); const d = (p = n.tileID, f = o.getProjection(), m = this.transform, f.name === this.projection ? m.calculateProjMatrix(p.toUnwrapped()) : wt(m, f, p)); var p, f, m; const g = "map" === a.get("text-pitch-alignment"), _ = "map" === a.get("text-rotation-alignment"); r.compileFilter(); const y = r.dynamicFilter(), v = r.dynamicFilterNeedsFeature(), x = this.transform.calculatePixelsToTileUnitsMatrix(n), b = st(d, n.tileID.canonical, g, _, this.transform, o.getProjection(), x); let w = null; if (g) { const t = at(d, n.tileID.canonical, g, _, this.transform, o.getProjection(), x); w = e.multiply([], this.transform.labelPlaneMatrix, t) } let T = null; y && n.latestFeatureIndex && (T = { unwrappedTileID: h, dynamicFilter: y, dynamicFilterNeedsFeature: v, featureIndex: n.latestFeatureIndex }), this.retainedQueryData[o.bucketInstanceId] = new It(o.bucketInstanceId, s, o.sourceLayerIndex, o.index, n.tileID); const k = { bucket: o, layout: a, posMatrix: d, textLabelPlaneMatrix: b, labelToScreenMatrix: w, clippingData: T, scale: l, textPixelRatio: u, holdingForFade: n.holdingForFade(), collisionBoxArray: c, partiallyEvaluatedTextSize: e.evaluateSizeForZoom(o.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: e.evaluateSizeForZoom(o.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o.sourceID) }; if (i) for (const e of o.sortKeyRanges) { const { sortKey: r, symbolInstanceStart: n, symbolInstanceEnd: i } = e; t.push({ sortKey: r, symbolInstanceStart: n, symbolInstanceEnd: i, parameters: k }) } else t.push({ symbolInstanceStart: 0, symbolInstanceEnd: o.symbolInstances.length, parameters: k }) } attemptAnchorPlacement(e, t, r, n, i, o, s, a, c, l, u, h, d, p, f, m, g, _) { const { textOffset0: y, textOffset1: v, crossTileID: x } = h, b = [y, v], w = Lt(e, r, n, b, i), T = this.collisionIndex.placeCollisionBox(p, i, t, Mt(w.x, w.y, o, s, this.transform.angle), u, a, c, l.predicate); if (m) { const e = p.getSymbolInstanceIconSize(_, this.transform.zoom, h.placedIconSymbolIndex); if (0 === this.collisionIndex.placeCollisionBox(p, e, m, Mt(w.x, w.y, o, s, this.transform.angle), u, a, c, l.predicate).box.length) return } if (T.box.length > 0) { let t; return this.prevPlacement && this.prevPlacement.variableOffsets[x] && this.prevPlacement.placements[x] && this.prevPlacement.placements[x].text && (t = this.prevPlacement.variableOffsets[x].anchor), this.variableOffsets[x] = { textOffset: b, width: r, height: n, anchor: e, textScale: i, prevAnchor: t }, this.markUsedJustification(p, e, h, f), p.allowVerticalPlacement && (this.markUsedOrientation(p, f, h), this.placedOrientations[x] = f), { shift: w, placedGlyphBoxes: T } } } placeLayerBucketPart(t, r, n, i) { const { bucket: o, layout: s, posMatrix: a, textLabelPlaneMatrix: c, labelToScreenMatrix: l, clippingData: u, textPixelRatio: h, holdingForFade: d, collisionBoxArray: p, partiallyEvaluatedTextSize: f, partiallyEvaluatedIconSize: m, collisionGroup: g } = t.parameters, _ = s.get("text-optional"), y = s.get("icon-optional"), v = s.get("text-allow-overlap"), x = s.get("icon-allow-overlap"), b = "map" === s.get("text-rotation-alignment"), w = "map" === s.get("text-pitch-alignment"), T = "none" !== s.get("icon-text-fit"), k = "viewport-y" === s.get("symbol-z-order"); this.transform.setProjection(o.projection); let C = v && (x || !o.hasIconData() || y), E = x && (v || !o.hasTextData() || _); !o.collisionArrays && p && o.deserializeCollisionBoxes(p), n && i && o.updateCollisionDebugBuffers(this.transform.zoom, p); const S = (t, i, p) => { const { crossTileID: k, numVerticalGlyphVertices: S } = t; if (u) { const n = { zoom: this.transform.zoom, pitch: this.transform.pitch }; let i = null; if (u.dynamicFilterNeedsFeature) { const e = this.retainedQueryData[o.bucketInstanceId]; i = u.featureIndex.loadFeature({ featureIndex: t.featureIndex, bucketIndex: e.bucketIndex, sourceLayerIndex: e.sourceLayerIndex, layoutVertexArrayOffset: 0 }) } if (!(0, u.dynamicFilter)(n, i, this.retainedQueryData[o.bucketInstanceId].tileID.canonical, new e.pointGeometry(t.tileAnchorX, t.tileAnchorY), this.transform.calculateDistanceTileData(u.unwrappedTileID))) return this.placements[k] = new St(!1, !1, !1, !0), void (r[k] = !0) } if (r[k]) return; if (d) return void (this.placements[k] = new St(!1, !1, !1)); let P = !1, I = !1, A = !0, L = !1, M = !1, B = null, R = { box: null, offscreen: null, occluded: null }, D = { box: null, offscreen: null, occluded: null }, F = null, O = null, z = null, U = 0, N = 0, G = 0; p.textFeatureIndex ? U = p.textFeatureIndex : t.useRuntimeCollisionCircles && (U = t.featureIndex), p.verticalTextFeatureIndex && (N = p.verticalTextFeatureIndex); const V = e => { e.tileID = this.retainedQueryData[o.bucketInstanceId].tileID; const t = this.transform.elevation; (t || e.elevation) && (e.elevation = t ? t.getAtTileOffset(e.tileID, e.tileAnchorX, e.tileAnchorY) : 0) }, q = p.textBox; if (q) { V(q); const r = r => { let n = e.WritingMode.horizontal; if (o.allowVerticalPlacement && !r && this.prevPlacement) { const e = this.prevPlacement.placedOrientations[k]; e && (this.placedOrientations[k] = e, n = e, this.markUsedOrientation(o, n, t)) } return n }, n = (t, r) => { if (o.allowVerticalPlacement && S > 0 && p.verticalTextBox) { for (const n of o.writingModes) if (n === e.WritingMode.vertical ? (R = r(), D = R) : R = t(), R && R.box && R.box.length) break } else R = t() }; if (s.get("text-variable-anchor")) { let c = s.get("text-variable-anchor"); if (this.prevPlacement && this.prevPlacement.variableOffsets[k]) { const e = this.prevPlacement.variableOffsets[k]; c.indexOf(e.anchor) > 0 && (c = c.filter((t => t !== e.anchor)), c.unshift(e.anchor)) } const l = (e, r, n) => { const s = o.getSymbolInstanceTextSize(f, t, this.transform.zoom, i), l = (e.x2 - e.x1) * s + 2 * e.padding, u = (e.y2 - e.y1) * s + 2 * e.padding, d = T && !x ? r : null; d && V(d); let p = { box: [], offscreen: !1, occluded: !1 }; const _ = v ? 2 * c.length : c.length; for (let y = 0; y < _; ++y) { const r = this.attemptAnchorPlacement(c[y % c.length], e, l, u, s, b, w, h, a, g, y >= c.length, t, i, o, n, d, f, m); if (r && (p = r.placedGlyphBoxes, p && p.box && p.box.length)) { P = !0, B = r.shift; break } } return p }; n((() => l(q, p.iconBox, e.WritingMode.horizontal)), (() => { const t = p.verticalTextBox; return t && V(t), o.allowVerticalPlacement && !(R && R.box && R.box.length) && S > 0 && t ? l(t, p.verticalIconBox, e.WritingMode.vertical) : { box: null, offscreen: null, occluded: null } })), R && (P = R.box, A = R.offscreen, L = R.occluded); const u = r(R && R.box); if (!P && this.prevPlacement) { const e = this.prevPlacement.variableOffsets[k]; e && (this.variableOffsets[k] = e, this.markUsedJustification(o, e.anchor, t, u)) } } else { const s = (r, n) => { const s = o.getSymbolInstanceTextSize(f, t, this.transform.zoom, i), c = this.collisionIndex.placeCollisionBox(o, s, r, new e.pointGeometry(0, 0), v, h, a, g.predicate); return c && c.box && c.box.length && (this.markUsedOrientation(o, n, t), this.placedOrientations[k] = n), c }; n((() => s(q, e.WritingMode.horizontal)), (() => { const t = p.verticalTextBox; return o.allowVerticalPlacement && S > 0 && t ? (V(t), s(t, e.WritingMode.vertical)) : { box: null, offscreen: null, occluded: null } })), r(R && R.box && R.box.length) } } if (F = R, P = F && F.box && F.box.length > 0, A = F && F.offscreen, L = F && F.occluded, t.useRuntimeCollisionCircles) { const r = o.text.placedSymbolArray.get(t.centerJustifiedTextSymbolIndex >= 0 ? t.centerJustifiedTextSymbolIndex : t.verticalPlacedTextSymbolIndex), i = e.evaluateSizeForFeature(o.textSizeData, f, r), u = s.get("text-padding"); O = this.collisionIndex.placeCollisionCircles(o, v, r, o.lineVertexArray, o.glyphOffsetArray, i, a, c, l, n, w, g.predicate, t.collisionCircleDiameter * i / e.ONE_EM, u, this.retainedQueryData[o.bucketInstanceId].tileID), P = v || O.circles.length > 0 && !O.collisionDetected, A = A && O.offscreen, L = O.occluded } if (p.iconFeatureIndex && (G = p.iconFeatureIndex), p.iconBox) { const r = r => { V(r); const n = T && B ? Mt(B.x, B.y, b, w, this.transform.angle) : new e.pointGeometry(0, 0), i = o.getSymbolInstanceIconSize(m, this.transform.zoom, t.placedIconSymbolIndex); return this.collisionIndex.placeCollisionBox(o, i, r, n, x, h, a, g.predicate) }; D && D.box && D.box.length && p.verticalIconBox ? (z = r(p.verticalIconBox), I = z.box.length > 0) : (z = r(p.iconBox), I = z.box.length > 0), A = A && z.offscreen, M = z.occluded } const j = _ || 0 === t.numHorizontalGlyphVertices && 0 === S, X = y || 0 === t.numIconVertices; if (j || X ? X ? j || (I = I && P) : P = I && P : I = P = I && P, P && F && F.box && this.collisionIndex.insertCollisionBox(F.box, s.get("text-ignore-placement"), o.bucketInstanceId, D && D.box && N ? N : U, g.ID), I && z && this.collisionIndex.insertCollisionBox(z.box, s.get("icon-ignore-placement"), o.bucketInstanceId, G, g.ID), O && (P && this.collisionIndex.insertCollisionCircles(O.circles, s.get("text-ignore-placement"), o.bucketInstanceId, U, g.ID), n)) { const e = o.bucketInstanceId; let t = this.collisionCircleArrays[e]; void 0 === t && (t = this.collisionCircleArrays[e] = new Pt); for (let r = 0; r < O.circles.length; r += 4)t.circles.push(O.circles[r + 0]), t.circles.push(O.circles[r + 1]), t.circles.push(O.circles[r + 2]), t.circles.push(O.collisionDetected ? 1 : 0) } const W = "globe" !== o.projection.name; C = C && (W || !L), E = E && (W || !M), this.placements[k] = new St(P || C, I || E, A || o.justReloaded), r[k] = !0 }; if (k) { const e = o.getSortedSymbolIndexes(this.transform.angle); for (let t = e.length - 1; t >= 0; --t) { const r = e[t]; S(o.symbolInstances.get(r), r, o.collisionArrays[r]) } } else for (let e = t.symbolInstanceStart; e < t.symbolInstanceEnd; e++)S(o.symbolInstances.get(e), e, o.collisionArrays[e]); if (n && o.bucketInstanceId in this.collisionCircleArrays) { const t = this.collisionCircleArrays[o.bucketInstanceId]; e.invert(t.invProjMatrix, a), t.viewportMatrix = this.collisionIndex.getViewportMatrix() } o.justReloaded = !1 } markUsedJustification(t, r, n, i) { const { leftJustifiedTextSymbolIndex: o, centerJustifiedTextSymbolIndex: s, rightJustifiedTextSymbolIndex: a, verticalPlacedTextSymbolIndex: c, crossTileID: l } = n, u = e.getAnchorJustification(r), h = i === e.WritingMode.vertical ? c : "left" === u ? o : "center" === u ? s : "right" === u ? a : -1; o >= 0 && (t.text.placedSymbolArray.get(o).crossTileID = h >= 0 && o !== h ? 0 : l), s >= 0 && (t.text.placedSymbolArray.get(s).crossTileID = h >= 0 && s !== h ? 0 : l), a >= 0 && (t.text.placedSymbolArray.get(a).crossTileID = h >= 0 && a !== h ? 0 : l), c >= 0 && (t.text.placedSymbolArray.get(c).crossTileID = h >= 0 && c !== h ? 0 : l) } markUsedOrientation(t, r, n) { const i = r === e.WritingMode.horizontal || r === e.WritingMode.horizontalOnly ? r : 0, o = r === e.WritingMode.vertical ? r : 0, { leftJustifiedTextSymbolIndex: s, centerJustifiedTextSymbolIndex: a, rightJustifiedTextSymbolIndex: c, verticalPlacedTextSymbolIndex: l } = n, u = t.text.placedSymbolArray; s >= 0 && (u.get(s).placedOrientation = i), a >= 0 && (u.get(a).placedOrientation = i), c >= 0 && (u.get(c).placedOrientation = i), l >= 0 && (u.get(l).placedOrientation = o) } commit(e) { this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom; const t = this.prevPlacement; let r = !1; this.prevZoomAdjustment = t ? t.zoomAdjustment(this.transform.zoom) : 0; const n = t ? t.symbolFadeChange(e) : 1, i = t ? t.opacities : {}, o = t ? t.variableOffsets : {}, s = t ? t.placedOrientations : {}; for (const a in this.placements) { const e = this.placements[a], t = i[a]; t ? (this.opacities[a] = new Et(t, n, e.text, e.icon, null, e.clipped), r = r || e.text !== t.text.placed || e.icon !== t.icon.placed) : (this.opacities[a] = new Et(null, n, e.text, e.icon, e.skipFade, e.clipped), r = r || e.text || e.icon) } for (const a in i) { const e = i[a]; if (!this.opacities[a]) { const t = new Et(e, n, !1, !1); t.isHidden() || (this.opacities[a] = t, r = r || e.text.placed || e.icon.placed) } } for (const a in o) this.variableOffsets[a] || !this.opacities[a] || this.opacities[a].isHidden() || (this.variableOffsets[a] = o[a]); for (const a in s) this.placedOrientations[a] || !this.opacities[a] || this.opacities[a].isHidden() || (this.placedOrientations[a] = s[a]); r ? this.lastPlacementChangeTime = e : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t ? t.lastPlacementChangeTime : e) } updateLayerOpacities(e, t) { const r = {}; for (const n of t) { const t = n.getBucket(e); t && n.latestFeatureIndex && e.id === t.layerIds[0] && this.updateBucketOpacities(t, r, n.collisionBoxArray) } } updateBucketOpacities(t, r, n) { t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear(); const i = t.layers[0].layout, o = !!t.layers[0].dynamicFilter(), s = new Et(null, 0, !1, !1, !0), a = i.get("text-allow-overlap"), c = i.get("icon-allow-overlap"), l = i.get("text-variable-anchor"), u = "map" === i.get("text-rotation-alignment"), h = "map" === i.get("text-pitch-alignment"), d = "none" !== i.get("icon-text-fit"), p = new Et(null, 0, a && (c || !t.hasIconData() || i.get("icon-optional")), c && (a || !t.hasTextData() || i.get("text-optional")), !0); !t.collisionArrays && n && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(n); const f = (e, t, r) => { for (let n = 0; n < t / 4; n++)e.opacityVertexArray.emplaceBack(r) }; let m = 0; for (let g = 0; g < t.symbolInstances.length; g++) { const n = t.symbolInstances.get(g), { numHorizontalGlyphVertices: i, numVerticalGlyphVertices: a, crossTileID: c, numIconVertices: _ } = n; let y = this.opacities[c]; r[c] ? y = s : y || (y = p, this.opacities[c] = y), r[c] = !0; const v = i > 0 || a > 0, x = _ > 0, b = this.placedOrientations[c], w = b === e.WritingMode.vertical, T = b === e.WritingMode.horizontal || b === e.WritingMode.horizontalOnly; if (!v && !x || y.isHidden() || m++, v) { const e = Vt(y.text); f(t.text, i, w ? qt : e), f(t.text, a, T ? qt : e); const r = y.text.isHidden(), { leftJustifiedTextSymbolIndex: o, centerJustifiedTextSymbolIndex: s, rightJustifiedTextSymbolIndex: l, verticalPlacedTextSymbolIndex: u } = n, h = t.text.placedSymbolArray, d = r || w ? 1 : 0; o >= 0 && (h.get(o).hidden = d), s >= 0 && (h.get(s).hidden = d), l >= 0 && (h.get(l).hidden = d), u >= 0 && (h.get(u).hidden = r || T ? 1 : 0); const p = this.variableOffsets[c]; p && this.markUsedJustification(t, p.anchor, n, b); const m = this.placedOrientations[c]; m && (this.markUsedJustification(t, "left", n, m), this.markUsedOrientation(t, m, n)) } if (x) { const e = Vt(y.icon), { placedIconSymbolIndex: r, verticalPlacedIconSymbolIndex: i } = n, o = t.icon.placedSymbolArray, s = y.icon.isHidden() ? 1 : 0; r >= 0 && (f(t.icon, _, w ? qt : e), o.get(r).hidden = s), i >= 0 && (f(t.icon, n.numVerticalIconVertices, T ? qt : e), o.get(i).hidden = s) } if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) { const r = t.collisionArrays[g]; if (r) { let n = new e.pointGeometry(0, 0), i = !0; if (r.textBox || r.verticalTextBox) { if (l) { const e = this.variableOffsets[c]; e ? (n = Lt(e.anchor, e.width, e.height, e.textOffset, e.textScale), u && n._rotate(h ? this.transform.angle : -this.transform.angle)) : i = !1 } o && (i = !y.clipped), r.textBox && Rt(t.textCollisionBox.collisionVertexArray, y.text.placed, !i || w, n.x, n.y), r.verticalTextBox && Rt(t.textCollisionBox.collisionVertexArray, y.text.placed, !i || T, n.x, n.y) } const s = i && Boolean(!T && r.verticalIconBox); r.iconBox && Rt(t.iconCollisionBox.collisionVertexArray, y.icon.placed, s, d ? n.x : 0, d ? n.y : 0), r.verticalIconBox && Rt(t.iconCollisionBox.collisionVertexArray, y.icon.placed, !s, d ? n.x : 0, d ? n.y : 0) } } } if (t.fullyClipped = 0 === m, t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.bucketInstanceId in this.collisionCircleArrays) { const e = this.collisionCircleArrays[t.bucketInstanceId]; t.placementInvProjMatrix = e.invProjMatrix, t.placementViewportMatrix = e.viewportMatrix, t.collisionCircleArray = e.circles, delete this.collisionCircleArrays[t.bucketInstanceId] } } symbolFadeChange(e) { return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment } zoomAdjustment(e) { return Math.max(0, (this.transform.zoom - e) / 1.5) } hasTransitions(e) { return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration } stillRecent(e, t) { const r = this.zoomAtLastRecencyCheck === t ? 1 - this.zoomAdjustment(t) : 1; return this.zoomAtLastRecencyCheck = t, this.commitTime + this.fadeDuration * r > e } setStale() { this.stale = !0 } } function Rt(e, t, r, n, i) { e.emplaceBack(t ? 1 : 0, r ? 1 : 0, n || 0, i || 0), e.emplaceBack(t ? 1 : 0, r ? 1 : 0, n || 0, i || 0), e.emplaceBack(t ? 1 : 0, r ? 1 : 0, n || 0, i || 0), e.emplaceBack(t ? 1 : 0, r ? 1 : 0, n || 0, i || 0) } const Dt = Math.pow(2, 25), Ft = Math.pow(2, 24), Ot = Math.pow(2, 17), zt = Math.pow(2, 16), Ut = Math.pow(2, 9), Nt = Math.pow(2, 8), Gt = Math.pow(2, 1); function Vt(e) { if (0 === e.opacity && !e.placed) return 0; if (1 === e.opacity && e.placed) return 4294967295; const t = e.placed ? 1 : 0, r = Math.floor(127 * e.opacity); return r * Dt + t * Ft + r * Ot + t * zt + r * Ut + t * Nt + r * Gt + t } const qt = 0; class jt { constructor(e) { this._sortAcrossTiles = "viewport-y" !== e.layout.get("symbol-z-order") && void 0 !== e.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [] } continuePlacement(e, t, r, n, i) { const o = this._bucketParts; for (; this._currentTileIndex < e.length;)if (t.getBucketParts(o, n, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, i()) return !0; for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, o.sort(((e, t) => e.sortKey - t.sortKey))); this._currentPartIndex < o.length;) { const e = o[this._currentPartIndex]; if (t.placeLayerBucketPart(e, this._seenCrossTileIDs, r, 0 === e.symbolInstanceStart), this._currentPartIndex++, i()) return !0 } return !1 } } class Xt { constructor(e, t, r, n, i, o, s, a) { this.placement = new Bt(e, i, o, s, a), this._currentPlacementIndex = t.length - 1, this._forceFullPlacement = r, this._showCollisionBoxes = n, this._done = !1 } isDone() { return this._done } continuePlacement(t, r, n) { const i = e.exported.now(), o = () => { const t = e.exported.now() - i; return !this._forceFullPlacement && t > 2 }; for (; this._currentPlacementIndex >= 0;) { const e = r[t[this._currentPlacementIndex]], i = this.placement.collisionIndex.transform.zoom; if ("symbol" === e.type && (!e.minzoom || e.minzoom <= i) && (!e.maxzoom || e.maxzoom > i)) { if (this._inProgressLayer || (this._inProgressLayer = new jt(e)), this._inProgressLayer.continuePlacement(n[e.source], this.placement, this._showCollisionBoxes, e, o)) return; delete this._inProgressLayer } this._currentPlacementIndex-- } this._done = !0 } commit(e) { return this.placement.commit(e), this.placement } } const Wt = 512 / e.EXTENT / 2; class Zt { constructor(e, t, r) { this.tileID = e, this.indexedSymbolInstances = {}, this.bucketInstanceId = r; for (let n = 0; n < t.length; n++) { const r = t.get(n), i = r.key; this.indexedSymbolInstances[i] || (this.indexedSymbolInstances[i] = []), this.indexedSymbolInstances[i].push({ crossTileID: r.crossTileID, coord: this.getScaledCoordinates(r, e) }) } } getScaledCoordinates(t, r) { const n = Wt / Math.pow(2, r.canonical.z - this.tileID.canonical.z); return { x: Math.floor((r.canonical.x * e.EXTENT + t.tileAnchorX) * n), y: Math.floor((r.canonical.y * e.EXTENT + t.tileAnchorY) * n) } } findMatches(e, t, r) { const n = this.tileID.canonical.z < t.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t.canonical.z); for (let i = 0; i < e.length; i++) { const o = e.get(i); if (o.crossTileID) continue; const s = this.indexedSymbolInstances[o.key]; if (!s) continue; const a = this.getScaledCoordinates(o, t); for (const e of s) if (Math.abs(e.coord.x - a.x) <= n && Math.abs(e.coord.y - a.y) <= n && !r[e.crossTileID]) { r[e.crossTileID] = !0, o.crossTileID = e.crossTileID; break } } } } class Ht { constructor() { this.maxCrossTileID = 0 } generate() { return ++this.maxCrossTileID } } class Qt { constructor() { this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0 } handleWrapJump(e) { const t = Math.round((e - this.lng) / 360); if (0 !== t) for (const r in this.indexes) { const e = this.indexes[r], n = {}; for (const r in e) { const i = e[r]; i.tileID = i.tileID.unwrapTo(i.tileID.wrap + t), n[i.tileID.key] = i } this.indexes[r] = n } this.lng = e } addBucket(e, t, r) { if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) { if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return !1; this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]) } for (let i = 0; i < t.symbolInstances.length; i++)t.symbolInstances.get(i).crossTileID = 0; this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {}); const n = this.usedCrossTileIDs[e.overscaledZ]; for (const i in this.indexes) { const r = this.indexes[i]; if (Number(i) > e.overscaledZ) for (const i in r) { const o = r[i]; o.tileID.isChildOf(e) && o.findMatches(t.symbolInstances, e, n) } else { const o = r[e.scaledTo(Number(i)).key]; o && o.findMatches(t.symbolInstances, e, n) } } for (let i = 0; i < t.symbolInstances.length; i++) { const e = t.symbolInstances.get(i); e.crossTileID || (e.crossTileID = r.generate(), n[e.crossTileID] = !0) } return void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Zt(e, t.symbolInstances, t.bucketInstanceId), !0 } removeBucketCrossTileIDs(e, t) { for (const r in t.indexedSymbolInstances) for (const n of t.indexedSymbolInstances[r]) delete this.usedCrossTileIDs[e][n.crossTileID] } removeStaleBuckets(e) { let t = !1; for (const r in this.indexes) { const n = this.indexes[r]; for (const i in n) e[n[i].bucketInstanceId] || (this.removeBucketCrossTileIDs(r, n[i]), delete n[i], t = !0) } return t } } class $t { constructor() { this.layerIndexes = {}, this.crossTileIDs = new Ht, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {} } addLayer(e, t, r, n) { let i = this.layerIndexes[e.id]; void 0 === i && (i = this.layerIndexes[e.id] = new Qt); let o = !1; const s = {}; "globe" !== n.name && i.handleWrapJump(r); for (const a of t) { const t = a.getBucket(e); t && e.id === t.layerIds[0] && (t.bucketInstanceId || (t.bucketInstanceId = ++this.maxBucketInstanceId), i.addBucket(a.tileID, t, this.crossTileIDs) && (o = !0), s[t.bucketInstanceId] = !0) } return i.removeStaleBuckets(s) && (o = !0), o } pruneUnusedLayers(e) { const t = {}; e.forEach((e => { t[e] = !0 })); for (const r in this.layerIndexes) t[r] || delete this.layerIndexes[r] } } const Jt = (t, r) => e.emitValidationErrors(t, r && r.filter((e => "source.canvas" !== e.identifier))), Kt = e.pick(Ze, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"]), Yt = e.pick(Ze, ["setCenter", "setZoom", "setBearing", "setPitch"]), er = { version: 8, layers: [], sources: {} }, tr = { fill: !0, line: !0, background: !0, hillshade: !0, raster: !0 }; class rr extends e.Evented { constructor(t, r = {}) { super(), this.map = t, this.dispatcher = new R(je(), this), this.imageManager = new x, this.imageManager.setEventedParent(this), this.glyphManager = new e.GlyphManager(t._requestManager, r.localFontFamily ? e.LocalGlyphMode.all : r.localIdeographFontFamily ? e.LocalGlyphMode.ideographs : e.LocalGlyphMode.none, r.localFontFamily || r.localIdeographFontFamily), this.crossTileSymbolIndex = new $t, this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = !1, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", e.getReferrer()); const n = this; this._rtlTextPluginCallback = rr.registerForPluginStateChange((t => { n.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t.pluginStatus, pluginURL: t.pluginURL }, ((t, r) => { if (e.triggerPluginCompletionEvent(t), r && r.every((e => e))) for (const e in n._sourceCaches) { const t = n._sourceCaches[e], r = t.getSource().type; "vector" !== r && "geojson" !== r || t.reload() } })) })), this.on("data", (e => { if ("source" !== e.dataType || "metadata" !== e.sourceDataType) return; const t = this.getSource(e.sourceId); if (t && t.vectorLayerIds) for (const r in this._layers) { const e = this._layers[r]; e.source === t.id && this._validateLayer(e) } })) } loadURL(t, r = {}) { this.fire(new e.Event("dataloading", { dataType: "style" })); const n = "boolean" == typeof r.validate ? r.validate : !e.isMapboxURL(t); t = this.map._requestManager.normalizeStyleURL(t, r.accessToken); const i = this.map._requestManager.transformRequest(t, e.ResourceType.Style); this._request = e.getJSON(i, ((t, r) => { this._request = null, t ? this.fire(new e.ErrorEvent(t)) : r && this._load(r, n) })) } loadJSON(t, r = {}) { this.fire(new e.Event("dataloading", { dataType: "style" })), this._request = e.exported.frame((() => { this._request = null, this._load(t, !1 !== r.validate) })) } loadEmpty() { this.fire(new e.Event("dataloading", { dataType: "style" })), this._load(er, !1) } _updateLayerCount(e, t) { const r = t ? 1 : -1; e.is3D() && (this._num3DLayers += r), "circle" === e.type && (this._numCircleLayers += r), "symbol" === e.type && (this._numSymbolLayers += r) } _load(t, r) { if (r && Jt(this, e.validateStyle(t))) return; this._loaded = !0, this.stylesheet = e.clone$1(t), this._updateMapProjection(); for (const e in t.sources) this.addSource(e, t.sources[e], { validate: !1 }); this._changed = !1, t.sprite ? this._loadSprite(t.sprite) : (this.imageManager.setLoaded(!0), this.dispatcher.broadcast("spriteLoaded", !0)), this.glyphManager.setURL(t.glyphs); const n = We(this.stylesheet.layers); this._order = n.map((e => e.id)), this._layers = {}, this._serializedLayers = {}; for (let i of n) i = e.createStyleLayer(i), i.setEventedParent(this, { layer: { id: i.id } }), this._layers[i.id] = i, this._serializedLayers[i.id] = i.serialize(), this._updateLayerCount(i, !0); this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new T(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e.Event("data", { dataType: "style" })), this.fire(new e.Event("style.load")) } terrainSetForDrapingOnly() { return !!this.terrain && 0 === this.terrain.drapeRenderMode } setProjection(e) { e ? this.stylesheet.projection = e : delete this.stylesheet.projection, this._updateMapProjection() } applyProjectionUpdate() { this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null)) } _updateMapProjection() { this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection) } _loadSprite(t) { this._spriteRequest = function (t, r, n) { let i, o, s; const a = e.exported.devicePixelRatio > 1 ? "@2x" : ""; let c = e.getJSON(r.transformRequest(r.normalizeSpriteURL(t, a, ".json"), e.ResourceType.SpriteJSON), ((e, t) => { c = null, s || (s = e, i = t, u()) })), l = e.getImage(r.transformRequest(r.normalizeSpriteURL(t, a, ".png"), e.ResourceType.SpriteImage), ((e, t) => { l = null, s || (s = e, o = t, u()) })); function u() { if (s) n(s); else if (i && o) { const t = e.exported.getImageData(o), r = {}; for (const n in i) { const { width: o, height: s, x: a, y: c, sdf: l, pixelRatio: u, stretchX: h, stretchY: d, content: p } = i[n], f = new e.RGBAImage({ width: o, height: s }); e.RGBAImage.copy(t, f, { x: a, y: c }, { x: 0, y: 0 }, { width: o, height: s }), r[n] = { data: f, pixelRatio: u, sdf: l, stretchX: h, stretchY: d, content: p } } n(null, r) } } return { cancel() { c && (c.cancel(), c = null), l && (l.cancel(), l = null) } } }(t, this.map._requestManager, ((t, r) => { if (this._spriteRequest = null, t) this.fire(new e.ErrorEvent(t)); else if (r) for (const e in r) this.imageManager.addImage(e, r[e]); this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", !0), this.fire(new e.Event("data", { dataType: "style" })) })) } _validateLayer(t) { const r = this.getSource(t.source); if (!r) return; const n = t.sourceLayer; n && ("geojson" === r.type || r.vectorLayerIds && -1 === r.vectorLayerIds.indexOf(n)) && this.fire(new e.ErrorEvent(new Error(`Source layer "${n}" does not exist on source "${r.id}" as specified by style layer "${t.id}"`))) } loaded() { if (!this._loaded) return !1; if (Object.keys(this._updatedSources).length) return !1; for (const e in this._sourceCaches) if (!this._sourceCaches[e].loaded()) return !1; return !!this.imageManager.isLoaded() } _serializeLayers(e) { const t = []; for (const r of e) { const e = this._layers[r]; "custom" !== e.type && t.push(e.serialize()) } return t } hasTransitions() { if (this.light && this.light.hasTransition()) return !0; if (this.fog && this.fog.hasTransition()) return !0; for (const e in this._sourceCaches) if (this._sourceCaches[e].hasTransition()) return !0; for (const e in this._layers) if (this._layers[e].hasTransition()) return !0; return !1 } get order() { return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order } isLayerDraped(e) { return !!this.terrain && ("function" == typeof e.isLayerDraped ? e.isLayerDraped() : tr[e.type]) } _checkLoaded() { if (!this._loaded) throw new Error("Style is not done loading") } update(t) { if (!this._loaded) return; const r = this._changed; if (this._changed) { const e = Object.keys(this._updatedLayers), r = Object.keys(this._removedLayers); (e.length || r.length) && this._updateWorkerLayers(e, r); for (const t in this._updatedSources) { const e = this._updatedSources[t]; "reload" === e ? this._reloadSource(t) : "clear" === e && this._clearSource(t) } this._updateTilesForChangedImages(); for (const n in this._updatedPaintProps) this._layers[n].updateTransitions(t); this.light.updateTransitions(t), this.fog && this.fog.updateTransitions(t), this._resetUpdates() } const n = {}; for (const e in this._sourceCaches) { const t = this._sourceCaches[e]; n[e] = t.used, t.used = !1 } for (const e of this._order) { const r = this._layers[e]; if (r.recalculate(t, this._availableImages), !r.isHidden(t.zoom)) { const e = this._getLayerSourceCache(r); e && (e.used = !0) } const n = this.map.painter; if (n) { const e = r.getProgramIds(); if (!e) continue; const i = r.getProgramConfiguration(t.zoom); for (const t of e) n.useProgram(t, i) } } for (const i in n) { const t = this._sourceCaches[i]; n[i] !== t.used && t.getSource().fire(new e.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: t.getSource().id })) } this.light.recalculate(t), this.terrain && this.terrain.recalculate(t), this.fog && this.fog.recalculate(t), this.z = t.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), r && this.fire(new e.Event("data", { dataType: "style" })) } _updateTilesForChangedImages() { const e = Object.keys(this._changedImages); if (e.length) { for (const t in this._sourceCaches) this._sourceCaches[t].reloadTilesForDependencies(["icons", "patterns"], e); this._changedImages = {} } } _updateWorkerLayers(e, t) { this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(e), removedIds: t }) } _resetUpdates() { this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {} } setState(r) { if (this._checkLoaded(), Jt(this, e.validateStyle(r))) return !1; (r = e.clone$1(r)).layers = We(r.layers); const n = function (e, r) { if (!e) return [{ command: Ze.setStyle, args: [r] }]; let n = []; try { if (!t(e.version, r.version)) return [{ command: Ze.setStyle, args: [r] }]; t(e.center, r.center) || n.push({ command: Ze.setCenter, args: [r.center] }), t(e.zoom, r.zoom) || n.push({ command: Ze.setZoom, args: [r.zoom] }), t(e.bearing, r.bearing) || n.push({ command: Ze.setBearing, args: [r.bearing] }), t(e.pitch, r.pitch) || n.push({ command: Ze.setPitch, args: [r.pitch] }), t(e.sprite, r.sprite) || n.push({ command: Ze.setSprite, args: [r.sprite] }), t(e.glyphs, r.glyphs) || n.push({ command: Ze.setGlyphs, args: [r.glyphs] }), t(e.transition, r.transition) || n.push({ command: Ze.setTransition, args: [r.transition] }), t(e.light, r.light) || n.push({ command: Ze.setLight, args: [r.light] }), t(e.fog, r.fog) || n.push({ command: Ze.setFog, args: [r.fog] }), t(e.projection, r.projection) || n.push({ command: Ze.setProjection, args: [r.projection] }); const i = {}, o = []; !function (e, r, n, i) { let o; for (o in r = r || {}, e = e || {}) e.hasOwnProperty(o) && (r.hasOwnProperty(o) || Qe(o, n, i)); for (o in r) r.hasOwnProperty(o) && (e.hasOwnProperty(o) ? t(e[o], r[o]) || ("geojson" === e[o].type && "geojson" === r[o].type && Je(e, r, o) ? n.push({ command: Ze.setGeoJSONSourceData, args: [o, r[o].data] }) : $e(o, r, n, i)) : He(o, r, n)) }(e.sources, r.sources, o, i); const s = []; e.layers && e.layers.forEach((e => { e.source && i[e.source] ? n.push({ command: Ze.removeLayer, args: [e.id] }) : s.push(e) })); let a = e.terrain; a && i[a.source] && (n.push({ command: Ze.setTerrain, args: [void 0] }), a = void 0), n = n.concat(o), t(a, r.terrain) || n.push({ command: Ze.setTerrain, args: [r.terrain] }), function (e, r, n) { r = r || []; const i = (e = e || []).map(Ye), o = r.map(Ye), s = e.reduce(et, {}), a = r.reduce(et, {}), c = i.slice(), l = Object.create(null); let u, h, d, p, f, m, g; for (u = 0, h = 0; u < i.length; u++)d = i[u], a.hasOwnProperty(d) ? h++ : (n.push({ command: Ze.removeLayer, args: [d] }), c.splice(c.indexOf(d, h), 1)); for (u = 0, h = 0; u < o.length; u++)d = o[o.length - 1 - u], c[c.length - 1 - u] !== d && (s.hasOwnProperty(d) ? (n.push({ command: Ze.removeLayer, args: [d] }), c.splice(c.lastIndexOf(d, c.length - h), 1)) : h++, m = c[c.length - u], n.push({ command: Ze.addLayer, args: [a[d], m] }), c.splice(c.length - u, 0, d), l[d] = !0); for (u = 0; u < o.length; u++)if (d = o[u], p = s[d], f = a[d], !l[d] && !t(p, f)) if (t(p.source, f.source) && t(p["source-layer"], f["source-layer"]) && t(p.type, f.type)) { for (g in Ke(p.layout, f.layout, n, d, null, Ze.setLayoutProperty), Ke(p.paint, f.paint, n, d, null, Ze.setPaintProperty), t(p.filter, f.filter) || n.push({ command: Ze.setFilter, args: [d, f.filter] }), t(p.minzoom, f.minzoom) && t(p.maxzoom, f.maxzoom) || n.push({ command: Ze.setLayerZoomRange, args: [d, f.minzoom, f.maxzoom] }), p) p.hasOwnProperty(g) && "layout" !== g && "paint" !== g && "filter" !== g && "metadata" !== g && "minzoom" !== g && "maxzoom" !== g && (0 === g.indexOf("paint.") ? Ke(p[g], f[g], n, d, g.slice(6), Ze.setPaintProperty) : t(p[g], f[g]) || n.push({ command: Ze.setLayerProperty, args: [d, g, f[g]] })); for (g in f) f.hasOwnProperty(g) && !p.hasOwnProperty(g) && "layout" !== g && "paint" !== g && "filter" !== g && "metadata" !== g && "minzoom" !== g && "maxzoom" !== g && (0 === g.indexOf("paint.") ? Ke(p[g], f[g], n, d, g.slice(6), Ze.setPaintProperty) : t(p[g], f[g]) || n.push({ command: Ze.setLayerProperty, args: [d, g, f[g]] })) } else n.push({ command: Ze.removeLayer, args: [d] }), m = c[c.lastIndexOf(d) + 1], n.push({ command: Ze.addLayer, args: [f, m] }) }(s, r.layers, n) } catch (e) { console.warn("Unable to compute style diff:", e), n = [{ command: Ze.setStyle, args: [r] }] } return n }(this.serialize(), r).filter((e => !(e.command in Yt))); if (0 === n.length) return !1; const i = n.filter((e => !(e.command in Kt))); if (i.length > 0) throw new Error(`Unimplemented: ${i.map((e => e.command)).join(", ")}.`); return n.forEach((e => { "setTransition" !== e.command && "setProjection" !== e.command && this[e.command].apply(this, e.args) })), this.stylesheet = r, this._updateMapProjection(), !0 } addImage(t, r) { return this.getImage(t) ? this.fire(new e.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t, r), this._afterImageUpdated(t), this) } updateImage(e, t) { this.imageManager.updateImage(e, t) } getImage(e) { return this.imageManager.getImage(e) } removeImage(t) { return this.getImage(t) ? (this.imageManager.removeImage(t), this._afterImageUpdated(t), this) : this.fire(new e.ErrorEvent(new Error("No image with this name exists."))) } _afterImageUpdated(t) { this._availableImages = this.imageManager.listImages(), this._changedImages[t] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e.Event("data", { dataType: "style" })) } listImages() { return this._checkLoaded(), this._availableImages.slice() } addSource(t, r, n = {}) { if (this._checkLoaded(), void 0 !== this.getSource(t)) throw new Error("There is already a source with this ID"); if (!r.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(r).join(", ")}.`); if (["vector", "raster", "geojson", "video", "image"].indexOf(r.type) >= 0 && this._validate(e.validateSource, `sources.${t}`, r, null, n)) return; this.map && this.map._collectResourceTiming && (r.collectResourceTiming = !0); const i = De(t, r, this.dispatcher, this); i.setEventedParent(this, (() => ({ isSourceLoaded: this._isSourceCacheLoaded(t), source: i.serialize(), sourceId: t }))); const o = r => { const n = (r ? "symbol:" : "other:") + t, o = this._sourceCaches[n] = new e.SourceCache(n, i, r); (r ? this._symbolSourceCaches : this._otherSourceCaches)[t] = o, o.style = this, o.onAdd(this.map) }; o(!1), "vector" !== r.type && "geojson" !== r.type || o(!0), i.onAdd && i.onAdd(this.map), this._changed = !0 } removeSource(t) { this._checkLoaded(); const r = this.getSource(t); if (!r) throw new Error("There is no source with this ID"); for (const i in this._layers) if (this._layers[i].source === t) return this.fire(new e.ErrorEvent(new Error(`Source "${t}" cannot be removed while layer "${i}" is using it.`))); if (this.terrain && this.terrain.get().source === t) return this.fire(new e.ErrorEvent(new Error(`Source "${t}" cannot be removed while terrain is using it.`))); const n = this._getSourceCaches(t); for (const i of n) delete this._sourceCaches[i.id], delete this._updatedSources[i.id], i.fire(new e.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: i.getSource().id })), i.setEventedParent(null), i.clearTiles(); return delete this._otherSourceCaches[t], delete this._symbolSourceCaches[t], r.setEventedParent(null), r.onRemove && r.onRemove(this.map), this._changed = !0, this } setGeoJSONSourceData(e, t) { this._checkLoaded(), this.getSource(e).setData(t), this._changed = !0 } getSource(e) { const t = this._getSourceCache(e); return t && t.getSource() } _getSources() { const e = []; for (const t in this._otherSourceCaches) { const r = this._getSourceCache(t); r && e.push(r.getSource()) } return e } addLayer(t, r, n = {}) { this._checkLoaded(); const i = t.id; if (this.getLayer(i)) return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${i}" already exists on this map`))); let o; if ("custom" === t.type) { if (Jt(this, e.validateCustomStyleLayer(t))) return; o = e.createStyleLayer(t) } else { if ("object" == typeof t.source && (this.addSource(i, t.source), t = e.clone$1(t), t = e.extend(t, { source: i })), this._validate(e.validateLayer, `layers.${i}`, t, { arrayIndex: -1 }, n)) return; o = e.createStyleLayer(t), this._validateLayer(o), o.setEventedParent(this, { layer: { id: i } }), this._serializedLayers[o.id] = o.serialize(), this._updateLayerCount(o, !0) } const s = r ? this._order.indexOf(r) : this._order.length; if (r && -1 === s) return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${r}" does not exist on this map.`))); this._order.splice(s, 0, i), this._layerOrderChanged = !0, this._layers[i] = o; const a = this._getLayerSourceCache(o); if (this._removedLayers[i] && o.source && a && "custom" !== o.type) { const e = this._removedLayers[i]; delete this._removedLayers[i], e.type !== o.type ? this._updatedSources[o.source] = "clear" : (this._updatedSources[o.source] = "reload", a.pause()) } this._updateLayer(o), o.onAdd && o.onAdd(this.map), this._updateDrapeFirstLayers() } moveLayer(t, r) { if (this._checkLoaded(), this._changed = !0, !this._layers[t]) return void this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`))); if (t === r) return; const n = this._order.indexOf(t); this._order.splice(n, 1); const i = r ? this._order.indexOf(r) : this._order.length; r && -1 === i ? this.fire(new e.ErrorEvent(new Error(`Layer with id "${r}" does not exist on this map.`))) : (this._order.splice(i, 0, t), this._layerOrderChanged = !0, this._updateDrapeFirstLayers()) } removeLayer(t) { this._checkLoaded(); const r = this._layers[t]; if (!r) return void this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be removed.`))); r.setEventedParent(null), this._updateLayerCount(r, !1); const n = this._order.indexOf(t); this._order.splice(n, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t] = r, delete this._layers[t], delete this._serializedLayers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t], r.onRemove && r.onRemove(this.map), this._updateDrapeFirstLayers() } getLayer(e) { return this._layers[e] } hasLayer(e) { return e in this._layers } hasLayerType(e) { for (const t in this._layers) if (this._layers[t].type === e) return !0; return !1 } setLayerZoomRange(t, r, n) { this._checkLoaded(); const i = this.getLayer(t); i ? i.minzoom === r && i.maxzoom === n || (null != r && (i.minzoom = r), null != n && (i.maxzoom = n), this._updateLayer(i)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot have zoom extent.`))) } setFilter(r, n, i = {}) { this._checkLoaded(); const o = this.getLayer(r); if (o) { if (!t(o.filter, n)) return null == n ? (o.filter = void 0, void this._updateLayer(o)) : void (this._validate(e.validateFilter, `layers.${o.id}.filter`, n, { layerType: o.type }, i) || (o.filter = e.clone$1(n), this._updateLayer(o))) } else this.fire(new e.ErrorEvent(new Error(`The layer '${r}' does not exist in the map's style and cannot be filtered.`))) } getFilter(t) { const r = this.getLayer(t); return r && e.clone$1(r.filter) } setLayoutProperty(r, n, i, o = {}) { this._checkLoaded(); const s = this.getLayer(r); s ? t(s.getLayoutProperty(n), i) || (s.setLayoutProperty(n, i, o), this._updateLayer(s)) : this.fire(new e.ErrorEvent(new Error(`The layer '${r}' does not exist in the map's style and cannot be styled.`))) } getLayoutProperty(t, r) { const n = this.getLayer(t); if (n) return n.getLayoutProperty(r); this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style.`))) } setPaintProperty(r, n, i, o = {}) { this._checkLoaded(); const s = this.getLayer(r); s ? t(s.getPaintProperty(n), i) || (s.setPaintProperty(n, i, o) && this._updateLayer(s), this._changed = !0, this._updatedPaintProps[r] = !0) : this.fire(new e.ErrorEvent(new Error(`The layer '${r}' does not exist in the map's style and cannot be styled.`))) } getPaintProperty(e, t) { const r = this.getLayer(e); return r && r.getPaintProperty(t) } setFeatureState(t, r) { this._checkLoaded(); const n = t.source, i = t.sourceLayer, o = this.getSource(n); if (!o) return void this.fire(new e.ErrorEvent(new Error(`The source '${n}' does not exist in the map's style.`))); const s = o.type; if ("geojson" === s && i) return void this.fire(new e.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))); if ("vector" === s && !i) return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types."))); void 0 === t.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided."))); const a = this._getSourceCaches(n); for (const e of a) e.setFeatureState(i, t.id, r) } removeFeatureState(t, r) { this._checkLoaded(); const n = t.source, i = this.getSource(n); if (!i) return void this.fire(new e.ErrorEvent(new Error(`The source '${n}' does not exist in the map's style.`))); const o = i.type, s = "vector" === o ? t.sourceLayer : void 0; if ("vector" === o && !s) return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types."))); if (r && "string" != typeof t.id && "number" != typeof t.id) return void this.fire(new e.ErrorEvent(new Error("A feature id is required to remove its specific state property."))); const a = this._getSourceCaches(n); for (const e of a) e.removeFeatureState(s, t.id, r) } getFeatureState(t) { this._checkLoaded(); const r = t.source, n = t.sourceLayer, i = this.getSource(r); if (i) { if ("vector" !== i.type || n) return void 0 === t.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(r)[0].getFeatureState(n, t.id); this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types."))) } else this.fire(new e.ErrorEvent(new Error(`The source '${r}' does not exist in the map's style.`))) } getTransition() { return e.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition) } serialize() { const t = {}; for (const e in this._sourceCaches) { const r = this._sourceCaches[e].getSource(); t[r.id] || (t[r.id] = r.serialize()) } return e.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, terrain: this.getTerrain() || void 0, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: t, layers: this._serializeLayers(this._order) }, (e => void 0 !== e)) } _updateLayer(e) { this._updatedLayers[e.id] = !0; const t = this._getLayerSourceCache(e); e.source && !this._updatedSources[e.source] && t && "raster" !== t.getSource().type && (this._updatedSources[e.source] = "reload", t.pause()), this._changed = !0, e.invalidateCompiledFilter() } _flattenAndSortRenderedFeatures(e) { const t = e => "fill-extrusion" === this._layers[e].type, r = {}, n = []; for (let o = this._order.length - 1; o >= 0; o--) { const i = this._order[o]; if (t(i)) { r[i] = o; for (const t of e) { const e = t[i]; if (e) for (const t of e) n.push(t) } } } n.sort(((e, t) => t.intersectionZ - e.intersectionZ)); const i = []; for (let o = this._order.length - 1; o >= 0; o--) { const s = this._order[o]; if (t(s)) for (let e = n.length - 1; e >= 0; e--) { const t = n[e].feature; if (r[t.layer.id] < o) break; i.push(t), n.pop() } else for (const t of e) { const e = t[s]; if (e) for (const t of e) i.push(t.feature) } } return i } queryRenderedFeatures(t, r, n) { r && r.filter && this._validate(e.validateFilter, "queryRenderedFeatures.filter", r.filter, null, r); const i = {}; if (r && r.layers) { if (!Array.isArray(r.layers)) return this.fire(new e.ErrorEvent(new Error("parameters.layers must be an Array."))), []; for (const t of r.layers) { const r = this._layers[t]; if (!r) return this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be queried for features.`))), []; i[r.source] = !0 } } const o = []; r.availableImages = this._availableImages; const s = r && r.layers ? r.layers.some((e => { const t = this.getLayer(e); return t && t.is3D() })) : this.has3DLayers(), a = F.createFromScreenPoints(t, n); for (const e in this._sourceCaches) { const t = this._sourceCaches[e].getSource().id; r.layers && !i[t] || o.push(Oe(this._sourceCaches[e], this._layers, this._serializedLayers, a, r, n, s, !!this.map._showQueryGeometry)) } return this.placement && o.push(function (e, t, r, n, i, o, s) { const a = {}, c = o.queryRenderedSymbols(n), l = []; for (const u of Object.keys(c).map(Number)) l.push(s[u]); l.sort(Ue); for (const u of l) { const r = u.featureIndex.lookupSymbolFeatures(c[u.bucketInstanceId], t, u.bucketIndex, u.sourceLayerIndex, i.filter, i.layers, i.availableImages, e); for (const e in r) { const t = a[e] = a[e] || [], n = r[e]; n.sort(((e, t) => { const r = u.featureSortOrder; if (r) { const n = r.indexOf(e.featureIndex); return r.indexOf(t.featureIndex) - n } return t.featureIndex - e.featureIndex })); for (const e of n) t.push(e) } } for (const u in a) a[u].forEach((t => { const n = t.feature, i = r(e[u]).getFeatureState(n.layer["source-layer"], n.id); n.source = n.layer.source, n.layer["source-layer"] && (n.sourceLayer = n.layer["source-layer"]), n.state = i })); return a }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), a.screenGeometry, r, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(o) } querySourceFeatures(t, r) { r && r.filter && this._validate(e.validateFilter, "querySourceFeatures.filter", r.filter, null, r); const n = this._getSourceCaches(t); let i = []; for (const e of n) i = i.concat(ze(e, r)); return i } addSourceType(e, t, r) { return rr.getSourceType(e) ? r(new Error(`A source type called "${e}" already exists.`)) : (rr.setSourceType(e, t), t.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e, url: t.workerSourceURL }, r) : r(null, null)) } getLight() { return this.light.getLight() } setLight(e, r = {}) { this._checkLoaded(); const n = this.light.getLight(); let i = !1; for (const s in e) if (!t(e[s], n[s])) { i = !0; break } if (!i) return; const o = this._setTransitionParameters({ duration: 300, delay: 0 }); this.light.setLight(e, r), this.light.updateTransitions(o) } getTerrain() { return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null } setTerrainForDraping() { this.setTerrain({ source: "", exaggeration: 0 }, 0) } setTerrain(r, n = 1) { if (this._checkLoaded(), !r) return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", !1), this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0); if (1 === n) { if ("object" == typeof r.source) { const t = "terrain-dem-src"; this.addSource(t, r.source), r = e.clone$1(r), r = e.extend(r, { source: t }) } if (this._validate(e.validateTerrain, "terrain", r)) return } if (!this.terrain || this.terrain && n !== this.terrain.drapeRenderMode) this._createTerrain(r, n); else { const n = this.terrain, i = n.get(); for (const t of Object.keys(e.spec.terrain)) !r.hasOwnProperty(t) && e.spec.terrain[t].default && (r[t] = e.spec.terrain[t].default); for (const e in r) if (!t(r[e], i[e])) { n.set(r), this.stylesheet.terrain = r; const e = this._setTransitionParameters({ duration: 0 }); n.updateTransitions(e); break } } this._updateDrapeFirstLayers(), this._markersNeedUpdate = !0 } _createFog(e) { const t = this.fog = new B(e, this.map.transform); this.stylesheet.fog = e; const r = this._setTransitionParameters({ duration: 0 }); t.updateTransitions(r) } _updateMarkersOpacity() { 0 !== this.map._markers.length && this.map._requestDomTask((() => { for (const e of this.map._markers) e._evaluateOpacity() })) } getFog() { return this.fog ? this.fog.get() : null } setFog(e) { if (this._checkLoaded(), !e) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0); if (this.fog) { const r = this.fog, n = r.get(); 0 === Object.keys(e).length && r.set(e); for (const i in e) if (!t(e[i], n[i])) { r.set(e), this.stylesheet.fog = e; const t = this._setTransitionParameters({ duration: 0 }); r.updateTransitions(t); break } } else this._createFog(e); this._markersNeedUpdate = !0 } _setTransitionParameters(t) { return { now: e.exported.now(), transition: e.extend(t, this.stylesheet.transition) } } _updateDrapeFirstLayers() { if (!this.map._optimizeForTerrain || !this.terrain) return; const e = this._order.filter((e => this.isLayerDraped(this._layers[e]))), t = this._order.filter((e => !this.isLayerDraped(this._layers[e]))); this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e), this._drapedFirstOrder.push(...t) } _createTerrain(e, t) { const r = this.terrain = new E(e, t); this.stylesheet.terrain = e, this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()), this._force3DLayerUpdate(); const n = this._setTransitionParameters({ duration: 0 }); r.updateTransitions(n) } _force3DLayerUpdate() { for (const e in this._layers) { const t = this._layers[e]; "fill-extrusion" === t.type && this._updateLayer(t) } } _forceSymbolLayerUpdate() { for (const e in this._layers) { const t = this._layers[e]; "symbol" === t.type && this._updateLayer(t) } } _validate(t, r, n, i, o = {}) { return (!o || !1 !== o.validate) && Jt(this, t.call(e.validateStyle, e.extend({ key: r, style: this.serialize(), value: n, styleSpec: e.spec }, i))) } _remove() { this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.evented.off("pluginStateChange", this._rtlTextPluginCallback); for (const e in this._layers) this._layers[e].setEventedParent(null); for (const e in this._sourceCaches) this._sourceCaches[e].clearTiles(), this._sourceCaches[e].setEventedParent(null); this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove() } _clearSource(e) { const t = this._getSourceCaches(e); for (const r of t) r.clearTiles() } _reloadSource(e) { const t = this._getSourceCaches(e); for (const r of t) r.resume(), r.reload() } _reloadSources() { for (const e of this._getSources()) e.reload && e.reload() } _updateSources(e) { for (const t in this._sourceCaches) this._sourceCaches[t].update(e) } _generateCollisionBoxes() { for (const e in this._sourceCaches) { const t = this._sourceCaches[e]; t.resume(), t.reload() } } _updatePlacement(t, r, n, i, o = !1) { let s = !1, a = !1; const c = {}; for (const e of this._order) { const r = this._layers[e]; if ("symbol" !== r.type) continue; if (!c[r.source]) { const e = this._getLayerSourceCache(r); if (!e) continue; c[r.source] = e.getRenderableIds(!0).map((t => e.getTileByID(t))).sort(((e, t) => t.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t.tileID) ? -1 : 1))) } const n = this.crossTileSymbolIndex.addLayer(r, c[r.source], t.center.lng, t.projection); s = s || n } if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), o = o || this._layerOrderChanged || 0 === n, this._layerOrderChanged && this.fire(new e.Event("neworder")), (o || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.exported.now(), t.zoom)) && (this.pauseablePlacement = new Xt(t, this._order, o, r, n, i, this.placement, this.fog && t.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, c), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.exported.now()), a = !0), s && this.pauseablePlacement.placement.setStale()), a || s) for (const e of this._order) { const t = this._layers[e]; "symbol" === t.type && this.placement.updateLayerOpacities(t, c[t.source]) } return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.exported.now()) } _releaseSymbolFadeTiles() { for (const e in this._sourceCaches) this._sourceCaches[e].releaseSymbolFadeTiles() } getImages(e, t, r) { this.imageManager.getImages(t.icons, r), this._updateTilesForChangedImages(); const n = e => { e && e.setDependencies(t.tileID.key, t.type, t.icons) }; n(this._otherSourceCaches[t.source]), n(this._symbolSourceCaches[t.source]) } getGlyphs(e, t, r) { this.glyphManager.getGlyphs(t.stacks, r) } getResource(t, r, n) { return e.makeRequest(r, n) } _getSourceCache(e) { return this._otherSourceCaches[e] } _getLayerSourceCache(e) { return "symbol" === e.type ? this._symbolSourceCaches[e.source] : this._otherSourceCaches[e.source] } _getSourceCaches(e) { const t = []; return this._otherSourceCaches[e] && t.push(this._otherSourceCaches[e]), this._symbolSourceCaches[e] && t.push(this._symbolSourceCaches[e]), t } _isSourceCacheLoaded(t) { const r = this._getSourceCaches(t); return 0 === r.length ? (this.fire(new e.ErrorEvent(new Error(`There is no source with ID '${t}'`))), !1) : r.every((e => e.loaded())) } has3DLayers() { return this._num3DLayers > 0 } hasSymbolLayers() { return this._numSymbolLayers > 0 } hasCircleLayers() { return this._numCircleLayers > 0 } _clearWorkerCaches() { this.dispatcher.broadcast("clearCaches") } destroy() { this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain) } } rr.getSourceType = function (e) { return Re[e] }, rr.setSourceType = function (e, t) { Re[e] = t }, rr.registerForPluginStateChange = e.registerForPluginStateChange; var nr = "\n#define EPSILON 0.0000001\r\n#define PI 3.141592653589793\r\n#define EXTENT 8192.0\r\n#define HALF_PI PI/2.0\r\n#define QUARTER_PI PI/4.0\r\n#define RAD_TO_DEG 180.0/PI\r\n#define DEG_TO_RAD PI/180.0\r\n#define GLOBE_RADIUS EXTENT/PI/2.0", ir = "attribute highp vec3 a_pos_3f;\r\nuniform lowp mat4 u_matrix;\r\nvarying highp vec3 v_uv;\r\nvoid main() {\r\nconst mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);\r\nv_uv=half_neg_pi_around_x*a_pos_3f;\r\nvec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;\r\n}", or = "\n#define ELEVATION_SCALE 7.0\r\n#define ELEVATION_OFFSET 450.0\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nuniform vec3 u_tile_tl_up;\r\nuniform vec3 u_tile_tr_up;\r\nuniform vec3 u_tile_br_up;\r\nuniform vec3 u_tile_bl_up;\r\nuniform float u_tile_up_scale;\r\nvec3 elevationVector(vec2 pos) {\r\nvec2 uv=pos/EXTENT;\r\nvec3 up=normalize(mix(\r\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));\r\nreturn up*u_tile_up_scale;\r\n}\r\n#else\r\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\r\n#endif\nconst float skirtOffset=24575.0;\r\nvec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\r\n{\r\nfloat skirt=float(posWithComposedSkirt.x >=skirtOffset);\r\nvec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);\r\nreturn vec3(pos,skirt);\r\n}\r\n#ifdef TERRAIN\r\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\r\nuniform highp sampler2D u_dem;\r\nuniform highp sampler2D u_dem_prev;\r\n#else\r\nuniform sampler2D u_dem;\r\nuniform sampler2D u_dem_prev;\r\n#endif\r\nuniform vec4 u_dem_unpack;\r\nuniform vec2 u_dem_tl;\r\nuniform vec2 u_dem_tl_prev;\r\nuniform float u_dem_scale;\r\nuniform float u_dem_scale_prev;\r\nuniform float u_dem_size;\r\nuniform float u_dem_lerp;\r\nuniform float u_exaggeration;\r\nuniform float u_meter_to_dem;\r\nuniform mat4 u_label_plane_matrix_inv;\r\nuniform sampler2D u_depth;\r\nuniform vec2 u_depth_size_inv;\r\nvec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {\r\nvec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;\r\nvec2 f=fract(pos);\r\nreturn vec4((pos-f+0.5)/(dem_size+2.0),f);\r\n}\r\nfloat decodeElevation(vec4 v) {\r\nreturn dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);\r\n}\r\nfloat currentElevation(vec2 apos) {\r\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\r\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);\r\nreturn u_exaggeration*texture2D(u_dem,pos).a;\r\n#else\r\nfloat dd=1.0/(u_dem_size+2.0);\r\nvec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);\r\nvec2 pos=r.xy;\r\nvec2 f=r.zw;\r\nfloat tl=decodeElevation(texture2D(u_dem,pos));\r\n#ifdef TERRAIN_DEM_NEAREST_FILTER\r\nreturn u_exaggeration*tl;\r\n#endif\r\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));\r\nfloat bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));\r\nfloat br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));\r\nreturn u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\r\n#endif\r\n}\r\nfloat prevElevation(vec2 apos) {\r\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\r\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);\r\nreturn u_exaggeration*texture2D(u_dem_prev,pos).a;\r\n#else\r\nfloat dd=1.0/(u_dem_size+2.0);\r\nvec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);\r\nvec2 pos=r.xy;\r\nvec2 f=r.zw;\r\nfloat tl=decodeElevation(texture2D(u_dem_prev,pos));\r\nfloat tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));\r\nfloat bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));\r\nfloat br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));\r\nreturn u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\r\n#endif\r\n}\r\n#ifdef TERRAIN_VERTEX_MORPHING\r\nfloat elevation(vec2 apos) {\r\n#ifdef ZERO_EXAGGERATION\r\nreturn 0.0;\r\n#endif\r\nfloat nextElevation=currentElevation(apos);\r\nfloat prevElevation=prevElevation(apos);\r\nreturn mix(prevElevation,nextElevation,u_dem_lerp);\r\n}\r\n#else\r\nfloat elevation(vec2 apos) {\r\n#ifdef ZERO_EXAGGERATION\r\nreturn 0.0;\r\n#endif\r\nreturn currentElevation(apos);\r\n}\r\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\r\n{\r\nconst highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\r\nreturn dot(rgba_depth,bit_shift)*2.0-1.0;\r\n}\r\nbool isOccluded(vec4 frag) {\r\nvec3 coord=frag.xyz/frag.w;\r\nfloat depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));\r\nreturn coord.z > depth+0.0005;\r\n}\r\nfloat occlusionFade(vec4 frag) {\r\nvec3 coord=frag.xyz/frag.w;\r\nvec3 df=vec3(5.0*u_depth_size_inv,0.0);\r\nvec2 uv=0.5*coord.xy+0.5;\r\nvec4 depth=vec4(\r\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\r\n);\r\nreturn dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));\r\n}vec4 fourSample(vec2 pos,vec2 off) {\r\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\r\nfloat tl=texture2D(u_dem,pos).a;\r\nfloat tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;\r\nfloat bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;\r\nfloat br=texture2D(u_dem,pos+off).a;\r\n#else\r\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);\r\nfloat tl=dot(demtl,u_dem_unpack);\r\nvec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);\r\nfloat tr=dot(demtr,u_dem_unpack);\r\nvec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);\r\nfloat bl=dot(dembl,u_dem_unpack);\r\nvec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);\r\nfloat br=dot(dembr,u_dem_unpack);\r\n#endif\r\nreturn vec4(tl,tr,bl,br);\r\n}\r\nfloat flatElevation(vec2 pack) {\r\nvec2 apos=floor(pack/8.0);\r\nvec2 span=10.0*(pack-apos*8.0);\r\nvec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;\r\nfloat size=u_dem_size+2.0;\r\nfloat dd=1.0/size;\r\nvec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;\r\nvec2 f=fract(pos);\r\npos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));\r\nfloat z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);\r\nvec2 w=floor(0.5*(span*u_meter_to_dem-1.0));\r\nvec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));\r\nvec4 diff=abs(h.xzxy-h.ywzw);\r\nvec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));\r\nvec2 fix=slope*span;\r\nfloat base=z+max(fix.x,fix.y);\r\nreturn u_exaggeration*base;\r\n}\r\nfloat elevationFromUint16(float word) {\r\nreturn u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);\r\n}\n#else\r\nfloat elevation(vec2 pos) { return 0.0; }\r\nbool isOccluded(vec4 frag) { return false; }\r\nfloat occlusionFade(vec4 frag) { return 1.0; }\r\n#endif", sr = "#ifdef FOG\r\nuniform mediump vec4 u_fog_color;\r\nuniform mediump vec2 u_fog_range;\r\nuniform mediump float u_fog_horizon_blend;\r\nuniform mediump mat4 u_fog_matrix;\r\nvarying vec3 v_fog_pos;\r\nfloat fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);\r\n}float fog_horizon_blending(vec3 camera_dir) {\r\nfloat t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);\r\n}float fog_opacity(float t) {\r\nconst float decay=6.0;\r\nfloat falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);\r\n}\r\nvec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;\r\n}\r\nvec3 fog_position(vec2 pos) {\r\nreturn fog_position(vec3(pos,0.0));\r\n}\r\nfloat fog(vec3 pos) {\r\nfloat depth=length(pos);\r\nfloat opacity=fog_opacity(fog_range(depth));\r\nreturn opacity*fog_horizon_blending(pos/depth);\r\n}\r\n#endif", ar = "#ifdef FOG\r\nuniform mediump vec4 u_fog_color;\r\nuniform mediump vec2 u_fog_range;\r\nuniform mediump float u_fog_horizon_blend;\r\nuniform mediump float u_fog_temporal_offset;\r\nvarying vec3 v_fog_pos;\r\nuniform highp vec3 u_frustum_tl;\r\nuniform highp vec3 u_frustum_tr;\r\nuniform highp vec3 u_frustum_br;\r\nuniform highp vec3 u_frustum_bl;\r\nuniform highp vec3 u_globe_pos;\r\nuniform highp float u_globe_radius;\r\nuniform highp vec2 u_viewport;\r\nuniform float u_globe_transition;\r\nuniform int u_is_globe;\r\nfloat fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);\r\n}float fog_horizon_blending(vec3 camera_dir) {\r\nfloat t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);\r\n}float fog_opacity(float t) {\r\nconst float decay=6.0;\r\nfloat falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);\r\n}\r\nfloat globe_glow_progress() {\r\nhighp vec2 uv=gl_FragCoord.xy/u_viewport;\r\nhighp vec3 ray_dir=mix(\r\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);\r\nhighp vec3 dir=normalize(ray_dir);\r\nhighp vec3 closest_point=dot(u_globe_pos,dir)*dir;\r\nhighp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;\r\nreturn sdf+PI*0.5;\r\n}float fog_opacity(vec3 pos) {\r\nfloat depth=length(pos);\r\nreturn fog_opacity(fog_range(depth));\r\n}\r\nvec3 fog_apply(vec3 color,vec3 pos) {\r\nfloat depth=length(pos);\r\nfloat opacity;\r\nif (u_is_globe==1) {\r\nfloat glow_progress=globe_glow_progress();\r\nfloat t=mix(glow_progress,depth,u_globe_transition);\r\nopacity=fog_opacity(fog_range(t));\r\n} else {\r\nopacity=fog_opacity(fog_range(depth));\r\nopacity*=fog_horizon_blending(pos/depth);\r\n}\r\nreturn mix(color,u_fog_color.rgb,opacity);\r\n}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {\r\nfloat alpha=EPSILON+color.a;\r\ncolor.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;\r\nreturn color;\r\n}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {\r\nfloat horizon_blend=fog_horizon_blending(normalize(camera_ray));\r\nreturn mix(sky_color,u_fog_color.rgb,horizon_blend);\r\n}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {\r\nfloat alpha=EPSILON+color.a;\r\ncolor.rgb=fog_apply(color.rgb/alpha,pos)*alpha;\r\nreturn color;\r\n}\r\nvec3 fog_dither(vec3 color) {\r\nvec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;\r\nreturn dither(color,dither_seed);\r\n}\r\nvec4 fog_dither(vec4 color) {\r\nreturn vec4(fog_dither(color.rgb),color.a);\r\n}\r\n#endif"; let cr = {}, lr = {}; const ur = []; mr(nr, ur), mr(or, ur), mr(sr, ur), mr(ar, ur), cr = gr("", or), lr = gr(ar, sr); const hr = gr("\n#if __VERSION__ >=300\r\n#define varying in\r\n#define gl_FragColor glFragColor\r\n#define texture2D texture\r\n#define textureCube texture\r\nout vec4 glFragColor;\r\n#endif\r\nhighp vec3 hash(highp vec2 p) {\r\nhighp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));\r\np3+=dot(p3,p3.yxz+19.19);\r\nreturn fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 dither(vec3 color,highp vec2 seed) {\r\nvec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;\r\nreturn color+rnd/255.0;\r\n}\r\nhighp float unpack_depth(highp vec4 rgba_depth)\r\n{\r\nconst highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\r\nreturn dot(rgba_depth,bit_shift)*2.0-1.0;\r\n}highp vec4 pack_depth(highp float ndc_z) {\r\nhighp float depth=ndc_z*0.5+0.5;\r\nconst highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\r\nconst highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\r\nhighp vec4 res=fract(depth*bit_shift);\r\nres-=res.xxyz*bit_mask;\r\nreturn res;\r\n}", "\n#if __VERSION__ >=300\r\n#define attribute in\r\n#define varying out\r\n#define texture2D texture\r\n#endif\r\nfloat wrap(float n,float min,float max) {\r\nfloat d=max-min;\r\nfloat w=mod(mod(n-min,d)+d,d)+min;\r\nreturn (w==min) ? max : w;\r\n}\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\r\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;\r\nvec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;\r\nmercator-=mercator_center;\r\nmercator.x=wrap(mercator.x,-0.5,0.5);\r\nvec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);\r\nmercator_tile=matrix*mercator_tile;\r\nreturn mercator_tile.xyz;\r\n#else\r\nreturn vec3(0.0);\r\n#endif\r\n}\r\nvec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {\r\nreturn mix(globe,mercator,t);\r\n}\r\nmat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {\r\nvec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));\r\nvec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));\r\nvec3 yAxis=normalize(cross(normal,xAxis));\r\nreturn mat3(xAxis,yAxis,normal);\r\n}\r\n#endif\nvec2 unpack_float(const float packedValue) {\r\nint packedIntValue=int(packedValue);\r\nint v0=packedIntValue/256;\r\nreturn vec2(v0,packedIntValue-v0*256);\r\n}\r\nvec2 unpack_opacity(const float packedOpacity) {\r\nint intOpacity=int(packedOpacity)/2;\r\nreturn vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));\r\n}vec4 decode_color(const vec2 encodedColor) {\r\nreturn vec4(\r\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\r\n);\r\n}float unpack_mix_vec2(const vec2 packedValue,const float t) {\r\nreturn mix(packedValue[0],packedValue[1],t);\r\n}vec4 unpack_mix_color(const vec4 packedColors,const float t) {\r\nvec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));\r\nvec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));\r\nreturn mix(minColor,maxColor,t);\r\n}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {\r\nvec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);\r\nreturn (tile_units_to_pixels*pos+offset)/pattern_size;\r\n}\r\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."), dr = nr, pr = "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif"; var fr = { background: gr("uniform vec4 u_color;\r\nuniform float u_opacity;\r\n#ifdef LIGHTING_3D_MODE\r\nvarying vec4 v_color;\r\n#endif\r\nvoid main() {\r\nvec4 out_color;\r\n#ifdef LIGHTING_3D_MODE\r\nout_color=v_color;\r\n#else\r\nout_color=u_color;\r\n#endif\r\n#ifdef FOG\r\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\r\n#endif\r\ngl_FragColor=out_color*u_opacity;\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "attribute vec2 a_pos;\r\nuniform mat4 u_matrix;\r\n#ifdef LIGHTING_3D_MODE\r\nuniform vec4 u_color;\r\nvarying vec4 v_color;\r\n#endif\r\nvoid main() {\r\ngl_Position=u_matrix*vec4(a_pos,0,1);\r\n#ifdef LIGHTING_3D_MODE\r\nv_color=apply_lighting(u_color);\r\n#endif\r\n#ifdef FOG\r\nv_fog_pos=fog_position(a_pos);\r\n#endif\r\n}"), backgroundPattern: gr("uniform vec2 u_pattern_tl;\r\nuniform vec2 u_pattern_br;\r\nuniform vec2 u_texsize;\r\nuniform float u_opacity;\r\nuniform sampler2D u_image;\r\nvarying vec2 v_pos;\r\nvoid main() {\r\nvec2 imagecoord=mod(v_pos,1.0);\r\nvec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);\r\nvec4 out_color=texture2D(u_image,pos);\r\n#ifdef LIGHTING_3D_MODE\r\nout_color=apply_lighting(out_color);\r\n#endif\r\n#ifdef FOG\r\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\r\n#endif\r\ngl_FragColor=out_color*u_opacity;\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "uniform mat4 u_matrix;\r\nuniform vec2 u_pattern_size;\r\nuniform vec2 u_pixel_coord_upper;\r\nuniform vec2 u_pixel_coord_lower;\r\nuniform float u_tile_units_to_pixels;\r\nattribute vec2 a_pos;\r\nvarying vec2 v_pos;\r\nvoid main() {\r\ngl_Position=u_matrix*vec4(a_pos,0,1);\r\nv_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\r\n#ifdef FOG\r\nv_fog_pos=fog_position(a_pos);\r\n#endif\r\n}"), circle: gr("varying vec3 v_data;\r\nvarying float v_visibility;\r\n#pragma mapbox: define highp vec4 color\r\n#pragma mapbox: define mediump float radius\r\n#pragma mapbox: define lowp float blur\r\n#pragma mapbox: define lowp float opacity\r\n#pragma mapbox: define highp vec4 stroke_color\r\n#pragma mapbox: define mediump float stroke_width\r\n#pragma mapbox: define lowp float stroke_opacity\r\nvoid main() {\r\n#pragma mapbox: initialize highp vec4 color\r\n#pragma mapbox: initialize mediump float radius\r\n#pragma mapbox: initialize lowp float blur\r\n#pragma mapbox: initialize lowp float opacity\r\n#pragma mapbox: initialize highp vec4 stroke_color\r\n#pragma mapbox: initialize mediump float stroke_width\r\n#pragma mapbox: initialize lowp float stroke_opacity\r\nvec2 extrude=v_data.xy;\r\nfloat extrude_length=length(extrude);\r\nlowp float antialiasblur=v_data.z;\r\nfloat antialiased_blur=-max(blur,antialiasblur);\r\nfloat opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);\r\nfloat color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\r\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\r\n);\r\nvec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\r\n#ifdef LIGHTING_3D_MODE\r\nout_color=apply_lighting(out_color);\r\n#endif\r\n#ifdef FOG\r\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\r\n#endif\r\ngl_FragColor=out_color*(v_visibility*opacity_t);\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "#define NUM_VISIBILITY_RINGS 2\r\n#define INV_SQRT2 0.70710678\r\n#define ELEVATION_BIAS 0.0001\r\n#define NUM_SAMPLES_PER_RING 16\r\nuniform mat4 u_matrix;\r\nuniform mat2 u_extrude_scale;\r\nuniform lowp float u_device_pixel_ratio;\r\nuniform highp float u_camera_to_center_distance;\r\nattribute vec2 a_pos;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;\r\nuniform vec2 u_merc_center;\r\nuniform vec3 u_tile_id;\r\nuniform float u_zoom_transition;\r\nuniform vec3 u_up_dir;\r\n#endif\r\nvarying vec3 v_data;\r\nvarying float v_visibility;\r\n#pragma mapbox: define highp vec4 color\r\n#pragma mapbox: define mediump float radius\r\n#pragma mapbox: define lowp float blur\r\n#pragma mapbox: define lowp float opacity\r\n#pragma mapbox: define highp vec4 stroke_color\r\n#pragma mapbox: define mediump float stroke_width\r\n#pragma mapbox: define lowp float stroke_opacity\r\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {\r\nreturn extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;\r\n}\r\nfloat cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {\r\nvec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);\r\nvec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);\r\nvec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);\r\nvec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);\r\nfloat h1=elevation(c1)+ELEVATION_BIAS;\r\nfloat h2=elevation(c2)+ELEVATION_BIAS;\r\nfloat h3=elevation(c3)+ELEVATION_BIAS;\r\nfloat h4=elevation(c4)+ELEVATION_BIAS;\r\nreturn max(h4,max(h3,max(h1,h2)));\r\n}\r\nfloat circle_elevation(vec2 pos) {\r\n#if defined(TERRAIN)\r\nreturn elevation(pos)+ELEVATION_BIAS;\r\n#else\r\nreturn 0.0;\r\n#endif\r\n}\r\nvec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {\r\nvec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\r\n#ifdef PITCH_WITH_MAP\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\r\n#else\r\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\r\n#endif\r\n#else\r\nreturn projected_center+vec4(sample_offset,0,0);\r\n#endif\r\n}\r\nfloat get_sample_step() {\r\n#ifdef PITCH_WITH_MAP\r\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\r\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\r\n#endif\r\n}\r\nvoid main(void) {\r\n#pragma mapbox: initialize highp vec4 color\r\n#pragma mapbox: initialize mediump float radius\r\n#pragma mapbox: initialize lowp float blur\r\n#pragma mapbox: initialize lowp float opacity\r\n#pragma mapbox: initialize highp vec4 stroke_color\r\n#pragma mapbox: initialize mediump float stroke_width\r\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);\r\nvec4 world_center;\r\nmat3 surface_vectors;\r\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;\r\nsurface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);\r\nvec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];\r\nvec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);\r\nvec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;\r\nvec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);\r\nvec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;\r\nvec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\r\nworld_center=vec4(pos,1);\r\n#else \r\nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);\r\nworld_center=vec4(circle_center,height,1);\r\n#endif\r\nvec4 projected_center=u_matrix*world_center;\r\nfloat view_scale=0.0;\r\n#ifdef PITCH_WITH_MAP\r\n#ifdef SCALE_WITH_MAP\r\nview_scale=1.0;\r\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\r\n#endif\r\n#else\r\n#ifdef SCALE_WITH_MAP\r\nview_scale=u_camera_to_center_distance;\r\n#else\r\nview_scale=projected_center.w;\r\n#endif\r\n#endif\r\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);\r\nfloat visibility=0.0;\r\n#ifdef TERRAIN\r\nfloat step=get_sample_step();\r\nvec4 occlusion_world_center;\r\nvec4 occlusion_projected_center;\r\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);\r\nocclusion_world_center=vec4(circle_center,cantilevered_height,1);\r\nocclusion_projected_center=u_matrix*occlusion_world_center;\r\n#else\r\nocclusion_world_center=world_center;\r\nocclusion_projected_center=projected_center;\r\n#endif\r\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {\r\nfloat scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);\r\nfor(int i=0; i < NUM_SAMPLES_PER_RING; i++) {\r\nvec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;\r\nvec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);\r\nvisibility+=float(!isOccluded(frag_pos));\r\n}\r\n}\r\nvisibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\r\n#else\r\nvisibility=1.0;\r\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\r\nvisibility=1.0;\r\n#endif\r\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);\r\nv_data=vec3(extrude.x,extrude.y,antialiasblur);\r\n#ifdef FOG\r\nv_fog_pos=fog_position(world_center.xyz);\r\n#endif\r\n}"), clippingMask: gr("void main() {\r\ngl_FragColor=vec4(1.0);\r\n}", "attribute vec2 a_pos;\r\nuniform mat4 u_matrix;\r\nvoid main() {\r\ngl_Position=u_matrix*vec4(a_pos,0,1);\r\n}"), heatmap: gr("uniform highp float u_intensity;\r\nvarying vec2 v_extrude;\r\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\r\nvoid main() {\r\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);\r\nfloat val=weight*u_intensity*GAUSS_COEF*exp(d);\r\ngl_FragColor=vec4(val,1.0,1.0,1.0);\r\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);\r\n}\r\n#endif\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "uniform mat4 u_matrix;\r\nuniform float u_extrude_scale;\r\nuniform float u_opacity;\r\nuniform float u_intensity;\r\nattribute vec2 a_pos;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;\r\nuniform vec2 u_merc_center;\r\nuniform vec3 u_tile_id;\r\nuniform float u_zoom_transition;\r\nuniform vec3 u_up_dir;\r\n#endif\r\nvarying vec2 v_extrude;\r\n#pragma mapbox: define highp float weight\r\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\r\nvoid main(void) {\r\n#pragma mapbox: initialize highp float weight\r\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);\r\nvec3 pos;\r\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;\r\nmat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);\r\nvec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];\r\nvec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);\r\nvec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;\r\nvec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);\r\nvec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;\r\npos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\r\n#else\r\npos=vec3(tilePos+extrude,elevation(tilePos));\r\n#endif\r\ngl_Position=u_matrix*vec4(pos,1);\r\n#ifdef FOG\r\nv_fog_pos=fog_position(pos);\r\n#endif\r\n}"), heatmapTexture: gr("uniform sampler2D u_image;\r\nuniform sampler2D u_color_ramp;\r\nuniform float u_opacity;\r\nvarying vec2 v_pos;\r\nvoid main() {\r\nfloat t=texture2D(u_image,v_pos).r;\r\nvec4 color=texture2D(u_color_ramp,vec2(t,0.5));\r\ngl_FragColor=color*u_opacity;\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(0.0);\r\n#endif\r\n}", "attribute vec2 a_pos;\r\nvarying vec2 v_pos;\r\nvoid main() {\r\ngl_Position=vec4(a_pos,0,1);\r\nv_pos=a_pos*0.5+0.5;\r\n}"), collisionBox: gr("varying float v_placed;\r\nvarying float v_notUsed;\r\nvoid main() {\r\nvec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;\r\ngl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));\r\n}", "attribute vec3 a_pos;\r\nattribute vec2 a_anchor_pos;\r\nattribute vec2 a_extrude;\r\nattribute vec2 a_placed;\r\nattribute vec2 a_shift;\r\nattribute float a_size_scale;\r\nattribute vec2 a_padding;\r\nuniform mat4 u_matrix;\r\nuniform vec2 u_extrude_scale;\r\nuniform float u_camera_to_center_distance;\r\nvarying float v_placed;\r\nvarying float v_notUsed;\r\nvoid main() {\r\nvec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);\r\nhighp float camera_to_anchor_distance=projectedPoint.w;\r\nhighp float collision_perspective_ratio=clamp(\r\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);\r\ngl_Position=projectedPoint;\r\ngl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;\r\nv_placed=a_placed.x;\r\nv_notUsed=a_placed.y;\r\n}"), collisionCircle: gr("varying float v_radius;\r\nvarying vec2 v_extrude;\r\nvarying float v_perspective_ratio;\r\nvarying float v_collision;\r\nvoid main() {\r\nfloat alpha=0.5*min(v_perspective_ratio,1.0);\r\nfloat stroke_radius=0.9*max(v_perspective_ratio,1.0);\r\nfloat distance_to_center=length(v_extrude);\r\nfloat distance_to_edge=abs(distance_to_center-v_radius);\r\nfloat opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);\r\nvec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);\r\ngl_FragColor=color*alpha*opacity_t;\r\n}", "attribute vec2 a_pos_2f;\r\nattribute float a_radius;\r\nattribute vec2 a_flags;\r\nuniform mat4 u_matrix;\r\nuniform mat4 u_inv_matrix;\r\nuniform vec2 u_viewport_size;\r\nuniform float u_camera_to_center_distance;\r\nvarying float v_radius;\r\nvarying vec2 v_extrude;\r\nvarying float v_perspective_ratio;\r\nvarying float v_collision;\r\nvec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);\r\nvec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);\r\nrayStart.xyz/=rayStart.w;\r\nrayEnd.xyz  /=rayEnd.w;\r\nhighp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);\r\nreturn mix(rayStart.xyz,rayEnd.xyz,t);\r\n}\r\nvoid main() {\r\nvec2 quadCenterPos=a_pos_2f;\r\nfloat radius=a_radius;\r\nfloat collision=a_flags.x;\r\nfloat vertexIdx=a_flags.y;\r\nvec2 quadVertexOffset=vec2(\r\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));\r\nvec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);\r\nvec4 clipPos=u_matrix*vec4(tilePos,1.0);\r\nhighp float camera_to_anchor_distance=clipPos.w;\r\nhighp float collision_perspective_ratio=clamp(\r\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;\r\nv_radius=radius;\r\nv_extrude=quadVertexExtent*padding_factor;\r\nv_perspective_ratio=collision_perspective_ratio;\r\nv_collision=collision;\r\ngl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);\r\n}"), debug: gr("uniform highp vec4 u_color;\r\nuniform sampler2D u_overlay;\r\nvarying vec2 v_uv;\r\nvoid main() {\r\nvec4 overlay_color=texture2D(u_overlay,v_uv);\r\ngl_FragColor=mix(u_color,overlay_color,overlay_color.a);\r\n}", "attribute vec2 a_pos;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nattribute vec3 a_pos_3;\r\n#endif\r\nvarying vec2 v_uv;\r\nuniform mat4 u_matrix;\r\nuniform float u_overlay_scale;\r\nvoid main() {float h=elevation(a_pos);\r\nv_uv=a_pos/8192.0;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\r\n#else\r\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\r\n#endif\r\n}"), fill: gr("#pragma mapbox: define highp vec4 color\r\n#pragma mapbox: define lowp float opacity\r\nvoid main() {\r\n#pragma mapbox: initialize highp vec4 color\r\n#pragma mapbox: initialize lowp float opacity\r\nvec4 out_color=color;\r\n#ifdef LIGHTING_3D_MODE\r\nout_color=apply_lighting(out_color);\r\n#endif\r\n#ifdef FOG\r\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\r\n#endif\r\ngl_FragColor=out_color*opacity;\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "attribute vec2 a_pos;\r\nuniform mat4 u_matrix;\r\n#pragma mapbox: define highp vec4 color\r\n#pragma mapbox: define lowp float opacity\r\nvoid main() {\r\n#pragma mapbox: initialize highp vec4 color\r\n#pragma mapbox: initialize lowp float opacity\r\ngl_Position=u_matrix*vec4(a_pos,0,1);\r\n#ifdef FOG\r\nv_fog_pos=fog_position(a_pos);\r\n#endif\r\n}"), fillOutline: gr("varying vec2 v_pos;\r\n#pragma mapbox: define highp vec4 outline_color\r\n#pragma mapbox: define lowp float opacity\r\nvoid main() {\r\n#pragma mapbox: initialize highp vec4 outline_color\r\n#pragma mapbox: initialize lowp float opacity\r\nfloat dist=length(v_pos-gl_FragCoord.xy);\r\nfloat alpha=1.0-smoothstep(0.0,1.0,dist);\r\nvec4 out_color=outline_color;\r\n#ifdef LIGHTING_3D_MODE\r\nout_color=apply_lighting(out_color);\r\n#endif\r\n#ifdef FOG\r\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\r\n#endif\r\ngl_FragColor=out_color*(alpha*opacity);\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "attribute vec2 a_pos;\r\nuniform mat4 u_matrix;\r\nuniform vec2 u_world;\r\nvarying vec2 v_pos;\r\n#pragma mapbox: define highp vec4 outline_color\r\n#pragma mapbox: define lowp float opacity\r\nvoid main() {\r\n#pragma mapbox: initialize highp vec4 outline_color\r\n#pragma mapbox: initialize lowp float opacity\r\ngl_Position=u_matrix*vec4(a_pos,0,1);\r\nv_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\r\n#ifdef FOG\r\nv_fog_pos=fog_position(a_pos);\r\n#endif\r\n}"), fillOutlinePattern: gr("uniform vec2 u_texsize;\r\nuniform sampler2D u_image;\r\nvarying vec2 v_pos;\r\nvarying vec2 v_pos_world;\r\n#pragma mapbox: define lowp float opacity\r\n#pragma mapbox: define lowp vec4 pattern\r\nvoid main() {\r\n#pragma mapbox: initialize lowp float opacity\r\n#pragma mapbox: initialize mediump vec4 pattern\r\nvec2 pattern_tl=pattern.xy;\r\nvec2 pattern_br=pattern.zw;\r\nvec2 imagecoord=mod(v_pos,1.0);\r\nvec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);\r\nfloat alpha=1.0-smoothstep(0.0,1.0,dist);\r\nvec4 out_color=texture2D(u_image,pos);\r\n#ifdef LIGHTING_3D_MODE\r\nout_color=apply_lighting(out_color);\r\n#endif\r\n#ifdef FOG\r\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\r\n#endif\r\ngl_FragColor=out_color*(alpha*opacity);\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "uniform mat4 u_matrix;\r\nuniform vec2 u_world;\r\nuniform vec2 u_pixel_coord_upper;\r\nuniform vec2 u_pixel_coord_lower;\r\nuniform float u_tile_units_to_pixels;\r\nattribute vec2 a_pos;\r\nvarying vec2 v_pos;\r\nvarying vec2 v_pos_world;\r\n#pragma mapbox: define lowp float opacity\r\n#pragma mapbox: define lowp vec4 pattern\r\n#pragma mapbox: define lowp float pixel_ratio\r\nvoid main() {\r\n#pragma mapbox: initialize lowp float opacity\r\n#pragma mapbox: initialize mediump vec4 pattern\r\n#pragma mapbox: initialize lowp float pixel_ratio\r\nvec2 pattern_tl=pattern.xy;\r\nvec2 pattern_br=pattern.zw;\r\ngl_Position=u_matrix*vec4(a_pos,0,1);\r\nvec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;\r\nv_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\r\nv_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\r\n#ifdef FOG\r\nv_fog_pos=fog_position(a_pos);\r\n#endif\r\n}"), fillPattern: gr("uniform vec2 u_texsize;\r\nuniform sampler2D u_image;\r\nvarying vec2 v_pos;\r\n#pragma mapbox: define lowp float opacity\r\n#pragma mapbox: define lowp vec4 pattern\r\nvoid main() {\r\n#pragma mapbox: initialize lowp float opacity\r\n#pragma mapbox: initialize mediump vec4 pattern\r\nvec2 pattern_tl=pattern.xy;\r\nvec2 pattern_br=pattern.zw;\r\nvec2 imagecoord=mod(v_pos,1.0);\r\nvec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);\r\nvec4 out_color=texture2D(u_image,pos);\r\n#ifdef LIGHTING_3D_MODE\r\nout_color=apply_lighting(out_color);\r\n#endif\r\n#ifdef FOG\r\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\r\n#endif\r\ngl_FragColor=out_color*opacity;\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "uniform mat4 u_matrix;\r\nuniform vec2 u_pixel_coord_upper;\r\nuniform vec2 u_pixel_coord_lower;\r\nuniform float u_tile_units_to_pixels;\r\nattribute vec2 a_pos;\r\nvarying vec2 v_pos;\r\n#pragma mapbox: define lowp float opacity\r\n#pragma mapbox: define lowp vec4 pattern\r\n#pragma mapbox: define lowp float pixel_ratio\r\nvoid main() {\r\n#pragma mapbox: initialize lowp float opacity\r\n#pragma mapbox: initialize mediump vec4 pattern\r\n#pragma mapbox: initialize lowp float pixel_ratio\r\nvec2 pattern_tl=pattern.xy;\r\nvec2 pattern_br=pattern.zw;\r\nvec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;\r\ngl_Position=u_matrix*vec4(a_pos,0,1);\r\nv_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\r\n#ifdef FOG\r\nv_fog_pos=fog_position(a_pos);\r\n#endif\r\n}"), fillExtrusion: gr("varying vec4 v_color;\r\n#ifdef RENDER_SHADOWS\r\nvarying highp vec4 v_pos_light_view_0;\r\nvarying highp vec4 v_pos_light_view_1;\r\nvarying float v_depth;\r\n#endif\r\n#ifdef FAUX_AO\r\nuniform lowp vec2 u_ao;\r\nvarying vec3 v_ao;\r\n#endif\r\n#ifdef ZERO_ROOF_RADIUS\r\nvarying vec4 v_roof_color;\r\n#endif\r\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\r\nvarying highp vec3 v_normal;\r\n#endif\r\nvoid main() {\r\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\r\nvec3 normal=v_normal;\r\n#endif\r\nfloat z;\r\nvec4 color;\r\n#ifdef ZERO_ROOF_RADIUS\r\nz=float(normal.z > 0.00001);\r\ncolor=mix(v_color,v_roof_color,z);\r\n#else\r\ncolor=v_color;\r\n#endif\r\n#ifdef FAUX_AO\r\nfloat intensity=u_ao[0];\r\nfloat h=max(0.0,v_ao.z);\r\nfloat h_floors=h/u_ao[1];\r\nfloat y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);\r\nfloat shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\r\n#ifdef ZERO_ROOF_RADIUS\r\nconcave*=(1.0-z);\r\n#endif\r\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);\r\nshade*=mix(1.0,x_shade*x_shade*x_shade,concave);\r\ncolor.rgb=color.rgb*shade;\r\n#endif\r\n#ifdef RENDER_SHADOWS\r\n#ifdef ZERO_ROOF_RADIUS\r\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\r\n#endif\r\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\r\n#endif\r\n#ifdef FOG\r\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\r\n#endif\r\ngl_FragColor=color;\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "uniform mat4 u_matrix;\r\nuniform vec3 u_lightcolor;\r\nuniform lowp vec3 u_lightpos;\r\nuniform lowp float u_lightintensity;\r\nuniform float u_vertical_gradient;\r\nuniform lowp float u_opacity;\r\nuniform float u_edge_radius;\r\nattribute vec4 a_pos_normal_ed;\r\nattribute vec2 a_centroid_pos;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;\r\nuniform vec2 u_merc_center;\r\nuniform vec3 u_tile_id;\r\nuniform float u_zoom_transition;\r\nuniform vec3 u_up_dir;\r\nuniform float u_height_lift;\r\n#endif\r\nvarying vec4 v_color;\r\n#ifdef RENDER_SHADOWS\r\nuniform mat4 u_light_matrix_0;\r\nuniform mat4 u_light_matrix_1;\r\nvarying highp vec4 v_pos_light_view_0;\r\nvarying highp vec4 v_pos_light_view_1;\r\nvarying float v_depth;\r\n#endif\r\n#ifdef ZERO_ROOF_RADIUS\r\nvarying vec4 v_roof_color;\r\n#endif\r\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\r\nvarying highp vec3 v_normal;\r\n#endif\r\n#ifdef FAUX_AO\r\nuniform lowp vec2 u_ao;\r\nvarying vec3 v_ao;\r\n#endif\r\n#pragma mapbox: define highp float base\r\n#pragma mapbox: define highp float height\r\n#pragma mapbox: define highp vec4 color\r\nvoid main() {\r\n#pragma mapbox: initialize highp float base\r\n#pragma mapbox: initialize highp float height\r\n#pragma mapbox: initialize highp vec4 color\r\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;\r\nvec3 top_up_ny=top_up_ny_start.xyz;\r\nfloat x_normal=pos_nx.z/8192.0;\r\nvec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\r\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\r\nv_normal=normal;\r\n#endif\r\nbase=max(0.0,base);\r\nheight=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);\r\nfloat t=top_up_ny.x;\r\nvec2 centroid_pos=vec2(0.0);\r\n#if defined(HAS_CENTROID) || defined(TERRAIN)\r\ncentroid_pos=a_centroid_pos;\r\n#endif\r\nfloat ele=0.0;\r\nfloat h=0.0;\r\nfloat c_ele;\r\nvec3 pos;\r\n#ifdef TERRAIN\r\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;\r\nele=elevation(pos_nx.xy);\r\nc_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);\r\npos=vec3(pos_nx.xy,h);\r\n#else\r\nh=t > 0.0 ? height : base;\r\npos=vec3(pos_nx.xy,h);\r\n#endif\r\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;\r\nh+=lift;\r\nvec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));\r\nvec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);\r\nvec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;\r\npos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\r\n#endif\r\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);\r\ngl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\r\n#ifdef RENDER_SHADOWS\r\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);\r\nv_pos_light_view_1=u_light_matrix_1*vec4(pos,1);\r\nv_depth=gl_Position.w;\r\n#endif\r\nfloat NdotL=0.0;\r\nfloat colorvalue=0.0;\r\n#ifdef LIGHTING_3D_MODE\r\nNdotL=calculate_NdotL(normal);\r\n#else\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);\r\ncolor+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\r\n#endif\nif (normal.y !=0.0) {\r\nfloat r=0.84;\r\n#ifndef LIGHTING_3D_MODE\r\nr=mix(0.7,0.98,1.0-u_lightintensity);\r\n#endif\nNdotL*=(\r\n(1.0-u_vertical_gradient)+\n(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));\r\n}\r\nv_color=vec4(0.0,0.0,0.0,1.0);\r\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;\r\nfloat start=top_up_ny_start.w;\r\nfloat y_ground=1.0-clamp(t+base,0.0,1.0);\r\nfloat top_height=height;\r\n#ifdef TERRAIN\r\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;\r\ny_ground+=y_ground*5.0/max(3.0,top_height);\r\n#endif\r\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);\r\nNdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\r\ntop_height+=u_height_lift;\r\n#endif\r\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\r\n#endif\r\n#ifdef LIGHTING_3D_MODE\r\nv_color=apply_lighting(color,NdotL);\r\n#else\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\r\n#endif\r\nv_color*=u_opacity;\r\n#ifdef ZERO_ROOF_RADIUS\r\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\r\n#ifdef LIGHTING_3D_MODE\r\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\r\n#else\r\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);\r\nroofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);\r\nv_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\r\n#endif\r\nv_roof_color*=u_opacity;\r\n#endif\r\n#ifdef FOG\r\nv_fog_pos=fog_position(pos);\r\n#endif\r\n}"), fillExtrusionPattern: gr("uniform vec2 u_texsize;\r\nuniform sampler2D u_image;\r\n#ifdef FAUX_AO\r\nuniform lowp vec2 u_ao;\r\nvarying vec3 v_ao;\r\n#endif\r\n#ifdef LIGHTING_3D_MODE\r\nvarying float v_NdotL;\r\n#endif\r\nvarying vec2 v_pos;\r\nvarying vec4 v_lighting;\r\nuniform lowp float u_opacity;\r\n#pragma mapbox: define lowp float base\r\n#pragma mapbox: define lowp float height\r\n#pragma mapbox: define lowp vec4 pattern\r\n#pragma mapbox: define lowp float pixel_ratio\r\nvoid main() {\r\n#pragma mapbox: initialize lowp float base\r\n#pragma mapbox: initialize lowp float height\r\n#pragma mapbox: initialize mediump vec4 pattern\r\n#pragma mapbox: initialize lowp float pixel_ratio\r\nvec2 pattern_tl=pattern.xy;\r\nvec2 pattern_br=pattern.zw;\r\nvec2 imagecoord=mod(v_pos,1.0);\r\nvec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);\r\nvec4 out_color=texture2D(u_image,pos);\r\n#ifdef LIGHTING_3D_MODE\r\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\r\n#else\r\nout_color=out_color*v_lighting;\r\n#endif\r\n#ifdef FAUX_AO\r\nfloat intensity=u_ao[0];\r\nfloat h=max(0.0,v_ao.z);\r\nfloat h_floors=h/u_ao[1];\r\nfloat y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);\r\nfloat shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\r\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);\r\nshade*=mix(1.0,x_shade*x_shade*x_shade,concave);\r\nout_color.rgb=out_color.rgb*shade;\r\n#endif\r\n#ifdef FOG\r\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\r\n#endif\r\ngl_FragColor=out_color;\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "uniform mat4 u_matrix;\r\nuniform vec2 u_pixel_coord_upper;\r\nuniform vec2 u_pixel_coord_lower;\r\nuniform float u_height_factor;\r\nuniform float u_tile_units_to_pixels;\r\nuniform float u_vertical_gradient;\r\nuniform lowp float u_opacity;\r\nuniform vec3 u_lightcolor;\r\nuniform lowp vec3 u_lightpos;\r\nuniform lowp float u_lightintensity;\r\nattribute vec4 a_pos_normal_ed;\r\nattribute vec2 a_centroid_pos;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;\r\nuniform vec2 u_merc_center;\r\nuniform vec3 u_tile_id;\r\nuniform float u_zoom_transition;\r\nuniform vec3 u_up_dir;\r\nuniform float u_height_lift;\r\n#endif\r\nvarying vec2 v_pos;\r\nvarying vec4 v_lighting;\r\n#ifdef FAUX_AO\r\nuniform lowp vec2 u_ao;\r\nvarying vec3 v_ao;\r\n#endif\r\n#ifdef LIGHTING_3D_MODE\r\nvarying float v_NdotL;\r\n#endif\r\n#pragma mapbox: define lowp float base\r\n#pragma mapbox: define lowp float height\r\n#pragma mapbox: define lowp vec4 pattern\r\n#pragma mapbox: define lowp float pixel_ratio\r\nvoid main() {\r\n#pragma mapbox: initialize lowp float base\r\n#pragma mapbox: initialize lowp float height\r\n#pragma mapbox: initialize mediump vec4 pattern\r\n#pragma mapbox: initialize lowp float pixel_ratio\r\nvec2 pattern_tl=pattern.xy;\r\nvec2 pattern_br=pattern.zw;\r\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;\r\nmediump vec3 top_up_ny=top_up_ny_start.xyz;\r\nfloat x_normal=pos_nx.z/8192.0;\r\nvec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\r\nfloat edgedistance=a_pos_normal_ed.w;\r\nvec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;\r\nbase=max(0.0,base);\r\nheight=max(0.0,height);\r\nfloat t=top_up_ny.x;\r\nfloat z=t > 0.0 ? height : base;\r\nvec2 centroid_pos=vec2(0.0);\r\n#if defined(HAS_CENTROID) || defined(TERRAIN)\r\ncentroid_pos=a_centroid_pos;\r\n#endif\r\nfloat ele=0.0;\r\nfloat h=z;\r\nvec3 p;\r\nfloat c_ele;\r\n#ifdef TERRAIN\r\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;\r\nele=elevation(pos_nx.xy);\r\nc_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);\r\np=vec3(pos_nx.xy,h);\r\n#else\r\np=vec3(pos_nx.xy,z);\r\n#endif\r\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;\r\nh+=lift;\r\nvec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));\r\nvec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));\r\nvec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;\r\np=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\r\n#endif\r\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);\r\ngl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);\r\nvec2 pos=normal.z==1.0\r\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);\r\nv_lighting=vec4(0.0,0.0,0.0,1.0);\r\nfloat NdotL=0.0;\r\n#ifdef LIGHTING_3D_MODE\r\nNdotL=calculate_NdotL(normal);\r\n#else\r\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);\r\nNdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\r\n#endif\r\nif (normal.y !=0.0) {\r\nfloat r=0.84;\r\n#ifndef LIGHTING_3D_MODE\r\nr=mix(0.7,0.98,1.0-u_lightintensity);\r\n#endif\nNdotL*=(\r\n(1.0-u_vertical_gradient)+\n(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));\r\n}\r\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;\r\nfloat start=top_up_ny_start.w;\r\nfloat y_ground=1.0-clamp(t+base,0.0,1.0);\r\nfloat top_height=height;\r\n#ifdef TERRAIN\r\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;\r\ny_ground+=y_ground*5.0/max(3.0,top_height);\r\n#endif\r\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);\r\nNdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\r\ntop_height+=u_height_lift;\r\n#endif\r\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\r\n#endif\r\n#ifdef LIGHTING_3D_MODE\r\nv_NdotL=NdotL;\r\n#else\r\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\r\nv_lighting*=u_opacity;\r\n#endif \r\n#ifdef FOG\r\nv_fog_pos=fog_position(p);\r\n#endif\r\n}"), hillshadePrepare: gr("#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\nuniform sampler2D u_image;\r\nvarying vec2 v_pos;\r\nuniform vec2 u_dimension;\r\nuniform float u_zoom;\r\nuniform vec4 u_unpack;\r\nfloat getElevation(vec2 coord) {\r\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\r\nreturn texture2D(u_image,coord).a/4.0;\r\n#else\nvec4 data=texture2D(u_image,coord)*255.0;\r\ndata.a=-1.0;\r\nreturn dot(data,u_unpack)/4.0;\r\n#endif\r\n}\r\nvoid main() {\r\nvec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));\r\nfloat b=getElevation(v_pos+vec2(0,-epsilon.y));\r\nfloat c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));\r\nfloat d=getElevation(v_pos+vec2(-epsilon.x,0));\r\nfloat e=getElevation(v_pos+vec2(epsilon.x,0));\r\nfloat f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));\r\nfloat g=getElevation(v_pos+vec2(0,epsilon.y));\r\nfloat h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;\r\nfloat exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;\r\nvec2 deriv=vec2(\r\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\r\n)/pow(2.0,exaggeration+(19.2562-u_zoom));\r\ngl_FragColor=clamp(vec4(\r\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "uniform mat4 u_matrix;\r\nuniform vec2 u_dimension;\r\nattribute vec2 a_pos;\r\nattribute vec2 a_texture_pos;\r\nvarying vec2 v_pos;\r\nvoid main() {\r\ngl_Position=u_matrix*vec4(a_pos,0,1);\r\nhighp vec2 epsilon=1.0/u_dimension;\r\nfloat scale=(u_dimension.x-2.0)/u_dimension.x;\r\nv_pos=(a_texture_pos/8192.0)*scale+epsilon;\r\n}"), hillshade: gr("uniform sampler2D u_image;\r\nvarying vec2 v_pos;\r\nuniform vec2 u_latrange;\r\nuniform vec2 u_light;\r\nuniform vec4 u_shadow;\r\nuniform vec4 u_highlight;\r\nuniform vec4 u_accent;\r\nvoid main() {\r\nvec4 pixel=texture2D(u_image,v_pos);\r\nvec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);\r\nfloat aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);\r\nfloat intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;\r\nfloat maxValue=0.5*PI;\r\nfloat scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);\r\nfloat shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);\r\nvec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);\r\ngl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\r\n#ifdef LIGHTING_3D_MODE\r\ngl_FragColor=apply_lighting(gl_FragColor);\r\n#endif\r\n#ifdef FOG\r\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\r\n#endif\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "uniform mat4 u_matrix;\r\nattribute vec2 a_pos;\r\nattribute vec2 a_texture_pos;\r\nvarying vec2 v_pos;\r\nvoid main() {\r\ngl_Position=u_matrix*vec4(a_pos,0,1);\r\nv_pos=a_texture_pos/8192.0;\r\n#ifdef FOG\r\nv_fog_pos=fog_position(a_pos);\r\n#endif\r\n}"), line: gr("uniform lowp float u_device_pixel_ratio;\r\nuniform float u_alpha_discard_threshold;\r\nuniform highp vec2 u_trim_offset;\r\nvarying vec2 v_width2;\r\nvarying vec2 v_normal;\r\nvarying float v_gamma_scale;\r\nvarying highp vec4 v_uv;\r\n#ifdef RENDER_LINE_DASH\r\nuniform sampler2D u_dash_image;\r\nvarying vec2 v_tex;\r\n#endif\r\n#ifdef RENDER_LINE_GRADIENT\r\nuniform sampler2D u_gradient_image;\r\n#endif\r\nuniform float u_border_width;\r\nuniform vec4 u_border_color;\r\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;\r\n}\r\n#pragma mapbox: define highp vec4 color\r\n#pragma mapbox: define lowp float floorwidth\r\n#pragma mapbox: define lowp vec4 dash\r\n#pragma mapbox: define lowp float blur\r\n#pragma mapbox: define lowp float opacity\r\nfloat linearstep(float edge0,float edge1,float x) {\r\nreturn  clamp((x-edge0)/(edge1-edge0),0.0,1.0);\r\n}\r\nvoid main() {\r\n#pragma mapbox: initialize highp vec4 color\r\n#pragma mapbox: initialize lowp float floorwidth\r\n#pragma mapbox: initialize lowp vec4 dash\r\n#pragma mapbox: initialize lowp float blur\r\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;\r\nfloat alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\r\n#ifdef RENDER_LINE_DASH\r\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;\r\nfloat sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;\r\nalpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\r\n#endif\r\nhighp vec4 out_color;\r\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\r\n#else\r\nout_color=color;\r\n#endif\r\nfloat trimmed=1.0;\r\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];\r\nhighp float end=v_uv[3];\r\nhighp float trim_start=u_trim_offset[0];\r\nhighp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {\r\nif (line_progress <=trim_end && line_progress >=trim_start) {\r\nout_color=vec4(0,0,0,0);\r\ntrimmed=0.0;\r\n}\r\n}\r\n#endif\r\n#ifdef LIGHTING_3D_MODE\r\nout_color=apply_lighting(out_color);\r\n#endif\r\n#ifdef FOG\r\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\r\n#endif\r\n#ifdef RENDER_LINE_ALPHA_DISCARD\r\nif (alpha < u_alpha_discard_threshold) {\r\ndiscard;\r\n}\r\n#endif\r\n#ifdef RENDER_LINE_BORDER\r\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);\r\nfloat alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);\r\nif (alpha2 < 1.) {\r\nfloat smoothAlpha=smoothstep(0.6,1.0,alpha2);\r\n#ifdef RENDER_LINE_BORDER_AUTO\r\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;\r\nif (out_color.a > 0.25 && Y < 0.25) {\r\nvec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;\r\nout_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));\r\n} else {\r\nout_color.rgb*=(0.6 +0.4*smoothAlpha);\r\n}\r\n#else\nout_color.rgb=mix(u_border_color.rgb*u_border_color.a*trimmed,out_color.rgb,smoothAlpha);\r\n#endif\n}\r\n#endif\r\ngl_FragColor=out_color*(alpha*opacity);\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "\n#define EXTRUDE_SCALE 0.015873016\r\nattribute vec2 a_pos_normal;\r\nattribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\r\nattribute highp vec4 a_packed;\r\n#endif\r\n#ifdef RENDER_LINE_DASH\r\nattribute float a_linesofar;\r\n#endif\r\nuniform mat4 u_matrix;\r\nuniform mat2 u_pixels_to_tile_units;\r\nuniform vec2 u_units_to_pixels;\r\nuniform lowp float u_device_pixel_ratio;\r\nvarying vec2 v_normal;\r\nvarying vec2 v_width2;\r\nvarying float v_gamma_scale;\r\nvarying highp vec4 v_uv;\r\n#ifdef RENDER_LINE_DASH\r\nuniform vec2 u_texsize;\r\nuniform float u_tile_units_to_pixels;\r\nvarying vec2 v_tex;\r\n#endif\r\n#ifdef RENDER_LINE_GRADIENT\r\nuniform float u_image_height;\r\n#endif\r\n#pragma mapbox: define highp vec4 color\r\n#pragma mapbox: define lowp float floorwidth\r\n#pragma mapbox: define lowp vec4 dash\r\n#pragma mapbox: define lowp float blur\r\n#pragma mapbox: define lowp float opacity\r\n#pragma mapbox: define mediump float gapwidth\r\n#pragma mapbox: define lowp float offset\r\n#pragma mapbox: define mediump float width\r\nvoid main() {\r\n#pragma mapbox: initialize highp vec4 color\r\n#pragma mapbox: initialize lowp float floorwidth\r\n#pragma mapbox: initialize lowp vec4 dash\r\n#pragma mapbox: initialize lowp float blur\r\n#pragma mapbox: initialize lowp float opacity\r\n#pragma mapbox: initialize mediump float gapwidth\r\n#pragma mapbox: initialize lowp float offset\r\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;\r\nvec2 a_extrude=a_data.xy-128.0;\r\nfloat a_direction=mod(a_data.z,4.0)-1.0;\r\nvec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;\r\nnormal.y=normal.y*2.0-1.0;\r\nv_normal=normal;gapwidth=gapwidth/2.0;\r\nfloat halfwidth=width/2.0;\r\noffset=-1.0*offset;\r\nfloat inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);\r\nfloat outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;\r\nmediump float t=1.0-abs(u);\r\nmediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);\r\nvec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);\r\ngl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\r\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);\r\nfloat extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);\r\nv_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\r\n#else\r\nv_gamma_scale=1.0;\r\n#endif\r\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\r\nfloat a_uv_x=a_packed[0];\r\nfloat a_split_index=a_packed[1];\r\nhighp float a_clip_start=a_packed[2];\r\nhighp float a_clip_end=a_packed[3];\r\n#ifdef RENDER_LINE_GRADIENT\r\nhighp float texel_height=1.0/u_image_height;\r\nhighp float half_texel_height=0.5*texel_height;\r\nv_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\r\n#else\r\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\r\n#endif\r\n#endif\r\n#ifdef RENDER_LINE_DASH\r\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;\r\nfloat height=dash.y;\r\nv_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\r\n#endif\r\nv_width2=vec2(outset,inset);\r\n#ifdef FOG\r\nv_fog_pos=fog_position(pos);\r\n#endif\r\n}"), linePattern: gr("uniform lowp float u_device_pixel_ratio;\r\nuniform vec2 u_texsize;\r\nuniform float u_tile_units_to_pixels;\r\nuniform sampler2D u_image;\r\nvarying vec2 v_normal;\r\nvarying vec2 v_width2;\r\nvarying float v_linesofar;\r\nvarying float v_gamma_scale;\r\nvarying float v_width;\r\n#pragma mapbox: define lowp vec4 pattern\r\n#pragma mapbox: define lowp float pixel_ratio\r\n#pragma mapbox: define lowp float blur\r\n#pragma mapbox: define lowp float opacity\r\nvoid main() {\r\n#pragma mapbox: initialize mediump vec4 pattern\r\n#pragma mapbox: initialize lowp float pixel_ratio\r\n#pragma mapbox: initialize lowp float blur\r\n#pragma mapbox: initialize lowp float opacity\r\nvec2 pattern_tl=pattern.xy;\r\nvec2 pattern_br=pattern.zw;\r\nvec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;\r\nvec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);\r\nfloat aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;\r\nfloat alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\r\nfloat x=mod(v_linesofar/pattern_size.x*aspect,1.0);\r\nfloat y=0.5*v_normal.y+0.5;\r\nvec2 texel_size=1.0/u_texsize;\r\nvec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));\r\nvec4 color=texture2D(u_image,pos);\r\n#ifdef LIGHTING_3D_MODE\r\ncolor=apply_lighting(color);\r\n#endif\r\n#ifdef FOG\r\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\r\n#endif\r\ngl_FragColor=color*(alpha*opacity);\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "\n#define scale 0.015873016\r\nattribute vec2 a_pos_normal;\r\nattribute vec4 a_data;\r\nattribute float a_linesofar;\r\nuniform mat4 u_matrix;\r\nuniform vec2 u_units_to_pixels;\r\nuniform mat2 u_pixels_to_tile_units;\r\nuniform lowp float u_device_pixel_ratio;\r\nvarying vec2 v_normal;\r\nvarying vec2 v_width2;\r\nvarying float v_linesofar;\r\nvarying float v_gamma_scale;\r\nvarying float v_width;\r\n#pragma mapbox: define lowp float blur\r\n#pragma mapbox: define lowp float opacity\r\n#pragma mapbox: define lowp float offset\r\n#pragma mapbox: define mediump float gapwidth\r\n#pragma mapbox: define mediump float width\r\n#pragma mapbox: define lowp float floorwidth\r\n#pragma mapbox: define lowp vec4 pattern\r\n#pragma mapbox: define lowp float pixel_ratio\r\nvoid main() {\r\n#pragma mapbox: initialize lowp float blur\r\n#pragma mapbox: initialize lowp float opacity\r\n#pragma mapbox: initialize lowp float offset\r\n#pragma mapbox: initialize mediump float gapwidth\r\n#pragma mapbox: initialize mediump float width\r\n#pragma mapbox: initialize lowp float floorwidth\r\n#pragma mapbox: initialize mediump vec4 pattern\r\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;\r\nvec2 a_extrude=a_data.xy-128.0;\r\nfloat a_direction=mod(a_data.z,4.0)-1.0;\r\nvec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;\r\nnormal.y=normal.y*2.0-1.0;\r\nv_normal=normal;gapwidth=gapwidth/2.0;\r\nfloat halfwidth=width/2.0;\r\noffset=-1.0*offset;\r\nfloat inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);\r\nfloat outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;\r\nmediump float t=1.0-abs(u);\r\nmediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);\r\nvec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);\r\ngl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\r\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);\r\nfloat extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);\r\nv_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\r\n#else\r\nv_gamma_scale=1.0;\r\n#endif\r\nv_linesofar=a_linesofar;\r\nv_width2=vec2(outset,inset);\r\nv_width=floorwidth;\r\n#ifdef FOG\r\nv_fog_pos=fog_position(pos);\r\n#endif\r\n}"), raster: gr("uniform float u_fade_t;\r\nuniform float u_opacity;\r\nuniform sampler2D u_image0;\r\nuniform sampler2D u_image1;\r\nvarying vec2 v_pos0;\r\nvarying vec2 v_pos1;\r\nuniform float u_brightness_low;\r\nuniform float u_brightness_high;\r\nuniform float u_saturation_factor;\r\nuniform float u_contrast_factor;\r\nuniform vec3 u_spin_weights;\r\nvoid main() {vec4 color0=texture2D(u_image0,v_pos0);\r\nvec4 color1=texture2D(u_image1,v_pos1);\r\nif (color0.a > 0.0) {\r\ncolor0.rgb=color0.rgb/color0.a;\r\n}\r\nif (color1.a > 0.0) {\r\ncolor1.rgb=color1.rgb/color1.a;\r\n}\r\nvec4 color=mix(color0,color1,u_fade_t);\r\ncolor.a*=u_opacity;\r\nvec3 rgb=color.rgb;rgb=vec3(\r\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;\r\nrgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);\r\nvec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);\r\nvec3 out_color=mix(u_high_vec,u_low_vec,rgb);\r\n#ifdef LIGHTING_3D_MODE\r\nout_color=apply_lighting(out_color);\r\n#endif\r\n#ifdef FOG\r\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\r\n#endif\r\ngl_FragColor=vec4(out_color*color.a,color.a);\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "uniform mat4 u_matrix;\r\nuniform vec2 u_tl_parent;\r\nuniform float u_scale_parent;\r\nuniform vec2 u_perspective_transform;\r\nattribute vec2 a_pos;\r\nattribute vec2 a_texture_pos;\r\nvarying vec2 v_pos0;\r\nvarying vec2 v_pos1;\r\nvoid main() {\r\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);\r\ngl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;\r\nv_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\r\n#ifdef FOG\r\nv_fog_pos=fog_position(a_pos);\r\n#endif\r\n}"), symbolIcon: gr("uniform sampler2D u_texture;\r\nvarying vec2 v_tex;\r\nvarying float v_fade_opacity;\r\n#pragma mapbox: define lowp float opacity\r\nvoid main() {\r\n#pragma mapbox: initialize lowp float opacity\r\nlowp float alpha=opacity*v_fade_opacity;\r\ngl_FragColor=texture2D(u_texture,v_tex)*alpha;\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "attribute vec4 a_pos_offset;\r\nattribute vec4 a_tex_size;\r\nattribute vec4 a_pixeloffset;\r\nattribute vec4 a_projected_pos;\r\nattribute float a_fade_opacity;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nattribute vec3 a_globe_anchor;\r\nattribute vec3 a_globe_normal;\r\n#endif\r\nuniform bool u_is_size_zoom_constant;\r\nuniform bool u_is_size_feature_constant;\r\nuniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;\r\nuniform bool u_rotate_symbol;\r\nuniform highp float u_aspect_ratio;\r\nuniform float u_fade_change;\r\nuniform mat4 u_matrix;\r\nuniform mat4 u_label_plane_matrix;\r\nuniform mat4 u_coord_matrix;\r\nuniform bool u_is_text;\r\nuniform bool u_pitch_with_map;\r\nuniform vec2 u_texsize;\r\nuniform vec3 u_up_vector;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nuniform vec3 u_tile_id;\r\nuniform mat4 u_inv_rot_matrix;\r\nuniform vec2 u_merc_center;\r\nuniform vec3 u_camera_forward;\r\nuniform float u_zoom_transition;\r\nuniform vec3 u_ecef_origin;\r\nuniform mat4 u_tile_matrix;\r\n#endif\r\nvarying vec2 v_tex;\r\nvarying float v_fade_opacity;\r\n#pragma mapbox: define lowp float opacity\r\nvoid main() {\r\n#pragma mapbox: initialize lowp float opacity\r\nvec2 a_pos=a_pos_offset.xy;\r\nvec2 a_offset=a_pos_offset.zw;\r\nvec2 a_tex=a_tex_size.xy;\r\nvec2 a_size=a_tex_size.zw;\r\nfloat a_size_min=floor(a_size[0]*0.5);\r\nvec2 a_pxoffset=a_pixeloffset.xy;\r\nvec2 a_min_font_scale=a_pixeloffset.zw/256.0;\r\nhighp float segment_angle=-a_projected_pos[3];\r\nfloat size;\r\nif (!u_is_size_zoom_constant && !u_is_size_feature_constant) {\r\nsize=mix(a_size_min,a_size[1],u_size_t)/128.0;\r\n} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {\r\nsize=a_size_min/128.0;\r\n} else {\r\nsize=u_size;\r\n}\r\nvec2 tile_anchor=a_pos;\r\nvec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);\r\nfloat globe_occlusion_fade;\r\nvec3 world_pos;\r\nvec3 mercator_pos;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);\r\nworld_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);\r\nvec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);\r\nvec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\r\n#else\r\nworld_pos=vec3(tile_anchor,0)+h;\r\nglobe_occlusion_fade=1.0;\r\n#endif\r\nvec4 projected_point=u_matrix*vec4(world_pos,1);\r\nhighp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\r\ncamera_to_anchor_distance/u_camera_to_center_distance :\r\nu_camera_to_center_distance/camera_to_anchor_distance;\r\nhighp float perspective_ratio=clamp(\r\n0.5+0.5*distance_ratio,0.0,1.5);\r\nsize*=perspective_ratio;\r\nfloat font_scale=u_is_text ? size/24.0 : size;\r\nhighp float symbol_rotation=0.0;\r\nif (u_rotate_symbol) {vec4 offsetProjected_point;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);\r\noffsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\r\n#else\r\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\r\n#endif\r\nvec2 a=projected_point.xy/projected_point.w;\r\nvec2 b=offsetProjected_point.xy/offsetProjected_point.w;\r\nsymbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);\r\n}\r\nvec4 projected_pos;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);\r\nprojected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\r\n#else\r\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\r\n#endif\r\nhighp float angle_sin=sin(segment_angle+symbol_rotation);\r\nhighp float angle_cos=cos(segment_angle+symbol_rotation);\r\nmat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);\r\nfloat z=0.0;\r\nvec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\r\n#ifdef TERRAIN\r\n#ifdef PITCH_WITH_MAP_TERRAIN\r\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);\r\nz=elevation(tile_pos.xy);\r\n#endif\r\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\r\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);\r\nvec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);\r\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\r\n#else\r\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\r\n#endif\r\nfloat projection_transition_fade=1.0;\r\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\r\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\r\n#endif\r\nv_tex=a_tex/u_texsize;\r\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);\r\nfloat fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;\r\nv_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;\r\n}"), symbolSDF: gr("#define SDF_PX 8.0\r\nuniform bool u_is_halo;\r\nuniform sampler2D u_texture;\r\nuniform highp float u_gamma_scale;\r\nuniform lowp float u_device_pixel_ratio;\r\nuniform bool u_is_text;\r\nvarying vec2 v_data0;\r\nvarying vec3 v_data1;\r\n#pragma mapbox: define highp vec4 fill_color\r\n#pragma mapbox: define highp vec4 halo_color\r\n#pragma mapbox: define lowp float opacity\r\n#pragma mapbox: define lowp float halo_width\r\n#pragma mapbox: define lowp float halo_blur\r\nvoid main() {\r\n#pragma mapbox: initialize highp vec4 fill_color\r\n#pragma mapbox: initialize highp vec4 halo_color\r\n#pragma mapbox: initialize lowp float opacity\r\n#pragma mapbox: initialize lowp float halo_width\r\n#pragma mapbox: initialize lowp float halo_blur\r\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;\r\nvec2 tex=v_data0.xy;\r\nfloat gamma_scale=v_data1.x;\r\nfloat size=v_data1.y;\r\nfloat fade_opacity=v_data1[2];\r\nfloat fontScale=u_is_text ? size/24.0 : size;\r\nlowp vec4 color=fill_color;\r\nhighp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);\r\nlowp float buff=(256.0-64.0)/256.0;\r\nif (u_is_halo) {\r\ncolor=halo_color;\r\ngamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);\r\nbuff=(6.0-halo_width/fontScale)/SDF_PX;\r\n}\r\nlowp float dist=texture2D(u_texture,tex).a;\r\nhighp float gamma_scaled=gamma*gamma_scale;\r\nhighp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);\r\ngl_FragColor=color*(alpha*opacity*fade_opacity);\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "attribute vec4 a_pos_offset;\r\nattribute vec4 a_tex_size;\r\nattribute vec4 a_pixeloffset;\r\nattribute vec4 a_projected_pos;\r\nattribute float a_fade_opacity;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nattribute vec3 a_globe_anchor;\r\nattribute vec3 a_globe_normal;\r\n#endif\nuniform bool u_is_size_zoom_constant;\r\nuniform bool u_is_size_feature_constant;\r\nuniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;\r\nuniform mat4 u_label_plane_matrix;\r\nuniform mat4 u_coord_matrix;\r\nuniform bool u_is_text;\r\nuniform bool u_pitch_with_map;\r\nuniform bool u_rotate_symbol;\r\nuniform highp float u_aspect_ratio;\r\nuniform highp float u_camera_to_center_distance;\r\nuniform float u_fade_change;\r\nuniform vec2 u_texsize;\r\nuniform vec3 u_up_vector;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nuniform vec3 u_tile_id;\r\nuniform mat4 u_inv_rot_matrix;\r\nuniform vec2 u_merc_center;\r\nuniform vec3 u_camera_forward;\r\nuniform float u_zoom_transition;\r\nuniform vec3 u_ecef_origin;\r\nuniform mat4 u_tile_matrix;\r\n#endif\r\nvarying vec2 v_data0;\r\nvarying vec3 v_data1;\r\n#pragma mapbox: define highp vec4 fill_color\r\n#pragma mapbox: define highp vec4 halo_color\r\n#pragma mapbox: define lowp float opacity\r\n#pragma mapbox: define lowp float halo_width\r\n#pragma mapbox: define lowp float halo_blur\r\nvoid main() {\r\n#pragma mapbox: initialize highp vec4 fill_color\r\n#pragma mapbox: initialize highp vec4 halo_color\r\n#pragma mapbox: initialize lowp float opacity\r\n#pragma mapbox: initialize lowp float halo_width\r\n#pragma mapbox: initialize lowp float halo_blur\r\nvec2 a_pos=a_pos_offset.xy;\r\nvec2 a_offset=a_pos_offset.zw;\r\nvec2 a_tex=a_tex_size.xy;\r\nvec2 a_size=a_tex_size.zw;\r\nfloat a_size_min=floor(a_size[0]*0.5);\r\nvec2 a_pxoffset=a_pixeloffset.xy;\r\nhighp float segment_angle=-a_projected_pos[3];\r\nfloat size;\r\nif (!u_is_size_zoom_constant && !u_is_size_feature_constant) {\r\nsize=mix(a_size_min,a_size[1],u_size_t)/128.0;\r\n} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {\r\nsize=a_size_min/128.0;\r\n} else {\r\nsize=u_size;\r\n}\r\nvec2 tile_anchor=a_pos;\r\nvec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);\r\nfloat globe_occlusion_fade;\r\nvec3 world_pos;\r\nvec3 mercator_pos;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);\r\nworld_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);\r\nvec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);\r\nvec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\r\n#else\r\nworld_pos=vec3(tile_anchor,0)+h;\r\nglobe_occlusion_fade=1.0;\r\n#endif\r\nvec4 projected_point=u_matrix*vec4(world_pos,1);\r\nhighp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\r\ncamera_to_anchor_distance/u_camera_to_center_distance :\r\nu_camera_to_center_distance/camera_to_anchor_distance;\r\nhighp float perspective_ratio=clamp(\r\n0.5+0.5*distance_ratio,0.0,1.5);\r\nsize*=perspective_ratio;\r\nfloat fontScale=u_is_text ? size/24.0 : size;\r\nhighp float symbol_rotation=0.0;\r\nif (u_rotate_symbol) {vec4 offsetprojected_point;\r\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);\r\noffsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\r\n#else\r\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\r\n#endif\r\nvec2 a=projected_point.xy/projected_point.w;\r\nvec2 b=offsetprojected_point.xy/offsetprojected_point.w;\r\nsymbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);\r\n}\r\nvec4 projected_pos;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);\r\nprojected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\r\n#else\r\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\r\n#endif\r\nhighp float angle_sin=sin(segment_angle+symbol_rotation);\r\nhighp float angle_cos=cos(segment_angle+symbol_rotation);\r\nmat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);\r\nfloat z=0.0;\r\nvec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\r\n#ifdef TERRAIN\r\n#ifdef PITCH_WITH_MAP_TERRAIN\r\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);\r\nz=elevation(tile_pos.xy);\r\n#endif\r\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\r\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);\r\nvec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);\r\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\r\n#else\r\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\r\n#endif\r\nfloat gamma_scale=gl_Position.w;\r\nfloat projection_transition_fade=1.0;\r\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\r\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\r\n#endif\r\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);\r\nfloat fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;\r\nfloat interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));\r\nv_data0=a_tex/u_texsize;\r\nv_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);\r\n}"), symbolTextAndIcon: gr("#define SDF_PX 8.0\r\n#define SDF 1.0\r\n#define ICON 0.0\r\nuniform bool u_is_halo;\r\nuniform sampler2D u_texture;\r\nuniform sampler2D u_texture_icon;\r\nuniform highp float u_gamma_scale;\r\nuniform lowp float u_device_pixel_ratio;\r\nvarying vec4 v_data0;\r\nvarying vec4 v_data1;\r\n#pragma mapbox: define highp vec4 fill_color\r\n#pragma mapbox: define highp vec4 halo_color\r\n#pragma mapbox: define lowp float opacity\r\n#pragma mapbox: define lowp float halo_width\r\n#pragma mapbox: define lowp float halo_blur\r\nvoid main() {\r\n#pragma mapbox: initialize highp vec4 fill_color\r\n#pragma mapbox: initialize highp vec4 halo_color\r\n#pragma mapbox: initialize lowp float opacity\r\n#pragma mapbox: initialize lowp float halo_width\r\n#pragma mapbox: initialize lowp float halo_blur\r\nfloat fade_opacity=v_data1[2];\r\nif (v_data1.w==ICON) {\r\nvec2 tex_icon=v_data0.zw;\r\nlowp float alpha=opacity*fade_opacity;\r\ngl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\nreturn;\r\n}\r\nvec2 tex=v_data0.xy;\r\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;\r\nfloat gamma_scale=v_data1.x;\r\nfloat size=v_data1.y;\r\nfloat fontScale=size/24.0;\r\nlowp vec4 color=fill_color;\r\nhighp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);\r\nlowp float buff=(256.0-64.0)/256.0;\r\nif (u_is_halo) {\r\ncolor=halo_color;\r\ngamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);\r\nbuff=(6.0-halo_width/fontScale)/SDF_PX;\r\n}\r\nlowp float dist=texture2D(u_texture,tex).a;\r\nhighp float gamma_scaled=gamma*gamma_scale;\r\nhighp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);\r\ngl_FragColor=color*(alpha*opacity*fade_opacity);\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "attribute vec4 a_pos_offset;\r\nattribute vec4 a_tex_size;\r\nattribute vec4 a_projected_pos;\r\nattribute float a_fade_opacity;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nattribute vec3 a_globe_anchor;\r\nattribute vec3 a_globe_normal;\r\n#endif\nuniform bool u_is_size_zoom_constant;\r\nuniform bool u_is_size_feature_constant;\r\nuniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;\r\nuniform mat4 u_label_plane_matrix;\r\nuniform mat4 u_coord_matrix;\r\nuniform bool u_is_text;\r\nuniform bool u_pitch_with_map;\r\nuniform bool u_rotate_symbol;\r\nuniform highp float u_aspect_ratio;\r\nuniform highp float u_camera_to_center_distance;\r\nuniform float u_fade_change;\r\nuniform vec2 u_texsize;\r\nuniform vec3 u_up_vector;\r\nuniform vec2 u_texsize_icon;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nuniform vec3 u_tile_id;\r\nuniform mat4 u_inv_rot_matrix;\r\nuniform vec2 u_merc_center;\r\nuniform vec3 u_camera_forward;\r\nuniform float u_zoom_transition;\r\nuniform vec3 u_ecef_origin;\r\nuniform mat4 u_tile_matrix;\r\n#endif\r\nvarying vec4 v_data0;\r\nvarying vec4 v_data1;\r\n#pragma mapbox: define highp vec4 fill_color\r\n#pragma mapbox: define highp vec4 halo_color\r\n#pragma mapbox: define lowp float opacity\r\n#pragma mapbox: define lowp float halo_width\r\n#pragma mapbox: define lowp float halo_blur\r\nvoid main() {\r\n#pragma mapbox: initialize highp vec4 fill_color\r\n#pragma mapbox: initialize highp vec4 halo_color\r\n#pragma mapbox: initialize lowp float opacity\r\n#pragma mapbox: initialize lowp float halo_width\r\n#pragma mapbox: initialize lowp float halo_blur\r\nvec2 a_pos=a_pos_offset.xy;\r\nvec2 a_offset=a_pos_offset.zw;\r\nvec2 a_tex=a_tex_size.xy;\r\nvec2 a_size=a_tex_size.zw;\r\nfloat a_size_min=floor(a_size[0]*0.5);\r\nfloat is_sdf=a_size[0]-2.0*a_size_min;\r\nhighp float segment_angle=-a_projected_pos[3];\r\nfloat size;\r\nif (!u_is_size_zoom_constant && !u_is_size_feature_constant) {\r\nsize=mix(a_size_min,a_size[1],u_size_t)/128.0;\r\n} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {\r\nsize=a_size_min/128.0;\r\n} else {\r\nsize=u_size;\r\n}\r\nvec2 tile_anchor=a_pos;\r\nvec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);\r\nfloat globe_occlusion_fade;\r\nvec3 world_pos;\r\nvec3 mercator_pos;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);\r\nworld_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);\r\nvec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);\r\nvec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\r\n#else\r\nworld_pos=vec3(tile_anchor,0)+h;\r\nglobe_occlusion_fade=1.0;\r\n#endif\r\nvec4 projected_point=u_matrix*vec4(world_pos,1);\r\nhighp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\r\ncamera_to_anchor_distance/u_camera_to_center_distance :\r\nu_camera_to_center_distance/camera_to_anchor_distance;\r\nhighp float perspective_ratio=clamp(\r\n0.5+0.5*distance_ratio,0.0,1.5);\r\nsize*=perspective_ratio;\r\nfloat font_scale=size/24.0;\r\nhighp float symbol_rotation=0.0;\r\nif (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);\r\nvec2 a=projected_point.xy/projected_point.w;\r\nvec2 b=offset_projected_point.xy/offset_projected_point.w;\r\nsymbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);\r\n}\r\nvec4 projected_pos;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);\r\nprojected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\r\n#else\r\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\r\n#endif\r\nhighp float angle_sin=sin(segment_angle+symbol_rotation);\r\nhighp float angle_cos=cos(segment_angle+symbol_rotation);\r\nmat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);\r\nfloat z=0.0;\r\nvec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\r\n#ifdef TERRAIN\r\n#ifdef PITCH_WITH_MAP_TERRAIN\r\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);\r\nz=elevation(tile_pos.xy);\r\n#endif\r\n#endif\r\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\r\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);\r\nvec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);\r\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\r\n#else\r\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\r\n#endif\r\nfloat gamma_scale=gl_Position.w;\r\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);\r\nfloat fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;\r\nfloat interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));\r\nfloat projection_transition_fade=1.0;\r\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\r\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\r\n#endif\r\nv_data0.xy=a_tex/u_texsize;\r\nv_data0.zw=a_tex/u_texsize_icon;\r\nv_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);\r\n}"), terrainRaster: gr("uniform sampler2D u_image0;\r\nvarying vec2 v_pos0;\r\n#ifdef FOG\r\nvarying float v_fog_opacity;\r\n#endif\r\n#ifdef RENDER_SHADOWS\r\nvarying vec4 v_pos_light_view_0;\r\nvarying vec4 v_pos_light_view_1;\r\nvarying float v_depth;\r\n#endif\r\nvoid main() {\r\nvec4 color=texture2D(u_image0,v_pos0);\r\n#ifdef RENDER_SHADOWS\r\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\r\n#endif\r\n#ifdef FOG\r\n#ifdef ZERO_EXAGGERATION\r\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\r\n#else\r\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\r\n#endif\r\n#endif\r\ngl_FragColor=color;\r\n#ifdef TERRAIN_WIREFRAME\r\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\r\n#endif\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "uniform mat4 u_matrix;\r\nuniform float u_skirt_height;\r\nattribute vec2 a_pos;\r\nvarying vec2 v_pos0;\r\n#ifdef FOG\r\nvarying float v_fog_opacity;\r\n#endif\r\n#ifdef RENDER_SHADOWS\r\nuniform mat4 u_light_matrix_0;\r\nuniform mat4 u_light_matrix_1;\r\nvarying vec4 v_pos_light_view_0;\r\nvarying vec4 v_pos_light_view_1;\r\nvarying float v_depth;\r\n#endif\r\nconst float wireframeOffset=0.00015;\r\nvoid main() {\r\nvec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);\r\nfloat skirt=decomposedPosAndSkirt.z;\r\nvec2 decodedPos=decomposedPosAndSkirt.xy;\r\nfloat elevation=elevation(decodedPos)-skirt*u_skirt_height;\r\n#ifdef TERRAIN_WIREFRAME\r\nelevation+=wireframeOffset;\r\n#endif\r\nv_pos0=decodedPos/8192.0;\r\ngl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\r\n#ifdef FOG\r\n#ifdef ZERO_EXAGGERATION\r\nv_fog_pos=fog_position(decodedPos);\r\n#else\r\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\r\n#endif\r\n#endif\r\n#ifdef RENDER_SHADOWS\r\nvec3 pos=vec3(decodedPos,elevation);\r\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);\r\nv_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\r\nv_depth=gl_Position.w;\r\n#endif\r\n}"), terrainDepth: gr("#ifdef GL_ES\r\nprecision highp float;\r\n#endif\r\nvarying float v_depth;\r\nvoid main() {\r\ngl_FragColor=pack_depth(v_depth);\r\n}", "uniform mat4 u_matrix;\r\nattribute vec2 a_pos;\r\nvarying float v_depth;\r\nvoid main() {\r\nfloat elevation=elevation(a_pos);\r\ngl_Position=u_matrix*vec4(a_pos,elevation,1.0);\r\nv_depth=gl_Position.z/gl_Position.w;\r\n}"), skybox: gr("\nvarying lowp vec3 v_uv;\r\nuniform lowp samplerCube u_cubemap;\r\nuniform lowp float u_opacity;\r\nuniform highp float u_temporal_offset;\r\nuniform highp vec3 u_sun_direction;\r\nfloat sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {\r\nhighp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;\r\nconst highp float smoothstep_delta=1e-5;\r\nreturn smoothstep(\r\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);\r\n}\r\nfloat map(float value,float start,float end,float new_start,float new_end) {\r\nreturn ((value-start)*(new_end-new_start))/(end-start)+new_start;\r\n}\r\nvoid main() {\r\nvec3 uv=v_uv;const float y_bias=0.015;\r\nuv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);\r\nvec3 sky_color=textureCube(u_cubemap,uv).rgb;\r\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\r\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);\r\ngl_FragColor=vec4(sky_color*u_opacity,u_opacity);\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", ir), skyboxGradient: gr("varying highp vec3 v_uv;\r\nuniform lowp sampler2D u_color_ramp;\r\nuniform highp vec3 u_center_direction;\r\nuniform lowp float u_radius;\r\nuniform lowp float u_opacity;\r\nuniform highp float u_temporal_offset;\r\nvoid main() {\r\nfloat progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;\r\nvec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\r\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\r\n#endif\r\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);\r\ngl_FragColor=color;\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", ir), skyboxCapture: gr("\nvarying highp vec3 v_position;\r\nuniform highp float u_sun_intensity;\r\nuniform highp float u_luminance;\r\nuniform lowp vec3 u_sun_direction;\r\nuniform highp vec4 u_color_tint_r;\r\nuniform highp vec4 u_color_tint_m;\r\n#ifdef GL_ES\r\nprecision highp float;\r\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\r\n#define MIE_G                   0.76\r\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\r\n#define DENSITY_STEPS           4\r\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {\r\nfloat a=dot(dir,dir);\r\nfloat b=2.0*dot(dir,orig);\r\nfloat c=dot(orig,orig)-radius*radius;\r\nfloat d=sqrt(b*b-4.0*a*c);\r\nreturn (-b+d)/(2.0*a);\r\n}\r\nvec3 extinction(vec2 density) {\r\nreturn exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));\r\n}\r\nvec2 local_density(vec3 point) {\r\nfloat height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);\r\nfloat exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);\r\nreturn vec2(exp_r,exp_m);\r\n}\r\nfloat phase_ray(float cos_angle) {\r\nreturn (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);\r\n}\r\nfloat phase_mie(float cos_angle) {\r\nreturn (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/\n((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));\r\n}\r\nvec2 density_to_atmosphere(vec3 point,vec3 light_dir) {\r\nfloat ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);\r\nfloat step_len=ray_len/float(DENSITY_STEPS);\r\nvec2 density_point_to_atmosphere=vec2(0.0);\r\nfor (int i=0; i < DENSITY_STEPS;++i) {\r\nvec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);\r\ndensity_point_to_atmosphere+=local_density(point_on_ray)*step_len;;\r\n}\r\nreturn density_point_to_atmosphere;\r\n}\r\nvec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {\r\nvec2 density_orig_to_point=vec2(0.0);\r\nvec3 scatter_r=vec3(0.0);\r\nvec3 scatter_m=vec3(0.0);\r\nvec3 origin=vec3(0.0,PLANET_RADIUS,0.0);\r\nfloat ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);\r\nfloat step_len=ray_len/float(SAMPLE_STEPS);\r\nfor (int i=0; i < SAMPLE_STEPS;++i) {\r\nvec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;\r\ndensity_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;\r\nvec3 extinction=extinction(density_orig_to_atmosphere);\r\nscatter_r+=density.x*extinction;\r\nscatter_m+=density.y*extinction;\r\n}float cos_angle=dot(ray_dir,sun_direction);\r\nfloat phase_r=phase_ray(cos_angle);\r\nfloat phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;\r\nvec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;\r\nreturn (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;\r\n}\r\nconst float A=0.15;\r\nconst float B=0.50;\r\nconst float C=0.10;\r\nconst float D=0.20;\r\nconst float E=0.02;\r\nconst float F=0.30;\r\nvec3 uncharted2_tonemap(vec3 x) {\r\nreturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\r\n}\r\nvoid main() {\r\nvec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;\r\nray_direction.y+=y_bias;\r\nvec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;\r\ngl_FragColor=vec4(color,1.0);\r\n}", "attribute highp vec3 a_pos_3f;\r\nuniform mat3 u_matrix_3f;\r\nvarying highp vec3 v_position;\r\nfloat map(float value,float start,float end,float new_start,float new_end) {\r\nreturn ((value-start)*(new_end-new_start))/(end-start)+new_start;\r\n}\r\nvoid main() {\r\nvec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);\r\nv_position=pos.xyz;\r\nv_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);\r\ngl_Position=vec4(a_pos_3f.xy,0.0,1.0);\r\n}"), globeRaster: gr("uniform sampler2D u_image0;\r\nvarying vec2 v_pos0;\r\n#ifndef FOG\r\nuniform highp vec3 u_frustum_tl;\r\nuniform highp vec3 u_frustum_tr;\r\nuniform highp vec3 u_frustum_br;\r\nuniform highp vec3 u_frustum_bl;\r\nuniform highp vec3 u_globe_pos;\r\nuniform highp float u_globe_radius;\r\nuniform vec2 u_viewport;\r\n#endif\r\nvoid main() {\r\nvec4 color;\r\n#ifdef CUSTOM_ANTIALIASING\r\nvec2 uv=gl_FragCoord.xy/u_viewport;\r\nhighp vec3 ray_dir=mix(\r\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);\r\nvec3 dir=normalize(ray_dir);\r\nvec3 closest_point=dot(u_globe_pos,dir)*dir;\r\nfloat norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;\r\nconst float antialias_pixel=2.0;\r\nfloat antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);\r\nfloat antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);\r\nvec4 raster=texture2D(u_image0,v_pos0);\r\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\r\n#else\r\ncolor=texture2D(u_image0,v_pos0);\r\n#endif\r\n#ifdef FOG\r\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\r\n#endif\r\ngl_FragColor=color;\r\n#ifdef TERRAIN_WIREFRAME\r\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\r\n#endif\r\n#ifdef OVERDRAW_INSPECTOR\r\ngl_FragColor=vec4(1.0);\r\n#endif\r\n}", "uniform mat4 u_proj_matrix;\r\nuniform mat4 u_normalize_matrix;\r\nuniform mat4 u_globe_matrix;\r\nuniform mat4 u_merc_matrix;\r\nuniform float u_zoom_transition;\r\nuniform vec2 u_merc_center;\r\nuniform mat3 u_grid_matrix;\r\nuniform float u_skirt_height;\r\n#ifdef GLOBE_POLES\r\nattribute vec3 a_globe_pos;\r\nattribute vec2 a_uv;\r\n#else\r\nattribute vec2 a_pos;\n#endif\r\nvarying vec2 v_pos0;\r\nconst float wireframeOffset=1e3;\r\nfloat mercatorXfromLng(float lng) {\r\nreturn (180.0+lng)/360.0;\r\n}\r\nfloat mercatorYfromLat(float lat) {\r\nreturn (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;\r\n}\r\nvec3 latLngToECEF(vec2 latLng) {\r\nlatLng=DEG_TO_RAD*latLng;\r\nfloat cosLat=cos(latLng[0]);\r\nfloat sinLat=sin(latLng[0]);\r\nfloat cosLng=cos(latLng[1]);\r\nfloat sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;\r\nfloat sy=-sinLat*GLOBE_RADIUS;\r\nfloat sz=cosLat*cosLng*GLOBE_RADIUS;\r\nreturn vec3(sx,sy,sz);\r\n}\r\nvoid main() {\r\n#ifdef GLOBE_POLES\r\nvec3 globe_pos=a_globe_pos;\r\nvec2 uv=a_uv;\r\n#else\nfloat tiles=u_grid_matrix[0][2];\r\nfloat idx=u_grid_matrix[1][2];\r\nfloat idy=u_grid_matrix[2][2];\r\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);\r\nvec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);\r\nfloat mercatorY=mercatorYfromLat(latLng[0]);\r\nfloat uvY=mercatorY*tiles-idy;\r\nfloat mercatorX=mercatorXfromLng(latLng[1]);\r\nfloat uvX=mercatorX*tiles-idx;\r\nvec3 globe_pos=latLngToECEF(latLng.xy);\r\nvec2 merc_pos=vec2(mercatorX,mercatorY);\r\nvec2 uv=vec2(uvX,uvY);\r\n#endif\r\nv_pos0=uv;\r\nvec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\r\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\r\n#else\r\nvec3 up_vector=elevationVector(tile_pos);\r\n#endif\r\nfloat height=elevation(tile_pos);\r\n#ifdef TERRAIN_WIREFRAME\r\nheight+=wireframeOffset;\r\n#endif\r\nglobe_pos+=up_vector*height;\r\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\r\n#endif\r\n#ifdef GLOBE_POLES\r\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\r\n#else\r\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);\r\nvec4 merc_world_pos=vec4(0.0);\r\nif (u_zoom_transition > 0.0) {\r\nmerc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);\r\nmerc_world_pos.xy-=u_merc_center;\r\nmerc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);\r\nmerc_world_pos=u_merc_matrix*merc_world_pos;\r\n}\r\nvec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\r\n#endif\r\ngl_Position=u_proj_matrix*interpolated_pos;\r\n#ifdef FOG\r\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\r\n#endif\r\n}"), globeAtmosphere: gr("uniform float u_transition;\r\nuniform highp float u_fadeout_range;\r\nuniform highp float u_temporal_offset;\r\nuniform vec3 u_start_color;\r\nuniform vec4 u_color;\r\nuniform vec4 u_space_color;\r\nuniform vec4 u_high_color;\r\nuniform float u_star_intensity;\r\nuniform float u_star_size;\r\nuniform float u_star_density;\r\nuniform float u_horizon_angle;\r\nuniform mat4 u_rotation_matrix;\r\nvarying highp vec3 v_ray_dir;\r\nvarying highp vec3 v_horizon_dir;\r\nhighp float random(highp vec3 p) {\r\np=fract(p*vec3(23.2342,97.1231,91.2342));\r\np+=dot(p.zxy,p.yxz+123.1234);\r\nreturn fract(p.x*p.y);\r\n}\r\nfloat stars(vec3 p,float scale,vec2 offset) {\r\nvec2 uv_scale=(u_viewport/u_star_size)*scale;\r\nvec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);\r\nvec3 q=fract(position)-0.5;\r\nvec3 id=floor(position);\r\nfloat random_visibility=step(random(id),u_star_density);\r\nfloat circle=smoothstep(0.5+u_star_intensity,0.5,length(q));\r\nreturn circle*random_visibility;\r\n}\r\nvoid main() {\r\nhighp vec3 dir=normalize(v_ray_dir);\r\nfloat globe_pos_dot_dir;\r\n#ifdef PROJECTION_GLOBE_VIEW\r\nglobe_pos_dot_dir=dot(u_globe_pos,dir);\r\nhighp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;\r\nfloat norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\r\ndiscard;\r\nreturn;\r\n}\r\n#endif\r\nhighp vec3 horizon_dir=normalize(v_horizon_dir);\r\nfloat horizon_angle_mercator=dir.y < horizon_dir.y ?\r\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);\r\nfloat horizon_angle;\r\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;\r\nfloat closest_point_to_center=length(closest_point-u_globe_pos);\r\nfloat theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\r\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);\r\nhorizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\r\n#else\r\nhorizon_angle=horizon_angle_mercator;\r\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);\r\nfloat alpha_0=u_color.a;\r\nfloat alpha_1=u_high_color.a;\r\nfloat alpha_2=u_space_color.a;\r\nvec3 color_stop_0=u_color.rgb;\r\nvec3 color_stop_1=u_high_color.rgb;\r\nvec3 color_stop_2=u_space_color.rgb;\r\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);\r\nvec3 c1=mix(c0,color_stop_0,alpha_0);\r\nvec3 c2=mix(c0,c1,t);\r\nvec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);\r\nfloat a1=mix(a0,1.0,alpha_0);\r\nfloat a2=mix(a0,a1,t);\r\nfloat a =mix(alpha_2,a2,t);\r\nvec2 uv=gl_FragCoord.xy/u_viewport-0.5;\r\nfloat aspect_ratio=u_viewport.x/u_viewport.y;\r\nvec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);\r\nuv_dir=u_rotation_matrix*uv_dir;\r\nvec3 n=abs(uv_dir.xyz);\r\nvec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\r\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\r\nuv_dir.xy/uv_dir.z;\r\nuv_remap.x/=aspect_ratio;\r\nvec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;\r\nif (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));\r\nstar_field+=stars(D,1.0,vec2(1.0,0.0));\r\nstar_field+=stars(D,0.8,vec2(0.0,1.0));\r\nstar_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;\r\n}c=dither(c,gl_FragCoord.xy+u_temporal_offset);\r\ngl_FragColor=vec4(c,a);\r\n}", "attribute vec3 a_pos;\r\nattribute vec2 a_uv;uniform vec3 u_frustum_tl;\r\nuniform vec3 u_frustum_tr;\r\nuniform vec3 u_frustum_br;\r\nuniform vec3 u_frustum_bl;\r\nuniform float u_horizon;\r\nvarying highp vec3 v_ray_dir;\r\nvarying highp vec3 v_horizon_dir;\r\nvoid main() {\r\nv_ray_dir=mix(\r\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);\r\nv_horizon_dir=mix(\r\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);\r\ngl_Position=vec4(a_pos,1.0);\r\n}") }; function mr(e, t) { const r = e.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n"); for (let n of r) if (n = n.trim(), "#" === n[0] && n.includes("if") && !n.includes("endif")) { n = n.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim(); const e = n.split(" "); for (const r of e) t.includes(r) || t.push(r) } } function gr(e, t) { const r = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, n = t.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g), i = {}, o = [...ur]; return mr(e, o), mr(t, o), { fragmentSource: e = e.replace(r, ((e, t, r, n, o) => (i[o] = !0, "define" === t ? `\n#ifndef HAS_UNIFORM_u_${o}\nvarying ${r} ${n} ${o};\n#else\nuniform ${r} ${n} u_${o};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${o}\n    ${r} ${n} ${o} = u_${o};\n#endif\n`))), vertexSource: t = t.replace(r, ((e, t, r, n, o) => { const s = "float" === n ? "vec2" : "vec4", a = o.match(/color/) ? "color" : s; return i[o] ? "define" === t ? `\n#ifndef HAS_UNIFORM_u_${o}\nuniform lowp float u_${o}_t;\nattribute ${r} ${s} a_${o};\nvarying ${r} ${n} ${o};\n#else\nuniform ${r} ${n} u_${o};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${o}\n    ${o} = a_${o};\n#else\n    ${r} ${n} ${o} = u_${o};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${o}\n    ${o} = unpack_mix_${a}(a_${o}, u_${o}_t);\n#else\n    ${r} ${n} ${o} = u_${o};\n#endif\n` : "define" === t ? `\n#ifndef HAS_UNIFORM_u_${o}\nuniform lowp float u_${o}_t;\nattribute ${r} ${s} a_${o};\n#else\nuniform ${r} ${n} u_${o};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${o}\n    ${r} ${n} ${o} = a_${o};\n#else\n    ${r} ${n} ${o} = u_${o};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${o}\n    ${r} ${n} ${o} = unpack_mix_${a}(a_${o}, u_${o}_t);\n#else\n    ${r} ${n} ${o} = u_${o};\n#endif\n` })), staticAttributes: n, usedDefines: o } } class _r { constructor() { this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null } bind(e, t, r, n, i, o, s) { this.context = e; let a = this.boundPaintVertexBuffers.length !== n.length; for (let l = 0; !a && l < n.length; l++)this.boundPaintVertexBuffers[l] !== n[l] && (a = !0); let c = this.boundDynamicVertexBuffers.length !== s.length; for (let l = 0; !c && l < s.length; l++)this.boundDynamicVertexBuffers[l] !== s[l] && (c = !0); if (!e.extVertexArrayObject || !this.vao || this.boundProgram !== t || this.boundLayoutVertexBuffer !== r || a || c || this.boundIndexBuffer !== i || this.boundVertexOffset !== o) this.freshBind(t, r, n, i, o, s); else { e.bindVertexArrayOES.set(this.vao); for (const e of s) e && e.bind(); i && i.dynamicDraw && i.bind() } } freshBind(e, t, r, n, i, o) { let s; const a = e.numAttributes, c = this.context, l = c.gl; if (c.extVertexArrayObject) this.vao && this.destroy(), this.vao = c.extVertexArrayObject.createVertexArrayOES(), c.bindVertexArrayOES.set(this.vao), s = 0, this.boundProgram = e, this.boundLayoutVertexBuffer = t, this.boundPaintVertexBuffers = r, this.boundIndexBuffer = n, this.boundVertexOffset = i, this.boundDynamicVertexBuffers = o; else { s = c.currentNumAttributes || 0; for (let e = a; e < s; e++)l.disableVertexAttribArray(e) } t.enableAttributes(l, e), t.bind(), t.setVertexAttribPointers(l, e, i); for (const u of r) u.enableAttributes(l, e), u.bind(), u.setVertexAttribPointers(l, e, i); for (const u of o) u && (u.enableAttributes(l, e), u.bind(), u.setVertexAttribPointers(l, e, i)); n && n.bind(), c.currentNumAttributes = a } destroy() { this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null) } } const yr = (e, t, r, n) => { const i = r.paint.get("hillshade-shadow-color"), o = r.paint.get("hillshade-highlight-color"), s = r.paint.get("hillshade-accent-color"); let a = r.paint.get("hillshade-illumination-direction") * (Math.PI / 180); "viewport" === r.paint.get("hillshade-illumination-anchor") && (a -= e.transform.angle); const c = !e.options.moving; return { u_matrix: n || e.transform.calculateProjMatrix(t.tileID.toUnwrapped(), c), u_image: 0, u_latrange: xr(0, t.tileID), u_light: [r.paint.get("hillshade-exaggeration"), a], u_shadow: i, u_highlight: o, u_accent: s } }, vr = (t, r) => { const n = r.stride, i = e.create(); return e.ortho(i, 0, e.EXTENT, -e.EXTENT, 0, 0, 1), e.translate(i, i, [0, -e.EXTENT, 0]), { u_matrix: i, u_image: 1, u_dimension: [n, n], u_zoom: t.overscaledZ, u_unpack: r.unpackVector } }; function xr(t, r) { const n = Math.pow(2, r.canonical.z), i = r.canonical.y; return [new e.MercatorCoordinate(0, i / n).toLngLat().lat, new e.MercatorCoordinate(0, (i + 1) / n).toLngLat().lat] } function br(t, r, n, i, o, s, a) { const c = t.context, l = c.gl, u = n.fbo; if (!u) return; t.prepareDrawTile(); const h = t.useProgram("hillshade"); c.activeTexture.set(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, u.colorAttachment.get()); const d = yr(t, n, i, t.terrain ? r.projMatrix : null); t.prepareDrawProgram(c, h, r.toUnwrapped()); const { tileBoundsBuffer: p, tileBoundsIndexBuffer: f, tileBoundsSegments: m } = t.getTileBoundsBuffers(n); h.draw(c, l.TRIANGLES, o, s, a, e.CullFaceMode.disabled, d, i.id, p, f, m) } function wr(t, r, n) { if (!r.needsDEMTextureUpload) return; const i = t.context, o = i.gl; i.pixelStoreUnpackPremultiplyAlpha.set(!1), r.demTexture = r.demTexture || t.getTileTexture(n.stride); const s = n.getPixels(); r.demTexture ? r.demTexture.update(s, { premultiply: !1 }) : r.demTexture = new e.Texture(i, s, o.RGBA, { premultiply: !1 }), r.needsDEMTextureUpload = !1 } function Tr(t, r, n, i, o, s) { const a = t.context, c = a.gl; if (!r.dem) return; const l = r.dem; if (a.activeTexture.set(c.TEXTURE1), wr(t, r, l), !r.demTexture) return; r.demTexture.bind(c.NEAREST, c.CLAMP_TO_EDGE); const u = l.dim; a.activeTexture.set(c.TEXTURE0); let h = r.fbo; if (!h) { const t = new e.Texture(a, { width: u, height: u, data: null }, c.RGBA); t.bind(c.LINEAR, c.CLAMP_TO_EDGE), h = r.fbo = a.createFramebuffer(u, u, !0), h.colorAttachment.set(t.texture) } a.bindFramebuffer.set(h.framebuffer), a.viewport.set([0, 0, u, u]); const { tileBoundsBuffer: d, tileBoundsIndexBuffer: p, tileBoundsSegments: f } = t.getMercatorTileBoundsBuffers(); t.useProgram("hillshadePrepare").draw(a, c.TRIANGLES, i, o, s, e.CullFaceMode.disabled, vr(r.tileID, l), n.id, d, p, f), r.needsHillshadePrepare = !1 } const kr = t => ({ u_matrix: new e.UniformMatrix4f(t), u_image0: new e.Uniform1i(t), u_skirt_height: new e.Uniform1f(t) }), Cr = (e, t) => ({ u_matrix: e, u_image0: 0, u_skirt_height: t }), Er = (e, t, r, n, i, o, s, a, c, l, u, h, d, p, f) => ({ u_proj_matrix: Float32Array.from(e), u_globe_matrix: t, u_normalize_matrix: Float32Array.from(n), u_merc_matrix: r, u_zoom_transition: i, u_merc_center: o, u_image0: 0, u_frustum_tl: s, u_frustum_tr: a, u_frustum_br: c, u_frustum_bl: l, u_globe_pos: u, u_globe_radius: h, u_viewport: d, u_grid_matrix: f ? Float32Array.from(f) : new Float32Array(9), u_skirt_height: p }); function Sr(e, t) { return null != e && null != t && !(!e.hasData() || !t.hasData()) && null != e.demTexture && null != t.demTexture && e.tileID.key !== t.tileID.key } const Pr = new class { constructor() { this.operations = {} } newMorphing(e, t, r, n, i) { if (e in this.operations) { const t = this.operations[e]; t.to.tileID.key !== r.tileID.key && (t.queued = r) } else this.operations[e] = { startTime: n, phase: 0, duration: i, from: t, to: r, queued: null } } getMorphValuesForProxy(e) { if (!(e in this.operations)) return null; const t = this.operations[e]; return { from: t.from, to: t.to, phase: t.phase } } update(e) { for (const t in this.operations) { const r = this.operations[t]; for (r.phase = (e - r.startTime) / r.duration; r.phase >= 1 || !this._validOp(r);)if (!this._nextOp(r, e)) { delete this.operations[t]; break } } } _nextOp(e, t) { return !!e.queued && (e.from = e.to, e.to = e.queued, e.queued = null, e.phase = 0, e.startTime = t, !0) } _validOp(e) { return e.from.hasData() && e.to.hasData() } }, Ir = { 0: null, 1: "TERRAIN_VERTEX_MORPHING", 2: "TERRAIN_WIREFRAME" }; function Ar(e) { return 6 * Math.pow(1.5, 22 - e) } function Lr(e, t) { const r = 1 << e.z; return !t && (0 === e.x || e.x === r - 1) || 0 === e.y || e.y === r - 1 } const Mr = e => ({ u_matrix: e }); function Br(t, r, n, i, o) { if (o > 0) { const s = e.exported.now(), a = (s - t.timeAdded) / o, c = r ? (s - r.timeAdded) / o : -1, l = n.getSource(), u = i.coveringZoomLevel({ tileSize: l.tileSize, roundZoom: l.roundZoom }), h = !r || Math.abs(r.tileID.overscaledZ - u) > Math.abs(t.tileID.overscaledZ - u), d = h && t.refreshedUponExpiration ? 1 : e.clamp(h ? a : 1 - c, 0, 1); return t.refreshedUponExpiration && a >= 1 && (t.refreshedUponExpiration = !1), r ? { opacity: 1, mix: 1 - d } : { opacity: d, mix: 0 } } return { opacity: 1, mix: 0 } } class Rr extends e.SourceCache { constructor(e) { const t = { type: "raster-dem", maxzoom: e.transform.maxZoom }, r = new R(je(), null), n = De("mock-dem", t, r, e.style); super("mock-dem", n, !1), n.setEventedParent(this), this._sourceLoaded = !0 } _loadTile(e, t) { e.state = "loaded", t(null) } } class Dr extends e.SourceCache { constructor(e) { const t = De("proxy", { type: "geojson", maxzoom: e.transform.maxZoom }, new R(je(), null), e.style); super("proxy", t, !1), t.setEventedParent(this), this.map = this.getSource().map = e, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {} } update(t, r, n) { if (t.freezeTileCoverage) return; this.transform = t; const i = t.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce(((r, n) => { if (r[n.key] = "", !this._tiles[n.key]) { const r = new e.Tile(n, this._source.tileSize * n.overscaleFactor(), t.tileZoom); r.state = "loaded", this._tiles[n.key] = r } return r }), {}); for (const e in this._tiles) e in i || (this.freeFBO(e), this._tiles[e].unloadVectorData(), delete this._tiles[e]) } freeFBO(e) { const t = this.proxyCachedFBO[e]; if (void 0 !== t) { const r = Object.values(t); this.renderCachePool.push(...r), delete this.proxyCachedFBO[e] } } deallocRenderCache() { this.renderCache.forEach((e => e.fb.destroy())), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {} } } class Fr extends e.OverscaledTileID { constructor(e, t, r) { super(e.overscaledZ, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y), this.proxyTileKey = t, this.projMatrix = r } } class Or extends e.Elevation { constructor(t, r) { super(), this.painter = t, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {}; const [n, i, o] = function (t) { const r = new e.StructArrayLayout2i4, n = new e.StructArrayLayout3ui6, i = 131; r.reserve(17161), n.reserve(33800); const o = e.EXTENT / 128, s = e.EXTENT + o / 2, a = s + o; for (let l = -o; l < a; l += o)for (let t = -o; t < a; t += o) { const n = t < 0 || t > s || l < 0 || l > s ? 24575 : 0, i = e.clamp(Math.round(t), 0, e.EXTENT), o = e.clamp(Math.round(l), 0, e.EXTENT); r.emplaceBack(i + n, o) } const c = (e, t) => { const r = t * i + e; n.emplaceBack(r + 1, r, r + i), n.emplaceBack(r + i, r + i + 1, r + 1) }; for (let e = 1; e < 129; e++)for (let t = 1; t < 129; t++)c(t, e); return [0, 129].forEach((e => { for (let t = 0; t < 130; t++)c(t, e), c(e, t) })), [r, n, 32768] }(), s = t.context; this.gridBuffer = s.createVertexBuffer(n, e.posAttributes.members), this.gridIndexBuffer = s.createIndexBuffer(i), this.gridSegments = e.SegmentVector.simpleSegment(0, 0, n.length, i.length), this.gridNoSkirtSegments = e.SegmentVector.simpleSegment(0, 0, n.length, o), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Dr(r.map), this.orthoMatrix = e.create(), e.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? .015 : 0, e.EXTENT, 0, e.EXTENT, 0, 1); const a = s.gl; this._overlapStencilMode = new e.StencilMode({ func: a.GEQUAL, mask: 255 }, 0, 255, a.KEEP, a.KEEP, a.REPLACE), this._previousZoom = t.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = r, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new Rr(r.map) } set style(e) { e.on("data", this._onStyleDataEvent.bind(this)), e.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = e, this._checkRenderCacheEfficiency(), this._style.map.on("moveend", (() => { this._clearLineLayersFromRenderCache() })) } update(t, r, n) { if (t && t.terrain) { this._style !== t && (this.style = t), this.enabled = !0; const i = t.terrain.properties; this.sourceCache = 0 === t.terrain.drapeRenderMode ? this._mockSourceCache : t._getSourceCache(i.get("source")), this._exaggeration = i.get("exaggeration"); const o = () => { this.sourceCache.used && e.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`); const t = this.getScaledDemTileSize(); this.sourceCache.update(r, t, !0), this.resetTileLookupCache(this.sourceCache.id) }; this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, o(), this._initializing = !0), o(), r.updateElevation(!0, n), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(r), this._emptyDEMTextureDirty = !0 } else this._disable() } resetTileLookupCache(e) { this._findCoveringTileCache[e] = {} } getScaledDemTileSize() { return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize } _checkRenderCacheEfficiency() { const t = this.renderCacheEfficiency(this._style); this._style.map._optimizeForTerrain || 100 !== t.efficiency && e.warnOnce(`Terrain render cache efficiency is not optimal (${t.efficiency}%) and performance\n                may be affected negatively, consider placing all background, fill and line layers before layer\n                with id '${t.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`) } _onStyleDataEvent(e) { e.coord && "source" === e.dataType ? this._clearRenderCacheForTile(e.sourceCacheId, e.coord) : "style" === e.dataType && (this._invalidateRenderCache = !0) } _disable() { if (this.enabled && (this.enabled = !1, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const e in this._style._sourceCaches) this._style._sourceCaches[e].usedForTerrain = !1 } destroy() { this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((e => e.fb.destroy())), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0) } _source() { return this.enabled ? this.sourceCache : null } isUsingMockSource() { return this.sourceCache === this._mockSourceCache } exaggeration() { return this._exaggeration } get visibleDemTiles() { return this._visibleDemTiles } get drapeBufferSize() { const e = 2 * this.proxySourceCache.getSource().tileSize; return [e, e] } set useVertexMorphing(e) { this._useVertexMorphing = e } updateTileBinding(t) { if (!this.enabled) return; this.prevTerrainTileForTile = this.terrainTileForTile; const r = this.proxySourceCache, n = this.painter.transform; this._initializing && (this._initializing = 0 === n._centerAltitude && -1 === this.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(n.center), -1), this._emptyDEMTextureDirty = !this._initializing); const i = this.proxyCoords = r.getIds().map((e => { const t = r.getTileByID(e).tileID; return t.projMatrix = n.calculateProjMatrix(t.toUnwrapped()), t })); !function (t, r) { const n = r.transform.pointCoordinate(r.transform.getCameraPoint()), i = new e.pointGeometry(n.x, n.y); t.sort(((t, r) => { if (r.overscaledZ - t.overscaledZ) return r.overscaledZ - t.overscaledZ; const n = new e.pointGeometry(t.canonical.x + (1 << t.canonical.z) * t.wrap, t.canonical.y), o = new e.pointGeometry(r.canonical.x + (1 << r.canonical.z) * r.wrap, r.canonical.y), s = i.mult(1 << t.canonical.z); return s.x -= .5, s.y -= .5, s.distSqr(n) - s.distSqr(o) })) }(i, this.painter), this._previousZoom = n.zoom; const o = this.proxyToSource || {}; this.proxyToSource = {}, i.forEach((e => { this.proxyToSource[e.key] = {} })), this.terrainTileForTile = {}; const s = this._style._sourceCaches; for (const e in s) { const r = s[e]; if (!r.used) continue; if (r !== this.sourceCache && this.resetTileLookupCache(r.id), this._setupProxiedCoordsForOrtho(r, t[e], o), r.usedForTerrain) continue; const n = t[e]; r.getSource().reparseOverscaled && this._assignTerrainTiles(n) } this.proxiedCoords[r.id] = i.map((e => new Fr(e, e.key, this.orthoMatrix))), this._assignTerrainTiles(i), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(o), this.renderingToTexture = !1, this._updateTimestamp = e.exported.now(); const a = {}; this._visibleDemTiles = []; for (const e of this.proxyCoords) { const t = this.terrainTileForTile[e.key]; if (!t) continue; const r = t.tileID.key; r in a || (this._visibleDemTiles.push(t), a[r] = r) } } _assignTerrainTiles(e) { this._initializing || e.forEach((e => { if (this.terrainTileForTile[e.key]) return; const t = this._findTileCoveringTileID(e, this.sourceCache); t && (this.terrainTileForTile[e.key] = t) })) } _prepareDEMTextures() { const e = this.painter.context, t = e.gl; for (const r in this.terrainTileForTile) { const n = this.terrainTileForTile[r], i = n.dem; !i || n.demTexture && !n.needsDEMTextureUpload || (e.activeTexture.set(t.TEXTURE1), wr(this.painter, n, i)) } } _prepareDemTileUniforms(e, t, r, n) { if (!t || null == t.demTexture) return !1; const i = e.tileID.canonical, o = Math.pow(2, t.tileID.canonical.z - i.z), s = n || ""; return r[`u_dem_tl${s}`] = [i.x * o % 1, i.y * o % 1], r[`u_dem_scale${s}`] = o, !0 } get emptyDEMTexture() { return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture() } get emptyDepthBufferTexture() { const t = this.painter.context, r = t.gl; if (!this._emptyDepthBufferTexture) { const n = new e.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(255, 255, 255, 255)); this._emptyDepthBufferTexture = new e.Texture(t, n, r.RGBA, { premultiply: !1 }) } return this._emptyDepthBufferTexture } _getLoadedAreaMinimum() { let e = 0; const t = this._visibleDemTiles.reduce(((t, r) => { if (!r.dem) return t; const n = r.dem.tree.minimums[0]; return n > 0 && e++, t + n }), 0); return e ? t / e : 0 } _updateEmptyDEMTexture() { const t = this.painter.context, r = t.gl; t.activeTexture.set(r.TEXTURE2); const n = this._getLoadedAreaMinimum(), i = new e.RGBAImage({ width: 1, height: 1 }, new Uint8Array(e.DEMData.pack(n, this.sourceCache.getSource().encoding))); this._emptyDEMTextureDirty = !1; let o = this._emptyDEMTexture; return o ? o.update(i, { premultiply: !1 }) : o = this._emptyDEMTexture = new e.Texture(t, i, r.RGBA, { premultiply: !1 }), o } setupElevationDraw(t, r, n) { const i = this.painter.context, o = i.gl, s = (a = this.sourceCache.getSource().encoding, { u_dem: 2, u_dem_prev: 4, u_dem_unpack: e.DEMData.getUnpackVector(a), u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0 }); var a; s.u_dem_size = this.sourceCache.getSource().tileSize, s.u_exaggeration = this.exaggeration(); let c = null, l = null, u = 1; if (n && n.morphing && this._useVertexMorphing) { const e = n.morphing.srcDemTile, r = n.morphing.dstDemTile; u = n.morphing.phase, e && r && (this._prepareDemTileUniforms(t, e, s, "_prev") && (l = e), this._prepareDemTileUniforms(t, r, s) && (c = r)) } if (l && c ? (i.activeTexture.set(o.TEXTURE2), c.demTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE, o.NEAREST), i.activeTexture.set(o.TEXTURE4), l.demTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE, o.NEAREST), s.u_dem_lerp = u) : (c = this.terrainTileForTile[t.tileID.key], i.activeTexture.set(o.TEXTURE2), (this._prepareDemTileUniforms(t, c, s) ? c.demTexture : this.emptyDEMTexture).bind(o.NEAREST, o.CLAMP_TO_EDGE)), i.activeTexture.set(o.TEXTURE3), n && n.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE), this._depthFBO && (s.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE), s.u_depth_size_inv = [1, 1]), n && n.useMeterToDem && c) { const t = (1 << c.tileID.canonical.z) * e.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize; s.u_meter_to_dem = t } if (n && n.labelPlaneMatrixInv && (s.u_label_plane_matrix_inv = n.labelPlaneMatrixInv), r.setTerrainUniformValues(i, s), "globe" === this.painter.transform.projection.name) { const e = this.globeUniformValues(this.painter.transform, t.tileID.canonical, n && n.useDenormalizedUpVectorScale); r.setGlobeUniformValues(i, e) } } globeUniformValues(t, r, n) { const i = t.projection; return { u_tile_tl_up: i.upVector(r, 0, 0), u_tile_tr_up: i.upVector(r, e.EXTENT, 0), u_tile_br_up: i.upVector(r, e.EXTENT, e.EXTENT), u_tile_bl_up: i.upVector(r, 0, e.EXTENT), u_tile_up_scale: n ? e.globeMetersToEcef(1) : i.upVectorScale(r, t.center.lat, t.worldSize).metersToTile } } renderToBackBuffer(t) { const r = this.painter, n = this.painter.context; 0 !== t.length && (n.bindFramebuffer.set(null), n.viewport.set([0, 0, r.width, r.height]), r.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function (t, r, n, i, o) { if ("globe" === t.transform.projection.name) !function (t, r, n, i, o) { const s = t.context, a = s.gl; let c, l; const u = t.options.showTerrainWireframe ? 2 : 0, h = t.transform, d = e.globeUseCustomAntiAliasing(t, s, h), p = (e, r) => { if (l === e) return; const n = [Ir[e], "PROJECTION_GLOBE_VIEW"]; d && n.push("CUSTOM_ANTIALIASING"), r && n.push(Ir[u]), c = t.useProgram("globeRaster", null, n), l = e }, f = t.colorModeForRenderPass(), m = new e.DepthMode(a.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D); Pr.update(o); const g = e.calculateGlobeMercatorMatrix(h), _ = [e.mercatorXfromLng(h.center.lng), e.mercatorYfromLat(h.center.lat)], y = u ? [!1, !0] : [!1], v = t.globeSharedBuffers, x = [h.width * e.exported.devicePixelRatio, h.height * e.exported.devicePixelRatio], b = Float32Array.from(h.globeMatrix), w = { useDenormalizedUpVectorScale: !0 }; if (y.forEach((u => { const h = t.transform, d = Ar(h.zoom) * r.exaggeration(); l = -1; const y = u ? a.LINES : a.TRIANGLES; for (const l of i) { const i = n.getTile(l), T = e.StencilMode.disabled, k = r.prevTerrainTileForTile[l.key], C = r.terrainTileForTile[l.key]; Sr(k, C) && Pr.newMorphing(l.key, k, C, o, 250), s.activeTexture.set(a.TEXTURE0), i.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE); const E = Pr.getMorphValuesForProxy(l.key), S = E ? 1 : 0; E && e.extend$1(w, { morphing: { srcDemTile: E.from, dstDemTile: E.to, phase: e.easeCubicInOut(E.phase) } }); const P = e.tileCornersToBounds(l.canonical), I = e.getLatitudinalLod(P.getCenter().lat), A = e.getGridMatrix(l.canonical, P, I, h.worldSize / h._pixelsPerMercatorPixel), L = e.globeNormalizeECEF(e.globeTileBounds(l.canonical)), M = Er(h.projMatrix, b, g, L, e.globeToMercatorTransition(h.zoom), _, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, x, d, A); if (p(S, u), r.setupElevationDraw(i, c, w), t.prepareDrawProgram(s, c, l.toUnwrapped()), v) { const [r, n, i] = u ? v.getWirefameBuffers(t.context, I) : v.getGridBuffers(I, 0 !== d); c.draw(s, y, m, T, f, e.CullFaceMode.backCCW, M, "globe_raster", r, n, i) } } })), v) { const o = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"]; d && o.push("CUSTOM_ANTIALIASING"), c = t.useProgram("globeRaster", null, o); for (const l of i) { const { x: i, y: o, z: u } = l.canonical, d = 0 === o, p = o === (1 << u) - 1, [g, y, b, T] = v.getPoleBuffers(u); if (T && (d || p)) { const o = n.getTile(l); s.activeTexture.set(a.TEXTURE0), o.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE); let v = e.globePoleMatrixForTile(u, i, h); const k = e.globeNormalizeECEF(e.globeTileBounds(l.canonical)), C = (t, r) => t.draw(s, a.TRIANGLES, m, e.StencilMode.disabled, f, e.CullFaceMode.disabled, Er(h.projMatrix, v, v, k, 0, _, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, x, 0), "globe_pole_raster", r, b, T); r.setupElevationDraw(o, c, w), t.prepareDrawProgram(s, c, l.toUnwrapped()), d && C(c, g), p && (v = e.scale(e.create(), v, [1, -1, 1]), C(c, y)) } } } }(t, r, n, i, o); else { const s = t.context, a = s.gl; let c, l; const u = t.options.showTerrainWireframe ? 2 : 0, h = (e, r) => { if (l === e) return; const n = [Ir[e]]; r && n.push(Ir[u]), c = t.useProgram("terrainRaster", null, n), l = e }, d = t.colorModeForRenderPass(), p = new e.DepthMode(a.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D); Pr.update(o); const f = t.transform, m = Ar(f.zoom) * r.exaggeration(); (u ? [!1, !0] : [!1]).forEach((u => { l = -1; const g = u ? a.LINES : a.TRIANGLES, [_, y] = u ? r.getWirefameBuffer() : [r.gridIndexBuffer, r.gridSegments]; for (const l of i) { const i = n.getTile(l), v = e.StencilMode.disabled, x = r.prevTerrainTileForTile[l.key], b = r.terrainTileForTile[l.key]; Sr(x, b) && Pr.newMorphing(l.key, x, b, o, 250), s.activeTexture.set(a.TEXTURE0), i.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST); const w = Pr.getMorphValuesForProxy(l.key), T = w ? 1 : 0; let k; w && (k = { morphing: { srcDemTile: w.from, dstDemTile: w.to, phase: e.easeCubicInOut(w.phase) } }); const C = Cr(l.projMatrix, Lr(l.canonical, f.renderWorldCopies) ? m / 10 : m); h(T, u), r.setupElevationDraw(i, c, k), t.prepareDrawProgram(s, c, l.toUnwrapped()), c.draw(s, g, p, v, d, e.CullFaceMode.backCCW, C, "terrain_raster", r.gridBuffer, _, y) } })) } }(r, this, this.proxySourceCache, t, this._updateTimestamp), this.renderingToTexture = !0, r.gpuTimingDeferredRenderEnd(), t.splice(0, t.length)) } renderBatch(t) { if (0 === this._drapedRenderBatches.length) return t + 1; this.renderingToTexture = !0; const r = this.painter, n = this.painter.context, i = this.proxySourceCache, o = this.proxiedCoords[i.id], s = this._drapedRenderBatches.shift(), a = [], c = r.style.order; let l = 0; for (const u of o) { const o = i.getTileByID(u.proxyTileKey), h = i.proxyCachedFBO[u.key] ? i.proxyCachedFBO[u.key][t] : void 0, d = void 0 !== h ? i.renderCache[h] : this.pool[l++], p = void 0 !== h; if (o.texture = d.tex, p && !d.dirty) { a.push(o.tileID); continue } let f; n.bindFramebuffer.set(d.fb.framebuffer), this.renderedToTile = !1, d.dirty && (n.clear({ color: e.Color.transparent, stencil: 0 }), d.dirty = !1); for (let e = s.start; e <= s.end; ++e) { const t = r.style._layers[c[e]]; if (t.isHidden(r.transform.zoom)) continue; const i = r.style._getLayerSourceCache(t), o = i ? this.proxyToSource[u.key][i.id] : [u]; if (!o) continue; const s = o; n.viewport.set([0, 0, d.fb.width, d.fb.height]), f !== (i ? i.id : null) && (this._setupStencil(d, o, t, i), f = i ? i.id : null), r.renderLayer(r, i, t, s) } this.renderedToTile ? (d.dirty = !0, a.push(o.tileID)) : p || --l, 5 === l && (l = 0, this.renderToBackBuffer(a)) } return this.renderToBackBuffer(a), this.renderingToTexture = !1, n.bindFramebuffer.set(null), n.viewport.set([0, 0, r.width, r.height]), s.end + 1 } postRender() { } renderCacheEfficiency(e) { const t = e.order.length; if (0 === t) return { efficiency: 100 }; let r, n = 0, i = 0, o = !1; for (let s = 0; s < t; ++s) { const t = e._layers[e.order[s]]; this._style.isLayerDraped(t) ? (o && ++n, ++i) : o || (o = !0, r = t.id) } return 0 === i ? { efficiency: 100 } : { efficiency: 100 * (1 - n / i), firstUndrapedLayer: r } } getMinElevationBelowMSL() { let e = 0; return this._visibleDemTiles.filter((e => e.dem)).forEach((t => { e = Math.min(e, t.dem.tree.minimums[0]) })), 0 === e ? e : (e - 30) * this._exaggeration } raycast(e, t, r) { if (!this._visibleDemTiles) return null; const n = this._visibleDemTiles.filter((e => e.dem)).map((n => { const i = n.tileID, o = 1 << i.overscaledZ, { x: s, y: a } = i.canonical, c = s / o, l = (s + 1) / o, u = a / o, h = (a + 1) / o; return { minx: c, miny: u, maxx: l, maxy: h, t: n.dem.tree.raycastRoot(c, u, l, h, e, t, r), tile: n } })); n.sort(((e, t) => (null !== e.t ? e.t : Number.MAX_VALUE) - (null !== t.t ? t.t : Number.MAX_VALUE))); for (const i of n) { if (null == i.t) return null; const n = i.tile.dem.tree.raycast(i.minx, i.miny, i.maxx, i.maxy, e, t, r); if (null != n) return n } return null } _createFBO() { const t = this.painter.context, r = t.gl, n = this.drapeBufferSize; t.activeTexture.set(r.TEXTURE0); const i = new e.Texture(t, { width: n[0], height: n[1], data: null }, r.RGBA); i.bind(r.LINEAR, r.CLAMP_TO_EDGE); const o = t.createFramebuffer(n[0], n[1], !1); return o.colorAttachment.set(i.texture), o.depthAttachment = new Ee(t, o.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t.createRenderbuffer(t.gl.DEPTH_STENCIL, n[0], n[1]), this._stencilRef = 0, o.depthAttachment.set(this._sharedDepthStencil), t.clear({ stencil: 0 })) : o.depthAttachment.set(this._sharedDepthStencil), t.extTextureFilterAnisotropic && !t.extTextureFilterAnisotropicForceOff && r.texParameterf(r.TEXTURE_2D, t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.extTextureFilterAnisotropicMax), { fb: o, tex: i, dirty: !1 } } _initFBOPool() { for (; this.pool.length < Math.min(5, this.proxyCoords.length);)this.pool.push(this._createFBO()) } _shouldDisableRenderCache() { if (this._style.light && this._style.light.hasTransition()) return !0; for (const e in this._style._sourceCaches) if (this._style._sourceCaches[e].hasTransition()) return !0; return this._style.order.some((e => { const t = this._style._layers[e], r = t.isHidden(this.painter.transform.zoom); return "custom" === t.type ? !r && t.shouldRedrape() : !r && t.hasTransition() })) } _clearLineLayersFromRenderCache() { let t = !1; for (const e of this._style._getSources()) if (e instanceof Ie) { t = !0; break } if (!t) return; const r = {}; for (let n = 0; n < this._style.order.length; ++n) { const t = this._style._layers[this._style.order[n]], i = this._style._getLayerSourceCache(t); if (i && !r[i.id] && !t.isHidden(this.painter.transform.zoom) && "line" === t.type && t.widthExpression() instanceof e.ZoomDependentExpression) { r[i.id] = !0; for (const e of this.proxyCoords) { const t = this.proxyToSource[e.key][i.id]; if (t) for (const e of t) this._clearRenderCacheForTile(i.id, e) } } } } _clearRasterLayersFromRenderCache() { let e = !1; for (const r in this._style._sourceCaches) if (this._style._sourceCaches[r]._source instanceof Ae) { e = !0; break } if (!e) return; const t = {}; for (let r = 0; r < this._style.order.length; ++r) { const e = this._style._layers[this._style.order[r]], n = this._style._getLayerSourceCache(e); if (!n || t[n.id]) continue; if (e.isHidden(this.painter.transform.zoom) || "raster" !== e.type) continue; const i = e.paint.get("raster-fade-duration"); for (const t of this.proxyCoords) { const e = this.proxyToSource[t.key][n.id]; if (e) for (const t of e) { const e = Br(n.getTile(t), n.findLoadedParent(t, 0), n, this.painter.transform, i); (1 !== e.opacity || 0 !== e.mix) && this._clearRenderCacheForTile(n.id, t) } } } } _setupDrapedRenderBatches() { const e = this._style.order, t = e.length; if (0 === t) return; const r = []; let n, i = 0, o = this._style._layers[e[i]]; for (; !this._style.isLayerDraped(o) && o.isHidden(this.painter.transform.zoom) && ++i < t;)o = this._style._layers[e[i]]; for (; i < t; ++i) { const t = this._style._layers[e[i]]; t.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t) ? void 0 === n && (n = i) : void 0 !== n && (r.push({ start: n, end: i - 1 }), n = void 0)) } void 0 !== n && r.push({ start: n, end: i - 1 }), this._drapedRenderBatches = r } _setupRenderCache(e) { const t = this.proxySourceCache; if (this._shouldDisableRenderCache() || this._invalidateRenderCache) { if (this._invalidateRenderCache = !1, t.renderCache.length > t.renderCachePool.length) { const e = Object.values(t.proxyCachedFBO); t.proxyCachedFBO = {}; for (let r = 0; r < e.length; ++r) { const n = Object.values(e[r]); t.renderCachePool.push(...n) } } return } this._clearRasterLayersFromRenderCache(); const r = this.proxyCoords, n = this._tilesDirty; for (let o = r.length - 1; o >= 0; o--) { const i = r[o]; if (t.getTileByID(i.key), void 0 !== t.proxyCachedFBO[i.key]) { const r = e[i.key], o = this.proxyToSource[i.key]; let s = 0; for (const e in o) { const t = o[e], i = r[e]; if (!i || i.length !== t.length || t.some(((t, r) => t !== i[r] || n[e] && n[e].hasOwnProperty(t.key)))) { s = -1; break } ++s } for (const e in t.proxyCachedFBO[i.key]) t.renderCache[t.proxyCachedFBO[i.key][e]].dirty = s < 0 || s !== Object.values(r).length } } const i = [...this._drapedRenderBatches]; i.sort(((e, t) => t.end - t.start - (e.end - e.start))); for (const o of i) for (const e of r) { if (t.proxyCachedFBO[e.key]) continue; let r = t.renderCachePool.pop(); void 0 === r && t.renderCache.length < 50 && (r = t.renderCache.length, t.renderCache.push(this._createFBO())), void 0 !== r && (t.proxyCachedFBO[e.key] = {}, t.proxyCachedFBO[e.key][o.start] = r, t.renderCache[r].dirty = !0) } this._tilesDirty = {} } _setupStencil(e, t, r, n) { if (!n || !this._sourceTilesOverlap[n.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1)); const i = this.painter.context, o = i.gl; if (t.length <= 1) return void (this._overlapStencilType = !1); let s; if (r.isTileClipped()) s = t.length, this._overlapStencilMode.test = { func: o.EQUAL, mask: 255 }, this._overlapStencilType = "Clip"; else { if (!(t[0].overscaledZ > t[t.length - 1].overscaledZ)) return void (this._overlapStencilType = !1); s = 1, this._overlapStencilMode.test = { func: o.GREATER, mask: 255 }, this._overlapStencilType = "Mask" } this._stencilRef + s > 255 && (i.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += s, this._overlapStencilMode.ref = this._stencilRef, r.isTileClipped() && this._renderTileClippingMasks(t, this._overlapStencilMode.ref) } clipOrMaskOverlapStencilType() { return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType } stencilModeForRTTOverlap(t) { return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t.key]), this._overlapStencilMode) : e.StencilMode.disabled } _renderTileClippingMasks(t, r) { const n = this.painter, i = this.painter.context, o = i.gl; n._tileClippingMaskIDs = {}, i.setColorMode(e.ColorMode.disabled), i.setDepthMode(e.DepthMode.disabled); const s = n.useProgram("clippingMask"); for (const a of t) { const t = n._tileClippingMaskIDs[a.key] = --r; s.draw(i, o.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({ func: o.ALWAYS, mask: 0 }, t, 255, o.KEEP, o.KEEP, o.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Mr(a.projMatrix), "$clipping", n.tileExtentBuffer, n.quadTriangleIndexBuffer, n.tileExtentSegments) } } pointCoordinate(t) { const r = this.painter.transform; if (t.x < 0 || t.x > r.width || t.y < 0 || t.y > r.height) return null; const n = [t.x, t.y, 1, 1]; e.transformMat4$1(n, n, r.pixelMatrixInverse), e.scale$1(n, n, 1 / n[3]), n[0] /= r.worldSize, n[1] /= r.worldSize; const i = r._camera.position, o = e.mercatorZfromAltitude(1, r.center.lat), s = [i[0], i[1], i[2] / o, 0], a = e.subtract([], n.slice(0, 3), s); e.normalize(a, a); const c = this.raycast(s, a, this._exaggeration); return null !== c && c ? (e.scaleAndAdd(s, s, a, c), s[3] = s[2], s[2] *= o, s) : null } drawDepth() { const t = this.painter, r = t.context, n = this.proxySourceCache, i = Math.ceil(t.width), o = Math.ceil(t.height); if (!this._depthFBO || this._depthFBO.width === i && this._depthFBO.height === o || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) { const t = r.gl, n = r.createFramebuffer(i, o, !0); r.activeTexture.set(t.TEXTURE0); const s = new e.Texture(r, { width: i, height: o, data: null }, t.RGBA); s.bind(t.NEAREST, t.CLAMP_TO_EDGE), n.colorAttachment.set(s.texture); const a = r.createRenderbuffer(r.gl.DEPTH_COMPONENT16, i, o); n.depthAttachment.set(a), this._depthFBO = n, this._depthTexture = s } r.bindFramebuffer.set(this._depthFBO.framebuffer), r.viewport.set([0, 0, i, o]), function (t, r, n, i) { if ("globe" === t.transform.projection.name) return; const o = t.context, s = o.gl; o.clear({ depth: 1 }); const a = t.useProgram("terrainDepth"), c = new e.DepthMode(s.LESS, e.DepthMode.ReadWrite, t.depthRangeFor3D); for (const l of i) { const t = n.getTile(l), i = Cr(l.projMatrix, 0); r.setupElevationDraw(t, a), a.draw(o, s.TRIANGLES, c, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.backCCW, i, "terrain_depth", r.gridBuffer, r.gridIndexBuffer, r.gridNoSkirtSegments) } }(t, this, n, this.proxyCoords) } _setupProxiedCoordsForOrtho(e, t, r) { if (e.getSource() instanceof Be) return this._setupProxiedCoordsForImageSource(e, t, r); this._findCoveringTileCache[e.id] = this._findCoveringTileCache[e.id] || {}; const n = this.proxiedCoords[e.id] = [], i = this.proxyCoords; for (let s = 0; s < i.length; s++) { const t = i[s], o = this._findTileCoveringTileID(t, e); if (o) { const i = this._createProxiedId(t, o, r[t.key] && r[t.key][e.id]); n.push(i), this.proxyToSource[t.key][e.id] = [i] } } let o = !1; for (let s = 0; s < t.length; s++) { const i = e.getTile(t[s]); if (!i || !i.hasData()) continue; const a = this._findTileCoveringTileID(i.tileID, this.proxySourceCache); if (a && a.tileID.canonical.z !== i.tileID.canonical.z) { const t = this.proxyToSource[a.tileID.key][e.id], s = this._createProxiedId(a.tileID, i, r[a.tileID.key] && r[a.tileID.key][e.id]); t ? t.splice(t.length - 1, 0, s) : this.proxyToSource[a.tileID.key][e.id] = [s], n.push(s), o = !0 } } this._sourceTilesOverlap[e.id] = o } _setupProxiedCoordsForImageSource(t, r, n) { if (!t.getSource().loaded()) return; const i = this.proxiedCoords[t.id] = [], o = this.proxyCoords, s = t.getSource(), a = new e.pointGeometry(s.tileID.x, s.tileID.y)._div(1 << s.tileID.z), c = s.coordinates.map(e.MercatorCoordinate.fromLngLat).reduce(((e, t) => (e.min.x = Math.min(e.min.x, t.x - a.x), e.min.y = Math.min(e.min.y, t.y - a.y), e.max.x = Math.max(e.max.x, t.x - a.x), e.max.y = Math.max(e.max.y, t.y - a.y), e)), { min: new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE), max: new e.pointGeometry(-Number.MAX_VALUE, -Number.MAX_VALUE) }), l = (t, r) => { const n = t.wrap + t.canonical.x / (1 << t.canonical.z), i = t.canonical.y / (1 << t.canonical.z), o = e.EXTENT / (1 << t.canonical.z), s = r.wrap + r.canonical.x / (1 << r.canonical.z), a = r.canonical.y / (1 << r.canonical.z); return n + o < s + c.min.x || n > s + c.max.x || i + o < a + c.min.y || i > a + c.max.y }; for (let e = 0; e < o.length; e++) { const s = o[e]; for (let e = 0; e < r.length; e++) { const o = t.getTile(r[e]); if (!o || !o.hasData()) continue; if (l(s, o.tileID)) continue; const a = this._createProxiedId(s, o, n[s.key] && n[s.key][t.id]), c = this.proxyToSource[s.key][t.id]; c ? c.push(a) : this.proxyToSource[s.key][t.id] = [a], i.push(a) } } } _createProxiedId(t, r, n) { let i = this.orthoMatrix; if (n) { const e = n.find((e => e.key === r.tileID.key)); if (e) return e } if (r.tileID.key !== t.key) { const n = t.canonical.z - r.tileID.canonical.z; let o, s, a; i = e.create(); const c = r.tileID.wrap - t.wrap << t.overscaledZ; n > 0 ? (o = e.EXTENT >> n, s = o * ((r.tileID.canonical.x << n) - t.canonical.x + c), a = o * ((r.tileID.canonical.y << n) - t.canonical.y)) : (o = e.EXTENT << -n, s = e.EXTENT * (r.tileID.canonical.x - (t.canonical.x + c << -n)), a = e.EXTENT * (r.tileID.canonical.y - (t.canonical.y << -n))), e.ortho(i, 0, o, 0, o, 0, 1), e.translate(i, i, [s, a, 0]) } return new Fr(r.tileID, t.key, i) } _findTileCoveringTileID(t, r) { let n = r.getTile(t); if (n && n.hasData()) return n; const i = this._findCoveringTileCache[r.id], o = i[t.key]; if (n = o ? r.getTileByID(o) : null, n && n.hasData() || null === o) return n; let s = n ? n.tileID : t, a = s.overscaledZ; const c = r.getSource().minzoom, l = []; if (!o) { const i = r.getSource().maxzoom; if (t.canonical.z >= i) { const n = t.canonical.z - i; r.getSource().reparseOverscaled ? (a = Math.max(t.canonical.z + 2, r.transform.tileZoom), s = new e.OverscaledTileID(a, t.wrap, i, t.canonical.x >> n, t.canonical.y >> n)) : 0 !== n && (a = i, s = new e.OverscaledTileID(a, t.wrap, i, t.canonical.x >> n, t.canonical.y >> n)) } s.key !== t.key && (l.push(s.key), n = r.getTile(s)) } const u = e => { l.forEach((t => { i[t] = e })), l.length = 0 }; for (a -= 1; a >= c && (!n || !n.hasData()); a--) { n && u(n.tileID.key); const e = s.calculateScaledKey(a); if (n = r.getTileByID(e), n && n.hasData()) break; const t = i[e]; if (null === t) break; void 0 === t ? l.push(e) : n = r.getTileByID(t) } return u(n ? n.tileID.key : null), n && n.hasData() ? n : null } findDEMTileFor(e) { return this.enabled ? this._findTileCoveringTileID(e, this.sourceCache) : null } prepareDrawTile() { this.renderedToTile = !0 } _clearRenderCacheForTile(e, t) { let r = this._tilesDirty[e]; r || (r = this._tilesDirty[e] = {}), r[t.key] = !0 } getWirefameBuffer() { if (!this.wireframeSegments) { const t = function (t) { let r = 0; const n = new e.StructArrayLayout2ui4, i = 131; for (let e = 1; e < 129; e++) { for (let t = 1; t < 129; t++)r = e * i + t, n.emplaceBack(r, r + 1), n.emplaceBack(r, r + i), n.emplaceBack(r + 1, r + i), 128 === e && n.emplaceBack(r + i, r + i + 1); n.emplaceBack(r + 1, r + 1 + i) } return n }(); this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t), this.wireframeSegments = e.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t.length) } return [this.wireframeIndexBuffer, this.wireframeSegments] } } class zr { static cacheKey(e, t, r, n) { let i = `${t}${n ? n.cacheKey : ""}`; for (const o of r) e.usedDefines.includes(o) && (i += `/${o}`); return i } constructor(t, r, n, i, o, s) { const a = t.gl; this.program = a.createProgram(); const c = function (e) { const t = []; for (let r = 0; r < e.length; r++) { if (null === e[r]) continue; const n = e[r].split(" "); t.push(n.pop()) } return t }(n.staticAttributes), l = i ? i.getBinderAttributes() : [], u = c.concat(l); let h = i ? i.defines() : []; h = h.concat(s.map((e => `#define ${e}`))); const d = t.isWebGL2 ? "#version 300 es\n" : "", p = d + h.concat(t.extStandardDerivatives && 0 === d.length ? "#extension GL_OES_standard_derivatives : enable\n".concat(pr) : pr, pr, dr, hr.fragmentSource, lr.fragmentSource, n.fragmentSource).join("\n"), f = d + h.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", dr, hr.vertexSource, lr.vertexSource, cr.vertexSource, n.vertexSource).join("\n"), m = a.createShader(a.FRAGMENT_SHADER); if (a.isContextLost()) return void (this.failedToCreate = !0); a.shaderSource(m, p), a.compileShader(m), a.attachShader(this.program, m); const g = a.createShader(a.VERTEX_SHADER); if (a.isContextLost()) this.failedToCreate = !0; else { a.shaderSource(g, f), a.compileShader(g), a.attachShader(this.program, g), this.attributes = {}, this.numAttributes = u.length; for (let e = 0; e < this.numAttributes; e++)u[e] && (a.bindAttribLocation(this.program, e, u[e]), this.attributes[u[e]] = e); a.linkProgram(this.program), a.deleteShader(g), a.deleteShader(m), this.fixedUniforms = o(t), this.binderUniforms = i ? i.getUniforms(t) : [], s.includes("TERRAIN") && (this.terrainUniforms = (t => ({ u_dem: new e.Uniform1i(t), u_dem_prev: new e.Uniform1i(t), u_dem_unpack: new e.Uniform4f(t), u_dem_tl: new e.Uniform2f(t), u_dem_scale: new e.Uniform1f(t), u_dem_tl_prev: new e.Uniform2f(t), u_dem_scale_prev: new e.Uniform1f(t), u_dem_size: new e.Uniform1f(t), u_dem_lerp: new e.Uniform1f(t), u_exaggeration: new e.Uniform1f(t), u_depth: new e.Uniform1i(t), u_depth_size_inv: new e.Uniform2f(t), u_meter_to_dem: new e.Uniform1f(t), u_label_plane_matrix_inv: new e.UniformMatrix4f(t) }))(t)), s.includes("GLOBE") && (this.globeUniforms = (t => ({ u_tile_tl_up: new e.Uniform3f(t), u_tile_tr_up: new e.Uniform3f(t), u_tile_br_up: new e.Uniform3f(t), u_tile_bl_up: new e.Uniform3f(t), u_tile_up_scale: new e.Uniform1f(t) }))(t)), s.includes("FOG") && (this.fogUniforms = (t => ({ u_fog_matrix: new e.UniformMatrix4f(t), u_fog_range: new e.Uniform2f(t), u_fog_color: new e.Uniform4f(t), u_fog_horizon_blend: new e.Uniform1f(t), u_fog_temporal_offset: new e.Uniform1f(t), u_frustum_tl: new e.Uniform3f(t), u_frustum_tr: new e.Uniform3f(t), u_frustum_br: new e.Uniform3f(t), u_frustum_bl: new e.Uniform3f(t), u_globe_pos: new e.Uniform3f(t), u_globe_radius: new e.Uniform1f(t), u_globe_transition: new e.Uniform1f(t), u_is_globe: new e.Uniform1i(t), u_viewport: new e.Uniform2f(t) }))(t)) } } setTerrainUniformValues(e, t) { if (!this.terrainUniforms) return; const r = this.terrainUniforms; if (!this.failedToCreate) { e.program.set(this.program); for (const e in t) r[e] && r[e].set(this.program, e, t[e]) } } setGlobeUniformValues(e, t) { if (!this.globeUniforms) return; const r = this.globeUniforms; if (!this.failedToCreate) { e.program.set(this.program); for (const e in t) r[e] && r[e].set(this.program, e, t[e]) } } setFogUniformValues(e, t) { if (!this.fogUniforms) return; const r = this.fogUniforms; if (!this.failedToCreate) { e.program.set(this.program); for (const e in t) r[e].set(this.program, e, t[e]) } } draw(e, t, r, n, i, o, s, a, c, l, u, h, d, p, f) { const m = e.gl; if (this.failedToCreate) return; e.program.set(this.program), e.setDepthMode(r), e.setStencilMode(n), e.setColorMode(i), e.setCullFace(o); for (const _ of Object.keys(this.fixedUniforms)) this.fixedUniforms[_].set(this.program, _, s[_]); p && p.setUniforms(this.program, e, this.binderUniforms, h, { zoom: d }); const g = { [m.LINES]: 2, [m.TRIANGLES]: 3, [m.LINE_STRIP]: 1 }[t]; for (const _ of u.get()) { const r = _.vaos || (_.vaos = {}); (r[a] || (r[a] = new _r)).bind(e, this, c, p ? p.getPaintVertexBuffers() : [], l, _.vertexOffset, f || []), m.drawElements(t, _.primitiveLength * g, m.UNSIGNED_SHORT, _.primitiveOffset * g * 2) } } } function Ur(e, t) { const r = Math.pow(2, t.tileID.overscaledZ), n = t.tileSize * Math.pow(2, e.transform.tileZoom) / r, i = n * (t.tileID.canonical.x + t.tileID.wrap * r), o = n * t.tileID.canonical.y; return { u_image: 0, u_texsize: t.imageAtlasTexture.size, u_tile_units_to_pixels: 1 / D(t, 1, e.transform.tileZoom), u_pixel_coord_upper: [i >> 16, o >> 16], u_pixel_coord_lower: [65535 & i, 65535 & o] } } const Nr = e.create(), Gr = (t, r, n, i, o, s, a, c, l, u, h) => { const d = r.style.light, p = d.properties.get("position"), f = [p.x, p.y, p.z], m = e.create$1(); "viewport" === d.properties.get("anchor") && (e.fromRotation(m, -r.transform.angle), e.transformMat3(f, f, m)); const g = d.properties.get("color"), _ = r.transform, y = { u_matrix: t, u_lightpos: f, u_lightintensity: d.properties.get("intensity"), u_lightcolor: [g.r, g.g, g.b], u_vertical_gradient: +n, u_opacity: i, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: Nr, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_ao: o, u_edge_radius: s }; return "globe" === _.projection.name && (y.u_tile_id = [a.canonical.x, a.canonical.y, 1 << a.canonical.z], y.u_zoom_transition = l, y.u_inv_rot_matrix = h, y.u_merc_center = u, y.u_up_dir = _.projection.upVector(new e.CanonicalTileID(0, 0, 0), u[0] * e.EXTENT, u[1] * e.EXTENT), y.u_height_lift = c), y }, Vr = (t, r, n, i, o, s, a, c, l, u, h, d) => { const p = Gr(t, r, n, i, o, s, a, l, u, h, d), f = { u_height_factor: -Math.pow(2, a.overscaledZ) / c.tileSize / 8 }; return e.extend(p, Ur(r, c), f) }, qr = e => ({ u_matrix: e }), jr = (t, r, n) => e.extend(qr(t), Ur(r, n)), Xr = (e, t) => ({ u_matrix: e, u_world: t }), Wr = (t, r, n, i) => e.extend(jr(t, r, n), { u_world: i }), Zr = e.create(), Hr = (t, r, n, i, o, s) => { const a = t.transform, c = "globe" === a.projection.name; let l; if ("map" === s.paint.get("circle-pitch-alignment")) if (c) { const t = e.globePixelsToTileUnits(a.zoom, r.canonical) * a._pixelsPerMercatorPixel; l = Float32Array.from([t, 0, 0, t]) } else l = a.calculatePixelsToTileUnitsMatrix(n); else l = new Float32Array([a.pixelsToGLUnits[0], 0, 0, a.pixelsToGLUnits[1]]); const u = { u_camera_to_center_distance: a.cameraToCenterDistance, u_matrix: t.translatePosMatrix(r.projMatrix, n, s.paint.get("circle-translate"), s.paint.get("circle-translate-anchor")), u_device_pixel_ratio: e.exported.devicePixelRatio, u_extrude_scale: l, u_inv_rot_matrix: Zr, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] }; if (c) { u.u_inv_rot_matrix = i, u.u_merc_center = o, u.u_tile_id = [r.canonical.x, r.canonical.y, 1 << r.canonical.z], u.u_zoom_transition = e.globeToMercatorTransition(a.zoom); const t = o[0] * e.EXTENT, n = o[1] * e.EXTENT; u.u_up_dir = a.projection.upVector(new e.CanonicalTileID(0, 0, 0), t, n) } return u }, Qr = e => { const t = []; return "map" === e.paint.get("circle-pitch-alignment") && t.push("PITCH_WITH_MAP"), "map" === e.paint.get("circle-pitch-scale") && t.push("SCALE_WITH_MAP"), t }, $r = (t, r, n, i) => { const o = e.EXTENT / n.tileSize; return { u_matrix: t, u_camera_to_center_distance: r.getCameraToCenterDistance(i), u_extrude_scale: [r.pixelsToGLUnits[0] / o, r.pixelsToGLUnits[1] / o] } }, Jr = (e, t, r, n) => ({ u_matrix: e, u_inv_matrix: t, u_camera_to_center_distance: r.getCameraToCenterDistance(n), u_viewport_size: [r.width, r.height] }), Kr = (e, t, r = 1) => ({ u_matrix: e, u_color: t, u_overlay: 0, u_overlay_scale: r }), Yr = e.create(), en = (t, r, n, i, o, s, a) => { const c = t.transform, l = "globe" === c.projection.name, u = l ? e.globePixelsToTileUnits(c.zoom, r.canonical) * c._pixelsPerMercatorPixel : D(n, 1, s), h = { u_matrix: r.projMatrix, u_extrude_scale: u, u_intensity: a, u_inv_rot_matrix: Yr, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] }; if (l) { h.u_inv_rot_matrix = i, h.u_merc_center = o, h.u_tile_id = [r.canonical.x, r.canonical.y, 1 << r.canonical.z], h.u_zoom_transition = e.globeToMercatorTransition(c.zoom); const t = o[0] * e.EXTENT, n = o[1] * e.EXTENT; h.u_up_dir = c.projection.upVector(new e.CanonicalTileID(0, 0, 0), t, n) } return h }, tn = (e, t, r, n, i, o, s) => { const a = e.transform, c = a.calculatePixelsToTileUnitsMatrix(t); return { u_matrix: on(e, t, r, n), u_pixels_to_tile_units: c, u_device_pixel_ratio: o, u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: i, u_texsize: sn(r) ? t.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: nn(t, e.transform), u_alpha_discard_threshold: 0, u_trim_offset: s } }, rn = (e, t, r, n, i) => { const o = e.transform; return { u_matrix: on(e, t, r, n), u_texsize: t.imageAtlasTexture.size, u_pixels_to_tile_units: o.calculatePixelsToTileUnitsMatrix(t), u_device_pixel_ratio: i, u_image: 0, u_tile_units_to_pixels: nn(t, o), u_units_to_pixels: [1 / o.pixelsToGLUnits[0], 1 / o.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0 } }; function nn(e, t) { return 1 / D(e, 1, t.tileZoom) } function on(e, t, r, n) { return e.translatePosMatrix(n || t.tileID.projMatrix, t, r.paint.get("line-translate"), r.paint.get("line-translate-anchor")) } function sn(e) { const t = e.paint.get("line-dasharray").value; return t.value || "constant" !== t.kind } const an = (e, t, r, n, i, o) => { return { u_matrix: e, u_tl_parent: t, u_scale_parent: r, u_fade_t: n.mix, u_opacity: n.opacity * i.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: i.paint.get("raster-brightness-min"), u_brightness_high: i.paint.get("raster-brightness-max"), u_saturation_factor: (a = i.paint.get("raster-saturation"), a > 0 ? 1 - 1 / (1.001 - a) : -a), u_contrast_factor: (s = i.paint.get("raster-contrast"), s > 0 ? 1 / (1 - s) : 1 + s), u_spin_weights: cn(i.paint.get("raster-hue-rotate")), u_perspective_transform: o }; var s, a }; function cn(e) { e *= Math.PI / 180; const t = Math.sin(e), r = Math.cos(e); return [(2 * r + 1) / 3, (-Math.sqrt(3) * t - r + 1) / 3, (Math.sqrt(3) * t - r + 1) / 3] } const ln = e.create(), un = (t, r, n, i, o, s, a, c, l, u, h, d, p, f, m, g) => { const _ = o.transform, y = { u_is_size_zoom_constant: +("constant" === t || "source" === t), u_is_size_feature_constant: +("constant" === t || "camera" === t), u_size_t: r ? r.uSizeT : 0, u_size: r ? r.uSize : 0, u_camera_to_center_distance: _.cameraToCenterDistance, u_rotate_symbol: +n, u_aspect_ratio: _.width / _.height, u_fade_change: o.options.fadeDuration ? o.symbolFadeChange : 1, u_matrix: s, u_label_plane_matrix: a, u_coord_matrix: c, u_is_text: +l, u_pitch_with_map: +i, u_texsize: u, u_texture: 0, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: ln, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: ln, u_up_vector: [0, -1, 0] }; return "globe" === g.name && (y.u_tile_id = [h.canonical.x, h.canonical.y, 1 << h.canonical.z], y.u_zoom_transition = d, y.u_inv_rot_matrix = f, y.u_merc_center = p, y.u_camera_forward = _._camera.forward(), y.u_ecef_origin = e.globeECEFOrigin(_.globeMatrix, h.toUnwrapped()), y.u_tile_matrix = Float32Array.from(_.globeMatrix), y.u_up_vector = m), y }, hn = (t, r, n, i, o, s, a, c, l, u, h, d, p, f, m, g, _) => e.extend(un(t, r, n, i, o, s, a, c, l, u, d, p, f, m, g, _), { u_gamma_scale: i ? o.transform.cameraToCenterDistance * Math.cos(o.terrain ? 0 : o.transform._pitch) : 1, u_device_pixel_ratio: e.exported.devicePixelRatio, u_is_halo: +h }), dn = (t, r, n, i, o, s, a, c, l, u, h, d, p, f, m, g) => e.extend(hn(t, r, n, i, o, s, a, c, !0, l, !0, h, d, p, f, m, g), { u_texsize_icon: u, u_texture_icon: 1 }), pn = (e, t, r) => ({ u_matrix: e, u_opacity: t, u_color: r }), fn = (t, r, n, i, o) => e.extend(function (e, t, r) { const n = t.imageManager.getPattern(e.toString()), { width: i, height: o } = t.imageManager.getPixelSize(), s = Math.pow(2, r.tileID.overscaledZ), a = r.tileSize * Math.pow(2, t.transform.tileZoom) / s, c = a * (r.tileID.canonical.x + r.tileID.wrap * s), l = a * r.tileID.canonical.y; return { u_image: 0, u_pattern_tl: n.tl, u_pattern_br: n.br, u_texsize: [i, o], u_pattern_size: n.displaySize, u_tile_units_to_pixels: 1 / D(r, 1, t.transform.tileZoom), u_pixel_coord_upper: [c >> 16, l >> 16], u_pixel_coord_lower: [65535 & c, 65535 & l] } }(i, n, o), { u_matrix: t, u_opacity: r }), mn = (e, t, r, n, i) => ({ u_matrix_3f: e, u_sun_direction: t, u_sun_intensity: r, u_color_tint_r: [n.r, n.g, n.b, n.a], u_color_tint_m: [i.r, i.g, i.b, i.a], u_luminance: 5e-5 }), gn = { fillExtrusion: t => ({ u_matrix: new e.UniformMatrix4f(t), u_lightpos: new e.Uniform3f(t), u_lightintensity: new e.Uniform1f(t), u_lightcolor: new e.Uniform3f(t), u_vertical_gradient: new e.Uniform1f(t), u_opacity: new e.Uniform1f(t), u_edge_radius: new e.Uniform1f(t), u_ao: new e.Uniform2f(t), u_tile_id: new e.Uniform3f(t), u_zoom_transition: new e.Uniform1f(t), u_inv_rot_matrix: new e.UniformMatrix4f(t), u_merc_center: new e.Uniform2f(t), u_up_dir: new e.Uniform3f(t), u_height_lift: new e.Uniform1f(t) }), fillExtrusionPattern: t => ({ u_matrix: new e.UniformMatrix4f(t), u_lightpos: new e.Uniform3f(t), u_lightintensity: new e.Uniform1f(t), u_lightcolor: new e.Uniform3f(t), u_vertical_gradient: new e.Uniform1f(t), u_height_factor: new e.Uniform1f(t), u_edge_radius: new e.Uniform1f(t), u_ao: new e.Uniform2f(t), u_tile_id: new e.Uniform3f(t), u_zoom_transition: new e.Uniform1f(t), u_inv_rot_matrix: new e.UniformMatrix4f(t), u_merc_center: new e.Uniform2f(t), u_up_dir: new e.Uniform3f(t), u_height_lift: new e.Uniform1f(t), u_image: new e.Uniform1i(t), u_texsize: new e.Uniform2f(t), u_pixel_coord_upper: new e.Uniform2f(t), u_pixel_coord_lower: new e.Uniform2f(t), u_tile_units_to_pixels: new e.Uniform1f(t), u_opacity: new e.Uniform1f(t) }), fill: t => ({ u_matrix: new e.UniformMatrix4f(t) }), fillPattern: t => ({ u_matrix: new e.UniformMatrix4f(t), u_image: new e.Uniform1i(t), u_texsize: new e.Uniform2f(t), u_pixel_coord_upper: new e.Uniform2f(t), u_pixel_coord_lower: new e.Uniform2f(t), u_tile_units_to_pixels: new e.Uniform1f(t) }), fillOutline: t => ({ u_matrix: new e.UniformMatrix4f(t), u_world: new e.Uniform2f(t) }), fillOutlinePattern: t => ({ u_matrix: new e.UniformMatrix4f(t), u_world: new e.Uniform2f(t), u_image: new e.Uniform1i(t), u_texsize: new e.Uniform2f(t), u_pixel_coord_upper: new e.Uniform2f(t), u_pixel_coord_lower: new e.Uniform2f(t), u_tile_units_to_pixels: new e.Uniform1f(t) }), circle: t => ({ u_camera_to_center_distance: new e.Uniform1f(t), u_extrude_scale: new e.UniformMatrix2f(t), u_device_pixel_ratio: new e.Uniform1f(t), u_matrix: new e.UniformMatrix4f(t), u_inv_rot_matrix: new e.UniformMatrix4f(t), u_merc_center: new e.Uniform2f(t), u_tile_id: new e.Uniform3f(t), u_zoom_transition: new e.Uniform1f(t), u_up_dir: new e.Uniform3f(t) }), collisionBox: t => ({ u_matrix: new e.UniformMatrix4f(t), u_camera_to_center_distance: new e.Uniform1f(t), u_extrude_scale: new e.Uniform2f(t) }), collisionCircle: t => ({ u_matrix: new e.UniformMatrix4f(t), u_inv_matrix: new e.UniformMatrix4f(t), u_camera_to_center_distance: new e.Uniform1f(t), u_viewport_size: new e.Uniform2f(t) }), debug: t => ({ u_color: new e.UniformColor(t), u_matrix: new e.UniformMatrix4f(t), u_overlay: new e.Uniform1i(t), u_overlay_scale: new e.Uniform1f(t) }), clippingMask: t => ({ u_matrix: new e.UniformMatrix4f(t) }), heatmap: t => ({ u_extrude_scale: new e.Uniform1f(t), u_intensity: new e.Uniform1f(t), u_matrix: new e.UniformMatrix4f(t), u_inv_rot_matrix: new e.UniformMatrix4f(t), u_merc_center: new e.Uniform2f(t), u_tile_id: new e.Uniform3f(t), u_zoom_transition: new e.Uniform1f(t), u_up_dir: new e.Uniform3f(t) }), heatmapTexture: t => ({ u_image: new e.Uniform1i(t), u_color_ramp: new e.Uniform1i(t), u_opacity: new e.Uniform1f(t) }), hillshade: t => ({ u_matrix: new e.UniformMatrix4f(t), u_image: new e.Uniform1i(t), u_latrange: new e.Uniform2f(t), u_light: new e.Uniform2f(t), u_shadow: new e.UniformColor(t), u_highlight: new e.UniformColor(t), u_accent: new e.UniformColor(t) }), hillshadePrepare: t => ({ u_matrix: new e.UniformMatrix4f(t), u_image: new e.Uniform1i(t), u_dimension: new e.Uniform2f(t), u_zoom: new e.Uniform1f(t), u_unpack: new e.Uniform4f(t) }), line: t => ({ u_matrix: new e.UniformMatrix4f(t), u_pixels_to_tile_units: new e.UniformMatrix2f(t), u_device_pixel_ratio: new e.Uniform1f(t), u_units_to_pixels: new e.Uniform2f(t), u_dash_image: new e.Uniform1i(t), u_gradient_image: new e.Uniform1i(t), u_image_height: new e.Uniform1f(t), u_texsize: new e.Uniform2f(t), u_tile_units_to_pixels: new e.Uniform1f(t), u_alpha_discard_threshold: new e.Uniform1f(t), u_trim_offset: new e.Uniform2f(t) }), linePattern: t => ({ u_matrix: new e.UniformMatrix4f(t), u_texsize: new e.Uniform2f(t), u_pixels_to_tile_units: new e.UniformMatrix2f(t), u_device_pixel_ratio: new e.Uniform1f(t), u_image: new e.Uniform1i(t), u_units_to_pixels: new e.Uniform2f(t), u_tile_units_to_pixels: new e.Uniform1f(t), u_alpha_discard_threshold: new e.Uniform1f(t) }), raster: t => ({ u_matrix: new e.UniformMatrix4f(t), u_tl_parent: new e.Uniform2f(t), u_scale_parent: new e.Uniform1f(t), u_fade_t: new e.Uniform1f(t), u_opacity: new e.Uniform1f(t), u_image0: new e.Uniform1i(t), u_image1: new e.Uniform1i(t), u_brightness_low: new e.Uniform1f(t), u_brightness_high: new e.Uniform1f(t), u_saturation_factor: new e.Uniform1f(t), u_contrast_factor: new e.Uniform1f(t), u_spin_weights: new e.Uniform3f(t), u_perspective_transform: new e.Uniform2f(t) }), symbolIcon: t => ({ u_is_size_zoom_constant: new e.Uniform1i(t), u_is_size_feature_constant: new e.Uniform1i(t), u_size_t: new e.Uniform1f(t), u_size: new e.Uniform1f(t), u_camera_to_center_distance: new e.Uniform1f(t), u_rotate_symbol: new e.Uniform1i(t), u_aspect_ratio: new e.Uniform1f(t), u_fade_change: new e.Uniform1f(t), u_matrix: new e.UniformMatrix4f(t), u_label_plane_matrix: new e.UniformMatrix4f(t), u_coord_matrix: new e.UniformMatrix4f(t), u_is_text: new e.Uniform1i(t), u_pitch_with_map: new e.Uniform1i(t), u_texsize: new e.Uniform2f(t), u_tile_id: new e.Uniform3f(t), u_zoom_transition: new e.Uniform1f(t), u_inv_rot_matrix: new e.UniformMatrix4f(t), u_merc_center: new e.Uniform2f(t), u_camera_forward: new e.Uniform3f(t), u_tile_matrix: new e.UniformMatrix4f(t), u_up_vector: new e.Uniform3f(t), u_ecef_origin: new e.Uniform3f(t), u_texture: new e.Uniform1i(t) }), symbolSDF: t => ({ u_is_size_zoom_constant: new e.Uniform1i(t), u_is_size_feature_constant: new e.Uniform1i(t), u_size_t: new e.Uniform1f(t), u_size: new e.Uniform1f(t), u_camera_to_center_distance: new e.Uniform1f(t), u_rotate_symbol: new e.Uniform1i(t), u_aspect_ratio: new e.Uniform1f(t), u_fade_change: new e.Uniform1f(t), u_matrix: new e.UniformMatrix4f(t), u_label_plane_matrix: new e.UniformMatrix4f(t), u_coord_matrix: new e.UniformMatrix4f(t), u_is_text: new e.Uniform1i(t), u_pitch_with_map: new e.Uniform1i(t), u_texsize: new e.Uniform2f(t), u_texture: new e.Uniform1i(t), u_gamma_scale: new e.Uniform1f(t), u_device_pixel_ratio: new e.Uniform1f(t), u_tile_id: new e.Uniform3f(t), u_zoom_transition: new e.Uniform1f(t), u_inv_rot_matrix: new e.UniformMatrix4f(t), u_merc_center: new e.Uniform2f(t), u_camera_forward: new e.Uniform3f(t), u_tile_matrix: new e.UniformMatrix4f(t), u_up_vector: new e.Uniform3f(t), u_ecef_origin: new e.Uniform3f(t), u_is_halo: new e.Uniform1i(t) }), symbolTextAndIcon: t => ({ u_is_size_zoom_constant: new e.Uniform1i(t), u_is_size_feature_constant: new e.Uniform1i(t), u_size_t: new e.Uniform1f(t), u_size: new e.Uniform1f(t), u_camera_to_center_distance: new e.Uniform1f(t), u_rotate_symbol: new e.Uniform1i(t), u_aspect_ratio: new e.Uniform1f(t), u_fade_change: new e.Uniform1f(t), u_matrix: new e.UniformMatrix4f(t), u_label_plane_matrix: new e.UniformMatrix4f(t), u_coord_matrix: new e.UniformMatrix4f(t), u_is_text: new e.Uniform1i(t), u_pitch_with_map: new e.Uniform1i(t), u_texsize: new e.Uniform2f(t), u_texsize_icon: new e.Uniform2f(t), u_texture: new e.Uniform1i(t), u_texture_icon: new e.Uniform1i(t), u_gamma_scale: new e.Uniform1f(t), u_device_pixel_ratio: new e.Uniform1f(t), u_is_halo: new e.Uniform1i(t) }), background: t => ({ u_matrix: new e.UniformMatrix4f(t), u_opacity: new e.Uniform1f(t), u_color: new e.UniformColor(t) }), backgroundPattern: t => ({ u_matrix: new e.UniformMatrix4f(t), u_opacity: new e.Uniform1f(t), u_image: new e.Uniform1i(t), u_pattern_tl: new e.Uniform2f(t), u_pattern_br: new e.Uniform2f(t), u_texsize: new e.Uniform2f(t), u_pattern_size: new e.Uniform2f(t), u_pixel_coord_upper: new e.Uniform2f(t), u_pixel_coord_lower: new e.Uniform2f(t), u_tile_units_to_pixels: new e.Uniform1f(t) }), terrainRaster: kr, terrainDepth: kr, skybox: t => ({ u_matrix: new e.UniformMatrix4f(t), u_sun_direction: new e.Uniform3f(t), u_cubemap: new e.Uniform1i(t), u_opacity: new e.Uniform1f(t), u_temporal_offset: new e.Uniform1f(t) }), skyboxGradient: t => ({ u_matrix: new e.UniformMatrix4f(t), u_color_ramp: new e.Uniform1i(t), u_center_direction: new e.Uniform3f(t), u_radius: new e.Uniform1f(t), u_opacity: new e.Uniform1f(t), u_temporal_offset: new e.Uniform1f(t) }), skyboxCapture: t => ({ u_matrix_3f: new e.UniformMatrix3f(t), u_sun_direction: new e.Uniform3f(t), u_sun_intensity: new e.Uniform1f(t), u_color_tint_r: new e.Uniform4f(t), u_color_tint_m: new e.Uniform4f(t), u_luminance: new e.Uniform1f(t) }), globeRaster: t => ({ u_proj_matrix: new e.UniformMatrix4f(t), u_globe_matrix: new e.UniformMatrix4f(t), u_normalize_matrix: new e.UniformMatrix4f(t), u_merc_matrix: new e.UniformMatrix4f(t), u_zoom_transition: new e.Uniform1f(t), u_merc_center: new e.Uniform2f(t), u_image0: new e.Uniform1i(t), u_grid_matrix: new e.UniformMatrix3f(t), u_skirt_height: new e.Uniform1f(t), u_frustum_tl: new e.Uniform3f(t), u_frustum_tr: new e.Uniform3f(t), u_frustum_br: new e.Uniform3f(t), u_frustum_bl: new e.Uniform3f(t), u_globe_pos: new e.Uniform3f(t), u_globe_radius: new e.Uniform1f(t), u_viewport: new e.Uniform2f(t) }), globeAtmosphere: t => ({ u_frustum_tl: new e.Uniform3f(t), u_frustum_tr: new e.Uniform3f(t), u_frustum_br: new e.Uniform3f(t), u_frustum_bl: new e.Uniform3f(t), u_horizon: new e.Uniform1f(t), u_transition: new e.Uniform1f(t), u_fadeout_range: new e.Uniform1f(t), u_color: new e.Uniform4f(t), u_high_color: new e.Uniform4f(t), u_space_color: new e.Uniform4f(t), u_star_intensity: new e.Uniform1f(t), u_star_density: new e.Uniform1f(t), u_star_size: new e.Uniform1f(t), u_temporal_offset: new e.Uniform1f(t), u_horizon_angle: new e.Uniform1f(t), u_rotation_matrix: new e.UniformMatrix4f(t) }) }; let _n; function yn(t, r, n, i, o, s, a) { const c = t.context, l = c.gl, u = t.transform, h = t.useProgram("collisionBox"), d = []; let p = 0, f = 0; for (let x = 0; x < i.length; x++) { const m = i[x], g = r.getTile(m), _ = g.getBucket(n); if (!_) continue; const y = Tt(m, _, u); let v = y; 0 === o[0] && 0 === o[1] || (v = t.translatePosMatrix(y, g, o, s)); const b = a ? _.textCollisionBox : _.iconCollisionBox, w = _.collisionCircleArray; if (w.length > 0) { const t = e.create(), r = v; e.mul(t, _.placementInvProjMatrix, u.glCoordMatrix), e.mul(t, t, _.placementViewportMatrix), d.push({ circleArray: w, circleOffset: f, transform: r, invTransform: t, projection: _.getProjection() }), p += w.length / 4, f = p } b && (t.terrain && t.terrain.setupElevationDraw(g, h), h.draw(c, l.LINES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, $r(v, u, g, _.getProjection()), n.id, b.layoutVertexBuffer, b.indexBuffer, b.segments, null, u.zoom, null, [b.collisionVertexBuffer, b.collisionVertexBufferExt])) } if (!a || !d.length) return; const m = t.useProgram("collisionCircle"), g = new e.StructArrayLayout2f1f2i16; g.resize(4 * p), g._trim(); let _ = 0; for (const e of d) for (let t = 0; t < e.circleArray.length / 4; t++) { const r = 4 * t, n = e.circleArray[r + 0], i = e.circleArray[r + 1], o = e.circleArray[r + 2], s = e.circleArray[r + 3]; g.emplace(_++, n, i, o, s, 0), g.emplace(_++, n, i, o, s, 1), g.emplace(_++, n, i, o, s, 2), g.emplace(_++, n, i, o, s, 3) } (!_n || _n.length < 2 * p) && (_n = function (t) { const r = 2 * t, n = new e.StructArrayLayout3ui6; n.resize(r), n._trim(); for (let e = 0; e < r; e++) { const t = 6 * e; n.uint16[t + 0] = 4 * e + 0, n.uint16[t + 1] = 4 * e + 1, n.uint16[t + 2] = 4 * e + 2, n.uint16[t + 3] = 4 * e + 2, n.uint16[t + 4] = 4 * e + 3, n.uint16[t + 5] = 4 * e + 0 } return n }(p)); const y = c.createIndexBuffer(_n, !0), v = c.createVertexBuffer(g, e.collisionCircleLayout.members, !0); for (const x of d) { const r = Jr(x.transform, x.invTransform, u, x.projection); m.draw(c, l.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, r, n.id, v, y, e.SegmentVector.simpleSegment(0, 2 * x.circleOffset, x.circleArray.length, x.circleArray.length / 2), null, u.zoom) } v.destroy(), y.destroy() } const vn = e.create(); function xn({ width: t, height: r, anchor: n, textOffset: i, textScale: o }, s) { const { horizontalAlign: a, verticalAlign: c } = e.getAnchorAlignment(n), l = -(a - .5) * t, u = -(c - .5) * r, h = e.evaluateVariableOffset(n, i); return new e.pointGeometry((l / o + h[0]) * s, (u / o + h[1]) * s) } function bn(t, r, n, i, o, s, a, c, l, u, h) { const d = t.text.placedSymbolArray, p = t.text.dynamicLayoutVertexArray, f = t.icon.dynamicLayoutVertexArray, m = {}, g = t.getProjection(), _ = kt(c, g, s), y = s.elevation, v = g.upVectorScale(c.canonical, s.center.lat, s.worldSize).metersToTile; p.clear(); for (let x = 0; x < d.length; x++) { const f = d.get(x), { tileAnchorX: b, tileAnchorY: w, numGlyphs: T } = f, k = f.hidden || !f.crossTileID || t.allowVerticalPlacement && !f.placedOrientation ? null : i[f.crossTileID]; if (k) { let i = 0, d = 0, x = 0; if (y) { const e = y ? y.getAtTileOffset(c, b, w) : 0, [t, r, n] = g.upVector(c.canonical, b, w); i = e * t * v, d = e * r * v, x = e * n * v } let [C, E, S, P] = ct(f.projectedAnchorX + i, f.projectedAnchorY + d, f.projectedAnchorZ + x, n ? _ : a); const I = lt(s.getCameraToCenterDistance(g), P); let A = o.evaluateSizeForFeature(t.textSizeData, u, f) * I / e.ONE_EM; n && (A *= t.tilePixelRatio / l); const L = xn(k, A); n ? (({ x: C, y: E, z: S } = g.projectTilePoint(b + L.x, w + L.y, c.canonical)), [C, E, S] = ct(C + i, E + d, S + x, a)) : (r && L._rotate(-s.angle), C += L.x, E += L.y, S = 0); const M = t.allowVerticalPlacement && f.placedOrientation === e.WritingMode.vertical ? Math.PI / 2 : 0; for (let t = 0; t < T; t++)e.addDynamicAttributes(p, C, E, S, M); h && f.associatedIconIndex >= 0 && (m[f.associatedIconIndex] = { x: C, y: E, z: S, angle: M }) } else yt(T, p) } if (h) { f.clear(); const r = t.icon.placedSymbolArray; for (let t = 0; t < r.length; t++) { const n = r.get(t), { numGlyphs: i } = n, o = m[t]; if (n.hidden || !o) yt(i, f); else { const { x: t, y: r, z: n, angle: s } = o; for (let o = 0; o < i; o++)e.addDynamicAttributes(f, t, r, n, s) } } t.icon.dynamicLayoutVertexBuffer.updateData(f) } t.text.dynamicLayoutVertexBuffer.updateData(p) } function wn(e, t, r) { return r.iconsInText && t ? "symbolTextAndIcon" : e ? "symbolSDF" : "symbolIcon" } function Tn(t, r, n, i, o, s, a, c, l, u, h, d) { const p = t.context, f = p.gl, m = t.transform, g = "map" === c, _ = "map" === l, y = g && "point" !== n.layout.get("symbol-placement"), v = g && !_ && !y, x = void 0 !== n.layout.get("symbol-sort-key").constantOr(1); let b = !1; const w = t.depthModeForSublayer(0, e.DepthMode.ReadOnly), T = [e.mercatorXfromLng(m.center.lng), e.mercatorYfromLat(m.center.lat)], k = n.layout.get("text-variable-anchor"), C = "globe" === m.projection.name, E = [], S = [0, -1, 0]; let P = S; !C && !m.mercatorFromTransition || g || (P = function (t) { const r = t._camera.getWorldToCamera(t.worldSize, 1), n = e.multiply([], r, t.globeMatrix); e.invert(n, n); const i = [0, 0, 0], o = [0, 1, 0, 0]; return e.transformMat4$1(o, o, n), i[0] = o[0], i[1] = o[1], i[2] = o[2], e.normalize(i, i), i }(m)); for (const I of i) { const i = r.getTile(I), c = i.getBucket(n); if (!c) continue; if ("mercator" === c.projection.name && C) continue; const l = o ? c.text : c.icon; if (!l || c.fullyClipped || !l.segments.get().length) continue; const h = l.programConfigurations.get(n.id), d = o || c.sdfIcons, p = o ? c.textSizeData : c.iconSizeData, w = _ || 0 !== m.pitch, A = e.evaluateSizeForZoom(p, m.zoom); let L, M, B, R, D = [0, 0], F = null; if (o) M = i.glyphAtlasTexture, B = f.LINEAR, L = i.glyphAtlasTexture.size, c.iconsInText && (D = i.imageAtlasTexture.size, F = i.imageAtlasTexture, R = w || t.options.rotating || t.options.zooming || "composite" === p.kind || "camera" === p.kind ? f.LINEAR : f.NEAREST); else { const e = 1 !== n.layout.get("icon-size").constantOr(0) || c.iconsNeedLinear; M = i.imageAtlasTexture, B = d || t.options.rotating || t.options.zooming || e || w ? f.LINEAR : f.NEAREST, L = i.imageAtlasTexture.size } const O = "globe" === c.projection.name, z = O ? P : S, U = O ? e.globeToMercatorTransition(m.zoom) : 0, N = kt(I, c.getProjection(), m), G = m.calculatePixelsToTileUnitsMatrix(i), V = ot(N, i.tileID.canonical, _, g, m, c.getProjection(), G), q = t.terrain && _ && y ? e.invert(e.create(), V) : vn, j = at(N, i.tileID.canonical, _, g, m, c.getProjection(), G), X = k && c.hasTextData(), W = "none" !== n.layout.get("icon-text-fit") && X && c.hasIconData(); if (y) { const e = m.elevation, r = e ? e.getAtTileOffsetFunc(I, m.center.lat, m.worldSize, c.getProjection()) : null, n = st(N, i.tileID.canonical, _, g, m, c.getProjection(), G); ht(c, N, t, o, n, j, _, u, r, I) } const Z = y || o && k || W, H = t.translatePosMatrix(N, i, s, a), Q = Z ? vn : V, $ = t.translatePosMatrix(j, i, s, a, !0), J = c.getProjection().createInversionMatrix(m, I.canonical), K = []; t.terrainRenderModeElevated() && _ && K.push("PITCH_WITH_MAP_TERRAIN"), O && K.push("PROJECTION_GLOBE_VIEW"), Z && K.push("PROJECTED_POS_ON_VIEWPORT"); const Y = d && 0 !== n.paint.get(o ? "text-halo-width" : "icon-halo-width").constantOr(1); let ee; ee = d ? c.iconsInText ? dn(p.kind, A, v, _, t, H, Q, $, L, D, I, U, T, J, z, c.getProjection()) : hn(p.kind, A, v, _, t, H, Q, $, o, L, !0, I, U, T, J, z, c.getProjection()) : un(p.kind, A, v, _, t, H, Q, $, o, L, I, U, T, J, z, c.getProjection()); const te = { program: t.useProgram(wn(d, o, c), h, K), buffers: l, uniformValues: ee, atlasTexture: M, atlasTextureIcon: F, atlasInterpolation: B, atlasInterpolationIcon: R, isSDF: d, hasHalo: Y, tile: i, labelPlaneMatrixInv: q }; if (x && c.canOverlap) { b = !0; const t = l.segments.get(); for (const r of t) E.push({ segments: new e.SegmentVector([r]), sortKey: r.sortKey, state: te }) } else E.push({ segments: l.segments, sortKey: 0, state: te }) } b && E.sort(((e, t) => e.sortKey - t.sortKey)); for (const e of E) { const r = e.state; if (t.terrain && t.terrain.setupElevationDraw(r.tile, r.program, { useDepthForOcclusion: !C, labelPlaneMatrixInv: r.labelPlaneMatrixInv }), p.activeTexture.set(f.TEXTURE0), r.atlasTexture.bind(r.atlasInterpolation, f.CLAMP_TO_EDGE), r.atlasTextureIcon && (p.activeTexture.set(f.TEXTURE1), r.atlasTextureIcon && r.atlasTextureIcon.bind(r.atlasInterpolationIcon, f.CLAMP_TO_EDGE)), r.isSDF) { const i = r.uniformValues; r.hasHalo && (i.u_is_halo = 1, kn(r.buffers, e.segments, n, t, r.program, w, h, d, i)), i.u_is_halo = 0 } kn(r.buffers, e.segments, n, t, r.program, w, h, d, r.uniformValues) } } function kn(t, r, n, i, o, s, a, c, l) { const u = i.context, h = [t.dynamicLayoutVertexBuffer, t.opacityVertexBuffer, t.globeExtVertexBuffer]; o.draw(u, u.gl.TRIANGLES, s, a, c, e.CullFaceMode.disabled, l, n.id, t.layoutVertexBuffer, t.indexBuffer, r, n.paint, i.transform.zoom, t.programConfigurations.get(n.id), h) } function Cn(t, r, n, i, o, s, a) { const c = t.context.gl, l = n.paint.get("fill-pattern"), u = l && l.constantOr(1); let h, d, p, f, m; a ? (d = u && !n.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", h = c.LINES) : (d = u ? "fillPattern" : "fill", h = c.TRIANGLES); for (const g of i) { const i = r.getTile(g); if (u && !i.patternsLoaded()) continue; const _ = i.getBucket(n); if (!_) continue; t.prepareDrawTile(); const y = _.programConfigurations.get(n.id), v = t.useProgram(d, y); u && (t.context.activeTexture.set(c.TEXTURE0), i.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE), y.updatePaintBuffers()); const x = l.constantOr(null); if (x && i.imageAtlas) { const e = i.imageAtlas.patternPositions[x.toString()]; e && y.setConstantPatternPositions(e) } const b = t.translatePosMatrix(g.projMatrix, i, n.paint.get("fill-translate"), n.paint.get("fill-translate-anchor")); if (a) { f = _.indexBuffer2, m = _.segments2; const e = t.terrain && t.terrain.renderingToTexture ? t.terrain.drapeBufferSize : [c.drawingBufferWidth, c.drawingBufferHeight]; p = "fillOutlinePattern" === d && u ? Wr(b, t, i, e) : Xr(b, e) } else f = _.indexBuffer, m = _.segments, p = u ? jr(b, t, i) : qr(b); t.prepareDrawProgram(t.context, v, g.toUnwrapped()), v.draw(t.context, h, o, t.stencilModeForClipping(g), s, e.CullFaceMode.disabled, p, n.id, _.layoutVertexBuffer, f, m, n.paint, t.transform.zoom, y) } } function En(t, r, n, i, o, s, a) { const c = t.context, l = c.gl, u = t.transform, h = n.paint.get("fill-extrusion-pattern"), d = h.constantOr(1), p = n.paint.get("fill-extrusion-opacity"), f = [n.paint.get("fill-extrusion-ambient-occlusion-intensity"), n.paint.get("fill-extrusion-ambient-occlusion-radius")], m = n.layout.get("fill-extrusion-edge-radius"), g = "globe" === u.projection.name ? e.fillExtrusionHeightLift() : 0, _ = "globe" === u.projection.name, y = _ ? e.globeToMercatorTransition(u.zoom) : 0, v = [e.mercatorXfromLng(u.center.lng), e.mercatorYfromLat(u.center.lat)], x = []; _ && x.push("PROJECTION_GLOBE_VIEW"), f[0] > 0 && x.push("FAUX_AO"); for (const b of i) { const i = r.getTile(b), w = i.getBucket(n); if (!w || w.projection.name !== u.projection.name) continue; const T = w.programConfigurations.get(n.id), k = t.useProgram(d ? "fillExtrusionPattern" : "fillExtrusion", T, x); if (t.terrain) { const e = t.terrain; if (t.style.terrainSetForDrapingOnly()) e.setupElevationDraw(i, k, { useMeterToDem: !0 }); else { if (!w.enableTerrain) continue; if (e.setupElevationDraw(i, k, { useMeterToDem: !0 }), Sn(c, r, b, w, n, e), !w.centroidVertexBuffer) { const e = k.attributes.a_centroid_pos; void 0 !== e && l.vertexAttrib2f(e, 0, 0) } } } d && (t.context.activeTexture.set(l.TEXTURE0), i.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), T.updatePaintBuffers()); const C = h.constantOr(null); if (C && i.imageAtlas) { const e = i.imageAtlas.patternPositions[C.toString()]; e && T.setConstantPatternPositions(e) } const E = t.translatePosMatrix(b.projMatrix, i, n.paint.get("fill-extrusion-translate"), n.paint.get("fill-extrusion-translate-anchor")), S = u.projection.createInversionMatrix(u, b.canonical), P = n.paint.get("fill-extrusion-vertical-gradient"), I = d ? Vr(E, t, P, p, f, m, b, i, g, y, v, S) : Gr(E, t, P, p, f, m, b, g, y, v, S); t.prepareDrawProgram(c, k, b.toUnwrapped()); const A = []; t.terrain && A.push(w.centroidVertexBuffer), _ && A.push(w.layoutVertexExtBuffer), k.draw(c, c.gl.TRIANGLES, o, s, a, e.CullFaceMode.backCCW, I, n.id, w.layoutVertexBuffer, w.indexBuffer, w.segments, n.paint, t.transform.zoom, T, A) } } function Sn(t, r, n, i, o, s) { const a = [t => { let r = t.canonical.x - 1, n = t.wrap; return r < 0 && (r = (1 << t.canonical.z) - 1, n--), new e.OverscaledTileID(t.overscaledZ, n, t.canonical.z, r, t.canonical.y) }, t => { let r = t.canonical.x + 1, n = t.wrap; return r === 1 << t.canonical.z && (r = 0, n++), new e.OverscaledTileID(t.overscaledZ, n, t.canonical.z, r, t.canonical.y) }, t => new e.OverscaledTileID(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, (0 === t.canonical.y ? 1 << t.canonical.z : t.canonical.y) - 1), t => new e.OverscaledTileID(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y === (1 << t.canonical.z) - 1 ? 0 : t.canonical.y + 1)], c = e => { const t = r.getSource().minzoom, n = e => { const t = r.getTileByID(e); if (t && t.hasData()) return t.getBucket(o) }, i = [0, -1, 1]; for (const r of i) { if (e.overscaledZ + r < t) continue; const i = n(e.calculateScaledKey(e.overscaledZ + r)); if (i) return i } }, l = [0, 0, 0], u = (t, r) => (l[0] = Math.min(t.min.y, r.min.y), l[1] = Math.max(t.max.y, r.max.y), l[2] = e.EXTENT - r.min.x > t.max.x ? r.min.x - e.EXTENT : t.max.x, l), h = (t, r) => (l[0] = Math.min(t.min.x, r.min.x), l[1] = Math.max(t.max.x, r.max.x), l[2] = e.EXTENT - r.min.y > t.max.y ? r.min.y - e.EXTENT : t.max.y, l), d = [(e, t) => u(e, t), (e, t) => u(t, e), (e, t) => h(e, t), (e, t) => h(t, e)], p = new e.pointGeometry(0, 0); let f, m, g; const _ = (t, r, i, o, a) => { const c = [[o ? i : t, o ? t : i, 0], [o ? i : r, o ? r : i, 0]], l = a < 0 ? e.EXTENT + a : a, u = [o ? l : (t + r) / 2, o ? (t + r) / 2 : l, 0]; return 0 === i && a < 0 || 0 !== i && a > 0 ? s.getForTilePoints(g, [u], !0, m) : c.push(u), s.getForTilePoints(n, c, !0, f), Math.max(c[0][2], c[1][2], u[2]) / s.exaggeration() }; for (let y = 0; y < 4; y++) { const t = (y < 2 ? 1 : 5) - y, r = i.borders[y]; if (0 === r.length) continue; const o = g = a[y](n), l = c(o); if (!(l && l instanceof e.FillExtrusionBucket && l.enableTerrain)) continue; if (i.borderDoneWithNeighborZ[y] === l.canonical.z && l.borderDoneWithNeighborZ[t] === i.canonical.z) continue; if (m = s.findDEMTileFor(o), !m || !m.dem) continue; if (!f) { const e = s.findDEMTileFor(n); if (!e || !e.dem) return; f = e } const u = l.borders[t]; let h = 0; const v = l.borderDoneWithNeighborZ[t] !== i.canonical.z; if (i.canonical.z === l.canonical.z) { for (let n = 0; n < r.length; n++) { const o = i.featuresOnBorder[r[n]], s = o.borders[y]; let a; for (; h < u.length && (a = l.featuresOnBorder[u[h]], !(a.borders[t][1] > s[0] + 3));)v && l.encodeCentroid(void 0, a, !1), h++; if (a && h < u.length) { const r = h; let n = 0; for (; !(a.borders[t][0] > s[1] - 3) && (n++, ++h !== u.length);)a = l.featuresOnBorder[u[h]]; if (a = l.featuresOnBorder[u[r]], o.intersectsCount() > 1 || a.intersectsCount() > 1 || 1 !== n) { 1 !== n && (h = r), i.encodeCentroid(void 0, o, !1), v && l.encodeCentroid(void 0, a, !1); continue } const c = d[y](o, a), f = y % 2 ? e.EXTENT - 1 : 0; p.x = _(c[0], Math.min(e.EXTENT - 1, c[1]), f, y < 2, c[2]), p.y = 0, i.encodeCentroid(p, o, !1), v && l.encodeCentroid(p, a, !1) } else i.encodeCentroid(void 0, o, !1) } i.borderDoneWithNeighborZ[y] = l.canonical.z, i.needsCentroidUpdate = !0, v && (l.borderDoneWithNeighborZ[t] = i.canonical.z, l.needsCentroidUpdate = !0) } else { for (const e of r) i.encodeCentroid(void 0, i.featuresOnBorder[e], !1); if (v) { for (const e of u) l.encodeCentroid(void 0, l.featuresOnBorder[e], !1); l.borderDoneWithNeighborZ[t] = i.canonical.z, l.needsCentroidUpdate = !0 } i.borderDoneWithNeighborZ[y] = l.canonical.z, i.needsCentroidUpdate = !0 } } (i.needsCentroidUpdate || !i.centroidVertexBuffer && 0 !== i.centroidVertexArray.length) && i.uploadCentroid(t) } const Pn = new e.Color(1, 0, 0, 1), In = new e.Color(0, 1, 0, 1), An = new e.Color(0, 0, 1, 1), Ln = new e.Color(1, 0, 1, 1), Mn = new e.Color(0, 1, 1, 1); function Bn(t, r, n) { const i = t.context, o = t.transform, s = i.gl, a = "globe" === o.projection.name, c = a ? ["PROJECTION_GLOBE_VIEW"] : null; let l = n.projMatrix; if (a && e.globeToMercatorTransition(o.zoom) > 0) { const t = e.transitionTileAABBinECEF(n.canonical, o), r = e.globeDenormalizeECEF(t); l = e.multiply(new Float32Array(16), o.globeMatrix, r), e.multiply(l, o.projMatrix, l) } const u = t.useProgram("debug", null, c), h = r.getTileByID(n.key); t.terrain && t.terrain.setupElevationDraw(h, u); const d = e.DepthMode.disabled, p = e.StencilMode.disabled, f = t.colorModeForRenderPass(), m = "$debug"; i.activeTexture.set(s.TEXTURE0), t.emptyTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE), a ? h._makeGlobeTileDebugBuffers(t.context, o) : h._makeDebugTileBoundsBuffers(t.context, o.projection); const g = h._tileDebugBuffer || t.debugBuffer, _ = h._tileDebugIndexBuffer || t.debugIndexBuffer, y = h._tileDebugSegments || t.debugSegments; u.draw(i, s.LINE_STRIP, d, p, f, e.CullFaceMode.disabled, Kr(l, e.Color.red), m, g, _, y, null, null, null, [h._globeTileDebugBorderBuffer]); const v = h.latestRawTileData, x = Math.floor((v && v.byteLength || 0) / 1024), b = r.getTile(n).tileSize, w = 512 / Math.min(b, 512) * (n.overscaledZ / o.zoom) * .5; let T = n.canonical.toString(); n.overscaledZ !== n.canonical.z && (T += ` => ${n.overscaledZ}`), T += ` ${x}kb`, function (e, t) { e.initDebugOverlayCanvas(); const r = e.debugOverlayCanvas, n = e.context.gl, i = e.debugOverlayCanvas.getContext("2d"); i.clearRect(0, 0, r.width, r.height), i.shadowColor = "white", i.shadowBlur = 2, i.lineWidth = 1.5, i.strokeStyle = "white", i.textBaseline = "top", i.font = "bold 36px Open Sans, sans-serif", i.fillText(t, 5, 5), i.strokeText(t, 5, 5), e.debugOverlayTexture.update(r), e.debugOverlayTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE) }(t, T); const k = h._tileDebugTextBuffer || t.debugBuffer, C = h._tileDebugTextIndexBuffer || t.quadTriangleIndexBuffer, E = h._tileDebugTextSegments || t.debugSegments; u.draw(i, s.TRIANGLES, d, p, e.ColorMode.alphaBlended, e.CullFaceMode.disabled, Kr(l, e.Color.transparent, w), m, k, C, E, null, null, null, [h._globeTileDebugTextBuffer]) } function Rn(e, t, r, n) { Fn(e, 0, t + r / 2, e.transform.width, r, n) } function Dn(e, t, r, n) { Fn(e, t - r / 2, 0, r, e.transform.height, n) } function Fn(t, r, n, i, o, s) { const a = t.context, c = a.gl; c.enable(c.SCISSOR_TEST), c.scissor(r * e.exported.devicePixelRatio, n * e.exported.devicePixelRatio, i * e.exported.devicePixelRatio, o * e.exported.devicePixelRatio), a.clear({ color: s }), c.disable(c.SCISSOR_TEST) } const On = e.createLayout([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: zn } = On; function Un(e, t, r, n) { e.emplaceBack(t, r, n) } class Nn { constructor(t) { this.vertexArray = new e.StructArrayLayout3f12, this.indices = new e.StructArrayLayout3ui6, Un(this.vertexArray, -1, -1, 1), Un(this.vertexArray, 1, -1, 1), Un(this.vertexArray, -1, 1, 1), Un(this.vertexArray, 1, 1, 1), Un(this.vertexArray, -1, -1, -1), Un(this.vertexArray, 1, -1, -1), Un(this.vertexArray, -1, 1, -1), Un(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t.createVertexBuffer(this.vertexArray, zn), this.indexBuffer = t.createIndexBuffer(this.indices), this.segment = e.SegmentVector.simpleSegment(0, 0, 36, 12) } } function Gn(t, r, n, i, o, s) { const a = t.gl, c = r.paint.get("sky-atmosphere-color"), l = r.paint.get("sky-atmosphere-halo-color"), u = r.paint.get("sky-atmosphere-sun-intensity"), h = mn(e.fromMat4(e.create$1(), i), o, u, c, l); a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + s, r.skyboxTexture, 0), n.draw(t, a.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.frontCW, h, "skyboxCapture", r.skyboxGeometry.vertexBuffer, r.skyboxGeometry.indexBuffer, r.skyboxGeometry.segment) } const Vn = e.createLayout([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]); class qn { constructor(t) { const r = new e.StructArrayLayout5f20; r.emplaceBack(-1, 1, 1, 0, 0), r.emplaceBack(1, 1, 1, 1, 0), r.emplaceBack(1, -1, 1, 1, 1), r.emplaceBack(-1, -1, 1, 0, 1); const n = new e.StructArrayLayout3ui6; n.emplaceBack(0, 1, 2), n.emplaceBack(2, 3, 0), this.vertexBuffer = t.createVertexBuffer(r, Vn.members), this.indexBuffer = t.createIndexBuffer(n), this.segments = e.SegmentVector.simpleSegment(0, 0, 4, 2) } destroy() { this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy() } } const jn = { symbol: function (t, r, n, i, o) { if ("translucent" !== t.renderPass) return; const s = e.StencilMode.disabled, a = t.colorModeForRenderPass(); n.layout.get("text-variable-anchor") && function (t, r, n, i, o, s, a) { const c = r.transform, l = "map" === o, u = "map" === s; for (const h of t) { const t = i.getTile(h), r = t.getBucket(n); if (!r || !r.text || !r.text.segments.get().length) continue; const o = e.evaluateSizeForZoom(r.textSizeData, c.zoom), s = kt(h, r.getProjection(), c), d = c.calculatePixelsToTileUnitsMatrix(t), p = ot(s, t.tileID.canonical, u, l, c, r.getProjection(), d), f = "none" !== n.layout.get("icon-text-fit") && r.hasIconData(); if (o) { const n = Math.pow(2, c.zoom - t.tileID.overscaledZ); bn(r, l, u, a, e.symbolSize, c, p, h, n, o, f) } } }(i, t, n, r, n.layout.get("text-rotation-alignment"), n.layout.get("text-pitch-alignment"), o), 0 !== n.paint.get("icon-opacity").constantOr(1) && Tn(t, r, n, i, !1, n.paint.get("icon-translate"), n.paint.get("icon-translate-anchor"), n.layout.get("icon-rotation-alignment"), n.layout.get("icon-pitch-alignment"), n.layout.get("icon-keep-upright"), s, a), 0 !== n.paint.get("text-opacity").constantOr(1) && Tn(t, r, n, i, !0, n.paint.get("text-translate"), n.paint.get("text-translate-anchor"), n.layout.get("text-rotation-alignment"), n.layout.get("text-pitch-alignment"), n.layout.get("text-keep-upright"), s, a), r.map.showCollisionBoxes && (yn(t, r, n, i, n.paint.get("text-translate"), n.paint.get("text-translate-anchor"), !0), yn(t, r, n, i, n.paint.get("icon-translate"), n.paint.get("icon-translate-anchor"), !1)) }, circle: function (t, r, n, i) { if ("translucent" !== t.renderPass) return; const o = n.paint.get("circle-opacity"), s = n.paint.get("circle-stroke-width"), a = n.paint.get("circle-stroke-opacity"), c = void 0 !== n.layout.get("circle-sort-key").constantOr(1); if (0 === o.constantOr(1) && (0 === s.constantOr(1) || 0 === a.constantOr(1))) return; const l = t.context, u = l.gl, h = t.transform, d = t.depthModeForSublayer(0, e.DepthMode.ReadOnly), p = e.StencilMode.disabled, f = t.colorModeForRenderPass(), m = "globe" === h.projection.name, g = [e.mercatorXfromLng(h.center.lng), e.mercatorYfromLat(h.center.lat)], _ = []; for (let v = 0; v < i.length; v++) { const o = i[v], s = r.getTile(o), a = s.getBucket(n); if (!a || a.projection.name !== h.projection.name) continue; const l = a.programConfigurations.get(n.id), u = Qr(n); m && u.push("PROJECTION_GLOBE_VIEW"); const d = t.useProgram("circle", l, u), p = a.layoutVertexBuffer, f = a.globeExtVertexBuffer, y = a.indexBuffer, x = h.projection.createInversionMatrix(h, o.canonical), b = { programConfiguration: l, program: d, layoutVertexBuffer: p, globeExtVertexBuffer: f, indexBuffer: y, uniformValues: Hr(t, o, s, x, g, n), tile: s }; if (c) { const t = a.segments.get(); for (const r of t) _.push({ segments: new e.SegmentVector([r]), sortKey: r.sortKey, state: b }) } else _.push({ segments: a.segments, sortKey: 0, state: b }) } c && _.sort(((e, t) => e.sortKey - t.sortKey)); const y = { useDepthForOcclusion: !m }; for (const v of _) { const { programConfiguration: r, program: i, layoutVertexBuffer: o, globeExtVertexBuffer: s, indexBuffer: a, uniformValues: c, tile: m } = v.state, g = v.segments; t.terrain && t.terrain.setupElevationDraw(m, i, y), t.prepareDrawProgram(l, i, m.tileID.toUnwrapped()), i.draw(l, u.TRIANGLES, d, p, f, e.CullFaceMode.disabled, c, n.id, o, a, g, n.paint, h.zoom, r, [s]) } }, heatmap: function (t, r, n, i) { if (0 !== n.paint.get("heatmap-opacity")) if ("offscreen" === t.renderPass) { const o = t.context, s = o.gl, a = e.StencilMode.disabled, c = new e.ColorMode([s.ONE, s.ONE], e.Color.transparent, [!0, !0, !0, !0]); !function (e, t, r, n) { const i = e.gl, o = t.width * n, s = t.height * n; e.activeTexture.set(i.TEXTURE1), e.viewport.set([0, 0, o, s]); let a = r.heatmapFbo; if (!a || a && (a.width !== o || a.height !== s)) { a && a.destroy(); const t = i.createTexture(); i.bindTexture(i.TEXTURE_2D, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR), a = r.heatmapFbo = e.createFramebuffer(o, s, !1), function (e, t, r, n, i, o) { const s = e.gl; s.texImage2D(s.TEXTURE_2D, 0, e.isWebGL2 && e.extRenderToTextureHalfFloat ? s.RGBA16F : s.RGBA, i, o, 0, s.RGBA, e.extRenderToTextureHalfFloat ? e.isWebGL2 ? s.HALF_FLOAT : e.extTextureHalfFloat.HALF_FLOAT_OES : s.UNSIGNED_BYTE, null), n.colorAttachment.set(r) }(e, 0, t, a, o, s) } else i.bindTexture(i.TEXTURE_2D, a.colorAttachment.get()), e.bindFramebuffer.set(a.framebuffer) }(o, t, n, "globe" === t.transform.projection.name ? .5 : .25), o.clear({ color: e.Color.transparent }); const l = t.transform, u = "globe" === l.projection.name, h = u ? ["PROJECTION_GLOBE_VIEW"] : null, d = u ? e.CullFaceMode.frontCCW : e.CullFaceMode.disabled, p = [e.mercatorXfromLng(l.center.lng), e.mercatorYfromLat(l.center.lat)]; for (let f = 0; f < i.length; f++) { const m = i[f]; if (r.hasRenderableParent(m)) continue; const g = r.getTile(m), _ = g.getBucket(n); if (!_ || _.projection.name !== l.projection.name) continue; const y = _.programConfigurations.get(n.id), v = t.useProgram("heatmap", y, h), { zoom: x } = t.transform; t.terrain && t.terrain.setupElevationDraw(g, v), t.prepareDrawProgram(o, v, m.toUnwrapped()); const b = l.projection.createInversionMatrix(l, m.canonical); v.draw(o, s.TRIANGLES, e.DepthMode.disabled, a, c, d, en(t, m, g, b, p, x, n.paint.get("heatmap-intensity")), n.id, _.layoutVertexBuffer, _.indexBuffer, _.segments, n.paint, t.transform.zoom, y, u ? [_.globeExtVertexBuffer] : null) } o.viewport.set([0, 0, t.width, t.height]) } else "translucent" === t.renderPass && (t.context.setColorMode(t.colorModeForRenderPass()), function (t, r) { const n = t.context, i = n.gl, o = r.heatmapFbo; if (!o) return; n.activeTexture.set(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, o.colorAttachment.get()), n.activeTexture.set(i.TEXTURE1); let s = r.colorRampTexture; s || (s = r.colorRampTexture = new e.Texture(n, r.colorRamp, i.RGBA)), s.bind(i.LINEAR, i.CLAMP_TO_EDGE), t.useProgram("heatmapTexture").draw(n, i.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, ((e, t, r, n) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t.paint.get("heatmap-opacity") }))(0, r), r.id, t.viewportBuffer, t.quadTriangleIndexBuffer, t.viewportSegments, r.paint, t.transform.zoom) }(t, n)) }, line: function (t, r, n, i) { if ("translucent" !== t.renderPass) return; const o = n.paint.get("line-opacity"), s = n.paint.get("line-width"); if (0 === o.constantOr(1) || 0 === s.constantOr(1)) return; const a = t.depthModeForSublayer(0, e.DepthMode.ReadOnly), c = t.colorModeForRenderPass(), l = t.terrain && t.terrain.renderingToTexture ? 1 : e.exported.devicePixelRatio, u = n.paint.get("line-dasharray"), h = u.constantOr(1), d = n.layout.get("line-cap"), p = n.paint.get("line-pattern"), f = p.constantOr(1), m = n.paint.get("line-gradient"), g = f ? "linePattern" : "line", _ = t.context, y = _.gl, v = (e => { const t = []; sn(e) && t.push("RENDER_LINE_DASH"), e.paint.get("line-gradient") && t.push("RENDER_LINE_GRADIENT"); const r = e.paint.get("line-trim-offset"); 0 === r[0] && 0 === r[1] || t.push("RENDER_LINE_TRIM_OFFSET"); const n = e.paint.get("line-pattern").constantOr(1), i = 1 !== e.paint.get("line-opacity").constantOr(1); return !n && i && t.push("RENDER_LINE_ALPHA_DISCARD"), t })(n); let x = v.includes("RENDER_LINE_ALPHA_DISCARD"); t.terrain && t.terrain.clipOrMaskOverlapStencilType() && (x = !1); for (const b of i) { const i = r.getTile(b); if (f && !i.patternsLoaded()) continue; const o = i.getBucket(n); if (!o) continue; t.prepareDrawTile(); const s = o.programConfigurations.get(n.id), w = t.useProgram(g, s, v), T = p.constantOr(null); if (T && i.imageAtlas) { const e = i.imageAtlas.patternPositions[T.toString()]; e && s.setConstantPatternPositions(e) } const k = u.constantOr(null), C = d.constantOr(null); if (!f && k && C && i.lineAtlas) { const e = i.lineAtlas.getDash(k, C); e && s.setConstantPatternPositions(e) } let [E, S] = n.paint.get("line-trim-offset"); if ("round" === C || "square" === C) { const e = 1; E !== S && (0 === E && (E -= e), 1 === S && (S += e)) } const P = t.terrain ? b.projMatrix : null, I = f ? rn(t, i, n, P, l) : tn(t, i, n, P, o.lineClipsArray.length, l, [E, S]); if (m) { const i = o.gradients[n.id]; let s = i.texture; if (n.gradientVersion !== i.version) { let a = 256; if (n.stepInterpolant) { const n = r.getSource().maxzoom, i = b.canonical.z === n ? Math.ceil(1 << t.transform.maxZoom - b.canonical.z) : 1; a = e.clamp(e.nextPowerOfTwo(o.maxLineLength / e.EXTENT * 1024 * i), 256, _.maxTextureSize) } i.gradient = e.renderColorRamp({ expression: n.gradientExpression(), evaluationKey: "lineProgress", resolution: a, image: i.gradient || void 0, clips: o.lineClipsArray }), i.texture ? i.texture.update(i.gradient) : i.texture = new e.Texture(_, i.gradient, y.RGBA), i.version = n.gradientVersion, s = i.texture } _.activeTexture.set(y.TEXTURE1), s.bind(n.stepInterpolant ? y.NEAREST : y.LINEAR, y.CLAMP_TO_EDGE) } h && (_.activeTexture.set(y.TEXTURE0), i.lineAtlasTexture.bind(y.LINEAR, y.REPEAT), s.updatePaintBuffers()), f && (_.activeTexture.set(y.TEXTURE0), i.imageAtlasTexture.bind(y.LINEAR, y.CLAMP_TO_EDGE), s.updatePaintBuffers()), t.prepareDrawProgram(_, w, b.toUnwrapped()); const A = r => { w.draw(_, y.TRIANGLES, a, r, c, e.CullFaceMode.disabled, I, n.id, o.layoutVertexBuffer, o.indexBuffer, o.segments, n.paint, t.transform.zoom, s, [o.layoutVertexBuffer2]) }; if (x) { const r = t.stencilModeForClipping(b).ref; 0 === r && t.terrain && _.clear({ stencil: 0 }); const n = { func: y.EQUAL, mask: 255 }; I.u_alpha_discard_threshold = .8, A(new e.StencilMode(n, r, 255, y.KEEP, y.KEEP, y.INVERT)), I.u_alpha_discard_threshold = 0, A(new e.StencilMode(n, r, 255, y.KEEP, y.KEEP, y.KEEP)) } else A(t.stencilModeForClipping(b)) } x && (t.resetStencilClippingMasks(), t.terrain && _.clear({ stencil: 0 })) }, fill: function (t, r, n, i) { const o = n.paint.get("fill-color"), s = n.paint.get("fill-opacity"); if (0 === s.constantOr(1)) return; const a = t.colorModeForRenderPass(), c = n.paint.get("fill-pattern"), l = t.opaquePassEnabledForLayer() && !c.constantOr(1) && 1 === o.constantOr(e.Color.transparent).a && 1 === s.constantOr(0) ? "opaque" : "translucent"; if (t.renderPass === l) { const o = t.depthModeForSublayer(1, "opaque" === t.renderPass ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly); Cn(t, r, n, i, o, a, !1) } if ("translucent" === t.renderPass && n.paint.get("fill-antialias")) { const o = t.depthModeForSublayer(n.getPaintProperty("fill-outline-color") ? 2 : 0, e.DepthMode.ReadOnly); Cn(t, r, n, i, o, a, !0) } }, "fill-extrusion": function (t, r, n, i) { const o = n.paint.get("fill-extrusion-opacity"); if (0 !== o && "translucent" === t.renderPass) { const s = new e.DepthMode(t.context.gl.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D); if (1 !== o || n.paint.get("fill-extrusion-pattern").constantOr(1)) En(t, r, n, i, s, e.StencilMode.disabled, e.ColorMode.disabled), En(t, r, n, i, s, t.stencilModeFor3D(), t.colorModeForRenderPass()), t.resetStencilClippingMasks(); else { const o = t.colorModeForRenderPass(); En(t, r, n, i, s, e.StencilMode.disabled, o) } } }, hillshade: function (t, r, n, i) { if ("offscreen" !== t.renderPass && "translucent" !== t.renderPass) return; const o = t.context, s = t.depthModeForSublayer(0, e.DepthMode.ReadOnly), a = t.colorModeForRenderPass(), c = t.terrain && t.terrain.renderingToTexture, [l, u] = "translucent" !== t.renderPass || c ? [{}, i] : t.stencilConfigForOverlap(i); for (const h of u) { const i = r.getTile(h); if (i.needsHillshadePrepare && "offscreen" === t.renderPass) Tr(t, i, n, s, e.StencilMode.disabled, a); else if ("translucent" === t.renderPass) { const e = c && t.terrain ? t.terrain.stencilModeForRTTOverlap(h) : l[h.overscaledZ]; br(t, h, i, n, s, e, a) } } o.viewport.set([0, 0, t.width, t.height]), t.resetStencilClippingMasks() }, raster: function (t, r, n, i, o, s) { if ("translucent" !== t.renderPass) return; if (0 === n.paint.get("raster-opacity")) return; if (!i.length) return; const a = t.context, c = a.gl, l = r.getSource(), u = t.useProgram("raster"), h = t.colorModeForRenderPass(), d = t.terrain && t.terrain.renderingToTexture, [p, f] = l instanceof Be || d ? [{}, i] : t.stencilConfigForOverlap(i), m = f[f.length - 1].overscaledZ, g = !t.options.moving; for (const _ of f) { const i = d ? e.DepthMode.disabled : t.depthModeForSublayer(_.overscaledZ - m, 1 === n.paint.get("raster-opacity") ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly, c.LESS), o = _.toUnwrapped(), f = r.getTile(_); if (d && (!f || !f.hasData())) continue; const y = d ? _.projMatrix : t.transform.calculateProjMatrix(o, g), v = t.terrain && d ? t.terrain.stencilModeForRTTOverlap(_) : p[_.overscaledZ], x = s ? 0 : n.paint.get("raster-fade-duration"); f.registerFadeDuration(x); const b = r.findLoadedParent(_, 0), w = Br(f, b, r, t.transform, x); let T, k; t.terrain && t.terrain.prepareDrawTile(); const C = "nearest" === n.paint.get("raster-resampling") ? c.NEAREST : c.LINEAR; a.activeTexture.set(c.TEXTURE0), f.texture.bind(C, c.CLAMP_TO_EDGE), a.activeTexture.set(c.TEXTURE1), b ? (b.texture.bind(C, c.CLAMP_TO_EDGE), T = Math.pow(2, b.tileID.overscaledZ - f.tileID.overscaledZ), k = [f.tileID.canonical.x * T % 1, f.tileID.canonical.y * T % 1]) : f.texture.bind(C, c.CLAMP_TO_EDGE), f.texture.useMipmap && a.extTextureFilterAnisotropic && t.transform.pitch > 20 && c.texParameterf(c.TEXTURE_2D, a.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, a.extTextureFilterAnisotropicMax); const E = an(y, k || [0, 0], T || 1, w, n, l instanceof Be ? l.perspectiveTransform : [0, 0]); if (t.prepareDrawProgram(a, u, o), l instanceof Be) l.boundsBuffer && l.boundsSegments && u.draw(a, c.TRIANGLES, i, e.StencilMode.disabled, h, e.CullFaceMode.disabled, E, n.id, l.boundsBuffer, t.quadTriangleIndexBuffer, l.boundsSegments); else { const { tileBoundsBuffer: r, tileBoundsIndexBuffer: o, tileBoundsSegments: s } = t.getTileBoundsBuffers(f); u.draw(a, c.TRIANGLES, i, v, h, e.CullFaceMode.disabled, E, n.id, r, o, s) } } t.resetStencilClippingMasks() }, background: function (t, r, n, i) { const o = n.paint.get("background-color"), s = n.paint.get("background-opacity"); if (0 === s) return; const a = t.context, c = a.gl, l = t.transform, u = l.tileSize, h = n.paint.get("background-pattern"); if (t.isPatternMissing(h)) return; const d = !h && 1 === o.a && 1 === s && t.opaquePassEnabledForLayer() ? "opaque" : "translucent"; if (t.renderPass !== d) return; const p = e.StencilMode.disabled, f = t.depthModeForSublayer(0, "opaque" === d ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly), m = t.colorModeForRenderPass(), g = t.useProgram(h ? "backgroundPattern" : "background"); let _, y = i; y || (_ = t.getBackgroundTiles(), y = Object.values(_).map((e => e.tileID))), h && (a.activeTexture.set(c.TEXTURE0), t.imageManager.bind(t.context)); for (const v of y) { const d = v.toUnwrapped(), y = i ? v.projMatrix : t.transform.calculateProjMatrix(d); t.prepareDrawTile(); const x = r ? r.getTile(v) : _ ? _[v.key] : new e.Tile(v, u, l.zoom, t), b = h ? fn(y, s, t, h, { tileID: v, tileSize: u }) : pn(y, s, o); t.prepareDrawProgram(a, g, d); const { tileBoundsBuffer: w, tileBoundsIndexBuffer: T, tileBoundsSegments: k } = t.getTileBoundsBuffers(x); g.draw(a, c.TRIANGLES, f, p, m, e.CullFaceMode.disabled, b, n.id, w, T, k) } }, sky: function (t, r, n) { const i = t.transform, o = "mercator" === i.projection.name || "globe" === i.projection.name ? 1 : e.smoothstep(7, 8, i.zoom), s = n.paint.get("sky-opacity") * o; if (0 === s) return; const a = t.context, c = n.paint.get("sky-type"), l = new e.DepthMode(a.gl.LEQUAL, e.DepthMode.ReadOnly, [0, 1]), u = t.frameCounter / 1e3 % 1; "atmosphere" === c ? "offscreen" === t.renderPass ? n.needsSkyboxCapture(t) && (function (t, r, n, i) { const o = t.context, s = o.gl; let a = r.skyboxFbo; if (!a) { a = r.skyboxFbo = o.createFramebuffer(32, 32, !1), r.skyboxGeometry = new Nn(o), r.skyboxTexture = o.gl.createTexture(), s.bindTexture(s.TEXTURE_CUBE_MAP, r.skyboxTexture), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MAG_FILTER, s.LINEAR); for (let e = 0; e < 6; ++e)s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, s.RGBA, 32, 32, 0, s.RGBA, s.UNSIGNED_BYTE, null) } o.bindFramebuffer.set(a.framebuffer), o.viewport.set([0, 0, 32, 32]); const c = r.getCenter(t, !0), l = t.useProgram("skyboxCapture"), u = new Float64Array(16); e.identity(u), e.rotateY(u, u, .5 * -Math.PI), Gn(o, r, l, u, c, 0), e.identity(u), e.rotateY(u, u, .5 * Math.PI), Gn(o, r, l, u, c, 1), e.identity(u), e.rotateX(u, u, .5 * -Math.PI), Gn(o, r, l, u, c, 2), e.identity(u), e.rotateX(u, u, .5 * Math.PI), Gn(o, r, l, u, c, 3), e.identity(u), Gn(o, r, l, u, c, 4), e.identity(u), e.rotateY(u, u, Math.PI), Gn(o, r, l, u, c, 5), o.viewport.set([0, 0, t.width, t.height]) }(t, n), n.markSkyboxValid(t)) : "sky" === t.renderPass && function (t, r, n, i, o) { const s = t.context, a = s.gl, c = t.transform, l = t.useProgram("skybox"); s.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_CUBE_MAP, r.skyboxTexture); const u = ((e, t, r, n, i) => ({ u_matrix: e, u_sun_direction: t, u_cubemap: 0, u_opacity: n, u_temporal_offset: i }))(c.skyboxMatrix, r.getCenter(t, !1), 0, i, o); t.prepareDrawProgram(s, l), l.draw(s, a.TRIANGLES, n, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.backCW, u, "skybox", r.skyboxGeometry.vertexBuffer, r.skyboxGeometry.indexBuffer, r.skyboxGeometry.segment) }(t, n, l, s, u) : "gradient" === c && "sky" === t.renderPass && function (t, r, n, i, o) { const s = t.context, a = s.gl, c = t.transform, l = t.useProgram("skyboxGradient"); r.skyboxGeometry || (r.skyboxGeometry = new Nn(s)), s.activeTexture.set(a.TEXTURE0); let u = r.colorRampTexture; u || (u = r.colorRampTexture = new e.Texture(s, r.colorRamp, a.RGBA)), u.bind(a.LINEAR, a.CLAMP_TO_EDGE); const h = ((t, r, n, i, o) => ({ u_matrix: t, u_color_ramp: 0, u_center_direction: r, u_radius: e.degToRad(n), u_opacity: i, u_temporal_offset: o }))(c.skyboxMatrix, r.getCenter(t, !1), r.paint.get("sky-gradient-radius"), i, o); t.prepareDrawProgram(s, l), l.draw(s, a.TRIANGLES, n, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.backCW, h, "skyboxGradient", r.skyboxGeometry.vertexBuffer, r.skyboxGeometry.indexBuffer, r.skyboxGeometry.segment) }(t, n, l, s, u) }, debug: function (e, t, r) { for (let n = 0; n < r.length; n++)Bn(e, t, r[n]) }, custom: function (t, r, n, i) { const o = t.context, s = n.implementation; if (!t.transform.projection.unsupportedLayers || !t.transform.projection.unsupportedLayers.includes("custom") || t.terrain && (t.terrain.renderingToTexture || "offscreen" === t.renderPass) && n.isLayerDraped()) { if ("offscreen" === t.renderPass) { const r = s.prerender; if (r) { if (t.setCustomLayerDefaults(), o.setColorMode(t.colorModeForRenderPass()), "globe" === t.transform.projection.name) { const n = t.transform.pointMerc; r.call(s, o.gl, t.transform.customLayerMatrix(), t.transform.getProjection(), t.transform.globeToMercatorMatrix(), e.globeToMercatorTransition(t.transform.zoom), [n.x, n.y], t.transform.pixelsPerMeterRatio) } else r.call(s, o.gl, t.transform.customLayerMatrix()); o.setDirty(), t.setBaseState() } } else if ("translucent" === t.renderPass) { if (t.terrain && t.terrain.renderingToTexture) { const r = s.renderToTile; if (r) { const n = i[0].canonical, a = new e.MercatorCoordinate(n.x + i[0].wrap * (1 << n.z), n.y, n.z); o.setDepthMode(e.DepthMode.disabled), o.setStencilMode(e.StencilMode.disabled), o.setColorMode(t.colorModeForRenderPass()), t.setCustomLayerDefaults(), r.call(s, o.gl, a), o.setDirty(), t.setBaseState() } return } t.setCustomLayerDefaults(), o.setColorMode(t.colorModeForRenderPass()), o.setStencilMode(e.StencilMode.disabled); const r = "3d" === s.renderingMode ? new e.DepthMode(t.context.gl.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D) : t.depthModeForSublayer(0, e.DepthMode.ReadOnly); if (o.setDepthMode(r), "globe" === t.transform.projection.name) { const r = t.transform.pointMerc; s.render(o.gl, t.transform.customLayerMatrix(), t.transform.getProjection(), t.transform.globeToMercatorMatrix(), e.globeToMercatorTransition(t.transform.zoom), [r.x, r.y], t.transform.pixelsPerMeterRatio) } else s.render(o.gl, t.transform.customLayerMatrix()); o.setDirty(), t.setBaseState(), o.bindFramebuffer.set(null) } } else e.warnOnce("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.") } }; class Xn { constructor(t, r, n = !1) { this.context = new Pe(t, n), this.transform = r, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e.SourceCache.maxUnderzooming + e.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new $t, this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {} } updateTerrain(e, t) { const r = !!e && !!e.terrain && this.transform.projection.supportsTerrain; if (!(r || this._terrain && this._terrain.enabled)) return; this._terrain || (this._terrain = new Or(this, e)); const n = this._terrain; this.transform.elevation = r ? n : null, n.update(e, this.transform, t) } _updateFog(e) { const t = e.fog; if (!t || "globe" === this.transform.projection.name || t.getOpacity(this.transform.pitch) < 1 || t.properties.get("horizon-blend") < .03) return void (this.transform.fogCullDistSq = null); const [r, n] = t.getFovAdjustedRange(this.transform._fov); if (r > n) return void (this.transform.fogCullDistSq = null); const i = r + .78 * (n - r); this.transform.fogCullDistSq = i * i } get terrain() { return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null } resize(t, r) { if (this.width = t * e.exported.devicePixelRatio, this.height = r * e.exported.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e of this.style.order) this.style._layers[e].resize() } setup() { const t = this.context, r = new e.StructArrayLayout2i4; r.emplaceBack(0, 0), r.emplaceBack(e.EXTENT, 0), r.emplaceBack(0, e.EXTENT), r.emplaceBack(e.EXTENT, e.EXTENT), this.tileExtentBuffer = t.createVertexBuffer(r, e.posAttributes.members), this.tileExtentSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2); const n = new e.StructArrayLayout2i4; n.emplaceBack(0, 0), n.emplaceBack(e.EXTENT, 0), n.emplaceBack(0, e.EXTENT), n.emplaceBack(e.EXTENT, e.EXTENT), this.debugBuffer = t.createVertexBuffer(n, e.posAttributes.members), this.debugSegments = e.SegmentVector.simpleSegment(0, 0, 4, 5); const i = new e.StructArrayLayout2i4; i.emplaceBack(-1, -1), i.emplaceBack(1, -1), i.emplaceBack(-1, 1), i.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(i, e.posAttributes.members), this.viewportSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2); const o = new e.StructArrayLayout4i8; o.emplaceBack(0, 0, 0, 0), o.emplaceBack(e.EXTENT, 0, e.EXTENT, 0), o.emplaceBack(0, e.EXTENT, 0, e.EXTENT), o.emplaceBack(e.EXTENT, e.EXTENT, e.EXTENT, e.EXTENT), this.mercatorBoundsBuffer = t.createVertexBuffer(o, e.boundsAttributes.members), this.mercatorBoundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2); const s = new e.StructArrayLayout3ui6; s.emplaceBack(0, 1, 2), s.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(s); const a = new e.StructArrayLayout1ui2; for (const e of [0, 1, 3, 2, 0]) a.emplaceBack(e); this.debugIndexBuffer = t.createIndexBuffer(a), this.emptyTexture = new e.Texture(t, new e.RGBAImage({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t.gl.RGBA), this.identityMat = e.create(); const c = this.context.gl; this.stencilClearMode = new e.StencilMode({ func: c.ALWAYS, mask: 0 }, 0, 255, c.ZERO, c.ZERO, c.ZERO), this.loadTimeStamps.push(e.window.performance.now()), this.atmosphereBuffer = new qn(this.context) } getMercatorTileBoundsBuffers() { return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments } } getTileBoundsBuffers(e) { return e._makeTileBoundsBuffers(this.context, this.transform.projection), e._tileBoundsBuffer ? { tileBoundsBuffer: e._tileBoundsBuffer, tileBoundsIndexBuffer: e._tileBoundsIndexBuffer, tileBoundsSegments: e._tileBoundsSegments } : this.getMercatorTileBoundsBuffers() } clearStencil() { const t = this.context, r = t.gl; this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.useProgram("clippingMask").draw(t, r.TRIANGLES, e.DepthMode.disabled, this.stencilClearMode, e.ColorMode.disabled, e.CullFaceMode.disabled, Mr(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments) } resetStencilClippingMasks() { this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}) } _renderTileClippingMasks(t, r, n) { if (!r || this.currentStencilSource === r.id || !t.isTileClipped() || !n || 0 === n.length) return; if (this._tileClippingMaskIDs && !this.terrain) { let e = !1; for (const t of n) if (void 0 === this._tileClippingMaskIDs[t.key]) { e = !0; break } if (!e) return } this.currentStencilSource = r.id; const i = this.context, o = i.gl; this.nextStencilID + n.length > 256 && this.clearStencil(), i.setColorMode(e.ColorMode.disabled), i.setDepthMode(e.DepthMode.disabled); const s = this.useProgram("clippingMask"); this._tileClippingMaskIDs = {}; for (const a of n) { const t = r.getTile(a), n = this._tileClippingMaskIDs[a.key] = this.nextStencilID++, { tileBoundsBuffer: c, tileBoundsIndexBuffer: l, tileBoundsSegments: u } = this.getTileBoundsBuffers(t); s.draw(i, o.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({ func: o.ALWAYS, mask: 0 }, n, 255, o.KEEP, o.KEEP, o.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Mr(a.projMatrix), "$clipping", c, l, u) } } stencilModeFor3D() { this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil(); const t = this.nextStencilID++, r = this.context.gl; return new e.StencilMode({ func: r.NOTEQUAL, mask: 255 }, t, 255, r.KEEP, r.KEEP, r.REPLACE) } stencilModeForClipping(t) { if (this.terrain) return this.terrain.stencilModeForRTTOverlap(t); const r = this.context.gl; return new e.StencilMode({ func: r.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t.key], 0, r.KEEP, r.KEEP, r.REPLACE) } stencilConfigForOverlap(t) { const r = this.context.gl, n = t.sort(((e, t) => t.overscaledZ - e.overscaledZ)), i = n[n.length - 1].overscaledZ, o = n[0].overscaledZ - i + 1; if (o > 1) { this.currentStencilSource = void 0, this.nextStencilID + o > 256 && this.clearStencil(); const t = {}; for (let n = 0; n < o; n++)t[n + i] = new e.StencilMode({ func: r.GEQUAL, mask: 255 }, n + this.nextStencilID, 255, r.KEEP, r.KEEP, r.REPLACE); return this.nextStencilID += o, [t, n] } return [{ [i]: e.StencilMode.disabled }, n] } colorModeForRenderPass() { const t = this.context.gl; if (this._showOverdrawInspector) { const r = 1 / 8; return new e.ColorMode([t.CONSTANT_COLOR, t.ONE], new e.Color(r, r, r, 0), [!0, !0, !0, !0]) } return "opaque" === this.renderPass ? e.ColorMode.unblended : e.ColorMode.alphaBlended } depthModeForSublayer(t, r, n) { if (!this.opaquePassEnabledForLayer()) return e.DepthMode.disabled; const i = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon; return new e.DepthMode(n || this.context.gl.LEQUAL, r, [i, i]) } opaquePassEnabledForLayer() { return this.currentLayer < this.opaquePassCutoff } render(t, r) { this.style = t, this.options = r, this.imageManager = t.imageManager, this.glyphManager = t.glyphManager, this.symbolFadeChange = t.placement.symbolFadeChange(e.exported.now()), this.imageManager.beginFrame(); const n = this.style.order, i = this.style._sourceCaches; for (const e in i) { const t = i[e]; t.used && t.prepare(this.context) } const o = {}, s = {}, a = {}; for (const e in i) { const t = i[e]; o[e] = t.getVisibleCoordinates(), s[e] = o[e].slice().reverse(), a[e] = t.getVisibleCoordinates(!0).reverse() } this.opaquePassCutoff = 1 / 0; for (let e = 0; e < n.length; e++)if (this.style._layers[n[e]].is3D()) { this.opaquePassCutoff = e; break } if (this.terrain && (this.terrain.updateTileBinding(a), this.opaquePassCutoff = 0), "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.GlobeSharedBuffers(this.context)), e.isMapAuthenticated(this.context.gl)) { this.renderPass = "offscreen"; for (const e of n) { const r = this.style._layers[e], n = t._getLayerSourceCache(r); if (!r.hasOffscreenPass() || r.isHidden(this.transform.zoom)) continue; const i = n ? s[n.id] : void 0; ("custom" === r.type || r.isSky() || i && i.length) && this.renderLayer(this, n, r, i) } if (this.depthRangeFor3D = [0, 1 - (t.order.length + 2) * this.numSublayers * this.depthEpsilon], this.terrain && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && this.terrain.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]), this.context.clear({ color: r.showOverdrawInspector ? e.Color.black : e.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = r.showOverdrawInspector, this.renderPass = "opaque", !this.terrain) for (this.currentLayer = n.length - 1; this.currentLayer >= 0; this.currentLayer--) { const e = this.style._layers[n[this.currentLayer]], r = t._getLayerSourceCache(e); if (e.isSky()) continue; const i = r ? s[r.id] : void 0; this._renderTileClippingMasks(e, r, i), this.renderLayer(this, r, e, i) } if (this.style.fog && this.transform.projection.supportsFog && function (t, r) { const n = t.context, i = n.gl, o = t.transform, s = new e.DepthMode(i.LEQUAL, e.DepthMode.ReadOnly, [0, 1]), a = t.useProgram("globeAtmosphere", null, "globe" === o.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"]), c = e.globeToMercatorTransition(o.zoom), l = r.properties.get("color").toArray01(), u = r.properties.get("high-color").toArray01(), h = r.properties.get("space-color").toArray01PremultipliedAlpha(), d = e.identity$1([]); e.rotateY$1(d, d, -e.degToRad(o._center.lng)), e.rotateX$1(d, d, e.degToRad(o._center.lat)), e.rotateZ$1(d, d, o.angle), e.rotateX$1(d, d, -o._pitch); const p = e.fromQuat(new Float32Array(16), d), f = e.mapValue(r.properties.get("star-intensity"), 0, 1, 0, .25), m = 5e-4, g = e.mapValue(r.properties.get("horizon-blend"), 0, 1, m, .25), _ = e.globeUseCustomAntiAliasing(t, n, o) && g === m ? o.worldSize / (2 * Math.PI * 1.025) - 1 : o.globeRadius, y = t.frameCounter / 1e3 % 1, v = e.length(o.globeCenterInViewSpace), x = Math.sqrt(Math.pow(v, 2) - Math.pow(_, 2)), b = Math.acos(x / v), w = ((t, r, n, i, o, s, a, c, l, u, h, d, p, f) => ({ u_frustum_tl: t, u_frustum_tr: r, u_frustum_br: n, u_frustum_bl: i, u_horizon: o, u_transition: s, u_fadeout_range: a, u_color: c, u_high_color: l, u_space_color: u, u_star_intensity: h, u_star_size: 5 * e.exported.devicePixelRatio, u_star_density: 0, u_temporal_offset: d, u_horizon_angle: p, u_rotation_matrix: f }))(o.frustumCorners.TL, o.frustumCorners.TR, o.frustumCorners.BR, o.frustumCorners.BL, o.frustumCorners.horizon, c, g, l, u, h, f, y, b, p); t.prepareDrawProgram(n, a); const T = t.atmosphereBuffer; T && a.draw(n, i.TRIANGLES, s, e.StencilMode.disabled, e.ColorMode.alphaBlended, e.CullFaceMode.backCW, w, "skybox", T.vertexBuffer, T.indexBuffer, T.segments) }(this, this.style.fog), this.renderPass = "sky", (e.globeToMercatorTransition(this.transform.zoom) > 0 || "globe" !== this.transform.projection.name) && this.transform.isHorizonVisible()) for (this.currentLayer = 0; this.currentLayer < n.length; this.currentLayer++) { const e = this.style._layers[n[this.currentLayer]], r = t._getLayerSourceCache(e); e.isSky() && this.renderLayer(this, r, e, r ? s[r.id] : void 0) } for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < n.length;) { const e = this.style._layers[n[this.currentLayer]], r = t._getLayerSourceCache(e); if (e.isSky()) { ++this.currentLayer; continue } if (this.terrain && this.style.isLayerDraped(e)) { if (e.isHidden(this.transform.zoom)) { ++this.currentLayer; continue } this.currentLayer = this.terrain.renderBatch(this.currentLayer); continue } const i = r ? ("symbol" === e.type ? a : s)[r.id] : void 0; this._renderTileClippingMasks(e, r, r ? o[r.id] : void 0), this.renderLayer(this, r, e, i), ++this.currentLayer } if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) { let r = null; e.values(this.style._layers).forEach((e => { const n = t._getLayerSourceCache(e); n && !e.isHidden(this.transform.zoom) && (!r || r.getSource().maxzoom < n.getSource().maxzoom) && (r = n) })), r && this.options.showTileBoundaries && jn.debug(this, r, r.getVisibleCoordinates()) } this.options.showPadding && function (e) { const t = e.transform.padding; Rn(e, e.transform.height - (t.top || 0), 3, Pn), Rn(e, t.bottom || 0, 3, In), Dn(e, t.left || 0, 3, An), Dn(e, e.transform.width - (t.right || 0), 3, Ln); const r = e.transform.centerPoint; !function (e, t, r, n) { Fn(e, t - 1, r - 10, 2, 20, n), Fn(e, t - 10, r - 1, 20, 2, n) }(e, r.x, e.transform.height - r.y, Mn) }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e.window.performance.now()), this.saveCanvasCopy()) } } renderLayer(e, t, r, n) { r.isHidden(this.transform.zoom) || ("background" === r.type || "sky" === r.type || "custom" === r.type || n && n.length) && (this.id = r.id, this.gpuTimingStart(r), (!e.transform.projection.unsupportedLayers || !e.transform.projection.unsupportedLayers.includes(r.type) || e.terrain && "custom" === r.type) && jn[r.type](e, t, r, n, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd()) } gpuTimingStart(e) { if (!this.options.gpuTiming) return; const t = this.context.extTimerQuery; let r = this.gpuTimers[e.id]; r || (r = this.gpuTimers[e.id] = { calls: 0, cpuTime: 0, query: t.createQueryEXT() }), r.calls++, t.beginQueryEXT(t.TIME_ELAPSED_EXT, r.query) } gpuTimingDeferredRenderStart() { if (this.options.gpuTimingDeferredRender) { const e = this.context.extTimerQuery, t = e.createQueryEXT(); this.deferredRenderGpuTimeQueries.push(t), e.beginQueryEXT(e.TIME_ELAPSED_EXT, t) } } gpuTimingDeferredRenderEnd() { if (!this.options.gpuTimingDeferredRender) return; const e = this.context.extTimerQuery; e.endQueryEXT(e.TIME_ELAPSED_EXT) } gpuTimingEnd() { if (!this.options.gpuTiming) return; const e = this.context.extTimerQuery; e.endQueryEXT(e.TIME_ELAPSED_EXT) } collectGpuTimers() { const e = this.gpuTimers; return this.gpuTimers = {}, e } collectDeferredRenderGpuQueries() { const e = this.deferredRenderGpuTimeQueries; return this.deferredRenderGpuTimeQueries = [], e } queryGpuTimers(e) { const t = {}; for (const r in e) { const n = e[r], i = this.context.extTimerQuery, o = i.getQueryObjectEXT(n.query, i.QUERY_RESULT_EXT) / 1e6; i.deleteQueryEXT(n.query), t[r] = o } return t } queryGpuTimeDeferredRender(e) { if (!this.options.gpuTimingDeferredRender) return 0; const t = this.context.extTimerQuery; let r = 0; for (const n of e) r += t.getQueryObjectEXT(n, t.QUERY_RESULT_EXT) / 1e6, t.deleteQueryEXT(n); return r } translatePosMatrix(t, r, n, i, o) { if (!n[0] && !n[1]) return t; const s = o ? "map" === i ? this.transform.angle : 0 : "viewport" === i ? -this.transform.angle : 0; if (s) { const e = Math.sin(s), t = Math.cos(s); n = [n[0] * t - n[1] * e, n[0] * e + n[1] * t] } const a = [o ? n[0] : D(r, n[0], this.transform.zoom), o ? n[1] : D(r, n[1], this.transform.zoom), 0], c = new Float32Array(16); return e.translate(c, t, a), c } saveTileTexture(e) { const t = this._tileTextures[e.size[0]]; t ? t.push(e) : this._tileTextures[e.size[0]] = [e] } getTileTexture(e) { const t = this._tileTextures[e]; return t && t.length > 0 ? t.pop() : null } isPatternMissing(e) { return null === e || void 0 !== e && !this.imageManager.getPattern(e.toString()) } terrainRenderModeElevated() { return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture } currentGlobalDefines() { const e = this.terrain && this.terrain.renderingToTexture, t = this.terrain && 0 === this.terrain.exaggeration(), r = this.style && this.style.fog, n = []; return this.terrainRenderModeElevated() && n.push("TERRAIN"), "globe" === this.transform.projection.name && n.push("GLOBE"), t && n.push("ZERO_EXAGGERATION"), r && !e && 0 !== r.getOpacity(this.transform.pitch) && n.push("FOG"), e && n.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && n.push("OVERDRAW_INSPECTOR"), n } useProgram(e, t, r) { this.cache = this.cache || {}; const n = r || [], i = this.currentGlobalDefines().concat(n), o = zr.cacheKey(fr[e], e, i, t); return this.cache[o] || (this.cache[o] = new zr(this.context, e, fr[e], t, gn[e], i)), this.cache[o] } setCustomLayerDefaults() { this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault() } setBaseState() { const e = this.context.gl; this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD) } initDebugOverlayCanvas() { null == this.debugOverlayCanvas && (this.debugOverlayCanvas = e.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA)) } destroy() { this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.atmosphereBuffer && this.atmosphereBuffer.destroy() } prepareDrawTile() { this.terrain && this.terrain.prepareDrawTile() } prepareDrawProgram(t, r, n) { if (this.terrain && this.terrain.renderingToTexture) return; const i = this.style.fog; if (i) { const o = i.getOpacity(this.transform.pitch), s = ((t, r, n, i, o, s, a, c, l, u, h) => { const d = t.transform, p = r.properties.get("color").toArray01(); p[3] = i; const f = t.frameCounter / 1e3 % 1; return { u_fog_matrix: n ? d.calculateFogTileMatrix(n) : t.identityMat, u_fog_range: r.getFovAdjustedRange(d._fov), u_fog_color: p, u_fog_horizon_blend: r.properties.get("horizon-blend"), u_fog_temporal_offset: f, u_frustum_tl: o, u_frustum_tr: s, u_frustum_br: a, u_frustum_bl: c, u_globe_pos: l, u_globe_radius: u, u_viewport: h, u_globe_transition: e.globeToMercatorTransition(d.zoom), u_is_globe: +("globe" === d.projection.name) } })(this, i, n, o, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e.exported.devicePixelRatio, this.transform.height * e.exported.devicePixelRatio]); r.setFogUniformValues(t, s) } } setTileLoadedFlag(e) { this.tileLoaded = e } saveCanvasCopy() { const e = this.canvasCopy(); e && (this.frameCopies.push(e), this.tileLoaded = !1) } canvasCopy() { const e = this.context.gl, t = e.createTexture(); return e.bindTexture(e.TEXTURE_2D, t), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, 0, 0, e.drawingBufferWidth, e.drawingBufferHeight, 0), t } getCanvasCopiesAndTimestamps() { return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps } } averageElevationNeedsEasing() { if (!this.transform._elevation) return !1; const e = this.style && this.style.fog; return !!e && 0 !== e.getOpacity(this.transform.pitch) } getBackgroundTiles() { const t = this._backgroundTiles, r = this._backgroundTiles = {}, n = this.transform.coveringTiles({ tileSize: 512 }); for (const i of n) r[i.key] = t[i.key] || new e.Tile(i, 512, this.transform.tileZoom, this); return r } clearBackgroundTiles() { this._backgroundTiles = {} } } class Wn { constructor(e = 0, t = 0, r = 0, n = 0) { if (isNaN(e) || e < 0 || isNaN(t) || t < 0 || isNaN(r) || r < 0 || isNaN(n) || n < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers"); this.top = e, this.bottom = t, this.left = r, this.right = n } interpolate(t, r, n) { return null != r.top && null != t.top && (this.top = e.number(t.top, r.top, n)), null != r.bottom && null != t.bottom && (this.bottom = e.number(t.bottom, r.bottom, n)), null != r.left && null != t.left && (this.left = e.number(t.left, r.left, n)), null != r.right && null != t.right && (this.right = e.number(t.right, r.right, n)), this } getCenter(t, r) { const n = e.clamp((this.left + t - this.right) / 2, 0, t), i = e.clamp((this.top + r - this.bottom) / 2, 0, r); return new e.pointGeometry(n, i) } equals(e) { return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right } clone() { return new Wn(this.top, this.bottom, this.left, this.right) } toJSON() { return { top: this.top, bottom: this.bottom, left: this.left, right: this.right } } } function Zn(t, r) { const n = e.getColumn(t, 3); e.fromQuat(t, r), e.setColumn(t, 3, n) } function Hn(t, r) { const n = e.identity$1([]); return e.rotateZ$1(n, n, -r), e.rotateX$1(n, n, -t), n } function Qn(t, r) { const n = [t[0], t[1], 0], i = [r[0], r[1], 0]; if (e.length(n) >= 1e-15) { const t = e.normalize([], n); e.scale$2(i, t, e.dot(i, t)), r[0] = i[0], r[1] = i[1] } const o = e.cross([], r, t); if (e.len(o) < 1e-15) return null; const s = Math.atan2(-o[1], o[0]); return Hn(Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2]), s) } class $n { constructor(e, t) { this.position = e, this.orientation = t } get position() { return this._position } set position(t) { if (t) { const r = t instanceof e.MercatorCoordinate ? t : new e.MercatorCoordinate(t[0], t[1], t[2]); this._renderWorldCopies && (r.x = e.wrap(r.x, 0, 1)), this._position = r } else this._position = null } lookAtPoint(t, r) { if (this.orientation = null, !this.position) return; const n = this._elevation ? this._elevation.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(t)) : 0, i = this.position, o = e.MercatorCoordinate.fromLngLat(t, n), s = [o.x - i.x, o.y - i.y, o.z - i.z]; r || (r = [0, 0, 1]), r[2] = Math.abs(r[2]), this.orientation = Qn(s, r) } setPitchBearing(t, r) { this.orientation = Hn(e.degToRad(t), e.degToRad(-r)) } } class Jn { constructor(t, r) { this._transform = e.identity([]), this.orientation = r, this.position = t } get mercatorPosition() { const t = this.position; return new e.MercatorCoordinate(t[0], t[1], t[2]) } get position() { const t = e.getColumn(this._transform, 3); return [t[0], t[1], t[2]] } set position(t) { var r; t && e.setColumn(this._transform, 3, [(r = t)[0], r[1], r[2], 1]) } get orientation() { return this._orientation } set orientation(t) { this._orientation = t || e.identity$1([]), t && Zn(this._transform, this._orientation) } getPitchBearing() { const e = this.forward(), t = this.right(); return { bearing: Math.atan2(-t[1], t[0]), pitch: Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2]) } } setPitchBearing(e, t) { this._orientation = Hn(e, t), Zn(this._transform, this._orientation) } forward() { const t = e.getColumn(this._transform, 2); return [-t[0], -t[1], -t[2]] } up() { const t = e.getColumn(this._transform, 1); return [-t[0], -t[1], -t[2]] } right() { const t = e.getColumn(this._transform, 0); return [t[0], t[1], t[2]] } getCameraToWorld(t, r) { const n = new Float64Array(16); return e.invert(n, this.getWorldToCamera(t, r)), n } getWorldToCameraPosition(t, r, n) { const i = this.position; e.scale$2(i, i, -t); const o = new Float64Array(16); return e.fromScaling(o, [n, n, n]), e.translate(o, o, i), o[10] *= r, o } getWorldToCamera(t, r) { const n = new Float64Array(16), i = new Float64Array(4), o = this.position; return e.conjugate(i, this._orientation), e.scale$2(o, o, -t), e.fromQuat(n, i), e.translate(n, n, o), n[1] *= -1, n[5] *= -1, n[9] *= -1, n[13] *= -1, n[8] *= r, n[9] *= r, n[10] *= r, n[11] *= r, n } getCameraToClipPerspective(t, r, n, i) { const o = new Float64Array(16); return e.perspective(o, t, r, n, i), o } getDistanceToElevation(t, r = !1) { const n = 0 === t ? 0 : e.mercatorZfromAltitude(t, r ? e.latFromMercatorY(this.position[1]) : this.position[1]), i = this.forward(); return (n - this.position[2]) / i[2] } clone() { return new Jn([...this.position], [...this.orientation]) } } function Kn(t, r) { const n = ei(t.projection, t.zoom, t.width, t.height), i = function (t, r, n, i, o) { const s = new e.LngLat(n.lng - 180 * ti, n.lat), a = new e.LngLat(n.lng + 180 * ti, n.lat), c = t.project(s.lng, s.lat), l = t.project(a.lng, a.lat), u = -Math.atan2(l.y - c.y, l.x - c.x), h = e.MercatorCoordinate.fromLngLat(n); h.y = e.clamp(h.y, -1 + ti, 1 - ti); const d = h.toLngLat(), p = t.project(d.lng, d.lat), f = e.MercatorCoordinate.fromLngLat(d); f.x += ti; const m = f.toLngLat(), g = t.project(m.lng, m.lat), _ = ni(g.x - p.x, g.y - p.y, u), y = e.MercatorCoordinate.fromLngLat(d); y.y += ti; const v = y.toLngLat(), x = t.project(v.lng, v.lat), b = ni(x.x - p.x, x.y - p.y, u), w = Math.abs(_.x) / Math.abs(b.y), T = e.identity([]); e.rotateZ(T, T, -u * (1 - (o ? 0 : i))); const k = e.identity([]); return e.scale(k, k, [1, 1 - (1 - w) * i, 1]), k[4] = -b.x / b.y * i, e.rotateZ(k, k, u), e.multiply(k, T, k), k }(t.projection, 0, t.center, n, r), o = Yn(t); return e.scale(i, i, [o, o, 1]), i } function Yn(t) { const r = t.projection, n = ei(t.projection, t.zoom, t.width, t.height), i = ri(r, t.center), o = ri(r, e.LngLat.convert(r.center)); return Math.pow(2, i * n + (1 - n) * o) } function ei(t, r, n, i, o = 1 / 0) { const s = t.range; if (!s) return 0; const a = Math.min(o, Math.max(n, i)), c = Math.log(a / 1024) / Math.LN2; return e.smoothstep(s[0] + c, s[1] + c, r) } const ti = 1 / 4e4; function ri(t, r) { const n = e.clamp(r.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE), i = new e.LngLat(r.lng - 180 * ti, n), o = new e.LngLat(r.lng + 180 * ti, n), s = t.project(i.lng, n), a = t.project(o.lng, n), c = e.MercatorCoordinate.fromLngLat(i), l = e.MercatorCoordinate.fromLngLat(o), u = a.x - s.x, h = a.y - s.y, d = l.x - c.x, p = l.y - c.y, f = Math.sqrt((d * d + p * p) / (u * u + h * h)); return Math.log(f) / Math.LN2 } function ni(e, t, r) { const n = Math.cos(r), i = Math.sin(r); return { x: e * n - t * i, y: e * i + t * n } } class ii { constructor(t, r, n, i, o, s, a) { this.tileSize = 512, this._renderWorldCopies = void 0 === o || o, this._minZoom = t || 0, this._maxZoom = r || 22, this._minPitch = null == n ? 0 : n, this._maxPitch = null == i ? 60 : i, this.setProjection(s), this.setMaxBounds(a), this.width = 0, this.height = 0, this._center = new e.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new Wn, this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Jn, this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._horizonShift = .1 } clone() { const e = new ii(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection()); return e._elevation = this._elevation, e._centerAltitude = this._centerAltitude, e._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e.tileSize = this.tileSize, e.mercatorFromTransition = this.mercatorFromTransition, e.width = this.width, e.height = this.height, e.cameraElevationReference = this.cameraElevationReference, e._center = this._center, e._setZoom(this.zoom), e._seaLevelZoom = this._seaLevelZoom, e.angle = this.angle, e._fov = this._fov, e._pitch = this._pitch, e._nearZ = this._nearZ, e._farZ = this._farZ, e._averageElevation = this._averageElevation, e._unmodified = this._unmodified, e._edgeInsets = this._edgeInsets.clone(), e._camera = this._camera.clone(), e._calcMatrices(), e.freezeTileCoverage = this.freezeTileCoverage, e.frustumCorners = this.frustumCorners, e } get elevation() { return this._elevation } set elevation(e) { this._elevation !== e && (this._elevation = e, this._updateCameraOnTerrain(), this._calcMatrices()) } updateElevation(e, t = !1) { const r = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration; (null == this._seaLevelZoom || r) && this._updateCameraOnTerrain(), (e || r) && this._constrainCamera(t), this._calcMatrices() } getProjection() { return e.pick(this.projection, ["name", "center", "parallels"]) } setProjection(r) { this.projectionOptions = r || { name: "mercator" }; const n = this.projection ? this.getProjection() : void 0; this.projection = e.getProjection(this.projectionOptions); const i = !t(n, this.getProjection()); return i && this._calcMatrices(), this.mercatorFromTransition = !1, i } setMercatorFromTransition() { const t = this.projection.name; this.mercatorFromTransition = !0, this.projectionOptions = { name: "mercator" }, this.projection = e.getProjection({ name: "mercator" }); const r = t !== this.projection.name; return r && this._calcMatrices(), r } get minZoom() { return this._minZoom } set minZoom(e) { this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e)) } get maxZoom() { return this._maxZoom } set maxZoom(e) { this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e)) } get minPitch() { return this._minPitch } set minPitch(e) { this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e)) } get maxPitch() { return this._maxPitch } set maxPitch(e) { this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e)) } get renderWorldCopies() { return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies } set renderWorldCopies(e) { void 0 === e ? e = !0 : null === e && (e = !1), this._renderWorldCopies = e } get worldSize() { return this.tileSize * this.scale } get cameraWorldSizeForFog() { const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON); return this._worldSizeFromZoom(this._zoomFromMercatorZ(e)) } get cameraWorldSize() { const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON); return this._worldSizeFromZoom(this._zoomFromMercatorZ(e)) } get pixelsPerMeter() { return this.projection.pixelsPerMeter(this.center.lat, this.worldSize) } get cameraPixelsPerMeter() { return e.mercatorZfromAltitude(this.center.lat, this.cameraWorldSizeForFog) } get centerOffset() { return this.centerPoint._sub(this.size._div(2)) } get size() { return new e.pointGeometry(this.width, this.height) } get bearing() { return e.wrap(this.rotation, -180, 180) } set bearing(e) { this.rotation = e } get rotation() { return -this.angle / Math.PI * 180 } set rotation(t) { const r = -t * Math.PI / 180; var n; this.angle !== r && (this._unmodified = !1, this.angle = r, this._calcMatrices(), this.rotationMatrix = (n = new e.ARRAY_TYPE(4), e.ARRAY_TYPE != Float32Array && (n[1] = 0, n[2] = 0), n[0] = 1, n[3] = 1, n), function (e, t, r) { var n = t[0], i = t[1], o = t[2], s = t[3], a = Math.sin(r), c = Math.cos(r); e[0] = n * c + o * a, e[1] = i * c + s * a, e[2] = n * -a + o * c, e[3] = i * -a + s * c }(this.rotationMatrix, this.rotationMatrix, this.angle)) } get pitch() { return this._pitch / Math.PI * 180 } set pitch(t) { const r = e.clamp(t, this.minPitch, this.maxPitch) / 180 * Math.PI; this._pitch !== r && (this._unmodified = !1, this._pitch = r, this._calcMatrices()) } get aspect() { return this.width / this.height } get fovX() { return this._fov } get fovY() { const e = 1 / Math.tan(.5 * this.fovX); return 2 * Math.atan(1 / this.aspect / e) } set fov(t) { t = Math.max(.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = e.degToRad(t), this._calcMatrices()) } get averageElevation() { return this._averageElevation } set averageElevation(e) { this._averageElevation = e, this._calcFogMatrices(), this._distanceTileDataCache = {} } get zoom() { return this._zoom } set zoom(e) { const t = Math.min(Math.max(e, this.minZoom), this.maxZoom); this._zoom !== t && (this._unmodified = !1, this._setZoom(t), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices()) } _setZoom(e) { this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom } _updateCameraOnTerrain() { if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center))) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0); const e = this._elevation; this._centerAltitude = e.getAtPointOrZero(this.locationCoordinate(this.center)), this._centerAltitudeValidForExaggeration = e.exaggeration(), this._updateSeaLevelZoom() } _updateSeaLevelZoom() { void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize)) } sampleAverageElevation() { if (!this._elevation) return 0; const t = this._elevation, r = [[.5, .2], [.3, .5], [.5, .5], [.7, .5], [.5, .8]], n = this.horizonLineFromTop(); let i = 0, o = 0; for (let s = 0; s < r.length; s++) { const a = new e.pointGeometry(r[s][0] * this.width, n + r[s][1] * (this.height - n)), c = t.pointCoordinate(a); if (!c) continue; const l = 1 / Math.hypot(c[0] - this._camera.position[0], c[1] - this._camera.position[1]); i += c[3] * l, o += l } return 0 === o ? NaN : i / o } get center() { return this._center } set center(e) { e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices()) } _updateZoomFromElevation() { if (null == this._seaLevelZoom || !this._elevation) return; const e = this._seaLevelZoom, t = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), r = this.pixelsPerMeter / this.worldSize * t, n = this._mercatorZfromZoom(e), i = this._mercatorZfromZoom(this._maxZoom), o = Math.max(n - r, i); this._setZoom(this._zoomFromMercatorZ(o)) } get padding() { return this._edgeInsets.toJSON() } set padding(e) { this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices()) } computeZoomRelativeTo(t) { const r = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude())); let n; n = t.z < this._camera.position[2] ? [r.x, r.y, r.z] : [t.x, t.y, t.z]; const i = e.length(e.sub([], this._camera.position, n)); return e.clamp(this._zoomFromMercatorZ(i), this._minZoom, this._maxZoom) } setFreeCameraOptions(t) { if (!this.height) return; if (!t.position && !t.orientation) return; this._updateCameraState(); let r = !1; if (t.orientation && !e.exactEquals(t.orientation, this._camera.orientation) && (r = this._setCameraOrientation(t.orientation)), t.position) { const n = [t.position.x, t.position.y, t.position.z]; e.exactEquals$1(n, this._camera.position) || (this._setCameraPosition(n), r = !0) } r && (this._updateStateFromCamera(), this.recenterOnTerrain()) } getFreeCameraOptions() { this._updateCameraState(); const t = this._camera.position, r = new $n; return r.position = new e.MercatorCoordinate(t[0], t[1], t[2]), r.orientation = this._camera.orientation, r._elevation = this.elevation, r._renderWorldCopies = this.renderWorldCopies, r } _setCameraOrientation(t) { if (!e.length$1(t)) return !1; e.normalize$1(t, t); const r = e.transformQuat([], [0, 0, -1], t), n = e.transformQuat([], [0, -1, 0], t); if (n[2] < 0) return !1; const i = Qn(r, n); return !!i && (this._camera.orientation = i, !0) } _setCameraPosition(t) { const r = this.zoomScale(this.minZoom) * this.tileSize, n = this.zoomScale(this.maxZoom) * this.tileSize, i = this.cameraToCenterDistance; t[2] = e.clamp(t[2], i / n, i / r), this._camera.position = t } get centerPoint() { return this._edgeInsets.getCenter(this.width, this.height) } get fovAboveCenter() { return this._fov * (.5 + this.centerOffset.y / this.height) } isPaddingEqual(e) { return this._edgeInsets.equals(e) } interpolatePadding(e, t, r) { this._unmodified = !1, this._edgeInsets.interpolate(e, t, r), this._constrain(), this._calcMatrices() } coveringZoomLevel(e) { const t = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize)); return Math.max(0, t) } getVisibleUnwrappedCoordinates(t) { const r = [new e.UnwrappedTileID(0, t)]; if (this.renderWorldCopies) { const n = this.pointCoordinate(new e.pointGeometry(0, 0)), i = this.pointCoordinate(new e.pointGeometry(this.width, 0)), o = this.pointCoordinate(new e.pointGeometry(this.width, this.height)), s = this.pointCoordinate(new e.pointGeometry(0, this.height)), a = Math.floor(Math.min(n.x, i.x, o.x, s.x)), c = Math.floor(Math.max(n.x, i.x, o.x, s.x)), l = 1; for (let u = a - l; u <= c + l; u++)0 !== u && r.push(new e.UnwrappedTileID(u, t)) } return r } coveringTiles(t) { let r = this.coveringZoomLevel(t); const n = r, i = this.elevation && !t.isTerrainDEM, o = "mercator" === this.projection.name; if (void 0 !== t.minzoom && r < t.minzoom) return []; void 0 !== t.maxzoom && r > t.maxzoom && (r = t.maxzoom); const s = this.locationCoordinate(this.center), a = this.center.lat, c = 1 << r, l = [c * s.x, c * s.y, 0], u = "globe" === this.projection.name, h = !u, d = e.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, r, h), p = u ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), f = c * e.mercatorZfromAltitude(1, this.center.lat), m = this._camera.position[2] / e.mercatorZfromAltitude(1, this.center.lat), g = [c * p.x, c * p.y, m * (h ? 1 : f)], _ = this.cameraToCenterDistance / t.tileSize * (t.roundZoom ? 1 : .502), y = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? r : 0, v = t.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude, x = t.isTerrainDEM ? -v : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, b = this.projection.isReprojectedInTileSpace ? Yn(this) : 1, w = t => { const r = 1 / 4e4, n = new e.MercatorCoordinate(t.x + r, t.y, t.z), i = new e.MercatorCoordinate(t.x, t.y + r, t.z), o = t.toLngLat(), s = n.toLngLat(), a = i.toLngLat(), c = this.locationCoordinate(o), l = this.locationCoordinate(s), u = this.locationCoordinate(a), h = Math.hypot(l.x - c.x, l.y - c.y), d = Math.hypot(u.x - c.x, u.y - c.y); return Math.sqrt(h * d) * b / r }, T = t => { const r = v, n = x; return { aabb: e.tileAABB(this, c, 0, 0, 0, t, n, r, this.projection), zoom: 0, x: 0, y: 0, minZ: n, maxZ: r, wrap: t, fullyVisible: !1 } }, k = []; let C = []; const E = r, S = t.reparseOverscaled ? n : r, P = e => e * e, I = P((m - this._centerAltitude) * f), A = e => { if (!this._elevation || !e.tileID || !o) return; const t = this._elevation.getMinMaxForTile(e.tileID), r = e.aabb; t ? (r.min[2] = t.min, r.max[2] = t.max, r.center[2] = (r.min[2] + r.max[2]) / 2) : (e.shouldSplit = L(e), e.shouldSplit || (r.min[2] = r.max[2] = r.center[2] = this._centerAltitude)) }, L = t => { if (t.zoom < y) return !0; if (t.zoom === E) return !1; if (null != t.shouldSplit) return t.shouldSplit; const r = t.aabb.distanceX(g), o = t.aabb.distanceY(g); let s = I, c = 1; if (u) { s = P(t.aabb.distanceZ(g)); const r = Math.pow(2, t.zoom), n = e.latFromMercatorY((t.y + 1) / r), i = e.latFromMercatorY(t.y / r), o = Math.min(Math.max(a, n), i), l = e.circumferenceAtLatitude(o) / e.circumferenceAtLatitude(a); if (c = o === a ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, l / this._mercatorScaleRatio), this.zoom <= e.GLOBE_ZOOM_THRESHOLD_MIN && t.zoom === E - 1 && l >= .9) return !0 } else if (i && (s = P(t.aabb.distanceZ(g) * f)), this.projection.isReprojectedInTileSpace && n <= 5) { const r = Math.pow(2, t.zoom), n = w(new e.MercatorCoordinate((t.x + .5) / r, (t.y + .5) / r)); c = n > .85 ? 1 : n } const l = r * r + o * o + s, h = P((1 << E - t.zoom) * _ * c * ((e, t) => { if (t * P(.707) < e) return 1; const r = Math.sqrt(t / e); return r / (1.4144271570014144 + (Math.pow(1.1, r - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1) })(Math.max(s, I), l)); return l < h }; if (this.renderWorldCopies) for (let e = 1; e <= 3; e++)k.push(T(-e)), k.push(T(e)); for (k.push(T(0)); k.length > 0;) { const n = k.pop(), s = n.x, a = n.y; let h = n.fullyVisible; if (!h) { const e = n.aabb.intersects(d); if (0 === e) continue; h = 2 === e } if (n.zoom !== E && L(n)) for (let t = 0; t < 4; t++) { const r = (s << 1) + t % 2, l = (a << 1) + (t >> 1), d = { aabb: o ? n.aabb.quadrant(t) : e.tileAABB(this, c, n.zoom + 1, r, l, n.wrap, n.minZ, n.maxZ, this.projection), zoom: n.zoom + 1, x: r, y: l, wrap: n.wrap, fullyVisible: h, tileID: void 0, shouldSplit: void 0, minZ: n.minZ, maxZ: n.maxZ }; i && !u && (d.tileID = new e.OverscaledTileID(n.zoom + 1 === E ? S : n.zoom + 1, n.wrap, n.zoom + 1, r, l), A(d)), k.push(d) } else { const i = n.zoom === E ? S : n.zoom; if (t.minzoom && t.minzoom > i) continue; const o = l[0] - (.5 + s + (n.wrap << n.zoom)) * (1 << r - n.zoom), c = l[1] - .5 - a, u = n.tileID ? n.tileID : new e.OverscaledTileID(i, n.wrap, n.zoom, s, a); C.push({ tileID: u, distanceSq: o * o + c * c }) } } if (this.fogCullDistSq) { const r = this.fogCullDistSq, n = this.horizonLineFromTop(); C = C.filter((i => { const o = [0, 0, 0, 1], s = [e.EXTENT, e.EXTENT, 0, 1], a = this.calculateFogTileMatrix(i.tileID.toUnwrapped()); e.transformMat4$1(o, o, a), e.transformMat4$1(s, s, a); const c = e.getAABBPointSquareDist(o, s); if (0 === c) return !0; let l = !1; const u = this._elevation; if (u && c > r && 0 !== n) { const r = this.calculateProjMatrix(i.tileID.toUnwrapped()); let o; t.isTerrainDEM || (o = u.getMinMaxForTile(i.tileID)), o || (o = { min: x, max: v }); const s = e.furthestTileCorner(this.rotation), a = [s[0] * e.EXTENT, s[1] * e.EXTENT, o.max]; e.transformMat4(a, a, r), l = (1 - a[1]) * this.height * .5 < n } return c < r || l })) } return C.sort(((e, t) => e.distanceSq - t.distanceSq)).map((e => e.tileID)) } resize(e, t) { this.width = e, this.height = t, this.pixelsToGLUnits = [2 / e, -2 / t], this._constrain(), this._calcMatrices() } get unmodified() { return this._unmodified } zoomScale(e) { return Math.pow(2, e) } scaleZoom(e) { return Math.log(e) / Math.LN2 } project(t) { const r = e.clamp(t.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE), n = this.projection.project(t.lng, r); return new e.pointGeometry(n.x * this.worldSize, n.y * this.worldSize) } unproject(e) { return this.projection.unproject(e.x / this.worldSize, e.y / this.worldSize) } get point() { return this.project(this.center) } get pointMerc() { return this.point._div(this.worldSize) } get pixelsPerMeterRatio() { return this.pixelsPerMeter / e.mercatorZfromAltitude(1, this.center.lat) / this.worldSize } setLocationAtPoint(t, r) { let n, i; const o = this.centerPoint; if ("globe" === this.projection.name) { const e = this.worldSize; n = (r.x - o.x) / e, i = (r.y - o.y) / e } else { const e = this.pointCoordinate(r), t = this.pointCoordinate(o); n = e.x - t.x, i = e.y - t.y } const s = this.locationCoordinate(t); this.setLocation(new e.MercatorCoordinate(s.x - n, s.y - i)) } setLocation(e) { this.center = this.coordinateLocation(e), this.projection.wrap && (this.center = this.center.wrap()) } locationPoint(e) { return this.projection.locationPoint(this, e) } locationPoint3D(e) { return this.projection.locationPoint(this, e, !0) } pointLocation(e) { return this.coordinateLocation(this.pointCoordinate(e)) } pointLocation3D(e) { return this.coordinateLocation(this.pointCoordinate3D(e)) } locationCoordinate(t, r) { const n = r ? e.mercatorZfromAltitude(r, t.lat) : void 0, i = this.projection.project(t.lng, t.lat); return new e.MercatorCoordinate(i.x, i.y, n) } coordinateLocation(e) { return this.projection.unproject(e.x, e.y) } pointRayIntersection(t, r) { const n = null != r ? r : this._centerAltitude, i = [t.x, t.y, 0, 1], o = [t.x, t.y, 1, 1]; e.transformMat4$1(i, i, this.pixelMatrixInverse), e.transformMat4$1(o, o, this.pixelMatrixInverse); const s = o[3]; e.scale$1(i, i, 1 / i[3]), e.scale$1(o, o, 1 / s); const a = i[2], c = o[2]; return { p0: i, p1: o, t: a === c ? 0 : (n - a) / (c - a) } } screenPointToMercatorRay(t) { const r = [t.x, t.y, 0, 1], n = [t.x, t.y, 1, 1]; return e.transformMat4$1(r, r, this.pixelMatrixInverse), e.transformMat4$1(n, n, this.pixelMatrixInverse), e.scale$1(r, r, 1 / r[3]), e.scale$1(n, n, 1 / n[3]), r[2] = e.mercatorZfromAltitude(r[2], this._center.lat) * this.worldSize, n[2] = e.mercatorZfromAltitude(n[2], this._center.lat) * this.worldSize, e.scale$1(r, r, 1 / this.worldSize), e.scale$1(n, n, 1 / this.worldSize), new e.Ray([r[0], r[1], r[2]], e.normalize([], e.sub([], n, r))) } rayIntersectionCoordinate(t) { const { p0: r, p1: n, t: i } = t, o = e.mercatorZfromAltitude(r[2], this._center.lat), s = e.mercatorZfromAltitude(n[2], this._center.lat); return new e.MercatorCoordinate(e.number(r[0], n[0], i) / this.worldSize, e.number(r[1], n[1], i) / this.worldSize, e.number(o, s, i)) } pointCoordinate(e, t = this._centerAltitude) { return this.projection.pointCoordinate(this, e.x, e.y, t) } pointCoordinate3D(t) { if (!this.elevation) return this.pointCoordinate(t); let r = this.projection.pointCoordinate3D(this, t.x, t.y); if (r) return new e.MercatorCoordinate(r[0], r[1], r[2]); let n = 0, i = this.horizonLineFromTop(); if (t.y > i) return this.pointCoordinate(t); const o = .02 * i, s = t.clone(); for (let a = 0; a < 10 && i - n > o; a++) { s.y = e.number(n, i, .66); const t = this.projection.pointCoordinate3D(this, s.x, s.y); t ? (i = s.y, r = t) : n = s.y } return r ? new e.MercatorCoordinate(r[0], r[1], r[2]) : this.pointCoordinate(t) } isPointAboveHorizon(e) { return this.projection.isPointAboveHorizon(this, e) } _coordinatePoint(t, r) { const n = r && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude, i = [t.x * this.worldSize, t.y * this.worldSize, n + t.toAltitude(), 1]; return e.transformMat4$1(i, i, this.pixelMatrix), i[3] > 0 ? new e.pointGeometry(i[0] / i[3], i[1] / i[3]) : new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE) } _getBoundsNonRectangular() { const { top: t, left: r } = this._edgeInsets, n = this.height - this._edgeInsets.bottom, i = this.width - this._edgeInsets.right, o = this.pointLocation3D(new e.pointGeometry(r, t)), s = this.pointLocation3D(new e.pointGeometry(i, t)), a = this.pointLocation3D(new e.pointGeometry(i, n)), c = this.pointLocation3D(new e.pointGeometry(r, n)); let l = Math.min(o.lng, s.lng, a.lng, c.lng), u = Math.max(o.lng, s.lng, a.lng, c.lng), h = Math.min(o.lat, s.lat, a.lat, c.lat), d = Math.max(o.lat, s.lat, a.lat, c.lat); const p = Math.pow(2, -this.zoom) / 16 * 270, f = "globe" === this.projection.name ? 1 : 4, m = (t, r, n, i, o) => { const s = (t + n) / 2, a = (r + i) / 2, c = new e.pointGeometry(s, a), { lng: g, lat: _ } = this.pointLocation3D(c), y = Math.max(0, l - g, h - _, g - u, _ - d); l = Math.min(l, g), u = Math.max(u, g), h = Math.min(h, _), d = Math.max(d, _), (o < f || y > p) && (m(t, r, s, a, o + 1), m(s, a, n, i, o + 1)) }; if (m(r, t, i, t, 1), m(i, t, i, n, 1), m(i, n, r, n, 1), m(r, n, r, t, 1), "globe" === this.projection.name) { const [t, r] = e.polesInViewport(this); t ? (d = 90, u = 180, l = -180) : r && (h = -90, u = 180, l = -180) } return new e.LngLatBounds(new e.LngLat(l, h), new e.LngLat(u, d)) } _getBoundsRectangular(t, r) { const { top: n, left: i } = this._edgeInsets, o = this.height - this._edgeInsets.bottom, s = this.width - this._edgeInsets.right, a = new e.pointGeometry(i, n), c = new e.pointGeometry(s, n), l = new e.pointGeometry(s, o), u = new e.pointGeometry(i, o); let h = this.pointCoordinate(a, t), d = this.pointCoordinate(c, t); const p = this.pointCoordinate(l, r), f = this.pointCoordinate(u, r), m = (e, t) => (t.y - e.y) / (t.x - e.x); return h.y > 1 && d.y >= 0 ? h = new e.MercatorCoordinate((1 - f.y) / m(f, h) + f.x, 1) : h.y < 0 && d.y <= 1 && (h = new e.MercatorCoordinate(-f.y / m(f, h) + f.x, 0)), d.y > 1 && h.y >= 0 ? d = new e.MercatorCoordinate((1 - p.y) / m(p, d) + p.x, 1) : d.y < 0 && h.y <= 1 && (d = new e.MercatorCoordinate(-p.y / m(p, d) + p.x, 0)), (new e.LngLatBounds).extend(this.coordinateLocation(h)).extend(this.coordinateLocation(d)).extend(this.coordinateLocation(f)).extend(this.coordinateLocation(p)) } _getBoundsRectangularTerrain() { const e = this.elevation; if (!e.visibleDemTiles.length || e.isUsingMockSource()) return this._getBoundsRectangular(0, 0); const t = e.visibleDemTiles.reduce(((e, t) => { if (t.dem) { const r = t.dem.tree; e.min = Math.min(e.min, r.minimums[0]), e.max = Math.max(e.max, r.maximums[0]) } return e }), { min: Number.MAX_VALUE, max: 0 }); return this._getBoundsRectangular(t.min * e.exaggeration(), t.max * e.exaggeration()) } getBounds() { return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular() } horizonLineFromTop(e = !0) { const t = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) + this.centerOffset.y, r = this.height / 2 - t * (1 - this._horizonShift); return e ? Math.max(0, r) : r } getMaxBounds() { return this.maxBounds } setMaxBounds(t) { this.maxBounds = t, this.minLat = -e.MAX_MERCATOR_LATITUDE, this.maxLat = e.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, t && (this.minLat = t.getSouth(), this.maxLat = t.getNorth(), this.minLng = t.getWest(), this.maxLng = t.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = e.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = e.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = e.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain() } calculatePosMatrix(e, t) { return this.projection.createTileMatrix(this, t, e) } calculateDistanceTileData(t) { const r = t.key, n = this._distanceTileDataCache; if (n[r]) return n[r]; const i = t.canonical, o = 1 / this.height, s = this.cameraWorldSize, a = s / this.zoomScale(i.z), c = (i.x + Math.pow(2, i.z) * t.wrap) * a, l = i.y * a, u = this.point; u.x *= s / this.worldSize, u.y *= s / this.worldSize; const h = this.angle, d = Math.sin(-h), p = -Math.cos(-h); return n[r] = { bearing: [d, p], center: [(u.x - c) * o, (u.y - l) * o], scale: a / e.EXTENT * o }, n[r] } calculateFogTileMatrix(t) { const r = t.key, n = this._fogTileMatrixCache; if (n[r]) return n[r]; const i = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t); return e.multiply(i, this.worldToFogMatrix, i), n[r] = new Float32Array(i), n[r] } calculateProjMatrix(t, r = !1) { const n = t.key, i = r ? this._alignedProjMatrixCache : this._projMatrixCache; if (i[n]) return i[n]; const o = this.calculatePosMatrix(t, this.worldSize); return e.multiply(o, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : r ? this.alignedProjMatrix : this.projMatrix, o), i[n] = new Float32Array(o), i[n] } calculatePixelsToTileUnitsMatrix(t) { const r = t.tileID.key, n = this._pixelsToTileUnitsCache; if (n[r]) return n[r]; const i = function (t, r) { const { scale: n } = t.tileTransform, i = n * e.EXTENT / (t.tileSize * Math.pow(2, r.zoom - t.tileID.overscaledZ + t.tileID.canonical.z)); return o = new Float32Array(4), c = (s = r.inverseAdjustmentMatrix)[1], l = s[2], u = s[3], d = (a = [i, i])[1], o[0] = s[0] * (h = a[0]), o[1] = c * h, o[2] = l * d, o[3] = u * d, o; var o, s, a, c, l, u, h, d }(t, this); return n[r] = i, n[r] } customLayerMatrix() { return this.mercatorMatrix.slice() } globeToMercatorMatrix() { if ("globe" === this.projection.name) { const t = 1 / this.worldSize, r = e.fromScaling([], [t, t, t]); return e.multiply(r, r, this.globeMatrix), r } } recenterOnTerrain() { if (!this._elevation || "globe" === this.projection.name) return; const t = this._elevation; this._updateCameraState(); const r = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, n = this._computeCameraPosition(r), i = this._camera.forward(), o = e.mercatorZfromAltitude(1, this._center.lat); n[2] /= o, i[2] /= o, e.normalize(i, i); const s = t.raycast(n, i, t.exaggeration()); if (s) { const t = e.scaleAndAdd([], n, i, s), r = new e.MercatorCoordinate(t[0], t[1], e.mercatorZfromAltitude(t[2], e.latFromMercatorY(t[1]))), a = (r.z + e.length([r.x - n[0], r.y - n[1], r.z - n[2] * o])) * this._pixelsPerMercatorPixel; this._seaLevelZoom = this._zoomFromMercatorZ(a), this._centerAltitude = r.toAltitude(), this._center = this.coordinateLocation(r), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices() } } _constrainCamera(t = !1) { if (!this._elevation) return; const r = this._elevation, n = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize, i = this._computeCameraPosition(n), o = r.getAtPointOrZero(new e.MercatorCoordinate(...i)), s = this.pixelsPerMeter / this.worldSize * o, a = this._minimumHeightOverTerrain(), c = i[2] - s; if (c <= a) if (c < 0 || t) { const t = this.locationCoordinate(this._center, this._centerAltitude), r = [i[0], i[1], t.z - i[2]], n = e.length(r); r[2] -= (a - c) / this._pixelsPerMercatorPixel; const o = e.length(r); if (0 === o) return; e.scale$2(r, r, n / o * this._pixelsPerMercatorPixel), this._camera.position = [i[0], i[1], t.z * this._pixelsPerMercatorPixel - r[2]], this._updateStateFromCamera() } else this._isCameraConstrained = !0 } _constrain() { if (!this.center || !this.width || !this.height || this._constraining) return; this._constraining = !0; const t = "globe" === this.projection.name || this.mercatorFromTransition; if (this.projection.isReprojectedInTileSpace || t) { const r = this.center; return r.lat = e.clamp(r.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t) && (r.lng = e.clamp(r.lng, this.minLng, this.maxLng)), this.center = r, void (this._constraining = !1) } const r = this._unmodified, { x: n, y: i } = this.point; let o = 0, s = n, a = i; const c = this.width / 2, l = this.height / 2, u = this.worldMinY * this.scale, h = this.worldMaxY * this.scale; if (i - l < u && (a = u + l), i + l > h && (a = h - l), h - u < this.height && (o = Math.max(o, this.height / (h - u)), a = (h + u) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) { const e = this.worldMinX * this.scale, t = this.worldMaxX * this.scale, r = this.worldSize / 2 - (e + t) / 2; s = (n + r + this.worldSize) % this.worldSize - r, s - c < e && (s = e + c), s + c > t && (s = t - c), t - e < this.width && (o = Math.max(o, this.width / (t - e)), s = (t + e) / 2) } s === n && a === i || (this.center = this.unproject(new e.pointGeometry(s, a))), o && (this.zoom += this.scaleZoom(o)), this._constrainCamera(), this._unmodified = r, this._constraining = !1 } _minZoomForBounds() { let e = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY))); return this.maxBounds && (e = Math.max(e, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e } _maxCameraBoundsDistance() { return this._mercatorZfromZoom(this._minZoomForBounds()) } _calcMatrices() { if (!this.height) return; const t = this.centerOffset, r = this.pixelsPerMeter; "globe" === this.projection.name && (this._mercatorScaleRatio = e.mercatorZfromAltitude(1, this.center.lat) / e.mercatorZfromAltitude(1, e.GLOBE_SCALE_MATCH_LATITUDE)); const n = ei(this.projection, this.zoom, this.width, this.height, 1024); this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, n), this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50; const i = "meters" === this.projection.zAxisUnit ? r : 1, o = this._camera.getWorldToCamera(this.worldSize, i), s = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ); s[8] = 2 * -t.x / this.width, s[9] = 2 * t.y / this.height; let a = e.mul([], s, o); if (this.projection.isReprojectedInTileSpace) { const t = this.locationCoordinate(this.center), r = e.identity([]); e.translate(r, r, [t.x * this.worldSize, t.y * this.worldSize, 0]), e.multiply(r, r, Kn(this)), e.translate(r, r, [-t.x * this.worldSize, -t.y * this.worldSize, 0]), e.multiply(a, a, r), this.inverseAdjustmentMatrix = function (e) { const t = Kn(e, !0); return y([], [t[0], t[1], t[4], t[5]]) }(this) } else this.inverseAdjustmentMatrix = [1, 0, 0, 1]; this.mercatorMatrix = e.scale([], a, [this.worldSize, this.worldSize, this.worldSize / i, 1]), this.projMatrix = a, this.invProjMatrix = e.invert(new Float64Array(16), this.projMatrix); const c = e.invert([], s); this.frustumCorners = e.FrustumCorners.fromInvProjectionMatrix(c, this.horizonLineFromTop(), this.height); const l = new Float32Array(16); e.identity(l), e.scale(l, l, [1, -1, 1]), e.rotateX(l, l, this._pitch), e.rotateZ(l, l, this.angle); const u = e.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ), h = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift; u[8] = 2 * -t.x / this.width, u[9] = 2 * (t.y + h) / this.height, this.skyboxMatrix = e.multiply(l, u, l); const d = this.point, p = d.x, f = d.y, m = this.width % 2 / 2, g = this.height % 2 / 2, _ = Math.cos(this.angle), v = Math.sin(this.angle), x = p - Math.round(p) + _ * m + v * g, b = f - Math.round(f) + _ * g + v * m, w = new Float64Array(a); if (e.translate(w, w, [x > .5 ? x - 1 : x, b > .5 ? b - 1 : b, 0]), this.alignedProjMatrix = w, a = e.create(), e.scale(a, a, [this.width / 2, -this.height / 2, 1]), e.translate(a, a, [1, -1, 0]), this.labelPlaneMatrix = a, a = e.create(), e.scale(a, a, [1, -1, 1]), e.translate(a, a, [-1, -1, 0]), e.scale(a, a, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a, this.pixelMatrix = e.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, a = e.invert(new Float64Array(16), this.pixelMatrix), !a) throw new Error("failed to invert matrix"); if (this.pixelMatrixInverse = a, "globe" === this.projection.name || this.mercatorFromTransition) { this.globeMatrix = e.calculateGlobeMatrix(this); const t = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]]; this.globeCenterInViewSpace = e.transformMat4(t, t, o), this.globeRadius = this.worldSize / 2 / Math.PI - 1 } else this.globeMatrix = a; this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {} } _calcFogMatrices() { this._fogTileMatrixCache = {}; const t = this.cameraWorldSizeForFog, r = this.cameraPixelsPerMeter, n = this._camera.position, i = 1 / this.height / this._pixelsPerMercatorPixel, o = [t, t, r]; e.scale$2(o, o, i), e.scale$2(n, n, -1), e.multiply$2(n, n, o); const s = e.create(); e.translate(s, s, n), e.scale(s, s, o), this.mercatorFogMatrix = s, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t, r, i) } _computeCameraPosition(e) { const t = (e = e || this.pixelsPerMeter) / this.pixelsPerMeter, r = this._camera.forward(), n = this.point, i = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t - e / this.worldSize * this._centerAltitude; return [n.x / this.worldSize - r[0] * i, n.y / this.worldSize - r[1] * i, e / this.worldSize * this._centerAltitude - r[2] * i] } _updateCameraState() { this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition()) } _translateCameraConstrained(t) { const r = this._maxCameraBoundsDistance() * Math.cos(this._pitch), n = this._camera.position[2], i = t[2]; let o = 1; this.projection.wrap && (this.center = this.center.wrap()), i > 0 && (o = Math.min((r - n) / i, 1)), this._camera.position = e.scaleAndAdd([], this._camera.position, t, o), this._updateStateFromCamera() } _updateStateFromCamera() { const t = this._camera.position, r = this._camera.forward(), { pitch: n, bearing: i } = this._camera.getPitchBearing(), o = e.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, s = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.degToRad(this._maxPitch)), a = Math.max((t[2] - o) / Math.cos(n), s), c = this._zoomFromMercatorZ(a); e.scaleAndAdd(t, t, r, a), this._pitch = e.clamp(n, e.degToRad(this.minPitch), e.degToRad(this.maxPitch)), this.angle = e.wrap(i, -Math.PI, Math.PI), this._setZoom(e.clamp(c, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.MercatorCoordinate(t[0], t[1], t[2])), this._unmodified = !1, this._constrain(), this._calcMatrices() } _worldSizeFromZoom(e) { return Math.pow(2, e) * this.tileSize } _mercatorZfromZoom(e) { return this.cameraToCenterDistance / this._worldSizeFromZoom(e) } _minimumHeightOverTerrain() { const e = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom); return this._mercatorZfromZoom(e) } _zoomFromMercatorZ(e) { return this.scaleZoom(this.cameraToCenterDistance / (e * this.tileSize)) } zoomFromMercatorZAdjusted(t) { let r = 0, n = e.GLOBE_ZOOM_THRESHOLD_MAX, i = 0, o = 1 / 0; for (; n - r > 1e-6 && n > r;) { const e = r + .5 * (n - r), s = this.tileSize * Math.pow(2, e), a = this.getCameraToCenterDistance(this.projection, e, s), c = this.scaleZoom(a / (t * this.tileSize)), l = Math.abs(e - c); l < o && (o = l, i = e), e < c ? r = e : n = e } return i } _terrainEnabled() { return !(!this._elevation || !this.projection.supportsTerrain && (e.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1)) } anyCornerOffEdge(t, r) { const n = Math.min(t.x, r.x), i = Math.max(t.x, r.x), o = Math.min(t.y, r.y), s = Math.max(t.y, r.y); if (o < this.horizonLineFromTop(!1)) return !0; if ("mercator" !== this.projection.name) return !1; const a = [new e.pointGeometry(n, o), new e.pointGeometry(i, s), new e.pointGeometry(n, s), new e.pointGeometry(i, o)], c = this.renderWorldCopies ? -3 : 0, l = this.renderWorldCopies ? 4 : 1; for (const e of a) { const t = this.pointRayIntersection(e); if (t.t < 0) return !0; const r = this.rayIntersectionCoordinate(t); if (r.x < c || r.y < 0 || r.x > l || r.y > 1) return !0 } return !1 } isHorizonVisible() { return this.pitch + e.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.pointGeometry(0, 0), new e.pointGeometry(this.width, this.height)) } zoomDeltaToMovement(t, r) { const n = e.length(e.sub([], this._camera.position, t)), i = this._zoomFromMercatorZ(n) + r; return n - this._mercatorZfromZoom(i) } getCameraPoint() { if ("globe" === this.projection.name) { const t = function ([t, r, n], i) { const o = [t, r, n, 1]; e.transformMat4$1(o, o, i); const s = o[3] = Math.max(o[3], 1e-6); return o[0] /= s, o[1] /= s, o[2] /= s, o }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix); return new e.pointGeometry(t[0], t[1]) } { const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1); return this.centerPoint.add(new e.pointGeometry(0, t)) } } getCameraToCenterDistance(e, t = this.zoom, r = this.worldSize) { const n = ei(e, t, this.width, this.height, 1024), i = e.pixelSpaceConversion(this.center.lat, r, n); return .5 / Math.tan(.5 * this._fov) * this.height * i } getWorldToCameraMatrix() { const t = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1); return "globe" === this.projection.name && e.multiply(t, t, this.globeMatrix), t } } function oi(e, t) { let r = !1, n = null; const i = () => { n = null, r && (e(), n = setTimeout(i, t), r = !1) }; return () => (r = !0, n || i(), n) } class si { constructor(t) { this._hashName = t && encodeURIComponent(t), e.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = oi(this._updateHashUnthrottled.bind(this), 300) } addTo(t) { return this._map = t, e.window.addEventListener("hashchange", this._onHashChange, !1), t.on("moveend", this._updateHash), this } remove() { return this._map ? (this._map.off("moveend", this._updateHash), e.window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this } getHashString() { const t = this._map; if (!t) return ""; const r = ai(t); if (this._hashName) { const t = this._hashName; let n = !1; const i = e.window.location.hash.slice(1).split("&").map((e => { const i = e.split("=")[0]; return i === t ? (n = !0, `${i}=${r}`) : e })).filter((e => e)); return n || i.push(`${t}=${r}`), `#${i.join("&")}` } return `#${r}` } _getCurrentHash() { const t = e.window.location.hash.replace("#", ""); if (this._hashName) { let e; return t.split("&").map((e => e.split("="))).forEach((t => { t[0] === this._hashName && (e = t) })), (e && e[1] || "").split("/") } return t.split("/") } _onHashChange() { const e = this._map; if (!e) return !1; const t = this._getCurrentHash(); if (t.length >= 3 && !t.some((e => isNaN(e)))) { const r = e.dragRotate.isEnabled() && e.touchZoomRotate.isEnabled() ? +(t[3] || 0) : e.getBearing(); return e.jumpTo({ center: [+t[2], +t[1]], zoom: +t[0], bearing: r, pitch: +(t[4] || 0) }), !0 } return !1 } _updateHashUnthrottled() { const t = e.window.location.href.replace(/(#.+)?$/, this.getHashString()); e.window.history.replaceState(e.window.history.state, null, t) } } function ai(e, t) { const r = e.getCenter(), n = Math.round(100 * e.getZoom()) / 100, i = Math.ceil((n * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), o = Math.pow(10, i), s = Math.round(r.lng * o) / o, a = Math.round(r.lat * o) / o, c = e.getBearing(), l = e.getPitch(); let u = t ? `/${s}/${a}/${n}` : `${n}/${a}/${s}`; return (c || l) && (u += "/" + Math.round(10 * c) / 10), l && (u += `/${Math.round(l)}`), u } const ci = { linearity: .3, easing: e.bezier(0, 0, .3, 1) }, li = e.extend({ deceleration: 2500, maxSpeed: 1400 }, ci), ui = e.extend({ deceleration: 20, maxSpeed: 1400 }, ci), hi = e.extend({ deceleration: 1e3, maxSpeed: 360 }, ci), di = e.extend({ deceleration: 1e3, maxSpeed: 90 }, ci); class pi { constructor(e) { this._map = e, this.clear() } clear() { this._inertiaBuffer = [] } record(t) { this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e.exported.now(), settings: t }) } _drainInertiaBuffer() { const t = this._inertiaBuffer, r = e.exported.now(); for (; t.length > 0 && r - t[0].time > 160;)t.shift() } _onMoveEnd(t) { if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return; const r = { zoom: 0, bearing: 0, pitch: 0, pan: new e.pointGeometry(0, 0), pinchAround: void 0, around: void 0 }; for (const { settings: e } of this._inertiaBuffer) r.zoom += e.zoomDelta || 0, r.bearing += e.bearingDelta || 0, r.pitch += e.pitchDelta || 0, e.panDelta && r.pan._add(e.panDelta), e.around && (r.around = e.around), e.pinchAround && (r.pinchAround = e.pinchAround); const n = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, i = {}; if (r.pan.mag()) { const o = mi(r.pan.mag(), n, e.extend({}, li, t || {})); i.offset = r.pan.mult(o.amount / r.pan.mag()), i.center = this._map.transform.center, fi(i, o) } if (r.zoom) { const e = mi(r.zoom, n, ui); i.zoom = this._map.transform.zoom + e.amount, fi(i, e) } if (r.bearing) { const t = mi(r.bearing, n, hi); i.bearing = this._map.transform.bearing + e.clamp(t.amount, -179, 179), fi(i, t) } if (r.pitch) { const e = mi(r.pitch, n, di); i.pitch = this._map.transform.pitch + e.amount, fi(i, e) } if (i.zoom || i.bearing) { const e = void 0 === r.pinchAround ? r.around : r.pinchAround; i.around = e ? this._map.unproject(e) : this._map.getCenter() } return this.clear(), i.noMoveStart = !0, i } } function fi(e, t) { (!e.duration || e.duration < t.duration) && (e.duration = t.duration, e.easing = t.easing) } function mi(t, r, n) { const { maxSpeed: i, linearity: o, deceleration: s } = n, a = e.clamp(t * o / (r / 1e3), -i, i), c = Math.abs(a) / (s * o); return { easing: n.easing, duration: 1e3 * c, amount: a * (c / 2) } } class gi extends e.Event { preventDefault() { this._defaultPrevented = !0 } get defaultPrevented() { return this._defaultPrevented } constructor(t, r, n, i = {}) { const o = f(r.getCanvasContainer(), n), s = r.unproject(o); super(t, e.extend({ point: o, lngLat: s, originalEvent: n }, i)), this._defaultPrevented = !1, this.target = r } } class _i extends e.Event { preventDefault() { this._defaultPrevented = !0 } get defaultPrevented() { return this._defaultPrevented } constructor(t, r, n) { const i = "touchend" === t ? n.changedTouches : n.touches, o = m(r.getCanvasContainer(), i), s = o.map((e => r.unproject(e))), a = o.reduce(((e, t, r, n) => e.add(t.div(n.length))), new e.pointGeometry(0, 0)); super(t, { points: o, point: a, lngLats: s, lngLat: r.unproject(a), originalEvent: n }), this._defaultPrevented = !1 } } class yi extends e.Event { preventDefault() { this._defaultPrevented = !0 } get defaultPrevented() { return this._defaultPrevented } constructor(e, t, r) { super(e, { originalEvent: r }), this._defaultPrevented = !1 } } class vi { constructor(e, t) { this._map = e, this._clickTolerance = t.clickTolerance } reset() { this._mousedownPos = void 0 } wheel(e) { return this._firePreventable(new yi(e.type, this._map, e)) } mousedown(e, t) { return this._mousedownPos = t, this._firePreventable(new gi(e.type, this._map, e)) } mouseup(e) { this._map.fire(new gi(e.type, this._map, e)) } preclick(t) { const r = e.extend({}, t); r.type = "preclick", this._map.fire(new gi(r.type, this._map, r)) } click(e, t) { this._mousedownPos && this._mousedownPos.dist(t) >= this._clickTolerance || (this.preclick(e), this._map.fire(new gi(e.type, this._map, e))) } dblclick(e) { return this._firePreventable(new gi(e.type, this._map, e)) } mouseover(e) { this._map.fire(new gi(e.type, this._map, e)) } mouseout(e) { this._map.fire(new gi(e.type, this._map, e)) } touchstart(e) { return this._firePreventable(new _i(e.type, this._map, e)) } touchmove(e) { this._map.fire(new _i(e.type, this._map, e)) } touchend(e) { this._map.fire(new _i(e.type, this._map, e)) } touchcancel(e) { this._map.fire(new _i(e.type, this._map, e)) } _firePreventable(e) { if (this._map.fire(e), e.defaultPrevented) return {} } isEnabled() { return !0 } isActive() { return !1 } enable() { } disable() { } } class xi { constructor(e) { this._map = e } reset() { this._delayContextMenu = !1, this._contextMenuEvent = void 0 } mousemove(e) { this._map.fire(new gi(e.type, this._map, e)) } mousedown() { this._delayContextMenu = !0 } mouseup() { this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new gi("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent) } contextmenu(e) { this._delayContextMenu ? this._contextMenuEvent = e : this._map.fire(new gi(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault() } isEnabled() { return !0 } isActive() { return !1 } enable() { } disable() { } } class bi { constructor(e, t) { this._map = e, this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t.clickTolerance || 1 } isEnabled() { return !!this._enabled } isActive() { return !!this._active } enable() { this.isEnabled() || (this._enabled = !0) } disable() { this.isEnabled() && (this._enabled = !1) } mousedown(e, t) { this.isEnabled() && e.shiftKey && 0 === e.button && (u(), this._startPos = this._lastPos = t, this._active = !0) } mousemoveWindow(e, t) { if (!this._active) return; const r = t, n = this._startPos, i = this._lastPos; if (!n || !i || i.equals(r) || !this._box && r.dist(n) < this._clickTolerance) return; this._lastPos = r, this._box || (this._box = o("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e)); const s = Math.min(n.x, r.x), a = Math.max(n.x, r.x), c = Math.min(n.y, r.y), l = Math.max(n.y, r.y); this._map._requestDomTask((() => { this._box && (this._box.style.transform = `translate(${s}px,${c}px)`, this._box.style.width = a - s + "px", this._box.style.height = l - c + "px") })) } mouseupWindow(t, r) { if (!this._active) return; const n = this._startPos, i = r; if (n && 0 === t.button) { if (this.reset(), p(), n.x !== i.x || n.y !== i.y) return this._map.fire(new e.Event("boxzoomend", { originalEvent: t })), { cameraAnimation: e => e.fitScreenCoordinates(n, i, this._map.getBearing(), { linear: !1 }) }; this._fireEvent("boxzoomcancel", t) } } keydown(e) { this._active && 27 === e.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e)) } blur() { this.reset() } reset() { this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), h(), delete this._startPos, delete this._lastPos } _fireEvent(t, r) { return this._map.fire(new e.Event(t, { originalEvent: r })) } } function wi(e, t) { const r = {}; for (let n = 0; n < e.length; n++)r[e[n].identifier] = t[n]; return r } class Ti { constructor(e) { this.reset(), this.numTouches = e.numTouches } reset() { this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1 } touchstart(t, r, n) { (this.centroid || n.length > this.numTouches) && (this.aborted = !0), this.aborted || (0 === this.startTime && (this.startTime = t.timeStamp), n.length === this.numTouches && (this.centroid = function (t) { const r = new e.pointGeometry(0, 0); for (const e of t) r._add(e); return r.div(t.length) }(r), this.touches = wi(n, r))) } touchmove(e, t, r) { if (this.aborted || !this.centroid) return; const n = wi(r, t); for (const i in this.touches) { const e = n[i]; (!e || e.dist(this.touches[i]) > 30) && (this.aborted = !0) } } touchend(e, t, r) { if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === r.length) { const e = !this.aborted && this.centroid; if (this.reset(), e) return e } } } class ki { constructor(e) { this.singleTap = new Ti(e), this.numTaps = e.numTaps, this.reset() } reset() { this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset() } touchstart(e, t, r) { this.singleTap.touchstart(e, t, r) } touchmove(e, t, r) { this.singleTap.touchmove(e, t, r) } touchend(e, t, r) { const n = this.singleTap.touchend(e, t, r); if (n) { const t = e.timeStamp - this.lastTime < 500, r = !this.lastTap || this.lastTap.dist(n) < 30; if (t && r || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = n, this.count === this.numTaps) return this.reset(), n } } } class Ci { constructor() { this._zoomIn = new ki({ numTouches: 1, numTaps: 2 }), this._zoomOut = new ki({ numTouches: 2, numTaps: 1 }), this.reset() } reset() { this._active = !1, this._zoomIn.reset(), this._zoomOut.reset() } touchstart(e, t, r) { this._zoomIn.touchstart(e, t, r), this._zoomOut.touchstart(e, t, r) } touchmove(e, t, r) { this._zoomIn.touchmove(e, t, r), this._zoomOut.touchmove(e, t, r) } touchend(e, t, r) { const n = this._zoomIn.touchend(e, t, r), i = this._zoomOut.touchend(e, t, r); return n ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: t => t.easeTo({ duration: 300, zoom: t.getZoom() + 1, around: t.unproject(n) }, { originalEvent: e }) }) : i ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: t => t.easeTo({ duration: 300, zoom: t.getZoom() - 1, around: t.unproject(i) }, { originalEvent: e }) }) : void 0 } touchcancel() { this.reset() } enable() { this._enabled = !0 } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } } const Ei = { 0: 1, 2: 2 }; class Si { constructor(e) { this.reset(), this._clickTolerance = e.clickTolerance || 1 } blur() { this.reset() } reset() { this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0 } _correctButton(e, t) { return !1 } _move(e, t) { return {} } mousedown(e, t) { if (this._lastPoint) return; const r = g(e); this._correctButton(e, r) && (this._lastPoint = t, this._eventButton = r) } mousemoveWindow(e, t) { const r = this._lastPoint; if (r) if (e.preventDefault(), null != this._eventButton && function (e, t) { const r = Ei[t]; return void 0 === e.buttons || (e.buttons & r) !== r }(e, this._eventButton)) this.reset(); else if (this._moved || !(t.dist(r) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t, this._move(r, t) } mouseupWindow(e) { this._lastPoint && g(e) === this._eventButton && (this._moved && p(), this.reset()) } enable() { this._enabled = !0 } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } } class Pi extends Si { mousedown(e, t) { super.mousedown(e, t), this._lastPoint && (this._active = !0) } _correctButton(e, t) { return 0 === t && !e.ctrlKey } _move(e, t) { return { around: t, panDelta: t.sub(e) } } } class Ii extends Si { _correctButton(e, t) { return 0 === t && e.ctrlKey || 2 === t } _move(e, t) { const r = .8 * (t.x - e.x); if (r) return this._active = !0, { bearingDelta: r } } contextmenu(e) { e.preventDefault() } } class Ai extends Si { _correctButton(e, t) { return 0 === t && e.ctrlKey || 2 === t } _move(e, t) { const r = -.5 * (t.y - e.y); if (r) return this._active = !0, { pitchDelta: r } } contextmenu(e) { e.preventDefault() } } class Li { constructor(t, r) { this._map = t, this._el = t.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = r.clickTolerance || 1, this.reset(), e.bindAll(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this) } reset() { this._active = !1, this._touches = {}, this._sum = new e.pointGeometry(0, 0) } touchstart(e, t, r) { return this._calculateTransform(e, t, r) } touchmove(t, r, n) { if (this._active && !(n.length < this._minTouches)) { if (this._map._cooperativeGestures && !this._map.isMoving()) { if (1 === n.length && !e.isFullscreen()) return void this._showTouchPanBlockerAlert(); "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer)) } return t.cancelable && t.preventDefault(), this._calculateTransform(t, r, n) } } touchend(e, t, r) { this._calculateTransform(e, t, r), this._active && r.length < this._minTouches && this.reset() } touchcancel() { this.reset() } _calculateTransform(t, r, n) { n.length > 0 && (this._active = !0); const i = wi(n, r), o = new e.pointGeometry(0, 0), s = new e.pointGeometry(0, 0); let a = 0; for (const e in i) { const t = i[e], r = this._touches[e]; r && (o._add(t), s._add(t.sub(r)), a++, i[e] = t) } if (this._touches = i, a < this._minTouches || !s.mag()) return; const c = s.div(a); return this._sum._add(c), this._sum.mag() < this._clickTolerance ? void 0 : { around: o.div(a), panDelta: c } } enable() { this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")) } disable() { this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset() } isEnabled() { return !!this._enabled } isActive() { return !!this._active } _addTouchPanBlocker() { this._map && !this._alertContainer && (this._alertContainer = o("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`) } _showTouchPanBlockerAlert() { this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout((() => { this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "null") }), 500) } } class Mi { constructor() { this.reset() } reset() { this._active = !1, this._firstTwoTouches = void 0 } _start(e) { } _move(e, t, r) { return {} } touchstart(e, t, r) { this._firstTwoTouches || r.length < 2 || (this._firstTwoTouches = [r[0].identifier, r[1].identifier], this._start([t[0], t[1]])) } touchmove(e, t, r) { const n = this._firstTwoTouches; if (!n) return; e.preventDefault(); const [i, o] = n, s = Bi(r, t, i), a = Bi(r, t, o); if (!s || !a) return; const c = this._aroundCenter ? null : s.add(a).div(2); return this._move([s, a], c, e) } touchend(e, t, r) { if (!this._firstTwoTouches) return; const [n, i] = this._firstTwoTouches, o = Bi(r, t, n), s = Bi(r, t, i); o && s || (this._active && p(), this.reset()) } touchcancel() { this.reset() } enable(e) { this._enabled = !0, this._aroundCenter = !!e && "center" === e.around } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } } function Bi(e, t, r) { for (let n = 0; n < e.length; n++)if (e[n].identifier === r) return t[n] } function Ri(e, t) { return Math.log(e / t) / Math.LN2 } class Di extends Mi { reset() { super.reset(), this._distance = 0, this._startDistance = 0 } _start(e) { this._startDistance = this._distance = e[0].dist(e[1]) } _move(e, t) { const r = this._distance; if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Ri(this._distance, this._startDistance)) < .1)) return this._active = !0, { zoomDelta: Ri(this._distance, r), pinchAround: t } } } function Fi(e, t) { return 180 * e.angleWith(t) / Math.PI } class Oi extends Mi { reset() { super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0 } _start(e) { this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]) } _move(e, t) { const r = this._vector; if (this._vector = e[0].sub(e[1]), r && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, { bearingDelta: Fi(this._vector, r), pinchAround: t } } _isBelowThreshold(e) { this._minDiameter = Math.min(this._minDiameter, e.mag()); const t = 25 / (Math.PI * this._minDiameter) * 360, r = this._startVector; if (!r) return !1; const n = Fi(e, r); return Math.abs(n) < t } } function zi(e) { return Math.abs(e.y) > Math.abs(e.x) } class Ui extends Mi { constructor(e) { super(), this._map = e } reset() { super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0 } _start(e) { this._lastPoints = e, zi(e[0].sub(e[1])) && (this._valid = !1) } _move(t, r, n) { const i = this._lastPoints; if (!i) return; const o = t[0].sub(i[0]), s = t[1].sub(i[1]); return this._map._cooperativeGestures && !e.isFullscreen() && n.touches.length < 3 || (this._valid = this.gestureBeginsVertically(o, s, n.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t, this._active = !0, { pitchDelta: (o.y + s.y) / 2 * -.5 }) } gestureBeginsVertically(e, t, r) { if (void 0 !== this._valid) return this._valid; const n = e.mag() >= 2, i = t.mag() >= 2; if (!n && !i) return; if (!n || !i) return null == this._firstMove && (this._firstMove = r), r - this._firstMove < 100 && void 0; const o = e.y > 0 == t.y > 0; return zi(e) && zi(t) && o } } const Ni = { panStep: 100, bearingStep: 15, pitchStep: 10 }; class Gi { constructor() { const e = Ni; this._panStep = e.panStep, this._bearingStep = e.bearingStep, this._pitchStep = e.pitchStep, this._rotationDisabled = !1 } blur() { this.reset() } reset() { this._active = !1 } keydown(e) { if (e.altKey || e.ctrlKey || e.metaKey) return; let t = 0, r = 0, n = 0, i = 0, o = 0; switch (e.keyCode) { case 61: case 107: case 171: case 187: t = 1; break; case 189: case 109: case 173: t = -1; break; case 37: e.shiftKey ? r = -1 : (e.preventDefault(), i = -1); break; case 39: e.shiftKey ? r = 1 : (e.preventDefault(), i = 1); break; case 38: e.shiftKey ? n = 1 : (e.preventDefault(), o = -1); break; case 40: e.shiftKey ? n = -1 : (e.preventDefault(), o = 1); break; default: return }return this._rotationDisabled && (r = 0, n = 0), { cameraAnimation: s => { const a = s.getZoom(); s.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Vi, zoom: t ? Math.round(a) + t * (e.shiftKey ? 2 : 1) : a, bearing: s.getBearing() + r * this._bearingStep, pitch: s.getPitch() + n * this._pitchStep, offset: [-i * this._panStep, -o * this._panStep], center: s.getCenter() }, { originalEvent: e }) } } } enable() { this._enabled = !0 } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } disableRotation() { this._rotationDisabled = !0 } enableRotation() { this._rotationDisabled = !1 } } function Vi(e) { return e * (2 - e) } const qi = 4.000244140625; class ji { constructor(t, r) { this._map = t, this._el = t.getCanvasContainer(), this._handler = r, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = .0022222222222222222, e.bindAll(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this) } setZoomRate(e) { this._defaultZoomRate = e } setWheelZoomRate(e) { this._wheelZoomRate = e } isEnabled() { return !!this._enabled } isActive() { return this._active || void 0 !== this._finishTimeout } isZooming() { return !!this._zooming } enable(e) { this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && "center" === e.around, this._map._cooperativeGestures && this._addScrollZoomBlocker()) } disable() { this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove())) } wheel(t) { if (!this.isEnabled()) return; if (this._map._cooperativeGestures) { if (!(t.ctrlKey || t.metaKey || this.isZooming() || e.isFullscreen())) return void this._showBlockerAlert(); "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer)) } let r = t.deltaMode === e.window.WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY; const n = e.exported.now(), i = n - (this._lastWheelEventTime || 0); this._lastWheelEventTime = n, 0 !== r && r % qi == 0 ? this._type = "wheel" : 0 !== r && Math.abs(r) < 4 ? this._type = "trackpad" : i > 400 ? (this._type = null, this._lastValue = r, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(i * r) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, r += this._lastValue)), t.shiftKey && r && (r /= 4), this._type && (this._lastWheelEvent = t, this._delta -= r, this._active || this._start(t)), t.preventDefault() } _onTimeout(e) { this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e) } _start(e) { if (!this._delta) return; this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout); const t = f(this._el, e); this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame()) } renderFrame() { if (!this._frameId) return; if (this._frameId = null, !this.isActive()) return; const t = this._map.transform; "wheel" === this._type && t.projection.wrap && (t._center.lng >= 180 || t._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0); const r = () => t._terrainEnabled() && this._aroundCoord ? t.computeZoomRelativeTo(this._aroundCoord) : t.zoom; if (0 !== this._delta) { const e = "wheel" === this._type && Math.abs(this._delta) > qi ? this._wheelZoomRate : this._defaultZoomRate; let n = 2 / (1 + Math.exp(-Math.abs(this._delta * e))); this._delta < 0 && 0 !== n && (n = 1 / n); const i = r(), o = Math.pow(2, i), s = "number" == typeof this._targetZoom ? t.zoomScale(this._targetZoom) : o; this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(s * n))), "wheel" === this._type && (this._startZoom = i, this._easing = this._smoothOutEasing(200)), this._delta = 0 } const n = "number" == typeof this._targetZoom ? this._targetZoom : r(), i = this._startZoom, o = this._easing; let s, a = !1; if ("wheel" === this._type && i && o) { const t = Math.min((e.exported.now() - this._lastWheelEventTime) / 200, 1), r = o(t); s = e.number(i, n, r), t < 1 ? this._frameId || (this._frameId = !0) : a = !0 } else s = n, a = !0; return this._active = !0, a && (this._active = !1, this._finishTimeout = setTimeout((() => { this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout }), 200)), { noInertia: !0, needsRenderFrame: !a, zoomDelta: s - r(), around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent } } _smoothOutEasing(t) { let r = e.ease; if (this._prevEase) { const t = this._prevEase, n = (e.exported.now() - t.start) / t.duration, i = t.easing(n + .01) - t.easing(n), o = .27 / Math.sqrt(i * i + 1e-4) * .01, s = Math.sqrt(.0729 - o * o); r = e.bezier(o, s, .25, 1) } return this._prevEase = { start: e.exported.now(), duration: t, easing: r }, r } blur() { this.reset() } reset() { this._active = !1 } _addScrollZoomBlocker() { this._map && !this._alertContainer && (this._alertContainer = o("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`) } _showBlockerAlert() { this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout((() => { this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "null") }), 200) } } class Xi { constructor(e, t) { this._clickZoom = e, this._tapZoom = t } enable() { this._clickZoom.enable(), this._tapZoom.enable() } disable() { this._clickZoom.disable(), this._tapZoom.disable() } isEnabled() { return this._clickZoom.isEnabled() && this._tapZoom.isEnabled() } isActive() { return this._clickZoom.isActive() || this._tapZoom.isActive() } } class Wi { constructor() { this.reset() } reset() { this._active = !1 } blur() { this.reset() } dblclick(e, t) { return e.preventDefault(), { cameraAnimation: r => { r.easeTo({ duration: 300, zoom: r.getZoom() + (e.shiftKey ? -1 : 1), around: r.unproject(t) }, { originalEvent: e }) } } } enable() { this._enabled = !0 } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } } class Zi { constructor() { this._tap = new ki({ numTouches: 1, numTaps: 1 }), this.reset() } reset() { this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset() } touchstart(e, t, r) { this._swipePoint || (this._tapTime && e.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? r.length > 0 && (this._swipePoint = t[0], this._swipeTouch = r[0].identifier) : this._tap.touchstart(e, t, r)) } touchmove(e, t, r) { if (this._tapTime) { if (this._swipePoint) { if (r[0].identifier !== this._swipeTouch) return; const n = t[0], i = n.y - this._swipePoint.y; return this._swipePoint = n, e.preventDefault(), this._active = !0, { zoomDelta: i / 128 } } } else this._tap.touchmove(e, t, r) } touchend(e, t, r) { this._tapTime ? this._swipePoint && 0 === r.length && this.reset() : this._tap.touchend(e, t, r) && (this._tapTime = e.timeStamp) } touchcancel() { this.reset() } enable() { this._enabled = !0 } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } } class Hi { constructor(e, t, r) { this._el = e, this._mousePan = t, this._touchPan = r } enable(e) { this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan") } disable() { this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan") } isEnabled() { return this._mousePan.isEnabled() && this._touchPan.isEnabled() } isActive() { return this._mousePan.isActive() || this._touchPan.isActive() } } class Qi { constructor(e, t, r) { this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t, this._mousePitch = r } enable() { this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable() } disable() { this._mouseRotate.disable(), this._mousePitch.disable() } isEnabled() { return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) } isActive() { return this._mouseRotate.isActive() || this._mousePitch.isActive() } } class $i { constructor(e, t, r, n) { this._el = e, this._touchZoom = t, this._touchRotate = r, this._tapDragZoom = n, this._rotationDisabled = !1, this._enabled = !0 } enable(e) { this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate") } disable() { this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate") } isEnabled() { return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled() } isActive() { return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive() } disableRotation() { this._rotationDisabled = !0, this._touchRotate.disable() } enableRotation() { this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable() } } const Ji = e => e.zoom || e.drag || e.pitch || e.rotate; class Ki extends e.Event { } class Yi { constructor() { this.constants = [1, 1, .01], this.radius = 0 } setup(t, r) { const n = e.sub([], r, t); this.radius = e.length(n[2] < 0 ? e.div([], n, this.constants) : [n[0], n[1], 0]) } projectRay(t) { e.div(t, t, this.constants), e.normalize(t, t), e.mul$1(t, t, this.constants); const r = e.scale$2([], t, this.radius); if (r[2] > 0) { const t = e.scale$2([], [0, 0, 1], e.dot(r, [0, 0, 1])), n = e.scale$2([], e.normalize([], [r[0], r[1], 0]), this.radius), i = e.add([], r, e.scale$2([], e.sub([], e.add([], n, t), r), 2)); r[0] = i[0], r[1] = i[1] } return r } } function eo(e) { return e.panDelta && e.panDelta.mag() || e.zoomDelta || e.bearingDelta || e.pitchDelta } class to { constructor(t, r) { this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new pi(t), this._bearingSnap = r.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Yi, this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(r), e.bindAll(["handleEvent", "handleWindowEvent"], this); const n = this._el; this._listeners = [[n, "touchstart", { passive: !0 }], [n, "touchmove", { passive: !1 }], [n, "touchend", void 0], [n, "touchcancel", void 0], [n, "mousedown", void 0], [n, "mousemove", void 0], [n, "mouseup", void 0], [e.window.document, "mousemove", { capture: !0 }], [e.window.document, "mouseup", void 0], [n, "mouseover", void 0], [n, "mouseout", void 0], [n, "dblclick", void 0], [n, "click", void 0], [n, "keydown", { capture: !1 }], [n, "keyup", void 0], [n, "wheel", { passive: !1 }], [n, "contextmenu", void 0], [e.window, "blur", void 0]]; for (const [i, o, s] of this._listeners) i.addEventListener(o, i === e.window.document ? this.handleWindowEvent : this.handleEvent, s) } destroy() { for (const [t, r, n] of this._listeners) t.removeEventListener(r, t === e.window.document ? this.handleWindowEvent : this.handleEvent, n) } _addDefaultHandlers(e) { const t = this._map, r = t.getCanvasContainer(); this._add("mapEvent", new vi(t, e)); const n = t.boxZoom = new bi(t, e); this._add("boxZoom", n); const i = new Ci, o = new Wi; t.doubleClickZoom = new Xi(o, i), this._add("tapZoom", i), this._add("clickZoom", o); const s = new Zi; this._add("tapDragZoom", s); const a = t.touchPitch = new Ui(t); this._add("touchPitch", a); const c = new Ii(e), l = new Ai(e); t.dragRotate = new Qi(e, c, l), this._add("mouseRotate", c, ["mousePitch"]), this._add("mousePitch", l, ["mouseRotate"]); const u = new Pi(e), h = new Li(t, e); t.dragPan = new Hi(r, u, h), this._add("mousePan", u), this._add("touchPan", h, ["touchZoom", "touchRotate"]); const d = new Oi, p = new Di; t.touchZoomRotate = new $i(r, p, d, s), this._add("touchRotate", d, ["touchPan", "touchZoom"]), this._add("touchZoom", p, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new xi(t)); const f = t.scrollZoom = new ji(t, this); this._add("scrollZoom", f, ["mousePan"]); const m = t.keyboard = new Gi; this._add("keyboard", m); for (const g of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]) e.interactive && e[g] && t[g].enable(e[g]) } _add(e, t, r) { this._handlers.push({ handlerName: e, handler: t, allowed: r }), this._handlersById[e] = t } stop(e) { if (!this._updatingCamera) { for (const { handler: e } of this._handlers) e.reset(); this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [] } } isActive() { for (const { handler: e } of this._handlers) if (e.isActive()) return !0; return !1 } isZooming() { return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming() } isRotating() { return !!this._eventsInProgress.rotate } isMoving() { return !!Ji(this._eventsInProgress) || this.isZooming() } _isDragging() { return !!this._eventsInProgress.drag } _blockedByActive(e, t, r) { for (const n in e) if (n !== r && (!t || t.indexOf(n) < 0)) return !0; return !1 } handleWindowEvent(e) { this.handleEvent(e, `${e.type}Window`) } _getMapTouches(e) { const t = []; for (const r of e) this._el.contains(r.target) && t.push(r); return t } handleEvent(e, t) { this._updatingCamera = !0; const r = "renderFrame" === e.type, n = r ? void 0 : e, i = { needsRenderFrame: !1 }, o = {}, s = {}, a = e.touches ? this._getMapTouches(e.touches) : void 0, c = a ? m(this._el, a) : r ? void 0 : f(this._el, e); for (const { handlerName: h, handler: d, allowed: p } of this._handlers) { if (!d.isEnabled()) continue; let r; this._blockedByActive(s, p, h) ? d.reset() : d[t || e.type] && (r = d[t || e.type](e, c, a), this.mergeHandlerResult(i, o, r, h, n), r && r.needsRenderFrame && this._triggerRenderFrame()), (r || d.isActive()) && (s[h] = d) } const l = {}; for (const h in this._previousActiveHandlers) s[h] || (l[h] = n); this._previousActiveHandlers = s, (Object.keys(l).length || eo(i)) && (this._changes.push([i, o, l]), this._triggerRenderFrame()), (Object.keys(s).length || eo(i)) && this._map._stop(!0), this._updatingCamera = !1; const { cameraAnimation: u } = i; u && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], u(this._map)) } mergeHandlerResult(t, r, n, i, o) { if (!n) return; e.extend(t, n); const s = { handlerName: i, originalEvent: n.originalEvent || o }; void 0 !== n.zoomDelta && (r.zoom = s), void 0 !== n.panDelta && (r.drag = s), void 0 !== n.pitchDelta && (r.pitch = s), void 0 !== n.bearingDelta && (r.rotate = s) } _applyChanges() { const t = {}, r = {}, n = {}; for (const [i, o, s] of this._changes) i.panDelta && (t.panDelta = (t.panDelta || new e.pointGeometry(0, 0))._add(i.panDelta)), i.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + i.zoomDelta), i.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + i.bearingDelta), i.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + i.pitchDelta), void 0 !== i.around && (t.around = i.around), void 0 !== i.aroundCoord && (t.aroundCoord = i.aroundCoord), void 0 !== i.pinchAround && (t.pinchAround = i.pinchAround), i.noInertia && (t.noInertia = i.noInertia), e.extend(r, o), e.extend(n, s); this._updateMapTransform(t, r, n), this._changes = [] } _updateMapTransform(t, r, n) { const i = this._map, o = i.transform, s = e => [e.x, e.y, e.z]; if ((e => { const t = this._eventsInProgress.drag; return t && !this._handlersById[t.handlerName].isActive() })() && !eo(t)) { const e = o.zoom; o.cameraElevationReference = "sea", o.recenterOnTerrain(), o.cameraElevationReference = "ground", e !== o.zoom && this._map._update(!0) } if (o._isCameraConstrained && i._stop(!0), !eo(t)) return void this._fireEvents(r, n, !0); let { panDelta: a, zoomDelta: c, bearingDelta: l, pitchDelta: u, around: h, aroundCoord: d, pinchAround: p } = t; o._isCameraConstrained && (c > 0 && (c = 0), o._isCameraConstrained = !1), void 0 !== p && (h = p), (c || (e => r[e] && !this._eventsInProgress[e])("drag")) && h && (this._dragOrigin = s(o.pointCoordinate3D(h)), this._trackingEllipsoid.setup(o._camera.position, this._dragOrigin)), o.cameraElevationReference = "sea", i._stop(!0), h = h || i.transform.centerPoint, l && (o.bearing += l), u && (o.pitch += u), o._updateCameraState(); const f = [0, 0, 0]; if (a) if ("mercator" === o.projection.name) { const e = this._trackingEllipsoid.projectRay(o.screenPointToMercatorRay(h).dir), t = this._trackingEllipsoid.projectRay(o.screenPointToMercatorRay(h.sub(a)).dir); f[0] = t[0] - e[0], f[1] = t[1] - e[1] } else { const t = o.pointCoordinate(h); if ("globe" === o.projection.name) { a = a.rotate(-o.angle); const r = o._pixelsPerMercatorPixel / o.worldSize; f[0] = -a.x * e.mercatorScale(e.latFromMercatorY(t.y)) * r, f[1] = -a.y * e.mercatorScale(o.center.lat) * r } else { const e = o.pointCoordinate(h.sub(a)); t && e && (f[0] = e.x - t.x, f[1] = e.y - t.y) } } const m = o.zoom, g = [0, 0, 0]; if (c) { const t = s(d || o.pointCoordinate3D(h)), r = { dir: e.normalize([], e.sub([], t, o._camera.position)) }; if (r.dir[2] < 0) { const n = o.zoomDeltaToMovement(t, c); e.scale$2(g, r.dir, n) } } const _ = e.add(f, f, g); o._translateCameraConstrained(_), c && Math.abs(o.zoom - m) > 1e-4 && o.recenterOnTerrain(), o.cameraElevationReference = "ground", this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(r, n, !0) } _fireEvents(t, r, n) { const i = Ji(this._eventsInProgress), o = Ji(t), s = {}; for (const e in t) { const { originalEvent: r } = t[e]; this._eventsInProgress[e] || (s[`${e}start`] = r), this._eventsInProgress[e] = t[e] } !i && o && this._fireEvent("movestart", o.originalEvent); for (const e in s) this._fireEvent(e, s[e]); o && this._fireEvent("move", o.originalEvent); for (const e in t) { const { originalEvent: r } = t[e]; this._fireEvent(e, r) } const a = {}; let c; for (const e in this._eventsInProgress) { const { handlerName: t, originalEvent: n } = this._eventsInProgress[e]; this._handlersById[t].isActive() || (delete this._eventsInProgress[e], c = r[t] || n, a[`${e}end`] = c) } for (const e in a) this._fireEvent(e, a[e]); const l = Ji(this._eventsInProgress); if (n && (i || o) && !l) { this._updatingCamera = !0; const t = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), r = e => 0 !== e && -this._bearingSnap < e && e < this._bearingSnap; t ? (r(t.bearing || this._map.getBearing()) && (t.bearing = 0), this._map.easeTo(t, { originalEvent: c })) : (this._map.fire(new e.Event("moveend", { originalEvent: c })), r(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1 } } _fireEvent(t, r) { this._map.fire(new e.Event(t, r ? { originalEvent: r } : {})) } _requestFrame() { return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e => { this._frameId = void 0, this.handleEvent(new Ki("renderFrame", { timeStamp: e })), this._applyChanges() })) } _triggerRenderFrame() { void 0 === this._frameId && (this._frameId = this._requestFrame()) } } const ro = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections."; class no extends e.Evented { constructor(t, r) { super(), this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = r.bearingSnap, e.bindAll(["_renderFrameCallback"], this) } getCenter() { return new e.LngLat(this.transform.center.lng, this.transform.center.lat) } setCenter(e, t) { return this.jumpTo({ center: e }, t) } panBy(t, r, n) { return t = e.pointGeometry.convert(t).mult(-1), this.panTo(this.transform.center, e.extend({ offset: t }, r), n) } panTo(t, r, n) { return this.easeTo(e.extend({ center: t }, r), n) } getZoom() { return this.transform.zoom } setZoom(e, t) { return this.jumpTo({ zoom: e }, t), this } zoomTo(t, r, n) { return this.easeTo(e.extend({ zoom: t }, r), n) } zoomIn(e, t) { return this.zoomTo(this.getZoom() + 1, e, t), this } zoomOut(e, t) { return this.zoomTo(this.getZoom() - 1, e, t), this } getBearing() { return this.transform.bearing } setBearing(e, t) { return this.jumpTo({ bearing: e }, t), this } getPadding() { return this.transform.padding } setPadding(e, t) { return this.jumpTo({ padding: e }, t), this } rotateTo(t, r, n) { return this.easeTo(e.extend({ bearing: t }, r), n) } resetNorth(t, r) { return this.rotateTo(0, e.extend({ duration: 1e3 }, t), r), this } resetNorthPitch(t, r) { return this.easeTo(e.extend({ bearing: 0, pitch: 0, duration: 1e3 }, t), r), this } snapToNorth(e, t) { return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t) : this } getPitch() { return this.transform.pitch } setPitch(e, t) { return this.jumpTo({ pitch: e }, t), this } cameraForBounds(t, r) { t = e.LngLatBounds.convert(t); const n = r && r.bearing || 0, i = r && r.pitch || 0, o = t.getNorthWest(), s = t.getSouthEast(); return this._cameraForBounds(this.transform, o, s, n, i, r) } _extendCameraOptions(t) { const r = { top: 0, bottom: 0, right: 0, left: 0 }; if ("number" == typeof (t = e.extend({ padding: r, offset: [0, 0], maxZoom: this.transform.maxZoom }, t)).padding) { const e = t.padding; t.padding = { top: e, bottom: e, right: e, left: e } } return t.padding = e.extend(r, t.padding), t } _minimumAABBFrustumDistance(e, t) { const r = t.max[0] - t.min[0], n = t.max[1] - t.min[1]; return r / n > e.aspect ? r / (2 * Math.tan(.5 * e.fovX) * e.aspect) : n / (2 * Math.tan(.5 * e.fovY) * e.aspect) } _cameraForBoundsOnGlobe(t, r, n, i, o, s) { const a = t.clone(), c = this._extendCameraOptions(s); a.bearing = i, a.pitch = o; const l = e.LngLat.convert(r), u = e.LngLat.convert(n), h = .5 * (l.lat + u.lat), d = .5 * (l.lng + u.lng), p = e.latLngToECEF(h, d), f = e.normalize([], p), m = e.normalize([], e.cross([], f, [0, 1, 0])), g = e.cross([], m, f), _ = [m[0], m[1], m[2], 0, g[0], g[1], g[2], 0, f[0], f[1], f[2], 0, 0, 0, 0, 1], y = [p, e.latLngToECEF(l.lat, l.lng), e.latLngToECEF(u.lat, l.lng), e.latLngToECEF(u.lat, u.lng), e.latLngToECEF(l.lat, u.lng), e.latLngToECEF(h, l.lng), e.latLngToECEF(h, u.lng), e.latLngToECEF(l.lat, d), e.latLngToECEF(u.lat, d)]; let v = e.Aabb.fromPoints(y.map((t => [e.dot(m, t), e.dot(g, t), e.dot(f, t)]))); const x = e.transformMat4([], v.center, _); 0 === e.squaredLength(x) && e.set(x, 0, 0, 1), e.normalize(x, x), e.scale$2(x, x, e.GLOBE_RADIUS), a.center = e.ecefToLatLng(x); const b = a.getWorldToCameraMatrix(), w = e.invert(new Float64Array(16), b); v = e.Aabb.applyTransform(v, e.multiply([], b, _)), e.transformMat4(x, x, b); const T = .5 * (v.max[2] - v.min[2]), k = this._minimumAABBFrustumDistance(a, v), C = e.scale$2([], [0, 0, 1], T), E = e.add(C, x, C), S = k + (0 === a.pitch ? 0 : e.distance(x, E)), P = a.globeCenterInViewSpace, I = e.sub([], x, [P[0], P[1], P[2]]); e.normalize(I, I), e.scale$2(I, I, S); const A = e.add([], x, I); e.transformMat4(A, A, w); const L = e.earthRadius / e.GLOBE_RADIUS, M = e.length(A), B = e.mercatorZfromAltitude(Math.max(M * L - e.earthRadius, Number.EPSILON), 0), R = Math.min(a.zoomFromMercatorZAdjusted(B), c.maxZoom); return R > .5 * (e.GLOBE_ZOOM_THRESHOLD_MIN + e.GLOBE_ZOOM_THRESHOLD_MAX) ? (a.setProjection({ name: "mercator" }), a.zoom = R, this._cameraForBounds(a, r, n, i, o, s)) : { center: a.center, zoom: R, bearing: i, pitch: o } } queryTerrainElevation(t, r) { const n = this.transform.elevation; return n ? (r = e.extend({}, { exaggerated: !0 }, r), n.getAtPoint(e.MercatorCoordinate.fromLngLat(t), null, r.exaggerated)) : null } _cameraForBounds(t, r, n, i, o, s) { if ("globe" === t.projection.name) return this._cameraForBoundsOnGlobe(t, r, n, i, o, s); const a = t.clone(), c = this._extendCameraOptions(s), l = a.padding; a.bearing = i, a.pitch = o; const u = e.LngLat.convert(r), h = e.LngLat.convert(n), d = new e.LngLat(u.lng, h.lat), p = new e.LngLat(h.lng, u.lat), f = a.project(u), m = a.project(h), g = this.queryTerrainElevation(u), _ = this.queryTerrainElevation(h), y = this.queryTerrainElevation(d), v = this.queryTerrainElevation(p), x = [[f.x, f.y, Math.min(g || 0, _ || 0, y || 0, v || 0)], [m.x, m.y, Math.max(g || 0, _ || 0, y || 0, v || 0)]]; let b = e.Aabb.fromPoints(x); const w = a.getWorldToCameraMatrix(), T = e.invert(new Float64Array(16), w); b = e.Aabb.applyTransform(b, w); const k = e.sub([], b.max, b.min), C = l.left || 0, E = l.right || 0, S = l.bottom || 0, P = l.top || 0, { left: I, right: A, top: L, bottom: M } = c.padding, B = .5 * (C + E), R = .5 * (P + S), D = Math.min(a.scaleZoom(a.scale * Math.min((a.width - (C + E + I + A)) / k[0], (a.height - (S + P + M + L)) / k[1])), c.maxZoom), F = a.scale / a.zoomScale(D); b = new e.Aabb([b.min[0] - (I + B) * F, b.min[1] - (M + R) * F, b.min[2]], [b.max[0] + (A + B) * F, b.max[1] + (L + R) * F, b.max[2]]); const O = .5 * k[2], z = this._minimumAABBFrustumDistance(a, b), U = [0, 0, 1, 0]; e.transformMat4$1(U, U, w), e.normalize$2(U, U); const N = e.scale$2([], U, z + O), G = e.add([], b.center, N), V = ("number" == typeof c.offset.x && "number" == typeof c.offset.y ? new e.pointGeometry(c.offset.x, c.offset.y) : e.pointGeometry.convert(c.offset)).rotate(-e.degToRad(i)); b.center[0] -= V.x * F, b.center[1] += V.y * F, e.transformMat4(b.center, b.center, T), e.transformMat4(G, G, T); const q = [b.center[0], b.center[1], G[2] * a.pixelsPerMeter]; e.scale$2(q, q, 1 / a.worldSize); const j = e.lngFromMercatorX(q[0]), X = e.latFromMercatorY(q[1]), W = Math.min(a._zoomFromMercatorZ(q[2]), c.maxZoom), Z = new e.LngLat(j, X); return a.mercatorFromTransition && W < .5 * (e.GLOBE_ZOOM_THRESHOLD_MIN + e.GLOBE_ZOOM_THRESHOLD_MAX) ? (a.setProjection({ name: "globe" }), a.zoom = W, this._cameraForBounds(a, r, n, i, o, s)) : { center: Z, zoom: W, bearing: i, pitch: o } } fitBounds(e, t, r) { const n = this.cameraForBounds(e, t); return this._fitInternal(n, t, r) } fitScreenCoordinates(t, r, n, i, o) { const s = e.pointGeometry.convert(t), a = e.pointGeometry.convert(r), c = new e.pointGeometry(Math.min(s.x, a.x), Math.min(s.y, a.y)), l = new e.pointGeometry(Math.max(s.x, a.x), Math.max(s.y, a.y)); if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(s, a)) return this; const u = this.transform.pointLocation3D(c), h = this.transform.pointLocation3D(l), d = this.transform.pointLocation3D(new e.pointGeometry(c.x, l.y)), p = this.transform.pointLocation3D(new e.pointGeometry(l.x, c.y)), f = [Math.min(u.lng, h.lng, d.lng, p.lng), Math.min(u.lat, h.lat, d.lat, p.lat)], m = [Math.max(u.lng, h.lng, d.lng, p.lng), Math.max(u.lat, h.lat, d.lat, p.lat)], g = i && i.pitch ? i.pitch : this.getPitch(), _ = this._cameraForBounds(this.transform, f, m, n, g, i); return this._fitInternal(_, i, o) } _fitInternal(t, r, n) { return t ? (delete (r = e.extend(t, r)).padding, r.linear ? this.easeTo(r, n) : this.flyTo(r, n)) : this } jumpTo(t, r) { this.stop(); const n = t.preloadOnly ? this.transform.clone() : this.transform; let i = !1, o = !1, s = !1; return "zoom" in t && n.zoom !== +t.zoom && (i = !0, n.zoom = +t.zoom), void 0 !== t.center && (n.center = e.LngLat.convert(t.center)), "bearing" in t && n.bearing !== +t.bearing && (o = !0, n.bearing = +t.bearing), "pitch" in t && n.pitch !== +t.pitch && (s = !0, n.pitch = +t.pitch), null == t.padding || n.isPaddingEqual(t.padding) || (n.padding = t.padding), t.preloadOnly ? (this._preloadTiles(n), this) : (this.fire(new e.Event("movestart", r)).fire(new e.Event("move", r)), i && this.fire(new e.Event("zoomstart", r)).fire(new e.Event("zoom", r)).fire(new e.Event("zoomend", r)), o && this.fire(new e.Event("rotatestart", r)).fire(new e.Event("rotate", r)).fire(new e.Event("rotateend", r)), s && this.fire(new e.Event("pitchstart", r)).fire(new e.Event("pitch", r)).fire(new e.Event("pitchend", r)), this.fire(new e.Event("moveend", r))) } getFreeCameraOptions() { return this.transform.projection.supportsFreeCamera || e.warnOnce(ro), this.transform.getFreeCameraOptions() } setFreeCameraOptions(t, r) { const n = this.transform; if (!n.projection.supportsFreeCamera) return e.warnOnce(ro), this; this.stop(); const i = n.zoom, o = n.pitch, s = n.bearing; n.setFreeCameraOptions(t); const a = i !== n.zoom, c = o !== n.pitch, l = s !== n.bearing; return this.fire(new e.Event("movestart", r)).fire(new e.Event("move", r)), a && this.fire(new e.Event("zoomstart", r)).fire(new e.Event("zoom", r)).fire(new e.Event("zoomend", r)), l && this.fire(new e.Event("rotatestart", r)).fire(new e.Event("rotate", r)).fire(new e.Event("rotateend", r)), c && this.fire(new e.Event("pitchstart", r)).fire(new e.Event("pitch", r)).fire(new e.Event("pitchend", r)), this.fire(new e.Event("moveend", r)), this } easeTo(t, r) { this._stop(!1, t.easeId), (!1 === (t = e.extend({ offset: [0, 0], duration: 500, easing: e.ease }, t)).animate || !t.essential && e.exported.prefersReducedMotion) && (t.duration = 0); const n = this.transform, i = this.getZoom(), o = this.getBearing(), s = this.getPitch(), a = this.getPadding(), c = "zoom" in t ? +t.zoom : i, l = "bearing" in t ? this._normalizeBearing(t.bearing, o) : o, u = "pitch" in t ? +t.pitch : s, h = "padding" in t ? t.padding : n.padding, d = e.pointGeometry.convert(t.offset); let p, f, m; if ("globe" === n.projection.name) { const r = e.MercatorCoordinate.fromLngLat(n.center), i = d.rotate(-n.angle); r.x += i.x / n.worldSize, r.y += i.y / n.worldSize; const o = r.toLngLat(), s = e.LngLat.convert(t.center || o); this._normalizeCenter(s), p = n.centerPoint.add(i), f = new e.pointGeometry(r.x, r.y).mult(n.worldSize), m = new e.pointGeometry(e.mercatorXfromLng(s.lng), e.mercatorYfromLat(s.lat)).mult(n.worldSize).sub(f) } else { p = n.centerPoint.add(d); const r = n.pointLocation(p), i = e.LngLat.convert(t.center || r); this._normalizeCenter(i), f = n.project(r), m = n.project(i).sub(f) } const g = n.zoomScale(c - i); let _, y; t.around && (_ = e.LngLat.convert(t.around), y = n.locationPoint(_)); const v = this._zooming || c !== i, x = this._rotating || o !== l, b = this._pitching || u !== s, w = !n.isPaddingEqual(h), T = n => T => { if (v && (n.zoom = e.number(i, c, T)), x && (n.bearing = e.number(o, l, T)), b && (n.pitch = e.number(s, u, T)), w && (n.interpolatePadding(a, h, T), p = n.centerPoint.add(d)), _) n.setLocationAtPoint(_, y); else { const e = n.zoomScale(n.zoom - i), t = c > i ? Math.min(2, g) : Math.max(.5, g), r = Math.pow(t, 1 - T), o = n.unproject(f.add(m.mult(T * r)).mult(e)); n.setLocationAtPoint(n.renderWorldCopies ? o.wrap() : o, p) } return t.preloadOnly || this._fireMoveEvents(r), n }; if (t.preloadOnly) { const e = this._emulate(T, t.duration, n); return this._preloadTiles(e), this } const k = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching }; return this._zooming = v, this._rotating = x, this._pitching = b, this._padding = w, this._easeId = t.easeId, this._prepareEase(r, t.noMoveStart, k), this._ease(T(n), (e => { n.recenterOnTerrain(), this._afterEase(r, e) }), t), this } _prepareEase(t, r, n = {}) { this._moving = !0, this.transform.cameraElevationReference = "sea", r || n.moving || this.fire(new e.Event("movestart", t)), this._zooming && !n.zooming && this.fire(new e.Event("zoomstart", t)), this._rotating && !n.rotating && this.fire(new e.Event("rotatestart", t)), this._pitching && !n.pitching && this.fire(new e.Event("pitchstart", t)) } _fireMoveEvents(t) { this.fire(new e.Event("move", t)), this._zooming && this.fire(new e.Event("zoom", t)), this._rotating && this.fire(new e.Event("rotate", t)), this._pitching && this.fire(new e.Event("pitch", t)) } _afterEase(t, r) { if (this._easeId && r && this._easeId === r) return; this._easeId = void 0, this.transform.cameraElevationReference = "ground"; const n = this._zooming, i = this._rotating, o = this._pitching; this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, n && this.fire(new e.Event("zoomend", t)), i && this.fire(new e.Event("rotateend", t)), o && this.fire(new e.Event("pitchend", t)), this.fire(new e.Event("moveend", t)) } flyTo(t, r) { if (!t.essential && e.exported.prefersReducedMotion) { const n = e.pick(t, ["center", "zoom", "bearing", "pitch", "around"]); return this.jumpTo(n, r) } this.stop(), t = e.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.ease }, t); const n = this.transform, i = this.getZoom(), o = this.getBearing(), s = this.getPitch(), a = this.getPadding(), c = "zoom" in t ? e.clamp(+t.zoom, n.minZoom, n.maxZoom) : i, l = "bearing" in t ? this._normalizeBearing(t.bearing, o) : o, u = "pitch" in t ? +t.pitch : s, h = "padding" in t ? t.padding : n.padding, d = n.zoomScale(c - i), p = e.pointGeometry.convert(t.offset); let f = n.centerPoint.add(p); const m = n.pointLocation(f), g = e.LngLat.convert(t.center || m); this._normalizeCenter(g); const _ = n.project(m), y = n.project(g).sub(_); let v = t.curve; const x = Math.max(n.width, n.height), b = x / d, w = y.mag(); if ("minZoom" in t) { const r = e.clamp(Math.min(t.minZoom, i, c), n.minZoom, n.maxZoom), o = x / n.zoomScale(r - i); v = Math.sqrt(o / w * 2) } const T = v * v; function k(e) { const t = (b * b - x * x + (e ? -1 : 1) * T * T * w * w) / (2 * (e ? b : x) * T * w); return Math.log(Math.sqrt(t * t + 1) - t) } function C(e) { return (Math.exp(e) - Math.exp(-e)) / 2 } function E(e) { return (Math.exp(e) + Math.exp(-e)) / 2 } const S = k(0); let P = function (e) { return E(S) / E(S + v * e) }, I = function (e) { return x * ((E(S) * (C(t = S + v * e) / E(t)) - C(S)) / T) / w; var t }, A = (k(1) - S) / v; if (Math.abs(w) < 1e-6 || !isFinite(A)) { if (Math.abs(x - b) < 1e-6) return this.easeTo(t, r); const e = b < x ? -1 : 1; A = Math.abs(Math.log(b / x)) / v, I = function () { return 0 }, P = function (t) { return Math.exp(e * v * t) } } t.duration = "duration" in t ? +t.duration : 1e3 * A / ("screenSpeed" in t ? +t.screenSpeed / v : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0); const L = o !== l, M = u !== s, B = !n.isPaddingEqual(h), R = n => d => { const m = d * A, v = 1 / P(m); n.zoom = 1 === d ? c : i + n.scaleZoom(v), L && (n.bearing = e.number(o, l, d)), M && (n.pitch = e.number(s, u, d)), B && (n.interpolatePadding(a, h, d), f = n.centerPoint.add(p)); const x = 1 === d ? g : n.unproject(_.add(y.mult(I(m))).mult(v)); return n.setLocationAtPoint(n.renderWorldCopies ? x.wrap() : x, f), n._updateCameraOnTerrain(), t.preloadOnly || this._fireMoveEvents(r), n }; if (t.preloadOnly) { const e = this._emulate(R, t.duration, n); return this._preloadTiles(e), this } return this._zooming = !0, this._rotating = L, this._pitching = M, this._padding = B, this._prepareEase(r, !1), this._ease(R(n), (() => this._afterEase(r)), t), this } isEasing() { return !!this._easeFrameId } stop() { return this._stop() } _stop(e, t) { if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) { const e = this._onEaseEnd; this._onEaseEnd = void 0, e.call(this, t) } if (!e) { const e = this.handlers; e && e.stop(!1) } return this } _ease(t, r, n) { !1 === n.animate || 0 === n.duration ? (t(1), r()) : (this._easeStart = e.exported.now(), this._easeOptions = n, this._onEaseFrame = t, this._onEaseEnd = r, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback)) } _renderFrameCallback() { const t = Math.min((e.exported.now() - this._easeStart) / this._easeOptions.duration, 1), r = this._onEaseFrame; r && r(this._easeOptions.easing(t)), t < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop() } _normalizeBearing(t, r) { t = e.wrap(t, -180, 180); const n = Math.abs(t - r); return Math.abs(t - 360 - r) < n && (t -= 360), Math.abs(t + 360 - r) < n && (t += 360), t } _normalizeCenter(e) { const t = this.transform; if (!t.renderWorldCopies || t.maxBounds) return; const r = e.lng - t.center.lng; e.lng += r > 180 ? -360 : r < -180 ? 360 : 0 } _emulate(e, t, r) { const n = Math.ceil(15 * t / 1e3), i = [], o = e(r.clone()); for (let s = 0; s <= n; s++) { const e = o(s / n); i.push(e.clone()) } return i } } class io { constructor(t = {}) { this.options = t, e.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this) } getDefaultPosition() { return "bottom-right" } onAdd(e) { const t = this.options && this.options.compact; return this._map = e, this._container = o("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = o("button", "mapboxgl-ctrl-attrib-button", this._container), o("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = o("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), t && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container } onRemove() { this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0 } _setElementTitle(e, t) { const r = this._map._getUIString(`AttributionControl.${t}`); e.setAttribute("aria-label", r), e.removeAttribute("title"), e.firstElementChild && e.firstElementChild.setAttribute("title", r) } _toggleAttribution() { this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true")) } _updateEditLink() { let t = this._editLink; t || (t = this._editLink = this._container.querySelector(".mapbox-improve-map")); const r = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e.config.ACCESS_TOKEN }]; if (t) { const n = r.reduce(((e, t, n) => (t.value && (e += `${t.key}=${t.value}${n < r.length - 1 ? "&" : ""}`), e)), "?"); t.href = `${e.config.FEEDBACK_URL}/${n}#${ai(this._map, !0)}`, t.rel = "noopener nofollow", this._setElementTitle(t, "MapFeedback") } } _updateData(e) { !e || "metadata" !== e.sourceDataType && "visibility" !== e.sourceDataType && "style" !== e.dataType || (this._updateAttributions(), this._updateEditLink()) } _updateAttributions() { if (!this._map.style) return; let e = []; if (this._map.style.stylesheet) { const e = this._map.style.stylesheet; this.styleOwner = e.owner, this.styleId = e.id } const t = this._map.style._sourceCaches; for (const n in t) { const r = t[n]; if (r.used) { const t = r.getSource(); t.attribution && e.indexOf(t.attribution) < 0 && e.push(t.attribution) } } e.sort(((e, t) => e.length - t.length)), e = e.filter(((t, r) => { for (let n = r + 1; n < e.length; n++)if (e[n].indexOf(t) >= 0) return !1; return !0 })), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = [...this.options.customAttribution, ...e] : e.unshift(this.options.customAttribution)); const r = e.join(" | "); r !== this._attribHTML && (this._attribHTML = r, e.length ? (this._innerContainer.innerHTML = r, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null) } _updateCompact() { this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show") } } class oo { constructor() { e.bindAll(["_updateLogo", "_updateCompact"], this) } onAdd(e) { this._map = e, this._container = o("div", "mapboxgl-ctrl"); const t = o("a", "mapboxgl-ctrl-logo"); return t.target = "_blank", t.rel = "noopener nofollow", t.href = "https://www.mapbox.com/", t.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container } onRemove() { this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact) } getDefaultPosition() { return "bottom-left" } _updateLogo(e) { e && "metadata" !== e.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none") } _logoRequired() { if (!this._map.style) return !0; const e = this._map.style._sourceCaches; if (0 === Object.entries(e).length) return !0; for (const t in e) { const r = e[t].getSource(); if (r.hasOwnProperty("mapbox_logo") && !r.mapbox_logo) return !1 } return !0 } _updateCompact() { const e = this._container.children; if (e.length) { const t = e[0]; this._map.getCanvasContainer().offsetWidth < 250 ? t.classList.add("mapboxgl-compact") : t.classList.remove("mapboxgl-compact") } } } class so { constructor() { this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1 } add(e) { const t = ++this._id; return this._queue.push({ callback: e, id: t, cancelled: !1 }), t } remove(e) { const t = this._currentlyRunning, r = t ? this._queue.concat(t) : this._queue; for (const n of r) if (n.id === e) return void (n.cancelled = !0) } run(e = 0) { const t = this._currentlyRunning = this._queue; this._queue = []; for (const r of t) if (!r.cancelled && (r.callback(e), this._cleared)) break; this._cleared = !1, this._currentlyRunning = !1 } clear() { this._currentlyRunning && (this._cleared = !0), this._queue = [] } } function ao(t, r, n) { if (t = new e.LngLat(t.lng, t.lat), r) { const i = new e.LngLat(t.lng - 360, t.lat), o = new e.LngLat(t.lng + 360, t.lat), s = 360 * Math.ceil(Math.abs(t.lng - n.center.lng) / 360), a = n.locationPoint(t).distSqr(r), c = r.x < 0 || r.y < 0 || r.x > n.width || r.y > n.height; n.locationPoint(i).distSqr(r) < a && (c || Math.abs(i.lng - n.center.lng) < s) ? t = i : n.locationPoint(o).distSqr(r) < a && (c || Math.abs(o.lng - n.center.lng) < s) && (t = o) } for (; Math.abs(t.lng - n.center.lng) > 180;) { const e = n.locationPoint(t); if (e.x >= 0 && e.y >= 0 && e.x <= n.width && e.y <= n.height) break; t.lng > n.center.lng ? t.lng -= 360 : t.lng += 360 } return t } const co = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" }; class lo extends e.Evented { constructor(t, r) { if (super(), (t instanceof e.window.HTMLElement || r) && (t = e.extend({ element: t }, r)), e.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment || "auto", this._updateMoving = () => this._update(!0), this._occludedOpacity = t && t.occludedOpacity || .2, t && t.element) this._element = t.element, this._offset = e.pointGeometry.convert(t && t.offset || [0, 0]); else { this._defaultMarker = !0, this._element = o("div"); const r = 41, n = 27, i = s("svg", { display: "block", height: r * this._scale + "px", width: n * this._scale + "px", viewBox: `0 0 ${n} ${r}` }, this._element), a = s("radialGradient", { id: "shadowGradient" }, s("defs", {}, i)); s("stop", { offset: "10%", "stop-opacity": .4 }, a), s("stop", { offset: "100%", "stop-opacity": .05 }, a), s("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, i), s("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, i), s("path", { opacity: .25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, i), s("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, i), this._offset = e.pointGeometry.convert(t && t.offset || [0, -14]) } this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e => { e.preventDefault() })), this._element.addEventListener("mousedown", (e => { e.preventDefault() })); const n = this._element.classList; for (const e in co) n.remove(`mapboxgl-marker-anchor-${e}`); n.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null } addTo(e) { return e === this._map || (this.remove(), this._map = e, e.getCanvasContainer().appendChild(this._element), e.on("move", this._updateMoving), e.on("moveend", this._update), e.on("remove", this._clearFadeTimer), e._addMarker(this), this.setDraggable(this._draggable), this._update(), e.on("click", this._onMapClick)), this } remove() { const e = this._map; return e && (e.off("click", this._onMapClick), e.off("move", this._updateMoving), e.off("moveend", this._update), e.off("mousedown", this._addDragHandler), e.off("touchstart", this._addDragHandler), e.off("mouseup", this._onUp), e.off("touchend", this._onUp), e.off("mousemove", this._onMove), e.off("touchmove", this._onMove), e.off("remove", this._clearFadeTimer), e._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this } getLngLat() { return this._lngLat } setLngLat(t) { return this._lngLat = e.LngLat.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this } getElement() { return this._element } setPopup(e) { if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) { if (!("offset" in e.options)) { const t = 38.1, r = 13.5, n = Math.sqrt(Math.pow(r, 2) / 2); e.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t], "bottom-left": [n, -1 * (t - r + n)], "bottom-right": [-n, -1 * (t - r + n)], left: [r, -1 * (t - r)], right: [-r, -1 * (t - r)] } : this._offset } this._popup = e, e._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false") } return this } _onKeyPress(e) { const t = e.code, r = e.charCode || e.keyCode; "Space" !== t && "Enter" !== t && 32 !== r && 13 !== r || this.togglePopup() } _onMapClick(e) { const t = e.originalEvent.target, r = this._element; this._popup && (t === r || r.contains(t)) && this.togglePopup() } getPopup() { return this._popup } togglePopup() { const e = this._popup; return e ? (e.isOpen() ? (e.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this } _behindTerrain() { const e = this._map, t = this._pos; if (!e || !t) return !1; const r = e.unproject(t), n = e.getFreeCameraOptions(); if (!n.position) return !1; const i = n.position.toLngLat(); return i.distanceTo(r) < .9 * i.distanceTo(this._lngLat) } _evaluateOpacity() { const t = this._map; if (!t) return; const r = this._pos; if (!r || r.x < 0 || r.x > t.transform.width || r.y < 0 || r.y > t.transform.height) return void this._clearFadeTimer(); const n = t.unproject(r); let i; t._showingGlobe() && e.isLngLatBehindGlobe(t.transform, this._lngLat) ? i = 0 : (i = 1 - t._queryFogOpacity(n), t.transform._terrainEnabled() && t.getTerrain() && this._behindTerrain() && (i *= this._occludedOpacity)), this._element.style.opacity = `${i}`, this._element.style.pointerEvents = i > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(i), this._fadeTimer = null } _clearFadeTimer() { this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null) } _updateDOM() { const e = this._pos; if (!e || !this._map) return; const t = this._offset.mult(this._scale); this._element.style.transform = `\n            translate(${e.x}px,${e.y}px)\n            ${co[this._anchor]}\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${t.x}px,${t.y}px)\n        ` } _calculateXYTransform() { const t = this._pos, r = this._map, n = this.getPitchAlignment(); if (!r || !t || "map" !== n) return ""; if (!r._showingGlobe()) { const e = r.getPitch(); return e ? `rotateX(${e}deg)` : "" } const i = e.radToDeg(e.globeTiltAtLngLat(r.transform, this._lngLat)), o = t.sub(e.globeCenterToScreenPoint(r.transform)), s = Math.abs(o.x) + Math.abs(o.y); if (0 === s) return ""; const a = i / s; return `rotateX(${-o.y * a}deg) rotateY(${o.x * a}deg)` } _calculateZTransform() { const t = this._pos, r = this._map; if (!r || !t) return ""; let n = 0; const i = this.getRotationAlignment(); if ("map" === i) if (r._showingGlobe()) { const t = r.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat + .001)), i = r.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat - .001)).sub(t); n = e.radToDeg(Math.atan2(i.y, i.x)) - 90 } else n = -r.getBearing(); else if ("horizon" === i) { const i = e.smoothstep(4, 6, r.getZoom()), o = e.globeCenterToScreenPoint(r.transform); o.y += i * r.transform.height; const s = t.sub(o), a = e.radToDeg(Math.atan2(s.y, s.x)); n = (a > 90 ? a - 270 : a + 90) * (1 - i) } return n += this._rotation, n ? `rotateZ(${n}deg)` : "" } _update(t) { e.window.cancelAnimationFrame(this._updateFrameId); const r = this._map; r && (r.transform.renderWorldCopies && (this._lngLat = ao(this._lngLat, this._pos, r.transform)), this._pos = r.project(this._lngLat), !0 === t ? this._updateFrameId = e.window.requestAnimationFrame((() => { this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM()) })) : this._pos = this._pos.round(), r._requestDomTask((() => { this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (r._showingGlobe() || r.getTerrain() || r.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60))) }))) } getOffset() { return this._offset } setOffset(t) { return this._offset = e.pointGeometry.convert(t), this._update(), this } _onMove(t) { const r = this._map; if (!r) return; const n = this._pointerdownPos, i = this._positionDelta; if (n && i) { if (!this._isDragging) { const e = this._clickTolerance || r._clickTolerance; if (t.point.dist(n) < e) return; this._isDragging = !0 } this._pos = t.point.sub(i), this._lngLat = r.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.Event("dragstart"))), this.fire(new e.Event("drag")) } } _onUp() { this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1; const t = this._map; t && (t.off("mousemove", this._onMove), t.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e.Event("dragend")), this._state = "inactive" } _addDragHandler(e) { const t = this._map, r = this._pos; t && r && this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(r), this._pointerdownPos = e.point, this._state = "pending", t.on("mousemove", this._onMove), t.on("touchmove", this._onMove), t.once("mouseup", this._onUp), t.once("touchend", this._onUp)) } setDraggable(e) { this._draggable = !!e; const t = this._map; return t && (e ? (t.on("mousedown", this._addDragHandler), t.on("touchstart", this._addDragHandler)) : (t.off("mousedown", this._addDragHandler), t.off("touchstart", this._addDragHandler))), this } isDraggable() { return this._draggable } setRotation(e) { return this._rotation = e || 0, this._update(), this } getRotation() { return this._rotation } setRotationAlignment(e) { return this._rotationAlignment = e || "auto", this._update(), this } getRotationAlignment() { return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment } setPitchAlignment(e) { return this._pitchAlignment = e || "auto", this._update(), this } getPitchAlignment() { return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment } setOccludedOpacity(e) { return this._occludedOpacity = e || .2, this._update(), this } getOccludedOpacity() { return this._occludedOpacity } } const uo = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px" }, ho = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "); function po(t = new e.pointGeometry(0, 0), r = "bottom") { if ("number" == typeof t) { const n = Math.round(Math.sqrt(.5 * Math.pow(t, 2))); switch (r) { case "top": return new e.pointGeometry(0, t); case "top-left": return new e.pointGeometry(n, n); case "top-right": return new e.pointGeometry(-n, n); case "bottom": return new e.pointGeometry(0, -t); case "bottom-left": return new e.pointGeometry(n, -n); case "bottom-right": return new e.pointGeometry(-n, -n); case "left": return new e.pointGeometry(t, 0); case "right": return new e.pointGeometry(-t, 0) }return new e.pointGeometry(0, 0) } return t instanceof e.pointGeometry || Array.isArray(t) ? e.pointGeometry.convert(t) : e.pointGeometry.convert(t[r] || [0, 0]) } class fo { constructor(e) { this.jumpTo(e) } getValue(t) { if (t <= this._startTime) return this._start; if (t >= this._endTime) return this._end; const r = e.easeCubicInOut((t - this._startTime) / (this._endTime - this._startTime)); return this._start * (1 - r) + this._end * r } isEasing(e) { return e >= this._startTime && e <= this._endTime } jumpTo(e) { this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e, this._end = e } easeTo(e, t, r) { this._start = this.getValue(t), this._end = e, this._startTime = t, this._endTime = t + r } } const mo = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use ⌘ + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" }, go = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, performanceMetricsCollection: !0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, optimizeForTerrain: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: !0 }, _o = { showCompass: !0, showZoom: !0, visualizePitch: !1 }; class yo { constructor(t, r, n = !1) { this._clickTolerance = 10, this.element = r, this.mouseRotate = new Ii({ clickTolerance: t.dragRotate._mouseRotate._clickTolerance }), this.map = t, n && (this.mousePitch = new Ai({ clickTolerance: t.dragRotate._mousePitch._clickTolerance })), e.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), r.addEventListener("mousedown", this.mousedown), r.addEventListener("touchstart", this.touchstart, { passive: !1 }), r.addEventListener("touchmove", this.touchmove), r.addEventListener("touchend", this.touchend), r.addEventListener("touchcancel", this.reset) } down(e, t) { this.mouseRotate.mousedown(e, t), this.mousePitch && this.mousePitch.mousedown(e, t), u() } move(e, t) { const r = this.map, n = this.mouseRotate.mousemoveWindow(e, t), i = n && n.bearingDelta; if (i && r.setBearing(r.getBearing() + i), this.mousePitch) { const n = this.mousePitch.mousemoveWindow(e, t), i = n && n.pitchDelta; i && r.setPitch(r.getPitch() + i) } } off() { const e = this.element; e.removeEventListener("mousedown", this.mousedown), e.removeEventListener("touchstart", this.touchstart, { passive: !1 }), e.removeEventListener("touchmove", this.touchmove), e.removeEventListener("touchend", this.touchend), e.removeEventListener("touchcancel", this.reset), this.offTemp() } offTemp() { h(), e.window.removeEventListener("mousemove", this.mousemove), e.window.removeEventListener("mouseup", this.mouseup) } mousedown(t) { this.down(e.extend({}, t, { ctrlKey: !0, preventDefault: () => t.preventDefault() }), f(this.element, t)), e.window.addEventListener("mousemove", this.mousemove), e.window.addEventListener("mouseup", this.mouseup) } mousemove(e) { this.move(e, f(this.element, e)) } mouseup(e) { this.mouseRotate.mouseupWindow(e), this.mousePitch && this.mousePitch.mouseupWindow(e), this.offTemp() } touchstart(e) { 1 !== e.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = m(this.element, e.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: !0, preventDefault: () => e.preventDefault() }, this._startPos)) } touchmove(e) { 1 !== e.targetTouches.length ? this.reset() : (this._lastPos = m(this.element, e.targetTouches)[0], this.move({ preventDefault: () => e.preventDefault() }, this._lastPos)) } touchend(e) { 0 === e.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset() } reset() { this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp() } } const vo = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0, showUserHeading: !1 }, xo = { maxWidth: 100, unit: "metric" }; function bo(e, t, r) { const n = wo(t), i = n / t, o = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }[r]; this._map._requestDomTask((() => { this._container.style.width = e * i + "px", this._container.innerHTML = `${n}&nbsp;${o}` })) } function wo(e) { const t = Math.pow(10, `${Math.floor(e)}`.length - 1); let r = e / t; return r = r >= 10 ? 10 : r >= 5 ? 5 : r >= 3 ? 3 : r >= 2 ? 2 : r >= 1 ? 1 : function (e) { const t = Math.pow(10, Math.ceil(-Math.log(e) / Math.LN10)); return Math.round(e * t) / t }(r), t * r } const To = { version: e.version, supported: r, setRTLTextPlugin: e.setRTLTextPlugin, getRTLTextPluginStatus: e.getRTLTextPluginStatus, Map: class extends no { constructor(t) { if (e.LivePerformanceUtils.mark(e.PerformanceMarkers.create), null != (t = e.extend({}, go, t)).minZoom && null != t.maxZoom && t.minZoom > t.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom"); if (null != t.minPitch && null != t.maxPitch && t.minPitch > t.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch"); if (null != t.minPitch && t.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0"); if (null != t.maxPitch && t.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85"); if (t.antialias && e.isSafariWithAntialiasingBug(e.window) && (t.antialias = !1, e.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new ii(t.minZoom, t.maxZoom, t.minPitch, t.maxPitch, t.renderWorldCopies), t), this._interactive = t.interactive, this._minTileCacheSize = t.minTileCacheSize, this._maxTileCacheSize = t.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t.preserveDrawingBuffer, this._antialias = t.antialias, this._useWebGL2 = t.useWebGL2, this._trackResize = t.trackResize, this._bearingSnap = t.bearingSnap, this._refreshExpiredTiles = t.refreshExpiredTiles, this._fadeDuration = t.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t.crossSourceCollisions, this._collectResourceTiming = t.collectResourceTiming, this._optimizeForTerrain = t.optimizeForTerrain, this._language = this._parseLanguage(t.language), this._worldview = t.worldview, this._renderTaskQueue = new so, this._domRenderTaskQueue = new so, this._controls = [], this._markers = [], this._popups = [], this._mapId = e.uniqueId(), this._locale = e.extend({}, mo, t.locale), this._clickTolerance = t.clickTolerance, this._cooperativeGestures = t.cooperativeGestures, this._performanceMetricsCollection = t.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new fo(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._requestManager = new e.RequestManager(t.transformRequest, t.accessToken, t.testMode), this._silenceAuthErrors = !!t.testMode, "string" == typeof t.container) { if (this._container = e.window.document.getElementById(t.container), !this._container) throw new Error(`Container '${t.container}' not found.`) } else { if (!(t.container instanceof e.window.HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement."); this._container = t.container } if (this._container.childNodes.length > 0 && e.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t.maxBounds && this.setMaxBounds(t.maxBounds), e.bindAll(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL."); this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), void 0 !== e.window && (e.window.addEventListener("online", this._onWindowOnline, !1), e.window.addEventListener("resize", this._onWindowResize, !1), e.window.addEventListener("orientationchange", this._onWindowResize, !1), e.window.addEventListener("webkitfullscreenchange", this._onWindowResize, !1), e.window.addEventListener("visibilitychange", this._onVisibilityChange, !1)), this.handlers = new to(this, t), this._localFontFamily = t.localFontFamily, this._localIdeographFontFamily = t.localIdeographFontFamily, t.style && this.setStyle(t.style, { localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t.projection && this.setProjection(t.projection), this._hash = t.hash && new si("string" == typeof t.hash && t.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: t.center, zoom: t.zoom, bearing: t.bearing, pitch: t.pitch }), t.bounds && (this.resize(), this.fitBounds(t.bounds, e.extend({}, t.fitBoundsOptions, { duration: 0 })))), this.resize(), t.attributionControl && this.addControl(new io({ customAttribution: t.customAttribution })), this._logoControl = new oo, this.addControl(this._logoControl, t.logoPosition), this.on("style.load", (() => { this.transform.unmodified && this.jumpTo(this.style.stylesheet) })), this.on("data", (t => { this._update("style" === t.dataType), this.fire(new e.Event(`${t.dataType}data`, t)) })), this.on("dataloading", (t => { this.fire(new e.Event(`${t.dataType}dataloading`, t)) })) } _getMapId() { return this._mapId } addControl(t, r) { if (void 0 === r && (r = t.getDefaultPosition ? t.getDefaultPosition() : "top-right"), !t || !t.onAdd) return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods."))); const n = t.onAdd(this); this._controls.push(t); const i = this._controlPositions[r]; return -1 !== r.indexOf("bottom") ? i.insertBefore(n, i.firstChild) : i.appendChild(n), this } removeControl(t) { if (!t || !t.onRemove) return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods."))); const r = this._controls.indexOf(t); return r > -1 && this._controls.splice(r, 1), t.onRemove(this), this } hasControl(e) { return this._controls.indexOf(e) > -1 } getContainer() { return this._container } getCanvasContainer() { return this._canvasContainer } getCanvas() { return this._canvas } resize(t) { if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this; this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight)); const r = !this._moving; return r && this.fire(new e.Event("movestart", t)).fire(new e.Event("move", t)), this.fire(new e.Event("resize", t)), r && this.fire(new e.Event("moveend", t)), this } getBounds() { return this.transform.getBounds() } getMaxBounds() { return this.transform.getMaxBounds() || null } setMaxBounds(t) { return this.transform.setMaxBounds(e.LngLatBounds.convert(t)), this._update() } setMinZoom(t) { if ((t = null == t ? -2 : t) >= -2 && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t ? this.setZoom(t) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this; throw new Error("minZoom must be between -2 and the current maxZoom, inclusive") } getMinZoom() { return this.transform.minZoom } setMaxZoom(t) { if ((t = null == t ? 22 : t) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t ? this.setZoom(t) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this; throw new Error("maxZoom must be greater than the current minZoom") } getMaxZoom() { return this.transform.maxZoom } setMinPitch(t) { if ((t = null == t ? 0 : t) < 0) throw new Error("minPitch must be greater than or equal to 0"); if (t >= 0 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t ? this.setPitch(t) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this; throw new Error("minPitch must be between 0 and the current maxPitch, inclusive") } getMinPitch() { return this.transform.minPitch } setMaxPitch(t) { if ((t = null == t ? 85 : t) > 85) throw new Error("maxPitch must be less than or equal to 85"); if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t ? this.setPitch(t) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this; throw new Error("maxPitch must be greater than or equal to minPitch") } getMaxPitch() { return this.transform.maxPitch } getRenderWorldCopies() { return this.transform.renderWorldCopies } setRenderWorldCopies(e) { return this.transform.renderWorldCopies = e, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update() } getLanguage() { return this._language } _parseLanguage(t) { return "auto" === t ? e.window.navigator.language : Array.isArray(t) ? 0 === t.length ? void 0 : t.map((t => "auto" === t ? e.window.navigator.language : t)) : t } setLanguage(e) { const t = this._parseLanguage(e); if (!this.style || t === this._language) return this; this._language = t, this.style._reloadSources(); for (const r of this._controls) r._setLanguage && r._setLanguage(this._language); return this } getWorldview() { return this._worldview } setWorldview(e) { return this.style && e !== this._worldview ? (this._worldview = e, this.style._reloadSources(), this) : this } getProjection() { return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection() } _showingGlobe() { return "globe" === this.transform.projection.name } setProjection(e) { return this._lazyInitEmptyStyle(), e ? "string" == typeof e && (e = { name: e }) : e = null, this._useExplicitProjection = !!e, this._prioritizeAndUpdateProjection(e, this.style.stylesheet ? this.style.stylesheet.projection : null) } _updateProjectionTransition() { if ("globe" !== this.getProjection().name) return; const t = this.transform, r = t.projection.name; let n; "globe" === r && t.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? (t.setMercatorFromTransition(), n = !0) : "mercator" === r && t.zoom < e.GLOBE_ZOOM_THRESHOLD_MAX && (t.setProjection({ name: "globe" }), n = !0), n && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate()) } _prioritizeAndUpdateProjection(e, t) { return this._updateProjection(e || t || { name: "mercator" }) } _updateProjection(t) { let r; if (r = "globe" === t.name && this.transform.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t), this.style.applyProjectionUpdate(), r) { this.painter.clearBackgroundTiles(); for (const e in this.style._sourceCaches) this.style._sourceCaches[e].clearTiles(); this._update(!0), this._forceMarkerAndPopupUpdate(!0) } return this } project(t) { return this.transform.locationPoint3D(e.LngLat.convert(t)) } unproject(t) { return this.transform.pointLocation3D(e.pointGeometry.convert(t)) } isMoving() { return this._moving || this.handlers && this.handlers.isMoving() || !1 } isZooming() { return this._zooming || this.handlers && this.handlers.isZooming() || !1 } isRotating() { return this._rotating || this.handlers && this.handlers.isRotating() || !1 } _isDragging() { return this.handlers && this.handlers._isDragging() || !1 } _createDelegatedListener(e, t, r) { if ("mouseenter" === e || "mouseover" === e) { let n = !1; const i = i => { const o = t.filter((e => this.getLayer(e))), s = o.length ? this.queryRenderedFeatures(i.point, { layers: o }) : []; s.length ? n || (n = !0, r.call(this, new gi(e, this, i.originalEvent, { features: s }))) : n = !1 }, o = () => { n = !1 }; return { layers: new Set(t), listener: r, delegates: { mousemove: i, mouseout: o } } } if ("mouseleave" === e || "mouseout" === e) { let n = !1; const i = i => { const o = t.filter((e => this.getLayer(e))); (o.length ? this.queryRenderedFeatures(i.point, { layers: o }) : []).length ? n = !0 : n && (n = !1, r.call(this, new gi(e, this, i.originalEvent))) }, o = t => { n && (n = !1, r.call(this, new gi(e, this, t.originalEvent))) }; return { layers: new Set(t), listener: r, delegates: { mousemove: i, mouseout: o } } } { const n = e => { const n = t.filter((e => this.getLayer(e))), i = n.length ? this.queryRenderedFeatures(e.point, { layers: n }) : []; i.length && (e.features = i, r.call(this, e), delete e.features) }; return { layers: new Set(t), listener: r, delegates: { [e]: n } } } } on(e, t, r) { if (void 0 === r) return super.on(e, t); Array.isArray(t) || (t = [t]); const n = this._createDelegatedListener(e, t, r); this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(n); for (const i in n.delegates) this.on(i, n.delegates[i]); return this } once(e, t, r) { if (void 0 === r) return super.once(e, t); Array.isArray(t) || (t = [t]); const n = this._createDelegatedListener(e, t, r); for (const i in n.delegates) this.once(i, n.delegates[i]); return this } off(e, t, r) { if (void 0 === r) return super.off(e, t); t = new Set(Array.isArray(t) ? t : [t]); const n = (e, t) => { if (e.size !== t.size) return !1; for (const r of e) if (!t.has(r)) return !1; return !0 }, i = this._delegatedListeners ? this._delegatedListeners[e] : void 0; return i && (e => { for (let i = 0; i < e.length; i++) { const o = e[i]; if (o.listener === r && n(o.layers, t)) { for (const e in o.delegates) this.off(e, o.delegates[e]); return e.splice(i, 1), this } } })(i), this } queryRenderedFeatures(t, r) { return this.style ? (void 0 !== r || void 0 === t || t instanceof e.pointGeometry || Array.isArray(t) || (r = t, t = void 0), this.style.queryRenderedFeatures(t = t || [[0, 0], [this.transform.width, this.transform.height]], r = r || {}, this.transform)) : [] } querySourceFeatures(e, t) { return this.style.querySourceFeatures(e, t) } setStyle(t, r) { return !1 !== (r = e.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, r)).diff && r.localIdeographFontFamily === this._localIdeographFontFamily && r.localFontFamily === this._localFontFamily && this.style && t ? (this._diffStyle(t, r), this) : (this._localIdeographFontFamily = r.localIdeographFontFamily, this._localFontFamily = r.localFontFamily, this._updateStyle(t, r)) } _getUIString(e) { const t = this._locale[e]; if (null == t) throw new Error(`Missing UI string '${e}'`); return t } _updateStyle(e, t) { return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e && (this.style = new rr(this, t || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e ? this.style.loadURL(e) : this.style.loadJSON(e)), this._updateTerrain(), this } _lazyInitEmptyStyle() { this.style || (this.style = new rr(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty()) } _diffStyle(t, r) { if ("string" == typeof t) { const n = this._requestManager.normalizeStyleURL(t), i = this._requestManager.transformRequest(n, e.ResourceType.Style); e.getJSON(i, ((t, n) => { t ? this.fire(new e.ErrorEvent(t)) : n && this._updateDiff(n, r) })) } else "object" == typeof t && this._updateDiff(t, r) } _updateDiff(t, r) { try { this.style.setState(t) && this._update(!0) } catch (n) { e.warnOnce(`Unable to perform style diff: ${n.message || n.error || n}.  Rebuilding the style from scratch.`), this._updateStyle(t, r) } } getStyle() { if (this.style) return this.style.serialize() } isStyleLoaded() { return this.style ? this.style.loaded() : (e.warnOnce("There is no style added to the map."), !1) } addSource(e, t) { return this._lazyInitEmptyStyle(), this.style.addSource(e, t), this._update(!0) } isSourceLoaded(e) { return !!this.style && this.style._isSourceCacheLoaded(e) } areTilesLoaded() { const e = this.style && this.style._sourceCaches; for (const t in e) { const r = e[t]._tiles; for (const e in r) { const t = r[e]; if ("loaded" !== t.state && "errored" !== t.state) return !1 } } return !0 } addSourceType(e, t, r) { this._lazyInitEmptyStyle(), this.style.addSourceType(e, t, r) } removeSource(e) { return this.style.removeSource(e), this._updateTerrain(), this._update(!0) } getSource(e) { return this.style.getSource(e) } addImage(t, r, { pixelRatio: n = 1, sdf: i = !1, stretchX: o, stretchY: s, content: a } = {}) { if (this._lazyInitEmptyStyle(), r instanceof e.window.HTMLImageElement || e.window.ImageBitmap && r instanceof e.window.ImageBitmap) { const { width: c, height: l, data: u } = e.exported.getImageData(r); this.style.addImage(t, { data: new e.RGBAImage({ width: c, height: l }, u), pixelRatio: n, stretchX: o, stretchY: s, content: a, sdf: i, version: 0 }) } else if (void 0 === r.width || void 0 === r.height) this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))); else { const { width: c, height: l } = r, u = r; this.style.addImage(t, { data: new e.RGBAImage({ width: c, height: l }, new Uint8Array(u.data)), pixelRatio: n, stretchX: o, stretchY: s, content: a, sdf: i, version: 0, userImage: u }), u.onAdd && u.onAdd(this, t) } } updateImage(t, r) { const n = this.style.getImage(t); if (!n) return void this.fire(new e.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead."))); const i = r instanceof e.window.HTMLImageElement || e.window.ImageBitmap && r instanceof e.window.ImageBitmap ? e.exported.getImageData(r) : r, { width: o, height: s } = i; void 0 !== o && void 0 !== s ? o === n.data.width && s === n.data.height ? (n.data.replace(i.data, !(r instanceof e.window.HTMLImageElement || e.window.ImageBitmap && r instanceof e.window.ImageBitmap)), this.style.updateImage(t, n)) : this.fire(new e.ErrorEvent(new Error(`The width and height of the updated image (${o}, ${s})\n                must be that same as the previous version of the image\n                (${n.data.width}, ${n.data.height})`))) : this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) } hasImage(t) { return t ? !!this.style.getImage(t) : (this.fire(new e.ErrorEvent(new Error("Missing required image id"))), !1) } removeImage(e) { this.style.removeImage(e) } loadImage(t, r) { e.getImage(this._requestManager.transformRequest(t, e.ResourceType.Image), ((t, n) => { r(t, n instanceof e.window.HTMLImageElement ? e.exported.getImageData(n) : n) })) } listImages() { return this.style.listImages() } addLayer(e, t) { return this._lazyInitEmptyStyle(), this.style.addLayer(e, t), this._update(!0) } moveLayer(e, t) { return this.style.moveLayer(e, t), this._update(!0) } removeLayer(e) { return this.style.removeLayer(e), this._update(!0) } getLayer(e) { return this.style.getLayer(e) } setLayerZoomRange(e, t, r) { return this.style.setLayerZoomRange(e, t, r), this._update(!0) } setFilter(e, t, r = {}) { return this.style.setFilter(e, t, r), this._update(!0) } getFilter(e) { return this.style.getFilter(e) } setPaintProperty(e, t, r, n = {}) { return this.style.setPaintProperty(e, t, r, n), this._update(!0) } getPaintProperty(e, t) { return this.style.getPaintProperty(e, t) } setLayoutProperty(e, t, r, n = {}) { return this.style.setLayoutProperty(e, t, r, n), this._update(!0) } getLayoutProperty(e, t) { return this.style.getLayoutProperty(e, t) } setLight(e, t = {}) { return this._lazyInitEmptyStyle(), this.style.setLight(e, t), this._update(!0) } getLight() { return this.style.getLight() } setTerrain(e) { return this._lazyInitEmptyStyle(), !e && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e), this._averageElevationLastSampledAt = -1 / 0, this._update(!0) } getTerrain() { return this.style ? this.style.getTerrain() : null } setFog(e) { return this._lazyInitEmptyStyle(), this.style.setFog(e), this._update(!0) } getFog() { return this.style ? this.style.getFog() : null } _queryFogOpacity(t) { return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.LngLat.convert(t), this.transform) : 0 } setFeatureState(e, t) { return this.style.setFeatureState(e, t), this._update() } removeFeatureState(e, t) { return this.style.removeFeatureState(e, t), this._update() } getFeatureState(e) { return this.style.getFeatureState(e) } _updateContainerDimensions() { if (!this._container) return; const t = this._container.getBoundingClientRect().width || 400, r = this._container.getBoundingClientRect().height || 300; let n, i, o, s = this._container; for (; s && (!i || !o);) { const t = e.window.getComputedStyle(s).transform; t && "none" !== t && (n = t.match(/matrix.*\((.+)\)/)[1].split(", "), n[0] && "0" !== n[0] && "1" !== n[0] && (i = n[0]), n[3] && "0" !== n[3] && "1" !== n[3] && (o = n[3])), s = s.parentElement } this._containerWidth = i ? Math.abs(t / i) : t, this._containerHeight = o ? Math.abs(r / o) : r } _detectMissingCSS() { "rgb(250, 128, 114)" !== e.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.") } _setupContainer() { const e = this._container; e.classList.add("mapboxgl-map"), (this._missingCSSCanary = o("div", "mapboxgl-canary", e)).style.visibility = "hidden", this._detectMissingCSS(); const t = this._canvasContainer = o("div", "mapboxgl-canvas-container", e); this._interactive && t.classList.add("mapboxgl-interactive"), this._canvas = o("canvas", "mapboxgl-canvas", t), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight); const r = this._controlContainer = o("div", "mapboxgl-control-container", e), n = this._controlPositions = {};["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e => { n[e] = o("div", `mapboxgl-ctrl-${e}`, r) })), this._container.addEventListener("scroll", this._onMapScroll, !1) } _resizeCanvas(t, r) { const n = e.exported.devicePixelRatio || 1; this._canvas.width = n * Math.ceil(t), this._canvas.height = n * Math.ceil(r), this._canvas.style.width = `${t}px`, this._canvas.style.height = `${r}px` } _addMarker(e) { this._markers.push(e) } _removeMarker(e) { const t = this._markers.indexOf(e); -1 !== t && this._markers.splice(t, 1) } _addPopup(e) { this._popups.push(e) } _removePopup(e) { const t = this._popups.indexOf(e); -1 !== t && this._popups.splice(t, 1) } _setupPainter() { const t = e.extend({}, r.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }), n = this._useWebGL2 && this._canvas.getContext("webgl2", t), i = n || this._canvas.getContext("webgl", t) || this._canvas.getContext("experimental-webgl", t); i ? (this._useWebGL2 && !n && e.warnOnce("Failed to create WebGL 2 context. Using WebGL 1."), e.storeAuthState(i, !0), this.painter = new Xn(i, this.transform, !!n), this.on("data", (e => { "source" === e.dataType && this.painter.setTileLoadedFlag(!0) })), e.exported$1.testSupport(i)) : this.fire(new e.ErrorEvent(new Error("Failed to initialize WebGL"))) } _contextLost(t) { t.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.Event("webglcontextlost", { originalEvent: t })) } _contextRestored(t) { this._setupPainter(), this.resize(), this._update(), this.fire(new e.Event("webglcontextrestored", { originalEvent: t })) } _onMapScroll(e) { if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1 } loaded() { return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded() } _update(e) { return this.style ? (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint(), this) : this } _requestRenderFrame(e) { return this._update(), this._renderTaskQueue.add(e) } _cancelRenderFrame(e) { this._renderTaskQueue.remove(e) } _requestDomTask(e) { !this.loaded() || this.loaded() && !this.isMoving() ? e() : this._domRenderTaskQueue.add(e) } _render(t) { let r; const n = this.painter.context.extTimerQuery, i = e.exported.now(); if (this.listens("gpu-timing-frame") && (r = n.createQueryEXT(), n.beginQueryEXT(n.TIME_ELAPSED_EXT, r)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], e.window.performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], e.window.performance.now())), this._renderTaskQueue.run(t), this._domRenderTaskQueue.run(t), this._removed) return; this._updateProjectionTransition(); const o = this._isInitialLoad ? 0 : this._fadeDuration; if (this.style && this._styleDirty) { this._styleDirty = !1; const t = this.transform.zoom, r = this.transform.pitch, n = e.exported.now(), i = new e.EvaluationParameters(t, { now: n, fadeDuration: o, pitch: r, transition: this.style.getTransition() }); this.style.update(i) } this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0); let s = !1; if (this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), s = this._updateAverageElevation(i), this.style._updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : s = this._updateAverageElevation(i), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, o, this._crossSourceCollisions), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showTerrainWireframe: this.showTerrainWireframe, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: o, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new e.Event("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), r) { const t = e.exported.now() - i; n.endQueryEXT(n.TIME_ELAPSED_EXT, r), setTimeout((() => { const o = n.getQueryObjectEXT(r, n.QUERY_RESULT_EXT) / 1e6; n.deleteQueryEXT(r), this.fire(new e.Event("gpu-timing-frame", { cpuTime: t, gpuTime: o })), e.window.performance.mark("frame-gpu", { startTime: i, detail: { gpuTime: o } }) }), 50) } if (this.listens("gpu-timing-layer")) { const t = this.painter.collectGpuTimers(); setTimeout((() => { const r = this.painter.queryGpuTimers(t); this.fire(new e.Event("gpu-timing-layer", { layerTimes: r })) }), 50) } if (this.listens("gpu-timing-deferred-render")) { const t = this.painter.collectDeferredRenderGpuQueries(); setTimeout((() => { const r = this.painter.queryGpuTimeDeferredRender(t); this.fire(new e.Event("gpu-timing-deferred-render", { gpuTime: r })) }), 50) } const a = this._sourcesDirty || this._styleDirty || this._placementDirty || s; if (a || this._repaint) this.triggerRepaint(); else { const t = !this.isMoving() && this.loaded(); if (t && (s = this._updateAverageElevation(i, !0)), s) this.triggerRepaint(); else if (this._triggerFrame(!1), t && (this.fire(new e.Event("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) { const t = this._calculateSpeedIndex(); this.fire(new e.Event("speedindexcompleted", { speedIndex: t })), this.speedIndexTiming = !1 } } !this._loaded || this._fullyLoaded || a || (this._fullyLoaded = !0, e.LivePerformanceUtils.mark(e.PerformanceMarkers.fullLoad), this._performanceMetricsCollection && e.postPerformanceEvent(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate()) } _forceMarkerAndPopupUpdate(e) { for (const t of this._markers) e && !this.getRenderWorldCopies() && (t._lngLat = t._lngLat.wrap()), t._update(); for (const t of this._popups) !e || this.getRenderWorldCopies() || t._trackPointer || (t._lngLat = t._lngLat.wrap()), t._update() } _updateAverageElevation(e, t = !1) { const r = e => (this.transform.averageElevation = e, this._update(!1), !0); if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && r(0); if ((t || e - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e)) { const t = this.transform.averageElevation; let n = this.transform.sampleAverageElevation(), i = !1; this.transform.elevation && (i = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration, this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(n) ? n = 0 : this._averageElevationLastSampledAt = e; const o = Math.abs(t - n); if (o > 1) { if (this._isInitialLoad || i) return this._averageElevation.jumpTo(n), r(n); this._averageElevation.easeTo(n, e, 300) } else if (o > 1e-4) return this._averageElevation.jumpTo(n), r(n) } return !!this._averageElevation.isEasing(e) && r(this._averageElevation.getValue(e)) } _authenticate() { e.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (e => { })), e.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (() => { })) } _updateTerrain() { const e = this._isDragging(); this.painter.updateTerrain(this.style, e) } _calculateSpeedIndex() { const e = this.painter.canvasCopy(), t = this.painter.getCanvasCopiesAndTimestamps(); t.timeStamps.push(performance.now()); const r = this.painter.context.gl, n = r.createFramebuffer(); function i(e) { r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, e, 0); const t = new Uint8Array(r.drawingBufferWidth * r.drawingBufferHeight * 4); return r.readPixels(0, 0, r.drawingBufferWidth, r.drawingBufferHeight, r.RGBA, r.UNSIGNED_BYTE, t), t } return r.bindFramebuffer(r.FRAMEBUFFER, n), this._canvasPixelComparison(i(e), t.canvasCopies.map(i), t.timeStamps) } _canvasPixelComparison(e, t, r) { let n = r[1] - r[0]; const i = e.length / 4; for (let o = 0; o < t.length; o++) { const s = t[o]; let a = 0; for (let t = 0; t < s.length; t += 4)s[t] === e[t] && s[t + 1] === e[t + 1] && s[t + 2] === e[t + 2] && s[t + 3] === e[t + 3] && (a += 1); n += (r[o + 2] - r[o + 1]) * (1 - a / i) } return n } remove() { this._hash && this._hash.remove(); for (const e of this._controls) e.onRemove(this); this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), void 0 !== e.window && (e.window.removeEventListener("resize", this._onWindowResize, !1), e.window.removeEventListener("orientationchange", this._onWindowResize, !1), e.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, !1), e.window.removeEventListener("online", this._onWindowOnline, !1), e.window.removeEventListener("visibilitychange", this._onVisibilityChange, !1)); const t = this.painter.context.gl.getExtension("WEBGL_lose_context"); t && t.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), e.removeAuthState(this.painter.context.gl), this._removed = !0, this.fire(new e.Event("remove")) } triggerRepaint() { this._triggerFrame(!0) } _triggerFrame(t) { this._renderNextFrame = this._renderNextFrame || t, this.style && !this._frame && (this._frame = e.exported.frame((e => { const t = !!this._renderNextFrame; this._frame = null, this._renderNextFrame = null, t && this._render(e) }))) } _preloadTiles(t) { const r = this.style ? Object.values(this.style._sourceCaches) : []; return e.asyncAll(r, ((e, r) => e._preloadTiles(t, r)), (() => { this.triggerRepaint() })), this } _onWindowOnline() { this._update() } _onWindowResize(e) { this._trackResize && this.resize({ originalEvent: e })._update() } _onVisibilityChange() { "hidden" === e.window.document.visibilityState && this._visibilityHidden++ } get showTileBoundaries() { return !!this._showTileBoundaries } set showTileBoundaries(e) { this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._update()) } get showTerrainWireframe() { return !!this._showTerrainWireframe } set showTerrainWireframe(e) { this._showTerrainWireframe !== e && (this._showTerrainWireframe = e, this._update()) } get speedIndexTiming() { return !!this._speedIndexTiming } set speedIndexTiming(e) { this._speedIndexTiming !== e && (this._speedIndexTiming = e, this._update()) } get showPadding() { return !!this._showPadding } set showPadding(e) { this._showPadding !== e && (this._showPadding = e, this._update()) } get showCollisionBoxes() { return !!this._showCollisionBoxes } set showCollisionBoxes(e) { this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, e ? this.style._generateCollisionBoxes() : this._update()) } get showOverdrawInspector() { return !!this._showOverdrawInspector } set showOverdrawInspector(e) { this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._update()) } get repaint() { return !!this._repaint } set repaint(e) { this._repaint !== e && (this._repaint = e, this.triggerRepaint()) } get vertices() { return !!this._vertices } set vertices(e) { this._vertices = e, this._update() } get showTileAABBs() { return !!this._showTileAABBs } set showTileAABBs(e) { this._showTileAABBs !== e && (this._showTileAABBs = e, e && this._update()) } _setCacheLimits(t, r) { e.setCacheLimits(t, r) } get version() { return e.version } }, NavigationControl: class { constructor(t) { this.options = e.extend({}, _o, t), this._container = o("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e => e.preventDefault())), this.options.showZoom && (e.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e => { this._map && this._map.zoomIn({}, { originalEvent: e }) })), o("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e => { this._map && this._map.zoomOut({}, { originalEvent: e }) })), o("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e => { const t = this._map; t && (this.options.visualizePitch ? t.resetNorthPitch({}, { originalEvent: e }) : t.resetNorth({}, { originalEvent: e })) })), this._compassIcon = o("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true")) } _updateZoomButtons() { const e = this._map; if (!e) return; const t = e.getZoom(), r = t === e.getMaxZoom(), n = t === e.getMinZoom(); this._zoomInButton.disabled = r, this._zoomOutButton.disabled = n, this._zoomInButton.setAttribute("aria-disabled", r.toString()), this._zoomOutButton.setAttribute("aria-disabled", n.toString()) } _rotateCompassArrow() { const e = this._map; if (!e) return; const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${e.transform.pitch}deg) rotateZ(${e.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e.transform.angle * (180 / Math.PI)}deg)`; e._requestDomTask((() => { this._compassIcon && (this._compassIcon.style.transform = t) })) } onAdd(e) { return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e.on("pitch", this._rotateCompassArrow), e.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new yo(e, this._compass, this.options.visualizePitch)), this._container } onRemove() { const e = this._map; e && (this._container.remove(), this.options.showZoom && e.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e.off("pitch", this._rotateCompassArrow), e.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0) } _createButton(e, t) { const r = o("button", e, this._container); return r.type = "button", r.addEventListener("click", t), r } _setButtonTitle(e, t) { if (!this._map) return; const r = this._map._getUIString(`NavigationControl.${t}`); e.setAttribute("aria-label", r), e.firstElementChild && e.firstElementChild.setAttribute("title", r) } }, GeolocateControl: class extends e.Evented { constructor(t) { super(), this.options = e.extend({ geolocation: e.window.navigator.geolocation }, vo, t), e.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = oi(this._updateMarkerRotation, 20), this._numberOfWatches = 0 } onAdd(e) { return this._map = e, this._container = o("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container } onRemove() { void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1 } _checkGeolocationSupport(t) { const r = (e = !!this.options.geolocation) => { this._supportsGeolocation = e, t(e) }; void 0 !== this._supportsGeolocation ? t(this._supportsGeolocation) : void 0 !== e.window.navigator.permissions ? e.window.navigator.permissions.query({ name: "geolocation" }).then((e => r("denied" !== e.state))).catch((() => r())) : r() } _isOutOfMapMaxBounds(e) { const t = this._map.getMaxBounds(), r = e.coords; return !!t && (r.longitude < t.getWest() || r.longitude > t.getEast() || r.latitude < t.getSouth() || r.latitude > t.getNorth()) } _setErrorState() { switch (this._watchState) { case "WAITING_ACTIVE": this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"); break; case "ACTIVE_LOCK": this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"); break; case "BACKGROUND": this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting") } } _onSuccess(t) { if (this._map) { if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new e.Event("outofmaxbounds", t)), this._updateMarker(), void this._finish(); if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) { case "WAITING_ACTIVE": case "ACTIVE_LOCK": case "ACTIVE_ERROR": this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active"); break; case "BACKGROUND": case "BACKGROUND_ERROR": this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background") }this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("geolocate", t)), this._finish() } } _updateCamera(t) { const r = new e.LngLat(t.coords.longitude, t.coords.latitude), n = t.coords.accuracy, i = this._map.getBearing(), o = e.extend({ bearing: i }, this.options.fitBoundsOptions); this._map.fitBounds(r.toBounds(n), o, { geolocateSource: !0 }) } _updateMarker(t) { if (t) { const r = new e.LngLat(t.coords.longitude, t.coords.latitude); this._accuracyCircleMarker.setLngLat(r).addTo(this._map), this._userLocationDotMarker.setLngLat(r).addTo(this._map), this._accuracy = t.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius() } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove() } _updateCircleRadius() { const t = this._map.transform, r = e.mercatorZfromAltitude(1, t._center.lat) * t.worldSize, n = Math.ceil(2 * this._accuracy * r); this._circleElement.style.width = `${n}px`, this._circleElement.style.height = `${n}px` } _onZoom() { this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius() } _updateMarkerRotation() { this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0)) } _onError(t) { if (this._map) { if (this.options.trackUserLocation) if (1 === t.code) { this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0; const e = this._map._getUIString("GeolocateControl.LocationNotAvailable"); this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e), void 0 !== this._geolocationWatchID && this._clearWatch() } else { if (3 === t.code && this._noTimeout) return; this._setErrorState() } "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("error", t)), this._finish() } } _finish() { this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0 } _setupUI(t) { if (void 0 !== this._map) { if (this._container.addEventListener("contextmenu", (e => e.preventDefault())), this._geolocateButton = o("button", "mapboxgl-ctrl-geolocate", this._container), o("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", !1 === t) { e.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled."); const t = this._map._getUIString("GeolocateControl.LocationNotAvailable"); this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t) } else { const e = this._map._getUIString("GeolocateControl.FindMyLocation"); this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e) } this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = o("div", "mapboxgl-user-location"), this._dotElement.appendChild(o("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(o("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new lo({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = o("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new lo({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (t => { t.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t.originalEvent && "resize" === t.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.Event("trackuserlocationend"))) })) } } _onDeviceOrientation(e) { this._userLocationDotMarker && (e.webkitCompassHeading ? this._heading = e.webkitCompassHeading : !0 === e.absolute && (this._heading = -1 * e.alpha), this._updateMarkerRotationThrottled()) } trigger() { if (!this._setup) return e.warnOnce("Geolocate control triggered before added to a map"), !1; if (this.options.trackUserLocation) { switch (this._watchState) { case "OFF": this._watchState = "WAITING_ACTIVE", this.fire(new e.Event("trackuserlocationstart")); break; case "WAITING_ACTIVE": case "ACTIVE_LOCK": case "ACTIVE_ERROR": case "BACKGROUND_ERROR": this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.Event("trackuserlocationend")); break; case "BACKGROUND": this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.Event("trackuserlocationstart")) }switch (this._watchState) { case "WAITING_ACTIVE": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active"); break; case "ACTIVE_LOCK": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active"); break; case "ACTIVE_ERROR": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"); break; case "BACKGROUND": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"); break; case "BACKGROUND_ERROR": this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error") }if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch(); else if (void 0 === this._geolocationWatchID) { let e; this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = !0) : (e = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e), this.options.showUserHeading && this._addDeviceOrientationListener() } } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4); return !0 } _addDeviceOrientationListener() { const t = () => { e.window.addEventListener("ondeviceorientationabsolute" in e.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation) }; void 0 !== e.window.DeviceMotionEvent && "function" == typeof e.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((e => { "granted" === e && t() })).catch(console.error) : t() } _clearWatch() { this.options.geolocation.clearWatch(this._geolocationWatchID), e.window.removeEventListener("deviceorientation", this._onDeviceOrientation), e.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null) } }, AttributionControl: io, ScaleControl: class { constructor(t) { this.options = e.extend({}, xo, t), function () { try { return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "narrow", unit: "meter" }), !0 } catch (e) { return !1 } }() || (this._setScale = bo.bind(this)), e.bindAll(["_update", "_setScale", "setUnit"], this) } getDefaultPosition() { return "bottom-left" } _update() { const e = this.options.maxWidth || 100, t = this._map, r = t._containerHeight / 2, n = t._containerWidth / 2 - e / 2, i = t.unproject([n, r]), o = t.unproject([n + e, r]), s = i.distanceTo(o); if ("imperial" === this.options.unit) { const t = 3.2808 * s; t > 5280 ? this._setScale(e, t / 5280, "mile") : this._setScale(e, t, "foot") } else "nautical" === this.options.unit ? this._setScale(e, s / 1852, "nautical-mile") : s >= 1e3 ? this._setScale(e, s / 1e3, "kilometer") : this._setScale(e, s, "meter") } _setScale(e, t, r) { const n = wo(t), i = n / t; this._map._requestDomTask((() => { this._container.style.width = e * i + "px", this._container.innerHTML = "nautical-mile" !== r ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "narrow", unit: r }).format(n) : `${n}&nbsp;nm` })) } onAdd(e) { return this._map = e, this._language = e.getLanguage(), this._container = o("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container } onRemove() { this._container.remove(), this._map.off("move", this._update), this._map = void 0 } _setLanguage(e) { this._language = e, this._update() } setUnit(e) { this.options.unit = e, this._update() } }, FullscreenControl: class { constructor(t) { this._fullscreen = !1, t && t.container && (t.container instanceof e.window.HTMLElement ? this._container = t.container : e.warnOnce("Full screen control 'container' must be a DOM element.")), e.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in e.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in e.window.document && (this._fullscreenchange = "webkitfullscreenchange") } onAdd(t) { return this._map = t, this._container || (this._container = this._map.getContainer()), this._controlContainer = o("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.warnOnce("This device does not support fullscreen mode.")), this._controlContainer } onRemove() { this._controlContainer.remove(), this._map = null, e.window.document.removeEventListener(this._fullscreenchange, this._changeIcon) } _checkFullscreenSupport() { return !(!e.window.document.fullscreenEnabled && !e.window.document.webkitFullscreenEnabled) } _setupUI() { const t = this._fullscreenButton = o("button", "mapboxgl-ctrl-fullscreen", this._controlContainer); o("span", "mapboxgl-ctrl-icon", t).setAttribute("aria-hidden", "true"), t.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), e.window.document.addEventListener(this._fullscreenchange, this._changeIcon) } _updateTitle() { const e = this._getTitle(); this._fullscreenButton.setAttribute("aria-label", e), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e) } _getTitle() { return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter") } _isFullscreen() { return this._fullscreen } _changeIcon() { (e.window.document.fullscreenElement || e.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle()) } _onClickFullscreen() { this._isFullscreen() ? e.window.document.exitFullscreen ? e.window.document.exitFullscreen() : e.window.document.webkitCancelFullScreen && e.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen() } }, Popup: class extends e.Evented { constructor(t) { super(), this.options = e.extend(Object.create(uo), t), e.bindAll(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t && t.className ? t.className.trim().split(/\s+/) : []) } addTo(t) { return this._map && this.remove(), this._map = t, this.options.closeOnClick && t.on("preclick", this._onClose), this.options.closeOnMove && t.on("move", this._onClose), t.on("remove", this.remove), this._update(), t._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t.on("mousemove", this._onMouseEvent), t.on("mouseup", this._onMouseEvent), t._canvasContainer.classList.add("mapboxgl-track-pointer")) : t.on("move", this._update), this.fire(new e.Event("open")), this } isOpen() { return !!this._map } remove() { this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0); const t = this._map; return t && (t.off("move", this._update), t.off("move", this._onClose), t.off("preclick", this._onClose), t.off("click", this._onClose), t.off("remove", this.remove), t.off("mousemove", this._onMouseEvent), t.off("mouseup", this._onMouseEvent), t.off("drag", this._onMouseEvent), t._canvasContainer && t._canvasContainer.classList.remove("mapboxgl-track-pointer"), t._removePopup(this), this._map = void 0), this.fire(new e.Event("close")), this } getLngLat() { return this._lngLat } setLngLat(t) { this._lngLat = e.LngLat.convert(t), this._pos = null, this._trackPointer = !1, this._update(); const r = this._map; return r && (r.on("move", this._update), r.off("mousemove", this._onMouseEvent), r._canvasContainer.classList.remove("mapboxgl-track-pointer")), this } trackPointer() { this._trackPointer = !0, this._pos = null, this._update(); const e = this._map; return e && (e.off("move", this._update), e.on("mousemove", this._onMouseEvent), e.on("drag", this._onMouseEvent), e._canvasContainer.classList.add("mapboxgl-track-pointer")), this } getElement() { return this._container } setText(t) { return this.setDOMContent(e.window.document.createTextNode(t)) } setHTML(t) { const r = e.window.document.createDocumentFragment(), n = e.window.document.createElement("body"); let i; for (n.innerHTML = t; i = n.firstChild, i;)r.appendChild(i); return this.setDOMContent(r) } getMaxWidth() { return this._container && this._container.style.maxWidth } setMaxWidth(e) { return this.options.maxWidth = e, this._update(), this } setDOMContent(e) { let t = this._content; if (t) for (; t.hasChildNodes();)t.firstChild && t.removeChild(t.firstChild); else t = this._content = o("div", "mapboxgl-popup-content", this._container || void 0); if (t.appendChild(e), this.options.closeButton) { const e = this._closeButton = o("button", "mapboxgl-popup-close-button", t); e.type = "button", e.setAttribute("aria-label", "Close popup"), e.setAttribute("aria-hidden", "true"), e.innerHTML = "&#215;", e.addEventListener("click", this._onClose) } return this._update(), this._focusFirstElement(), this } addClassName(e) { return this._classList.add(e), this._updateClassList(), this } removeClassName(e) { return this._classList.delete(e), this._updateClassList(), this } setOffset(e) { return this.options.offset = e, this._update(), this } toggleClassName(e) { let t; return this._classList.delete(e) ? t = !1 : (this._classList.add(e), t = !0), this._updateClassList(), t } _onMouseEvent(e) { this._update(e.point) } _getAnchor(e) { if (this.options.anchor) return this.options.anchor; const t = this._map, r = this._container, n = this._pos; if (!t || !r || !n) return "bottom"; const i = r.offsetWidth, o = r.offsetHeight, s = n.x < i / 2, a = n.x > t.transform.width - i / 2; if (n.y + e < o) return s ? "top-left" : a ? "top-right" : "top"; if (n.y > t.transform.height - o) { if (s) return "bottom-left"; if (a) return "bottom-right" } return s ? "left" : a ? "right" : "bottom" } _updateClassList() { const e = this._container; if (!e) return; const t = [...this._classList]; t.push("mapboxgl-popup"), this._anchor && t.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t.push("mapboxgl-popup-track-pointer"), e.className = t.join(" ") } _update(t) { const r = this._map, n = this._content; if (!r || !this._lngLat && !this._trackPointer || !n) return; let i = this._container; if (i || (i = this._container = o("div", "mapboxgl-popup", r.getContainer()), this._tip = o("div", "mapboxgl-popup-tip", i), i.appendChild(n)), this.options.maxWidth && i.style.maxWidth !== this.options.maxWidth && (i.style.maxWidth = this.options.maxWidth), r.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = ao(this._lngLat, this._pos, r.transform)), !this._trackPointer || t) { const e = this._pos = this._trackPointer && t ? t : r.project(this._lngLat), n = po(this.options.offset), i = this._anchor = this._getAnchor(n.y), o = po(this.options.offset, i), s = e.add(o).round(); r._requestDomTask((() => { this._container && i && (this._container.style.transform = `${co[i]} translate(${s.x}px,${s.y}px)`) })) } if (!this._marker && r._showingGlobe()) { const t = e.isLngLatBehindGlobe(r.transform, this._lngLat) ? 0 : 1; this._setOpacity(t) } this._updateClassList() } _focusFirstElement() { if (!this.options.focusAfterOpen || !this._container) return; const e = this._container.querySelector(ho); e && e.focus() } _onClose() { this.remove() } _setOpacity(e) { this._container && (this._container.style.opacity = `${e}`), this._content && (this._content.style.pointerEvents = e ? "auto" : "none") } }, Marker: lo, Style: rr, LngLat: e.LngLat, LngLatBounds: e.LngLatBounds, Point: e.pointGeometry, MercatorCoordinate: e.MercatorCoordinate, FreeCameraOptions: $n, Evented: e.Evented, config: e.config, prewarm: function () { je().acquire(Ge) }, clearPrewarmedResources: function () { const e = qe; e && (e.isPreloaded() && 1 === e.numActive() ? (e.release(Ge), qe = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()")) }, get accessToken() { return e.config.ACCESS_TOKEN }, set accessToken(t) { e.config.ACCESS_TOKEN = t }, get baseApiUrl() { return e.config.API_URL }, set baseApiUrl(t) { e.config.API_URL = t }, get workerCount() { return Ve.workerCount }, set workerCount(e) { Ve.workerCount = e }, get maxParallelImageRequests() { return e.config.MAX_PARALLEL_IMAGE_REQUESTS }, set maxParallelImageRequests(t) { e.config.MAX_PARALLEL_IMAGE_REQUESTS = t }, clearStorage(t) { e.clearTileCache(t) }, workerUrl: "", workerClass: null, setNow: e.exported.setNow, restoreNow: e.exported.restoreNow }; return To })), r }() })); function Fe(e, t) { void 0 === t && (t = {}); var r = t.insertAt; if (e && "undefined" != typeof document) { var n = document.head || document.getElementsByTagName("head")[0], i = document.createElement("style"); i.type = "text/css", "top" === r && n.firstChild ? n.insertBefore(i, n.firstChild) : n.appendChild(i), i.styleSheet ? i.styleSheet.cssText = e : i.appendChild(document.createTextNode(e)) } } Fe(".mapboxgl-map{font:12px/20px Helvetica Neue,Arial,Helvetica,sans-serif;overflow:hidden;position:relative;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mapboxgl-canvas{position:absolute;left:0;top:0}.mapboxgl-map:-webkit-full-screen{width:100%;height:100%}.mapboxgl-canary{background-color:salmon}.mapboxgl-canvas-container.mapboxgl-interactive,.mapboxgl-ctrl-group button.mapboxgl-ctrl-compass{cursor:-webkit-grab;cursor:-moz-grab;cursor:grab;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.mapboxgl-canvas-container.mapboxgl-interactive.mapboxgl-track-pointer{cursor:pointer}.mapboxgl-canvas-container.mapboxgl-interactive:active,.mapboxgl-ctrl-group button.mapboxgl-ctrl-compass:active{cursor:-webkit-grabbing;cursor:-moz-grabbing;cursor:grabbing}.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate,.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate .mapboxgl-canvas{touch-action:pan-x pan-y}.mapboxgl-canvas-container.mapboxgl-touch-drag-pan,.mapboxgl-canvas-container.mapboxgl-touch-drag-pan .mapboxgl-canvas{touch-action:pinch-zoom}.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan,.mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan .mapboxgl-canvas{touch-action:none}.mapboxgl-ctrl-bottom-left,.mapboxgl-ctrl-bottom-right,.mapboxgl-ctrl-top-left,.mapboxgl-ctrl-top-right{position:absolute;pointer-events:none;z-index:0;display: none;}.mapboxgl-ctrl-top-left{top:0;left:0}.mapboxgl-ctrl-top-right{top:0;right:0}.mapboxgl-ctrl-bottom-left{bottom:0;left:0}.mapboxgl-ctrl-bottom-right{right:0;bottom:0}.mapboxgl-ctrl{clear:both;pointer-events:auto;transform:translate(0)}.mapboxgl-ctrl-top-left .mapboxgl-ctrl{margin:10px 0 0 10px;float:left}.mapboxgl-ctrl-top-right .mapboxgl-ctrl{margin:10px 10px 0 0;float:right}.mapboxgl-ctrl-bottom-left .mapboxgl-ctrl{margin:0 0 10px 10px;float:left}.mapboxgl-ctrl-bottom-right .mapboxgl-ctrl{margin:0 10px 10px 0;float:right}.mapboxgl-ctrl-group{border-radius:4px;background:#fff}.mapboxgl-ctrl-group:not(:empty){-moz-box-shadow:0 0 2px rgba(0,0,0,.1);-webkit-box-shadow:0 0 2px rgba(0,0,0,.1);box-shadow:0 0 0 2px rgba(0,0,0,.1)}@media (-ms-high-contrast:active){.mapboxgl-ctrl-group:not(:empty){box-shadow:0 0 0 2px ButtonText}}.mapboxgl-ctrl-group button{width:29px;height:29px;display:block;padding:0;outline:none;border:0;box-sizing:border-box;background-color:transparent;cursor:pointer}.mapboxgl-ctrl-group button+button{border-top:1px solid #ddd}.mapboxgl-ctrl button .mapboxgl-ctrl-icon{display:block;width:100%;height:100%;background-repeat:no-repeat;background-position:50%}@media (-ms-high-contrast:active){.mapboxgl-ctrl-icon{background-color:transparent}.mapboxgl-ctrl-group button+button{border-top:1px solid ButtonText}}.mapboxgl-ctrl button::-moz-focus-inner{border:0;padding:0}.mapboxgl-ctrl-group button:focus{box-shadow:0 0 2px 2px #0096ff}.mapboxgl-ctrl button:disabled{cursor:not-allowed}.mapboxgl-ctrl button:disabled .mapboxgl-ctrl-icon{opacity:.25}.mapboxgl-ctrl button:not(:disabled):hover{background-color:rgba(0,0,0,.05)}.mapboxgl-ctrl-group button:focus:focus-visible{box-shadow:0 0 2px 2px #0096ff}.mapboxgl-ctrl-group button:focus:not(:focus-visible){box-shadow:none}.mapboxgl-ctrl-group button:focus:first-child{border-radius:4px 4px 0 0}.mapboxgl-ctrl-group button:focus:last-child{border-radius:0 0 4px 4px}.mapboxgl-ctrl-group button:focus:only-child{border-radius:inherit}.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-out .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-in .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E\")}@media (-ms-high-contrast:active){.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-out .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-in .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E\")}}@media (-ms-high-contrast:black-on-white){.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-out .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-9z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-zoom-in .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5z'/%3E%3C/svg%3E\")}}.mapboxgl-ctrl button.mapboxgl-ctrl-fullscreen .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-shrink .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E\")}@media (-ms-high-contrast:active){.mapboxgl-ctrl button.mapboxgl-ctrl-fullscreen .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-shrink .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E\")}}@media (-ms-high-contrast:black-on-white){.mapboxgl-ctrl button.mapboxgl-ctrl-fullscreen .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3h1zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16h1zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5H13zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1V7.5z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-shrink .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1h-5.5zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1v-5.5zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1v5.5zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1h5.5z'/%3E%3C/svg%3E\")}}.mapboxgl-ctrl button.mapboxgl-ctrl-compass .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E\")}@media (-ms-high-contrast:active){.mapboxgl-ctrl button.mapboxgl-ctrl-compass .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath d='M10.5 16l4 8 4-8h-8z' fill='%23999'/%3E%3C/svg%3E\")}}@media (-ms-high-contrast:black-on-white){.mapboxgl-ctrl button.mapboxgl-ctrl-compass .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E\")}}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate:disabled .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23aaa'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath d='M14 5l1 1-9 9-1-1 9-9z' fill='red'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active-error .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e58978'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background-error .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e54e33'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-waiting .mapboxgl-ctrl-icon{-webkit-animation:mapboxgl-spin 2s linear infinite;-moz-animation:mapboxgl-spin 2s infinite linear;-o-animation:mapboxgl-spin 2s infinite linear;-ms-animation:mapboxgl-spin 2s infinite linear;animation:mapboxgl-spin 2s linear infinite}@media (-ms-high-contrast:active){.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23fff'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate:disabled .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23999'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath d='M14 5l1 1-9 9-1-1 9-9z' fill='red'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-active-error .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e58978'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%2333b5e5'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate.mapboxgl-ctrl-geolocate-background-error .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23e54e33'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3C/svg%3E\")}}@media (-ms-high-contrast:black-on-white){.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E\")}.mapboxgl-ctrl button.mapboxgl-ctrl-geolocate:disabled .mapboxgl-ctrl-icon{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill='%23666'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 005.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 009 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 003.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0011 5.1V5s0-1-1-1zm0 2.5a3.5 3.5 0 110 7 3.5 3.5 0 110-7z'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath d='M14 5l1 1-9 9-1-1 9-9z' fill='red'/%3E%3C/svg%3E\")}}@-webkit-keyframes mapboxgl-spin{0%{-webkit-transform:rotate(0deg)}to{-webkit-transform:rotate(1turn)}}@-moz-keyframes mapboxgl-spin{0%{-moz-transform:rotate(0deg)}to{-moz-transform:rotate(1turn)}}@-o-keyframes mapboxgl-spin{0%{-o-transform:rotate(0deg)}to{-o-transform:rotate(1turn)}}@-ms-keyframes mapboxgl-spin{0%{-ms-transform:rotate(0deg)}to{-ms-transform:rotate(1turn)}}@keyframes mapboxgl-spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}a.mapboxgl-ctrl-logo{width:88px;height:23px;margin:0 0 -4px -4px;display:block;background-repeat:no-repeat;cursor:pointer;overflow:hidden;background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='88' height='23' viewBox='0 0 88 23' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' fill-rule='evenodd'%3E%3Cdefs%3E%3Cpath id='a' d='M11.5 2.25c5.105 0 9.25 4.145 9.25 9.25s-4.145 9.25-9.25 9.25-9.25-4.145-9.25-9.25 4.145-9.25 9.25-9.25zM6.997 15.983c-.051-.338-.828-5.802 2.233-8.873a4.395 4.395 0 013.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39 0 1.18-.449 2.301-1.28 3.13C12.72 16.93 7 16 7 16l-.003-.017zM15.3 10.5l-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z'/%3E%3Cpath id='b' d='M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19c-1.04 0-2.03-.43-2.74-1.18v3.77c0 .13-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01c.01 0 .01 0 .01-.01.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V15c-.7.76-1.69 1.19-2.73 1.19-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.375-.19a4.24 4.24 0 00-4.16 3.29c-.13.59-.13 1.19 0 1.77a4.233 4.233 0 004.17 3.3c2.35 0 4.26-1.87 4.26-4.19 0-2.32-1.9-4.17-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18 1.88 0 3.45 1.4 3.84 3.28.13.59.13 1.2 0 1.8-.39 1.88-1.96 3.29-3.84 3.29-1.03 0-2.02-.43-2.73-1.18v.77c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4c-.13 0-.23-.11-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55.45-.95 1.4-1.55 2.44-1.56 1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.615 0h-1.61c-.04 0-.08-.01-.12-.03-.09-.06-.13-.19-.06-.28l2.43-3.71-2.39-3.65a.213.213 0 01-.03-.12c0-.12.09-.21.21-.21h1.61c.13 0 .24.06.3.17l1.41 2.37 1.4-2.37a.34.34 0 01.3-.17h1.6c.04 0 .08.01.12.03.09.06.13.19.06.28l-2.37 3.65 2.43 3.7c0 .05.01.09.01.13 0 .12-.09.21-.21.21h-1.61c-.13 0-.24-.06-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 01-.3.17zm-7.12-1.49c-1.33 0-2.42-1.12-2.42-2.51 0-1.39 1.08-2.52 2.42-2.52 1.33 0 2.42 1.12 2.42 2.51 0 1.39-1.08 2.51-2.42 2.52zm-19.865 0c-1.32 0-2.39-1.11-2.42-2.48v-.07c.02-1.38 1.09-2.49 2.4-2.49 1.32 0 2.41 1.12 2.41 2.51 0 1.39-1.07 2.52-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51c0-1.39 1.08-2.52 2.4-2.52 1.33 0 2.39 1.11 2.41 2.48l.02.08zm18.12 2.47c-1.32 0-2.39-1.11-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51c0 1.39-1.09 2.51-2.42 2.51z'/%3E%3C/defs%3E%3Cmask id='c'%3E%3Crect width='100%25' height='100%25' fill='%23fff'/%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/mask%3E%3Cg opacity='.3' stroke='%23000' stroke-width='3'%3E%3Ccircle mask='url(%23c)' cx='11.5' cy='11.5' r='9.25'/%3E%3Cuse xlink:href='%23b' mask='url(%23c)'/%3E%3C/g%3E%3Cg opacity='.9' fill='%23fff'%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/g%3E%3C/svg%3E\")}a.mapboxgl-ctrl-logo.mapboxgl-compact{width:23px}@media (-ms-high-contrast:active){a.mapboxgl-ctrl-logo{background-color:transparent;background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='88' height='23' viewBox='0 0 88 23' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' fill-rule='evenodd'%3E%3Cdefs%3E%3Cpath id='a' d='M11.5 2.25c5.105 0 9.25 4.145 9.25 9.25s-4.145 9.25-9.25 9.25-9.25-4.145-9.25-9.25 4.145-9.25 9.25-9.25zM6.997 15.983c-.051-.338-.828-5.802 2.233-8.873a4.395 4.395 0 013.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39 0 1.18-.449 2.301-1.28 3.13C12.72 16.93 7 16 7 16l-.003-.017zM15.3 10.5l-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z'/%3E%3Cpath id='b' d='M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19c-1.04 0-2.03-.43-2.74-1.18v3.77c0 .13-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01c.01 0 .01 0 .01-.01.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V15c-.7.76-1.69 1.19-2.73 1.19-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.375-.19a4.24 4.24 0 00-4.16 3.29c-.13.59-.13 1.19 0 1.77a4.233 4.233 0 004.17 3.3c2.35 0 4.26-1.87 4.26-4.19 0-2.32-1.9-4.17-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18 1.88 0 3.45 1.4 3.84 3.28.13.59.13 1.2 0 1.8-.39 1.88-1.96 3.29-3.84 3.29-1.03 0-2.02-.43-2.73-1.18v.77c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4c-.13 0-.23-.11-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55.45-.95 1.4-1.55 2.44-1.56 1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.615 0h-1.61c-.04 0-.08-.01-.12-.03-.09-.06-.13-.19-.06-.28l2.43-3.71-2.39-3.65a.213.213 0 01-.03-.12c0-.12.09-.21.21-.21h1.61c.13 0 .24.06.3.17l1.41 2.37 1.4-2.37a.34.34 0 01.3-.17h1.6c.04 0 .08.01.12.03.09.06.13.19.06.28l-2.37 3.65 2.43 3.7c0 .05.01.09.01.13 0 .12-.09.21-.21.21h-1.61c-.13 0-.24-.06-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 01-.3.17zm-7.12-1.49c-1.33 0-2.42-1.12-2.42-2.51 0-1.39 1.08-2.52 2.42-2.52 1.33 0 2.42 1.12 2.42 2.51 0 1.39-1.08 2.51-2.42 2.52zm-19.865 0c-1.32 0-2.39-1.11-2.42-2.48v-.07c.02-1.38 1.09-2.49 2.4-2.49 1.32 0 2.41 1.12 2.41 2.51 0 1.39-1.07 2.52-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51c0-1.39 1.08-2.52 2.4-2.52 1.33 0 2.39 1.11 2.41 2.48l.02.08zm18.12 2.47c-1.32 0-2.39-1.11-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51c0 1.39-1.09 2.51-2.42 2.51z'/%3E%3C/defs%3E%3Cmask id='c'%3E%3Crect width='100%25' height='100%25' fill='%23fff'/%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/mask%3E%3Cg stroke='%23000' stroke-width='3'%3E%3Ccircle mask='url(%23c)' cx='11.5' cy='11.5' r='9.25'/%3E%3Cuse xlink:href='%23b' mask='url(%23c)'/%3E%3C/g%3E%3Cg fill='%23fff'%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/g%3E%3C/svg%3E\")}}@media (-ms-high-contrast:black-on-white){a.mapboxgl-ctrl-logo{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='88' height='23' viewBox='0 0 88 23' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' fill-rule='evenodd'%3E%3Cdefs%3E%3Cpath id='a' d='M11.5 2.25c5.105 0 9.25 4.145 9.25 9.25s-4.145 9.25-9.25 9.25-9.25-4.145-9.25-9.25 4.145-9.25 9.25-9.25zM6.997 15.983c-.051-.338-.828-5.802 2.233-8.873a4.395 4.395 0 013.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39 0 1.18-.449 2.301-1.28 3.13C12.72 16.93 7 16 7 16l-.003-.017zM15.3 10.5l-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z'/%3E%3Cpath id='b' d='M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19c-1.04 0-2.03-.43-2.74-1.18v3.77c0 .13-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01c.01 0 .01 0 .01-.01.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V15c-.7.76-1.69 1.19-2.73 1.19-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.375-.19a4.24 4.24 0 00-4.16 3.29c-.13.59-.13 1.19 0 1.77a4.233 4.233 0 004.17 3.3c2.35 0 4.26-1.87 4.26-4.19 0-2.32-1.9-4.17-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18 1.88 0 3.45 1.4 3.84 3.28.13.59.13 1.2 0 1.8-.39 1.88-1.96 3.29-3.84 3.29-1.03 0-2.02-.43-2.73-1.18v.77c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4c-.13 0-.23-.11-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55.45-.95 1.4-1.55 2.44-1.56 1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.615 0h-1.61c-.04 0-.08-.01-.12-.03-.09-.06-.13-.19-.06-.28l2.43-3.71-2.39-3.65a.213.213 0 01-.03-.12c0-.12.09-.21.21-.21h1.61c.13 0 .24.06.3.17l1.41 2.37 1.4-2.37a.34.34 0 01.3-.17h1.6c.04 0 .08.01.12.03.09.06.13.19.06.28l-2.37 3.65 2.43 3.7c0 .05.01.09.01.13 0 .12-.09.21-.21.21h-1.61c-.13 0-.24-.06-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 01-.3.17zm-7.12-1.49c-1.33 0-2.42-1.12-2.42-2.51 0-1.39 1.08-2.52 2.42-2.52 1.33 0 2.42 1.12 2.42 2.51 0 1.39-1.08 2.51-2.42 2.52zm-19.865 0c-1.32 0-2.39-1.11-2.42-2.48v-.07c.02-1.38 1.09-2.49 2.4-2.49 1.32 0 2.41 1.12 2.41 2.51 0 1.39-1.07 2.52-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51c0-1.39 1.08-2.52 2.4-2.52 1.33 0 2.39 1.11 2.41 2.48l.02.08zm18.12 2.47c-1.32 0-2.39-1.11-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51c0 1.39-1.09 2.51-2.42 2.51z'/%3E%3C/defs%3E%3Cmask id='c'%3E%3Crect width='100%25' height='100%25' fill='%23fff'/%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/mask%3E%3Cg stroke='%23fff' stroke-width='3' fill='%23fff'%3E%3Ccircle mask='url(%23c)' cx='11.5' cy='11.5' r='9.25'/%3E%3Cuse xlink:href='%23b' mask='url(%23c)'/%3E%3C/g%3E%3Cuse xlink:href='%23a'/%3E%3Cuse xlink:href='%23b'/%3E%3C/svg%3E\")}}.mapboxgl-ctrl.mapboxgl-ctrl-attrib{padding:0 5px;background-color:hsla(0,0%,100%,.5);margin:0}@media screen{.mapboxgl-ctrl-attrib.mapboxgl-compact{min-height:20px;padding:0;margin:10px;position:relative;background-color:#fff;border-radius:3px 12px 12px 3px}.mapboxgl-ctrl-attrib.mapboxgl-compact:hover{padding:2px 24px 2px 4px;visibility:visible;margin-top:6px}.mapboxgl-ctrl-bottom-left>.mapboxgl-ctrl-attrib.mapboxgl-compact:hover,.mapboxgl-ctrl-top-left>.mapboxgl-ctrl-attrib.mapboxgl-compact:hover{padding:2px 4px 2px 24px;border-radius:12px 3px 3px 12px}.mapboxgl-ctrl-attrib.mapboxgl-compact .mapboxgl-ctrl-attrib-inner{display:none}.mapboxgl-ctrl-attrib.mapboxgl-compact:hover .mapboxgl-ctrl-attrib-inner{display:block}.mapboxgl-ctrl-attrib.mapboxgl-compact:after{content:\"\";cursor:pointer;position:absolute;background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd'%3E%3Cpath d='M4 10a6 6 0 1012 0 6 6 0 10-12 0m5-3a1 1 0 102 0 1 1 0 10-2 0m0 3a1 1 0 112 0v3a1 1 0 11-2 0'/%3E%3C/svg%3E\");background-color:hsla(0,0%,100%,.5);width:24px;height:24px;box-sizing:border-box;border-radius:12px}.mapboxgl-ctrl-bottom-right>.mapboxgl-ctrl-attrib.mapboxgl-compact:after{bottom:0;right:0}.mapboxgl-ctrl-top-right>.mapboxgl-ctrl-attrib.mapboxgl-compact:after{top:0;right:0}.mapboxgl-ctrl-top-left>.mapboxgl-ctrl-attrib.mapboxgl-compact:after{top:0;left:0}.mapboxgl-ctrl-bottom-left>.mapboxgl-ctrl-attrib.mapboxgl-compact:after{bottom:0;left:0}}@media screen and (-ms-high-contrast:active){.mapboxgl-ctrl-attrib.mapboxgl-compact:after{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd' fill='%23fff'%3E%3Cpath d='M4 10a6 6 0 1012 0 6 6 0 10-12 0m5-3a1 1 0 102 0 1 1 0 10-2 0m0 3a1 1 0 112 0v3a1 1 0 11-2 0'/%3E%3C/svg%3E\")}}@media screen and (-ms-high-contrast:black-on-white){.mapboxgl-ctrl-attrib.mapboxgl-compact:after{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd'%3E%3Cpath d='M4 10a6 6 0 1012 0 6 6 0 10-12 0m5-3a1 1 0 102 0 1 1 0 10-2 0m0 3a1 1 0 112 0v3a1 1 0 11-2 0'/%3E%3C/svg%3E\")}}.mapboxgl-ctrl-attrib a{color:rgba(0,0,0,.75);text-decoration:none}.mapboxgl-ctrl-attrib a:hover{color:inherit;text-decoration:underline}.mapboxgl-ctrl-attrib .mapbox-improve-map{font-weight:700;margin-left:2px}.mapboxgl-attrib-empty{display:none}.mapboxgl-ctrl-scale{background-color:hsla(0,0%,100%,.75);font-size:10px;border:2px solid #333;border-top:#333;padding:0 5px;color:#333;box-sizing:border-box}.mapboxgl-popup{position:absolute;top:0;left:0;display:-webkit-flex;display:flex;will-change:transform;pointer-events:none}.mapboxgl-popup-anchor-top,.mapboxgl-popup-anchor-top-left,.mapboxgl-popup-anchor-top-right{-webkit-flex-direction:column;flex-direction:column}.mapboxgl-popup-anchor-bottom,.mapboxgl-popup-anchor-bottom-left,.mapboxgl-popup-anchor-bottom-right{-webkit-flex-direction:column-reverse;flex-direction:column-reverse}.mapboxgl-popup-anchor-left{-webkit-flex-direction:row;flex-direction:row}.mapboxgl-popup-anchor-right{-webkit-flex-direction:row-reverse;flex-direction:row-reverse}.mapboxgl-popup-tip{width:0;height:0;border:10px solid transparent;z-index:1}.mapboxgl-popup-anchor-top .mapboxgl-popup-tip{-webkit-align-self:center;align-self:center;border-top:none;border-bottom-color:#fff}.mapboxgl-popup-anchor-top-left .mapboxgl-popup-tip{-webkit-align-self:flex-start;align-self:flex-start;border-top:none;border-left:none;border-bottom-color:#fff}.mapboxgl-popup-anchor-top-right .mapboxgl-popup-tip{-webkit-align-self:flex-end;align-self:flex-end;border-top:none;border-right:none;border-bottom-color:#fff}.mapboxgl-popup-anchor-bottom .mapboxgl-popup-tip{-webkit-align-self:center;align-self:center;border-bottom:none;border-top-color:#fff}.mapboxgl-popup-anchor-bottom-left .mapboxgl-popup-tip{-webkit-align-self:flex-start;align-self:flex-start;border-bottom:none;border-left:none;border-top-color:#fff}.mapboxgl-popup-anchor-bottom-right .mapboxgl-popup-tip{-webkit-align-self:flex-end;align-self:flex-end;border-bottom:none;border-right:none;border-top-color:#fff}.mapboxgl-popup-anchor-left .mapboxgl-popup-tip{-webkit-align-self:center;align-self:center;border-left:none;border-right-color:#fff}.mapboxgl-popup-anchor-right .mapboxgl-popup-tip{-webkit-align-self:center;align-self:center;border-right:none;border-left-color:#fff}.mapboxgl-popup-close-button{position:absolute;right:0;top:0;border:0;border-radius:0 3px 0 0;cursor:pointer;background-color:transparent}.mapboxgl-popup-close-button:hover{background-color:rgba(0,0,0,.05)}.mapboxgl-popup-content{position:relative;background:#fff;border-radius:3px;box-shadow:0 1px 2px rgba(0,0,0,.1);padding:10px 10px 15px;pointer-events:auto}.mapboxgl-popup-anchor-top-left .mapboxgl-popup-content{border-top-left-radius:0}.mapboxgl-popup-anchor-top-right .mapboxgl-popup-content{border-top-right-radius:0}.mapboxgl-popup-anchor-bottom-left .mapboxgl-popup-content{border-bottom-left-radius:0}.mapboxgl-popup-anchor-bottom-right .mapboxgl-popup-content{border-bottom-right-radius:0}.mapboxgl-popup-track-pointer{display:none}.mapboxgl-popup-track-pointer *{pointer-events:none;user-select:none}.mapboxgl-map:hover .mapboxgl-popup-track-pointer{display:flex}.mapboxgl-map:active .mapboxgl-popup-track-pointer{display:none}.mapboxgl-marker{position:absolute;top:0;left:0;will-change:transform}.mapboxgl-user-location-dot,.mapboxgl-user-location-dot:before{background-color:#1da1f2;width:15px;height:15px;border-radius:50%}.mapboxgl-user-location-dot:before{content:\"\";position:absolute;-webkit-animation:mapboxgl-user-location-dot-pulse 2s infinite;-moz-animation:mapboxgl-user-location-dot-pulse 2s infinite;-ms-animation:mapboxgl-user-location-dot-pulse 2s infinite;animation:mapboxgl-user-location-dot-pulse 2s infinite}.mapboxgl-user-location-dot:after{border-radius:50%;border:2px solid #fff;content:\"\";height:19px;left:-2px;position:absolute;top:-2px;width:19px;box-sizing:border-box;box-shadow:0 0 3px rgba(0,0,0,.35)}@-webkit-keyframes mapboxgl-user-location-dot-pulse{0%{-webkit-transform:scale(1);opacity:1}70%{-webkit-transform:scale(3);opacity:0}to{-webkit-transform:scale(1);opacity:0}}@-ms-keyframes mapboxgl-user-location-dot-pulse{0%{-ms-transform:scale(1);opacity:1}70%{-ms-transform:scale(3);opacity:0}to{-ms-transform:scale(1);opacity:0}}@keyframes mapboxgl-user-location-dot-pulse{0%{transform:scale(1);opacity:1}70%{transform:scale(3);opacity:0}to{transform:scale(1);opacity:0}}.mapboxgl-user-location-dot-stale{background-color:#aaa}.mapboxgl-user-location-dot-stale:after{display:none}.mapboxgl-user-location-accuracy-circle{background-color:rgba(29,161,242,.2);width:1px;height:1px;border-radius:100%}.mapboxgl-crosshair,.mapboxgl-crosshair .mapboxgl-interactive,.mapboxgl-crosshair .mapboxgl-interactive:active{cursor:crosshair}.mapboxgl-boxzoom{position:absolute;top:0;left:0;width:0;height:0;background:#fff;border:2px dotted #202020;opacity:.5}@media print{.mapbox-improve-map{display:none}}"); var Oe = ve((function (e, t) { e.exports = function () { var e = function (e, t) { var r = { drag: [], click: [], mousemove: [], mousedown: [], mouseup: [], mouseout: [], keydown: [], keyup: [], touchstart: [], touchmove: [], touchend: [], tap: [] }, n = { on: function (e, t, n) { if (void 0 === r[e]) throw new Error("Invalid event type: " + e); r[e].push({ selector: t, fn: n }) }, render: function (e) { t.store.featureChanged(e) } }, i = function (e, i) { for (var o = r[e], s = o.length; s--;) { var a = o[s]; if (a.selector(i)) { a.fn.call(n, i) || t.store.render(), t.ui.updateMapClasses(); break } } }; return e.start.call(n), { render: e.render, stop: function () { e.stop && e.stop() }, trash: function () { e.trash && (e.trash(), t.store.render()) }, combineFeatures: function () { e.combineFeatures && e.combineFeatures() }, uncombineFeatures: function () { e.uncombineFeatures && e.uncombineFeatures() }, drag: function (e) { i("drag", e) }, click: function (e) { i("click", e) }, mousemove: function (e) { i("mousemove", e) }, mousedown: function (e) { i("mousedown", e) }, mouseup: function (e) { i("mouseup", e) }, mouseout: function (e) { i("mouseout", e) }, keydown: function (e) { i("keydown", e) }, keyup: function (e) { i("keyup", e) }, touchstart: function (e) { i("touchstart", e) }, touchmove: function (e) { i("touchmove", e) }, touchend: function (e) { i("touchend", e) }, tap: function (e) { i("tap", e) } } }, t = { RADIUS: 6378137, FLATTENING: 1 / 298.257223563, POLAR_RADIUS: 6356752.3142 }; function r(e) { var t, i = 0; switch (e.type) { case "Polygon": return n(e.coordinates); case "MultiPolygon": for (t = 0; t < e.coordinates.length; t++)i += n(e.coordinates[t]); return i; case "Point": case "MultiPoint": case "LineString": case "MultiLineString": return 0; case "GeometryCollection": for (t = 0; t < e.geometries.length; t++)i += r(e.geometries[t]); return i } } function n(e) { var t = 0; if (e && e.length > 0) { t += Math.abs(i(e[0])); for (var r = 1; r < e.length; r++)t -= Math.abs(i(e[r])) } return t } function i(e) { var r, n, i, s, a, c, l = 0, u = e.length; if (u > 2) { for (c = 0; c < u; c++)c === u - 2 ? (i = u - 2, s = u - 1, a = 0) : c === u - 1 ? (i = u - 1, s = 0, a = 1) : (i = c, s = c + 1, a = c + 2), r = e[i], n = e[s], l += (o(e[a][0]) - o(r[0])) * Math.sin(o(n[1])); l = l * t.RADIUS * t.RADIUS / 2 } return l } function o(e) { return e * Math.PI / 180 } var s = { geometry: r, ring: i }, a = { CONTROL_BASE: "mapboxgl-ctrl", CONTROL_PREFIX: "mapboxgl-ctrl-", CONTROL_BUTTON: "mapbox-gl-draw_ctrl-draw-btn", CONTROL_BUTTON_LINE: "mapbox-gl-draw_line", CONTROL_BUTTON_POLYGON: "mapbox-gl-draw_polygon", CONTROL_BUTTON_POINT: "mapbox-gl-draw_point", CONTROL_BUTTON_TRASH: "mapbox-gl-draw_trash", CONTROL_BUTTON_COMBINE_FEATURES: "mapbox-gl-draw_combine", CONTROL_BUTTON_UNCOMBINE_FEATURES: "mapbox-gl-draw_uncombine", CONTROL_GROUP: "mapboxgl-ctrl-group", ATTRIBUTION: "mapboxgl-ctrl-attrib", ACTIVE_BUTTON: "active", BOX_SELECT: "mapbox-gl-draw_boxselect" }, c = { HOT: "mapbox-gl-draw-hot", COLD: "mapbox-gl-draw-cold" }, l = { ADD: "add", MOVE: "move", DRAG: "drag", POINTER: "pointer", NONE: "none" }, u = { POLYGON: "polygon", LINE: "line_string", POINT: "point" }, h = { FEATURE: "Feature", POLYGON: "Polygon", LINE_STRING: "LineString", POINT: "Point", FEATURE_COLLECTION: "FeatureCollection", MULTI_PREFIX: "Multi", MULTI_POINT: "MultiPoint", MULTI_LINE_STRING: "MultiLineString", MULTI_POLYGON: "MultiPolygon" }, d = { DRAW_LINE_STRING: "draw_line_string", DRAW_POLYGON: "draw_polygon", DRAW_POINT: "draw_point", SIMPLE_SELECT: "simple_select", DIRECT_SELECT: "direct_select", STATIC: "static" }, p = { CREATE: "draw.create", DELETE: "draw.delete", UPDATE: "draw.update", SELECTION_CHANGE: "draw.selectionchange", MODE_CHANGE: "draw.modechange", ACTIONABLE: "draw.actionable", RENDER: "draw.render", COMBINE_FEATURES: "draw.combine", UNCOMBINE_FEATURES: "draw.uncombine" }, f = { MOVE: "move", CHANGE_COORDINATES: "change_coordinates" }, m = { FEATURE: "feature", MIDPOINT: "midpoint", VERTEX: "vertex" }, g = { ACTIVE: "true", INACTIVE: "false" }, _ = ["scrollZoom", "boxZoom", "dragRotate", "dragPan", "keyboard", "doubleClickZoom", "touchZoomRotate"], y = -90, v = -85, x = 90, b = 85, w = -270, T = 270, k = { Point: 0, LineString: 1, Polygon: 2 }; function C(e, t) { var r = k[e.geometry.type] - k[t.geometry.type]; return 0 === r && e.geometry.type === h.POLYGON ? e.area - t.area : r } function E(e) { return e.map((function (e) { return e.geometry.type === h.POLYGON && (e.area = s.geometry({ type: h.FEATURE, property: {}, geometry: e.geometry })), e })).sort(C).map((function (e) { return delete e.area, e })) } function S(e, t) { return void 0 === t && (t = 0), [[e.point.x - t, e.point.y - t], [e.point.x + t, e.point.y + t]] } function P(e) { if (this._items = {}, this._nums = {}, this._length = e ? e.length : 0, e) for (var t = 0, r = e.length; t < r; t++)this.add(e[t]), void 0 !== e[t] && ("string" == typeof e[t] ? this._items[e[t]] = t : this._nums[e[t]] = t) } P.prototype.add = function (e) { return this.has(e) || (this._length++, "string" == typeof e ? this._items[e] = this._length : this._nums[e] = this._length), this }, P.prototype.delete = function (e) { return !1 === this.has(e) || (this._length--, delete this._items[e], delete this._nums[e]), this }, P.prototype.has = function (e) { return !("string" != typeof e && "number" != typeof e || void 0 === this._items[e] && void 0 === this._nums[e]) }, P.prototype.values = function () { var e = this, t = []; return Object.keys(this._items).forEach((function (r) { t.push({ k: r, v: e._items[r] }) })), Object.keys(this._nums).forEach((function (r) { t.push({ k: JSON.parse(r), v: e._nums[r] }) })), t.sort((function (e, t) { return e.v - t.v })).map((function (e) { return e.k })) }, P.prototype.clear = function () { return this._length = 0, this._items = {}, this._nums = {}, this }; var I = [m.FEATURE, m.MIDPOINT, m.VERTEX], A = { click: L, touch: M }; function L(e, t, r) { return B(e, t, r, r.options.clickBuffer) } function M(e, t, r) { return B(e, t, r, r.options.touchBuffer) } function B(e, t, r, n) { if (null === r.map) return []; var i = e ? S(e, n) : t, o = {}; r.options.styles && (o.layers = r.options.styles.map((function (e) { return e.id }))); var s = r.map.queryRenderedFeatures(i, o).filter((function (e) { return -1 !== I.indexOf(e.properties.meta) })), a = new P, c = []; return s.forEach((function (e) { var t = e.properties.id; a.has(t) || (a.add(t), c.push(e)) })), E(c) } function R(e, t) { var r = A.click(e, null, t), n = { mouse: l.NONE }; return r[0] && (n.mouse = r[0].properties.active === g.ACTIVE ? l.MOVE : l.POINTER, n.feature = r[0].properties.meta), -1 !== t.events.currentModeName().indexOf("draw") && (n.mouse = l.ADD), t.ui.queueMapClasses(n), t.ui.updateMapClasses(), r[0] } function D(e, t) { var r = e.x - t.x, n = e.y - t.y; return Math.sqrt(r * r + n * n) } var F = 4, O = 12, z = 500; function U(e, t, r) { void 0 === r && (r = {}); var n = null != r.fineTolerance ? r.fineTolerance : F, i = null != r.grossTolerance ? r.grossTolerance : O, o = null != r.interval ? r.interval : z; e.point = e.point || t.point, e.time = e.time || t.time; var s = D(e.point, t.point); return s < n || s < i && t.time - e.time < o } var N = 25, G = 250; function V(e, t, r) { void 0 === r && (r = {}); var n = null != r.tolerance ? r.tolerance : N, i = null != r.interval ? r.interval : G; return e.point = e.point || t.point, e.time = e.time || t.time, D(e.point, t.point) < n && t.time - e.time < i } function q(e, t) { return e(t = { exports: {} }, t.exports), t.exports } var j = q((function (e) { var t = e.exports = function (e, t) { return ((new Date).getTime() / 1e3 | 0).toString(16).padStart(8, "0") + Math.floor(16777215 * Math.random()).toString(16).padStart(6, "0") + Math.floor(65535 * Math.random()).toString(16).padStart(4, "0") + Math.floor(16777215 * Math.random()).toString(16).padStart(6, "0") }; t.rack = function (e, r, n) { var i = function (i) { var s = 0; do { if (s++ > 10) { if (!n) throw new Error("too many ID collisions, use more bits"); e += n } var a = t(e, r) } while (Object.hasOwnProperty.call(o, a)); return o[a] = i, a }, o = i.hats = {}; return i.get = function (e) { return i.hats[e] }, i.set = function (e, t) { return i.hats[e] = t, i }, i.bits = e || 128, i.base = r || 16, i } })), X = function (e, t) { this.ctx = e, this.properties = t.properties || {}, this.coordinates = t.geometry.coordinates, this.id = t.id || j(), this.type = t.geometry.type }; X.prototype.changed = function () { this.ctx.store.featureChanged(this.id) }, X.prototype.incomingCoords = function (e) { this.setCoordinates(e) }, X.prototype.setCoordinates = function (e) { this.coordinates = e, this.changed() }, X.prototype.getCoordinates = function () { return JSON.parse(JSON.stringify(this.coordinates)) }, X.prototype.setProperty = function (e, t) { this.properties[e] = t }, X.prototype.toGeoJSON = function () { return JSON.parse(JSON.stringify({ id: this.id, type: h.FEATURE, properties: this.properties, geometry: { coordinates: this.getCoordinates(), type: this.type } })) }, X.prototype.internal = function (e) { var t = { id: this.id, meta: m.FEATURE, "meta:type": this.type, active: g.INACTIVE, mode: e }; if (this.ctx.options.userProperties) for (var r in this.properties) t["user_" + r] = this.properties[r]; return { type: h.FEATURE, properties: t, geometry: { coordinates: this.getCoordinates(), type: this.type } } }; var W = function (e, t) { X.call(this, e, t) }; W.prototype = Object.create(X.prototype), W.prototype.isValid = function () { return "number" == typeof this.coordinates[0] && "number" == typeof this.coordinates[1] }, W.prototype.updateCoordinate = function (e, t, r) { this.coordinates = 3 === arguments.length ? [t, r] : [e, t], this.changed() }, W.prototype.getCoordinate = function () { return this.getCoordinates() }; var Z = function (e, t) { X.call(this, e, t) }; Z.prototype = Object.create(X.prototype), Z.prototype.isValid = function () { return this.coordinates.length > 1 }, Z.prototype.addCoordinate = function (e, t, r) { this.changed(); var n = parseInt(e, 10); this.coordinates.splice(n, 0, [t, r]) }, Z.prototype.getCoordinate = function (e) { var t = parseInt(e, 10); return JSON.parse(JSON.stringify(this.coordinates[t])) }, Z.prototype.removeCoordinate = function (e) { this.changed(), this.coordinates.splice(parseInt(e, 10), 1) }, Z.prototype.updateCoordinate = function (e, t, r) { var n = parseInt(e, 10); this.coordinates[n] = [t, r], this.changed() }; var H = function (e, t) { X.call(this, e, t), this.coordinates = this.coordinates.map((function (e) { return e.slice(0, -1) })) }; H.prototype = Object.create(X.prototype), H.prototype.isValid = function () { return 0 !== this.coordinates.length && this.coordinates.every((function (e) { return e.length > 2 })) }, H.prototype.incomingCoords = function (e) { this.coordinates = e.map((function (e) { return e.slice(0, -1) })), this.changed() }, H.prototype.setCoordinates = function (e) { this.coordinates = e, this.changed() }, H.prototype.addCoordinate = function (e, t, r) { this.changed(); var n = e.split(".").map((function (e) { return parseInt(e, 10) })); this.coordinates[n[0]].splice(n[1], 0, [t, r]) }, H.prototype.removeCoordinate = function (e) { this.changed(); var t = e.split(".").map((function (e) { return parseInt(e, 10) })), r = this.coordinates[t[0]]; r && (r.splice(t[1], 1), r.length < 3 && this.coordinates.splice(t[0], 1)) }, H.prototype.getCoordinate = function (e) { var t = e.split(".").map((function (e) { return parseInt(e, 10) })), r = this.coordinates[t[0]]; return JSON.parse(JSON.stringify(r[t[1]])) }, H.prototype.getCoordinates = function () { return this.coordinates.map((function (e) { return e.concat([e[0]]) })) }, H.prototype.updateCoordinate = function (e, t, r) { this.changed(); var n = e.split("."), i = parseInt(n[0], 10), o = parseInt(n[1], 10); void 0 === this.coordinates[i] && (this.coordinates[i] = []), this.coordinates[i][o] = [t, r] }; var Q = { MultiPoint: W, MultiLineString: Z, MultiPolygon: H }, $ = function (e, t, r, n, i) { var o = r.split("."), s = parseInt(o[0], 10), a = o[1] ? o.slice(1).join(".") : null; return e[s][t](a, n, i) }, J = function (e, t) { if (X.call(this, e, t), delete this.coordinates, this.model = Q[t.geometry.type], void 0 === this.model) throw new TypeError(t.geometry.type + " is not a valid type"); this.features = this._coordinatesToFeatures(t.geometry.coordinates) }; function K(e) { this.map = e.map, this.drawConfig = JSON.parse(JSON.stringify(e.options || {})), this._ctx = e } J.prototype = Object.create(X.prototype), J.prototype._coordinatesToFeatures = function (e) { var t = this, r = this.model.bind(this); return e.map((function (e) { return new r(t.ctx, { id: j(), type: h.FEATURE, properties: {}, geometry: { coordinates: e, type: t.type.replace("Multi", "") } }) })) }, J.prototype.isValid = function () { return this.features.every((function (e) { return e.isValid() })) }, J.prototype.setCoordinates = function (e) { this.features = this._coordinatesToFeatures(e), this.changed() }, J.prototype.getCoordinate = function (e) { return $(this.features, "getCoordinate", e) }, J.prototype.getCoordinates = function () { return JSON.parse(JSON.stringify(this.features.map((function (e) { return e.type === h.POLYGON ? e.getCoordinates() : e.coordinates })))) }, J.prototype.updateCoordinate = function (e, t, r) { $(this.features, "updateCoordinate", e, t, r), this.changed() }, J.prototype.addCoordinate = function (e, t, r) { $(this.features, "addCoordinate", e, t, r), this.changed() }, J.prototype.removeCoordinate = function (e) { $(this.features, "removeCoordinate", e), this.changed() }, J.prototype.getFeatures = function () { return this.features }, K.prototype.setSelected = function (e) { return this._ctx.store.setSelected(e) }, K.prototype.setSelectedCoordinates = function (e) { var t = this; this._ctx.store.setSelectedCoordinates(e), e.reduce((function (e, r) { return void 0 === e[r.feature_id] && (e[r.feature_id] = !0, t._ctx.store.get(r.feature_id).changed()), e }), {}) }, K.prototype.getSelected = function () { return this._ctx.store.getSelected() }, K.prototype.getSelectedIds = function () { return this._ctx.store.getSelectedIds() }, K.prototype.isSelected = function (e) { return this._ctx.store.isSelected(e) }, K.prototype.getFeature = function (e) { return this._ctx.store.get(e) }, K.prototype.select = function (e) { return this._ctx.store.select(e) }, K.prototype.deselect = function (e) { return this._ctx.store.deselect(e) }, K.prototype.deleteFeature = function (e, t) { return void 0 === t && (t = {}), this._ctx.store.delete(e, t) }, K.prototype.addFeature = function (e) { return this._ctx.store.add(e) }, K.prototype.clearSelectedFeatures = function () { return this._ctx.store.clearSelected() }, K.prototype.clearSelectedCoordinates = function () { return this._ctx.store.clearSelectedCoordinates() }, K.prototype.setActionableState = function (e) { void 0 === e && (e = {}); var t = { trash: e.trash || !1, combineFeatures: e.combineFeatures || !1, uncombineFeatures: e.uncombineFeatures || !1 }; return this._ctx.events.actionable(t) }, K.prototype.changeMode = function (e, t, r) { return void 0 === t && (t = {}), void 0 === r && (r = {}), this._ctx.events.changeMode(e, t, r) }, K.prototype.updateUIClasses = function (e) { return this._ctx.ui.queueMapClasses(e) }, K.prototype.activateUIButton = function (e) { return this._ctx.ui.setActiveButton(e) }, K.prototype.featuresAt = function (e, t, r) { if (void 0 === r && (r = "click"), "click" !== r && "touch" !== r) throw new Error("invalid buffer type"); return A[r](e, t, this._ctx) }, K.prototype.newFeature = function (e) { var t = e.geometry.type; return t === h.POINT ? new W(this._ctx, e) : t === h.LINE_STRING ? new Z(this._ctx, e) : t === h.POLYGON ? new H(this._ctx, e) : new J(this._ctx, e) }, K.prototype.isInstanceOf = function (e, t) { if (e === h.POINT) return t instanceof W; if (e === h.LINE_STRING) return t instanceof Z; if (e === h.POLYGON) return t instanceof H; if ("MultiFeature" === e) return t instanceof J; throw new Error("Unknown feature class: " + e) }, K.prototype.doRender = function (e) { return this._ctx.store.featureChanged(e) }, K.prototype.onSetup = function () { }, K.prototype.onDrag = function () { }, K.prototype.onClick = function () { }, K.prototype.onMouseMove = function () { }, K.prototype.onMouseDown = function () { }, K.prototype.onMouseUp = function () { }, K.prototype.onMouseOut = function () { }, K.prototype.onKeyUp = function () { }, K.prototype.onKeyDown = function () { }, K.prototype.onTouchStart = function () { }, K.prototype.onTouchMove = function () { }, K.prototype.onTouchEnd = function () { }, K.prototype.onTap = function () { }, K.prototype.onStop = function () { }, K.prototype.onTrash = function () { }, K.prototype.onCombineFeature = function () { }, K.prototype.onUncombineFeature = function () { }, K.prototype.toDisplayFeatures = function () { throw new Error("You must overwrite toDisplayFeatures") }; var Y = { drag: "onDrag", click: "onClick", mousemove: "onMouseMove", mousedown: "onMouseDown", mouseup: "onMouseUp", mouseout: "onMouseOut", keyup: "onKeyUp", keydown: "onKeyDown", touchstart: "onTouchStart", touchmove: "onTouchMove", touchend: "onTouchEnd", tap: "onTap" }, ee = Object.keys(Y); function te(e) { var t = Object.keys(e); return function (r, n) { void 0 === n && (n = {}); var i = {}, o = t.reduce((function (t, r) { return t[r] = e[r], t }), new K(r)); function s(e) { return function (t) { return o[e](i, t) } } return { start: function () { var t = this; i = o.onSetup(n), ee.forEach((function (r) { var n = Y[r], i = function () { return !1 }; e[n] && (i = function () { return !0 }), t.on(r, i, s(n)) })) }, stop: function () { o.onStop(i) }, trash: function () { o.onTrash(i) }, combineFeatures: function () { o.onCombineFeatures(i) }, uncombineFeatures: function () { o.onUncombineFeatures(i) }, render: function (e, t) { o.toDisplayFeatures(i, e, t) } } } } function re(t) { var r = Object.keys(t.options.modes).reduce((function (e, r) { return e[r] = te(t.options.modes[r]), e }), {}), n = {}, i = {}, o = {}, s = null, a = null; o.drag = function (e, r) { r({ point: e.point, time: (new Date).getTime() }) ? (t.ui.queueMapClasses({ mouse: l.DRAG }), a.drag(e)) : e.originalEvent.stopPropagation() }, o.mousedrag = function (e) { o.drag(e, (function (e) { return !U(n, e) })) }, o.touchdrag = function (e) { o.drag(e, (function (e) { return !V(i, e) })) }, o.mousemove = function (e) { if (1 === (void 0 !== e.originalEvent.buttons ? e.originalEvent.buttons : e.originalEvent.which)) return o.mousedrag(e); var r = R(e, t); e.featureTarget = r, a.mousemove(e) }, o.mousedown = function (e) { n = { time: (new Date).getTime(), point: e.point }; var r = R(e, t); e.featureTarget = r, a.mousedown(e) }, o.mouseup = function (e) { var r = R(e, t); e.featureTarget = r, U(n, { point: e.point, time: (new Date).getTime() }) ? a.click(e) : a.mouseup(e) }, o.mouseout = function (e) { a.mouseout(e) }, o.touchstart = function (e) { if (t.options.touchEnabled) { i = { time: (new Date).getTime(), point: e.point }; var r = A.touch(e, null, t)[0]; e.featureTarget = r, a.touchstart(e) } }, o.touchmove = function (e) { if (e.originalEvent.preventDefault(), t.options.touchEnabled) return a.touchmove(e), o.touchdrag(e) }, o.touchend = function (e) { if (e.originalEvent.preventDefault(), t.options.touchEnabled) { var r = A.touch(e, null, t)[0]; e.featureTarget = r, V(i, { time: (new Date).getTime(), point: e.point }) ? a.tap(e) : a.touchend(e) } }; var c = function (e) { return !(8 === e || 46 === e || e >= 48 && e <= 57) }; function u(n, i, o) { void 0 === o && (o = {}), a.stop(); var c = r[n]; if (void 0 === c) throw new Error(n + " is not valid"); s = n; var l = c(t, i); a = e(l, t), o.silent || t.map.fire(p.MODE_CHANGE, { mode: n }), t.store.setDirty(), t.store.render() } o.keydown = function (e) { "mapboxgl-canvas" === (e.srcElement || e.target).classList[0] && (8 !== e.keyCode && 46 !== e.keyCode || !t.options.controls.trash ? c(e.keyCode) ? a.keydown(e) : 49 === e.keyCode && t.options.controls.point ? u(d.DRAW_POINT) : 50 === e.keyCode && t.options.controls.line_string ? u(d.DRAW_LINE_STRING) : 51 === e.keyCode && t.options.controls.polygon && u(d.DRAW_POLYGON) : (e.preventDefault(), a.trash())) }, o.keyup = function (e) { c(e.keyCode) && a.keyup(e) }, o.zoomend = function () { t.store.changeZoom() }, o.data = function (e) { if ("style" === e.dataType) { var r = t.setup, n = t.map, i = t.options, o = t.store; i.styles.some((function (e) { return n.getLayer(e.id) })) || (r.addLayers(), o.setDirty(), o.render()) } }; var h = { trash: !1, combineFeatures: !1, uncombineFeatures: !1 }; function f(e) { var r = !1; Object.keys(e).forEach((function (t) { if (void 0 === h[t]) throw new Error("Invalid action type"); h[t] !== e[t] && (r = !0), h[t] = e[t] })), r && t.map.fire(p.ACTIONABLE, { actions: h }) } return { start: function () { s = t.options.defaultMode, a = e(r[s](t), t) }, changeMode: u, actionable: f, currentModeName: function () { return s }, currentModeRender: function (e, t) { return a.render(e, t) }, fire: function (e, t) { o[e] && o[e](t) }, addEventListeners: function () { t.map.on("mousemove", o.mousemove), t.map.on("mousedown", o.mousedown), t.map.on("mouseup", o.mouseup), t.map.on("data", o.data), t.map.on("touchmove", o.touchmove), t.map.on("touchstart", o.touchstart), t.map.on("touchend", o.touchend), t.container.addEventListener("mouseout", o.mouseout), t.options.keybindings && (t.container.addEventListener("keydown", o.keydown), t.container.addEventListener("keyup", o.keyup)) }, removeEventListeners: function () { t.map.off("mousemove", o.mousemove), t.map.off("mousedown", o.mousedown), t.map.off("mouseup", o.mouseup), t.map.off("data", o.data), t.map.off("touchmove", o.touchmove), t.map.off("touchstart", o.touchstart), t.map.off("touchend", o.touchend), t.container.removeEventListener("mouseout", o.mouseout), t.options.keybindings && (t.container.removeEventListener("keydown", o.keydown), t.container.removeEventListener("keyup", o.keyup)) }, trash: function (e) { a.trash(e) }, combineFeatures: function () { a.combineFeatures() }, uncombineFeatures: function () { a.uncombineFeatures() }, getMode: function () { return s } } } function ne(e) { return [].concat(e).filter((function (e) { return void 0 !== e })) } function ie() { var e = this; if (!e.ctx.map || void 0 === e.ctx.map.getSource(c.HOT)) return l(); var t = e.ctx.events.currentModeName(); e.ctx.ui.queueMapClasses({ mode: t }); var r = [], n = []; e.isDirty ? n = e.getAllIds() : (r = e.getChangedIds().filter((function (t) { return void 0 !== e.get(t) })), n = e.sources.hot.filter((function (t) { return t.properties.id && -1 === r.indexOf(t.properties.id) && void 0 !== e.get(t.properties.id) })).map((function (e) { return e.properties.id }))), e.sources.hot = []; var i = e.sources.cold.length; e.sources.cold = e.isDirty ? [] : e.sources.cold.filter((function (e) { var t = e.properties.id || e.properties.parent; return -1 === r.indexOf(t) })); var o = i !== e.sources.cold.length || n.length > 0; function s(r, n) { var i = e.get(r).internal(t); e.ctx.events.currentModeRender(i, (function (t) { e.sources[n].push(t) })) } if (r.forEach((function (e) { return s(e, "hot") })), n.forEach((function (e) { return s(e, "cold") })), o && e.ctx.map.getSource(c.COLD).setData({ type: h.FEATURE_COLLECTION, features: e.sources.cold }), e.ctx.map.getSource(c.HOT).setData({ type: h.FEATURE_COLLECTION, features: e.sources.hot }), e._emitSelectionChange && (e.ctx.map.fire(p.SELECTION_CHANGE, { features: e.getSelected().map((function (e) { return e.toGeoJSON() })), points: e.getSelectedCoordinates().map((function (e) { return { type: h.FEATURE, properties: {}, geometry: { type: h.POINT, coordinates: e.coordinates } } })) }), e._emitSelectionChange = !1), e._deletedFeaturesToEmit.length) { var a = e._deletedFeaturesToEmit.map((function (e) { return e.toGeoJSON() })); e._deletedFeaturesToEmit = [], e.ctx.map.fire(p.DELETE, { features: a }) } function l() { e.isDirty = !1, e.clearChangedIds() } l(), e.ctx.map.fire(p.RENDER, {}) } function oe(e) { var t, r = this; this._features = {}, this._featureIds = new P, this._selectedFeatureIds = new P, this._selectedCoordinates = [], this._changedFeatureIds = new P, this._deletedFeaturesToEmit = [], this._emitSelectionChange = !1, this._mapInitialConfig = {}, this.ctx = e, this.sources = { hot: [], cold: [] }, this.render = function () { t || (t = requestAnimationFrame((function () { t = null, ie.call(r) }))) }, this.isDirty = !1 } function se(e, t) { var r = e._selectedCoordinates.filter((function (t) { return e._selectedFeatureIds.has(t.feature_id) })); e._selectedCoordinates.length === r.length || t.silent || (e._emitSelectionChange = !0), e._selectedCoordinates = r } oe.prototype.createRenderBatch = function () { var e = this, t = this.render, r = 0; return this.render = function () { r++ }, function () { e.render = t, r > 0 && e.render() } }, oe.prototype.setDirty = function () { return this.isDirty = !0, this }, oe.prototype.featureChanged = function (e) { return this._changedFeatureIds.add(e), this }, oe.prototype.getChangedIds = function () { return this._changedFeatureIds.values() }, oe.prototype.clearChangedIds = function () { return this._changedFeatureIds.clear(), this }, oe.prototype.getAllIds = function () { return this._featureIds.values() }, oe.prototype.add = function (e) { return this.featureChanged(e.id), this._features[e.id] = e, this._featureIds.add(e.id), this }, oe.prototype.delete = function (e, t) { var r = this; return void 0 === t && (t = {}), ne(e).forEach((function (e) { r._featureIds.has(e) && (r._featureIds.delete(e), r._selectedFeatureIds.delete(e), t.silent || -1 === r._deletedFeaturesToEmit.indexOf(r._features[e]) && r._deletedFeaturesToEmit.push(r._features[e]), delete r._features[e], r.isDirty = !0) })), se(this, t), this }, oe.prototype.get = function (e) { return this._features[e] }, oe.prototype.getAll = function () { var e = this; return Object.keys(this._features).map((function (t) { return e._features[t] })) }, oe.prototype.select = function (e, t) { var r = this; return void 0 === t && (t = {}), ne(e).forEach((function (e) { r._selectedFeatureIds.has(e) || (r._selectedFeatureIds.add(e), r._changedFeatureIds.add(e), t.silent || (r._emitSelectionChange = !0)) })), this }, oe.prototype.deselect = function (e, t) { var r = this; return void 0 === t && (t = {}), ne(e).forEach((function (e) { r._selectedFeatureIds.has(e) && (r._selectedFeatureIds.delete(e), r._changedFeatureIds.add(e), t.silent || (r._emitSelectionChange = !0)) })), se(this, t), this }, oe.prototype.clearSelected = function (e) { return void 0 === e && (e = {}), this.deselect(this._selectedFeatureIds.values(), { silent: e.silent }), this }, oe.prototype.setSelected = function (e, t) { var r = this; return void 0 === t && (t = {}), e = ne(e), this.deselect(this._selectedFeatureIds.values().filter((function (t) { return -1 === e.indexOf(t) })), { silent: t.silent }), this.select(e.filter((function (e) { return !r._selectedFeatureIds.has(e) })), { silent: t.silent }), this }, oe.prototype.setSelectedCoordinates = function (e) { return this._selectedCoordinates = e, this._emitSelectionChange = !0, this }, oe.prototype.clearSelectedCoordinates = function () { return this._selectedCoordinates = [], this._emitSelectionChange = !0, this }, oe.prototype.getSelectedIds = function () { return this._selectedFeatureIds.values() }, oe.prototype.getSelected = function () { var e = this; return this._selectedFeatureIds.values().map((function (t) { return e.get(t) })) }, oe.prototype.getSelectedCoordinates = function () { var e = this; return this._selectedCoordinates.map((function (t) { return { coordinates: e.get(t.feature_id).getCoordinate(t.coord_path) } })) }, oe.prototype.isSelected = function (e) { return this._selectedFeatureIds.has(e) }, oe.prototype.setFeatureProperty = function (e, t, r) { this.get(e).setProperty(t, r), this.featureChanged(e) }, oe.prototype.storeMapConfig = function () { var e = this; _.forEach((function (t) { e.ctx.map[t] && (e._mapInitialConfig[t] = e.ctx.map[t].isEnabled()) })) }, oe.prototype.restoreMapConfig = function () { var e = this; Object.keys(this._mapInitialConfig).forEach((function (t) { e._mapInitialConfig[t] ? e.ctx.map[t].enable() : e.ctx.map[t].disable() })) }, oe.prototype.getInitialConfigValue = function (e) { return void 0 === this._mapInitialConfig[e] || this._mapInitialConfig[e] }; var ae = le, ce = Object.prototype.hasOwnProperty; function le() { for (var e = arguments, t = {}, r = 0; r < arguments.length; r++) { var n = e[r]; for (var i in n) ce.call(n, i) && (t[i] = n[i]) } return t } var ue = ["mode", "feature", "mouse"]; function he(e) { var t = {}, r = null, n = { mode: null, feature: null, mouse: null }, i = { mode: null, feature: null, mouse: null }; function o() { s({ mode: null, feature: null, mouse: null }), c() } function s(e) { i = ae(i, e) } function c() { var t, r; if (e.container) { var o = [], s = []; ue.forEach((function (e) { i[e] !== n[e] && (o.push(e + "-" + n[e]), null !== i[e] && s.push(e + "-" + i[e])) })), o.length > 0 && (t = e.container.classList).remove.apply(t, o), s.length > 0 && (r = e.container.classList).add.apply(r, s), n = ae(n, i) } } function l(e, t) { void 0 === t && (t = {}); var n = document.createElement("button"); return n.className = a.CONTROL_BUTTON + " " + t.className, n.setAttribute("title", t.title), t.container.appendChild(n), n.addEventListener("click", (function (n) { if (n.preventDefault(), n.stopPropagation(), n.target === r) return h(), void t.onDeactivate(); p(e), t.onActivate() }), !0), n } function h() { r && (r.classList.remove(a.ACTIVE_BUTTON), r = null) } function p(e) { h(); var n = t[e]; n && n && "trash" !== e && (n.classList.add(a.ACTIVE_BUTTON), r = n) } function f() { var r = e.options.controls, n = document.createElement("div"); return n.className = a.CONTROL_GROUP + " " + a.CONTROL_BASE, r ? (r[u.LINE] && (t[u.LINE] = l(u.LINE, { container: n, className: a.CONTROL_BUTTON_LINE, title: "线 " + (e.options.keybindings, ""), onActivate: function () { return e.events.changeMode(d.DRAW_LINE_STRING) }, onDeactivate: function () { return e.events.trash() } })), r[u.POLYGON] && (t[u.POLYGON] = l(u.POLYGON, { container: n, className: a.CONTROL_BUTTON_POLYGON, title: "面 " + (e.options.keybindings, ""), onActivate: function () { return e.events.changeMode(d.DRAW_POLYGON) }, onDeactivate: function () { return e.events.trash() } })), r[u.POINT] && (t[u.POINT] = l(u.POINT, { container: n, className: a.CONTROL_BUTTON_POINT, title: "点 " + (e.options.keybindings, ""), onActivate: function () { return e.events.changeMode(d.DRAW_POINT) }, onDeactivate: function () { return e.events.trash() } })), r.trash && (t.trash = l("trash", { container: n, className: a.CONTROL_BUTTON_TRASH, title: "删除", onActivate: function () { e.events.trash() } })), r.combine_features && (t.combine_features = l("combineFeatures", { container: n, className: a.CONTROL_BUTTON_COMBINE_FEATURES, title: "Combine", onActivate: function () { e.events.combineFeatures() } })), r.uncombine_features && (t.uncombine_features = l("uncombineFeatures", { container: n, className: a.CONTROL_BUTTON_UNCOMBINE_FEATURES, title: "Uncombine", onActivate: function () { e.events.uncombineFeatures() } })), n) : n } function m() { Object.keys(t).forEach((function (e) { var r = t[e]; r.parentNode && r.parentNode.removeChild(r), delete t[e] })) } return { setActiveButton: p, queueMapClasses: s, updateMapClasses: c, clearMapClasses: o, addButtons: f, removeButtons: m } } function de(e) { var t = null, r = null, n = { onRemove: function () { return e.map.off("load", n.connect), clearInterval(r), n.removeLayers(), e.store.restoreMapConfig(), e.ui.removeButtons(), e.events.removeEventListeners(), e.ui.clearMapClasses(), e.map = null, e.container = null, e.store = null, t && t.parentNode && t.parentNode.removeChild(t), t = null, this }, connect: function () { e.map.off("load", n.connect), clearInterval(r), n.addLayers(), e.store.storeMapConfig(), e.events.addEventListeners() }, onAdd: function (i) { var o = i.fire; return i.fire = function (e, t) { var r = arguments; return 1 === o.length && 1 !== arguments.length && (r = [ae({}, { type: e }, t)]), o.apply(i, r) }, e.map = i, e.events = re(e), e.ui = he(e), e.container = i.getContainer(), e.store = new oe(e), t = e.ui.addButtons(), e.options.boxSelect && (i.boxZoom.disable(), i.dragPan.disable(), i.dragPan.enable()), i.loaded() ? n.connect() : (i.on("load", n.connect), r = setInterval((function () { i.loaded() && n.connect() }), 16)), e.events.start(), t }, addLayers: function () { e.map.addSource(c.COLD, { data: { type: h.FEATURE_COLLECTION, features: [] }, type: "geojson" }), e.map.addSource(c.HOT, { data: { type: h.FEATURE_COLLECTION, features: [] }, type: "geojson" }), e.options.styles.forEach((function (t) { e.map.addLayer(t) })), e.store.setDirty(!0), e.store.render() }, removeLayers: function () { e.options.styles.forEach((function (t) { e.map.getLayer(t.id) && e.map.removeLayer(t.id) })), e.map.getSource(c.COLD) && e.map.removeSource(c.COLD), e.map.getSource(c.HOT) && e.map.removeSource(c.HOT) } }; return e.setup = n, n } var pe = [{ id: "gl-draw-polygon-fill-inactive", type: "fill", filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]], paint: { "fill-color": "#3bb2d0", "fill-outline-color": "#3bb2d0", "fill-opacity": .1 } }, { id: "gl-draw-polygon-fill-active", type: "fill", filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]], paint: { "fill-color": "#fbb03b", "fill-outline-color": "#fbb03b", "fill-opacity": .1 } }, { id: "gl-draw-polygon-midpoint", type: "circle", filter: ["all", ["==", "$type", "Point"], ["==", "meta", "midpoint"]], paint: { "circle-radius": 3, "circle-color": "#fbb03b" } }, { id: "gl-draw-polygon-stroke-inactive", type: "line", filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#3bb2d0", "line-width": 2 } }, { id: "gl-draw-polygon-stroke-active", type: "line", filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#fbb03b", "line-dasharray": [.2, 2], "line-width": 2 } }, { id: "gl-draw-line-inactive", type: "line", filter: ["all", ["==", "active", "false"], ["==", "$type", "LineString"], ["!=", "mode", "static"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#3bb2d0", "line-width": 2 } }, { id: "gl-draw-line-active", type: "line", filter: ["all", ["==", "$type", "LineString"], ["==", "active", "true"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#fbb03b", "line-dasharray": [.2, 2], "line-width": 2 } }, { id: "gl-draw-polygon-and-line-vertex-stroke-inactive", type: "circle", filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]], paint: { "circle-radius": 5, "circle-color": "#fff" } }, { id: "gl-draw-polygon-and-line-vertex-inactive", type: "circle", filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]], paint: { "circle-radius": 3, "circle-color": "#fbb03b" } }, { id: "gl-draw-point-point-stroke-inactive", type: "circle", filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]], paint: { "circle-radius": 5, "circle-opacity": 1, "circle-color": "#fff" } }, { id: "gl-draw-point-inactive", type: "circle", filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]], paint: { "circle-radius": 3, "circle-color": "#3bb2d0" } }, { id: "gl-draw-point-stroke-active", type: "circle", filter: ["all", ["==", "$type", "Point"], ["==", "active", "true"], ["!=", "meta", "midpoint"]], paint: { "circle-radius": 7, "circle-color": "#fff" } }, { id: "gl-draw-point-active", type: "circle", filter: ["all", ["==", "$type", "Point"], ["!=", "meta", "midpoint"], ["==", "active", "true"]], paint: { "circle-radius": 5, "circle-color": "#fbb03b" } }, { id: "gl-draw-polygon-fill-static", type: "fill", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]], paint: { "fill-color": "#404040", "fill-outline-color": "#404040", "fill-opacity": .1 } }, { id: "gl-draw-polygon-stroke-static", type: "line", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#404040", "line-width": 2 } }, { id: "gl-draw-line-static", type: "line", filter: ["all", ["==", "mode", "static"], ["==", "$type", "LineString"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#404040", "line-width": 2 } }, { id: "gl-draw-point-static", type: "circle", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Point"]], paint: { "circle-radius": 5, "circle-color": "#404040" } }]; function fe(e) { return function (t) { var r = t.featureTarget; return !!r && !!r.properties && r.properties.meta === e } } function me(e) { return !!e.originalEvent && !!e.originalEvent.shiftKey && 0 === e.originalEvent.button } function ge(e) { return !!e.featureTarget && !!e.featureTarget.properties && e.featureTarget.properties.active === g.ACTIVE && e.featureTarget.properties.meta === m.FEATURE } function _e(e) { return !!e.featureTarget && !!e.featureTarget.properties && e.featureTarget.properties.active === g.INACTIVE && e.featureTarget.properties.meta === m.FEATURE } function ve(e) { return void 0 === e.featureTarget } function xe(e) { return !!e.featureTarget && !!e.featureTarget.properties && e.featureTarget.properties.meta === m.FEATURE } function be(e) { var t = e.featureTarget; return !!t && !!t.properties && t.properties.meta === m.VERTEX } function we(e) { return !!e.originalEvent && !0 === e.originalEvent.shiftKey } function Te(e) { return 27 === e.keyCode } function ke(e) { return 13 === e.keyCode } var Ce = Ee; function Ee(e, t) { this.x = e, this.y = t } function Se(e, t) { var r = t.getBoundingClientRect(); return new Ce(e.clientX - r.left - (t.clientLeft || 0), e.clientY - r.top - (t.clientTop || 0)) } function Pe(e, t, r, n) { return { type: h.FEATURE, properties: { meta: m.VERTEX, parent: e, coord_path: r, active: n ? g.ACTIVE : g.INACTIVE }, geometry: { type: h.POINT, coordinates: t } } } function Ie(e, t, r) { var n = t.geometry.coordinates, i = r.geometry.coordinates; if (n[1] > b || n[1] < v || i[1] > b || i[1] < v) return null; var o = { lng: (n[0] + i[0]) / 2, lat: (n[1] + i[1]) / 2 }; return { type: h.FEATURE, properties: { meta: m.MIDPOINT, parent: e, lng: o.lng, lat: o.lat, coord_path: r.properties.coord_path }, geometry: { type: h.POINT, coordinates: [o.lng, o.lat] } } } function Ae(e, t, r) { void 0 === t && (t = {}), void 0 === r && (r = null); var n = e.geometry, i = n.type, o = n.coordinates, s = e.properties && e.properties.id, a = []; function c(e, r) { var n = "", i = null; e.forEach((function (e, o) { var c = null != r ? r + "." + o : String(o), u = Pe(s, e, c, l(c)); if (t.midpoints && i) { var h = Ie(s, i, u); h && a.push(h) } i = u; var d = JSON.stringify(e); n !== d && a.push(u), 0 === o && (n = d) })) } function l(e) { return !!t.selectedPaths && -1 !== t.selectedPaths.indexOf(e) } function u() { var r = i.replace(h.MULTI_PREFIX, ""); o.forEach((function (n, i) { var o = { type: h.FEATURE, properties: e.properties, geometry: { type: r, coordinates: n } }; a = a.concat(Ae(o, t, i)) })) } return i === h.POINT ? a.push(Pe(s, o, r, l(r))) : i === h.POLYGON ? o.forEach((function (e, t) { c(e, null !== r ? r + "." + t : String(t)) })) : i === h.LINE_STRING ? c(o, r) : 0 === i.indexOf(h.MULTI_PREFIX) && u(), a } Ee.prototype = { clone: function () { return new Ee(this.x, this.y) }, add: function (e) { return this.clone()._add(e) }, sub: function (e) { return this.clone()._sub(e) }, multByPoint: function (e) { return this.clone()._multByPoint(e) }, divByPoint: function (e) { return this.clone()._divByPoint(e) }, mult: function (e) { return this.clone()._mult(e) }, div: function (e) { return this.clone()._div(e) }, rotate: function (e) { return this.clone()._rotate(e) }, rotateAround: function (e, t) { return this.clone()._rotateAround(e, t) }, matMult: function (e) { return this.clone()._matMult(e) }, unit: function () { return this.clone()._unit() }, perp: function () { return this.clone()._perp() }, round: function () { return this.clone()._round() }, mag: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, equals: function (e) { return this.x === e.x && this.y === e.y }, dist: function (e) { return Math.sqrt(this.distSqr(e)) }, distSqr: function (e) { var t = e.x - this.x, r = e.y - this.y; return t * t + r * r }, angle: function () { return Math.atan2(this.y, this.x) }, angleTo: function (e) { return Math.atan2(this.y - e.y, this.x - e.x) }, angleWith: function (e) { return this.angleWithSep(e.x, e.y) }, angleWithSep: function (e, t) { return Math.atan2(this.x * t - this.y * e, this.x * e + this.y * t) }, _matMult: function (e) { var t = e[0] * this.x + e[1] * this.y, r = e[2] * this.x + e[3] * this.y; return this.x = t, this.y = r, this }, _add: function (e) { return this.x += e.x, this.y += e.y, this }, _sub: function (e) { return this.x -= e.x, this.y -= e.y, this }, _mult: function (e) { return this.x *= e, this.y *= e, this }, _div: function (e) { return this.x /= e, this.y /= e, this }, _multByPoint: function (e) { return this.x *= e.x, this.y *= e.y, this }, _divByPoint: function (e) { return this.x /= e.x, this.y /= e.y, this }, _unit: function () { return this._div(this.mag()), this }, _perp: function () { var e = this.y; return this.y = this.x, this.x = -e, this }, _rotate: function (e) { var t = Math.cos(e), r = Math.sin(e), n = t * this.x - r * this.y, i = r * this.x + t * this.y; return this.x = n, this.y = i, this }, _rotateAround: function (e, t) { var r = Math.cos(e), n = Math.sin(e), i = t.x + r * (this.x - t.x) - n * (this.y - t.y), o = t.y + n * (this.x - t.x) + r * (this.y - t.y); return this.x = i, this.y = o, this }, _round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } }, Ee.convert = function (e) { return e instanceof Ee ? e : Array.isArray(e) ? new Ee(e[0], e[1]) : e }; var Le = { enable: function (e) { setTimeout((function () { e.map && e.map.doubleClickZoom && e._ctx && e._ctx.store && e._ctx.store.getInitialConfigValue && e._ctx.store.getInitialConfigValue("doubleClickZoom") && e.map.doubleClickZoom.enable() }), 0) }, disable: function (e) { setTimeout((function () { e.map && e.map.doubleClickZoom && e.map.doubleClickZoom.disable() }), 0) } }, Me = Re, Be = { Point: "geometry", MultiPoint: "geometry", LineString: "geometry", MultiLineString: "geometry", Polygon: "geometry", MultiPolygon: "geometry", GeometryCollection: "geometry", Feature: "feature", FeatureCollection: "featurecollection" }; function Re(e) { if (!e || !e.type) return null; var t = Be[e.type]; return t ? "geometry" === t ? { type: "FeatureCollection", features: [{ type: "Feature", properties: {}, geometry: e }] } : "feature" === t ? { type: "FeatureCollection", features: [e] } : "featurecollection" === t ? e : void 0 : null } function De(e) { switch (e && e.type || null) { case "FeatureCollection": return e.features = e.features.reduce((function (e, t) { return e.concat(De(t)) }), []), e; case "Feature": return e.geometry ? De(e.geometry).map((function (t) { var r = { type: "Feature", properties: JSON.parse(JSON.stringify(e.properties)), geometry: t }; return void 0 !== e.id && (r.id = e.id), r })) : [e]; case "MultiPoint": return e.coordinates.map((function (e) { return { type: "Point", coordinates: e } })); case "MultiPolygon": return e.coordinates.map((function (e) { return { type: "Polygon", coordinates: e } })); case "MultiLineString": return e.coordinates.map((function (e) { return { type: "LineString", coordinates: e } })); case "GeometryCollection": return e.geometries.map(De).reduce((function (e, t) { return e.concat(t) }), []); case "Point": case "Polygon": case "LineString": return [e] } } var Fe = function (e) { return t(e); function t(e) { return Array.isArray(e) && e.length && "number" == typeof e[0] ? [e] : e.reduce((function (e, r) { return Array.isArray(r) && Array.isArray(r[0]) ? e.concat(t(r)) : (e.push(r), e) }), []) } }, Oe = function (e) { if (!e) return []; var t = De(Me(e)), r = []; return t.features.forEach((function (e) { e.geometry && (r = r.concat(Fe(e.geometry.coordinates))) })), r }, ze = q((function (e) { var t = e.exports = function (e) { return new r(e) }; function r(e) { this.value = e } function n(e, t, r) { var n = [], s = [], a = !0; return function e(c) { var l = r ? i(c) : c, u = {}, h = !0, d = { node: l, node_: c, path: [].concat(n), parent: s[s.length - 1], parents: s, key: n.slice(-1)[0], isRoot: 0 === n.length, level: n.length, circular: null, update: function (e, t) { d.isRoot || (d.parent.node[d.key] = e), d.node = e, t && (h = !1) }, delete: function (e) { delete d.parent.node[d.key], e && (h = !1) }, remove: function (e) { p(d.parent.node) ? d.parent.node.splice(d.key, 1) : delete d.parent.node[d.key], e && (h = !1) }, keys: null, before: function (e) { u.before = e }, after: function (e) { u.after = e }, pre: function (e) { u.pre = e }, post: function (e) { u.post = e }, stop: function () { a = !1 }, block: function () { h = !1 } }; if (!a) return d; function g() { if ("object" == typeof d.node && null !== d.node) { d.keys && d.node_ === d.node || (d.keys = o(d.node)), d.isLeaf = 0 == d.keys.length; for (var e = 0; e < s.length; e++)if (s[e].node_ === c) { d.circular = s[e]; break } } else d.isLeaf = !0, d.keys = null; d.notLeaf = !d.isLeaf, d.notRoot = !d.isRoot } g(); var _ = t.call(d, d.node); return void 0 !== _ && d.update && d.update(_), u.before && u.before.call(d, d.node), h ? ("object" != typeof d.node || null === d.node || d.circular || (s.push(d), g(), f(d.keys, (function (t, i) { n.push(t), u.pre && u.pre.call(d, d.node[t], t); var o = e(d.node[t]); r && m.call(d.node, t) && (d.node[t] = o.node), o.isLast = i == d.keys.length - 1, o.isFirst = 0 == i, u.post && u.post.call(d, o), n.pop() })), s.pop()), u.after && u.after.call(d, d.node), d) : d }(e).node } function i(e) { if ("object" == typeof e && null !== e) { var t; if (p(e)) t = []; else if (a(e)) t = new Date(e.getTime ? e.getTime() : e); else if (c(e)) t = new RegExp(e); else if (l(e)) t = { message: e.message }; else if (u(e)) t = new Boolean(e); else if (h(e)) t = new Number(e); else if (d(e)) t = new String(e); else if (Object.create && Object.getPrototypeOf) t = Object.create(Object.getPrototypeOf(e)); else if (e.constructor === Object) t = {}; else { var r = e.constructor && e.constructor.prototype || e.__proto__ || {}, n = function () { }; n.prototype = r, t = new n } return f(o(e), (function (r) { t[r] = e[r] })), t } return e } r.prototype.get = function (e) { for (var t = this.value, r = 0; r < e.length; r++) { var n = e[r]; if (!t || !m.call(t, n)) { t = void 0; break } t = t[n] } return t }, r.prototype.has = function (e) { for (var t = this.value, r = 0; r < e.length; r++) { var n = e[r]; if (!t || !m.call(t, n)) return !1; t = t[n] } return !0 }, r.prototype.set = function (e, t) { for (var r = this.value, n = 0; n < e.length - 1; n++) { var i = e[n]; m.call(r, i) || (r[i] = {}), r = r[i] } return r[e[n]] = t, t }, r.prototype.map = function (e) { return n(this.value, e, !0) }, r.prototype.forEach = function (e) { return this.value = n(this.value, e, !1), this.value }, r.prototype.reduce = function (e, t) { var r = 1 === arguments.length, n = r ? this.value : t; return this.forEach((function (t) { this.isRoot && r || (n = e.call(this, n, t)) })), n }, r.prototype.paths = function () { var e = []; return this.forEach((function (t) { e.push(this.path) })), e }, r.prototype.nodes = function () { var e = []; return this.forEach((function (t) { e.push(this.node) })), e }, r.prototype.clone = function () { var e = [], t = []; return function r(n) { for (var s = 0; s < e.length; s++)if (e[s] === n) return t[s]; if ("object" == typeof n && null !== n) { var a = i(n); return e.push(n), t.push(a), f(o(n), (function (e) { a[e] = r(n[e]) })), e.pop(), t.pop(), a } return n }(this.value) }; var o = Object.keys || function (e) { var t = []; for (var r in e) t.push(r); return t }; function s(e) { return Object.prototype.toString.call(e) } function a(e) { return "[object Date]" === s(e) } function c(e) { return "[object RegExp]" === s(e) } function l(e) { return "[object Error]" === s(e) } function u(e) { return "[object Boolean]" === s(e) } function h(e) { return "[object Number]" === s(e) } function d(e) { return "[object String]" === s(e) } var p = Array.isArray || function (e) { return "[object Array]" === Object.prototype.toString.call(e) }, f = function (e, t) { if (e.forEach) return e.forEach(t); for (var r = 0; r < e.length; r++)t(e[r], r, e) }; f(o(r.prototype), (function (e) { t[e] = function (t) { var n = [].slice.call(arguments, 1), i = new r(t); return i[e].apply(i, n) } })); var m = Object.hasOwnProperty || function (e, t) { return t in e } })), Ue = Ne; function Ne(e) { if (!(this instanceof Ne)) return new Ne(e); this._bbox = e || [1 / 0, 1 / 0, -1 / 0, -1 / 0], this._valid = !!e } Ne.prototype.include = function (e) { return this._valid = !0, this._bbox[0] = Math.min(this._bbox[0], e[0]), this._bbox[1] = Math.min(this._bbox[1], e[1]), this._bbox[2] = Math.max(this._bbox[2], e[0]), this._bbox[3] = Math.max(this._bbox[3], e[1]), this }, Ne.prototype.equals = function (e) { var t; return t = e instanceof Ne ? e.bbox() : e, this._bbox[0] == t[0] && this._bbox[1] == t[1] && this._bbox[2] == t[2] && this._bbox[3] == t[3] }, Ne.prototype.center = function (e) { return this._valid ? [(this._bbox[0] + this._bbox[2]) / 2, (this._bbox[1] + this._bbox[3]) / 2] : null }, Ne.prototype.union = function (e) { var t; return this._valid = !0, t = e instanceof Ne ? e.bbox() : e, this._bbox[0] = Math.min(this._bbox[0], t[0]), this._bbox[1] = Math.min(this._bbox[1], t[1]), this._bbox[2] = Math.max(this._bbox[2], t[2]), this._bbox[3] = Math.max(this._bbox[3], t[3]), this }, Ne.prototype.bbox = function () { return this._valid ? this._bbox : null }, Ne.prototype.contains = function (e) { if (!e) return this._fastContains(); if (!this._valid) return null; var t = e[0], r = e[1]; return this._bbox[0] <= t && this._bbox[1] <= r && this._bbox[2] >= t && this._bbox[3] >= r }, Ne.prototype.intersect = function (e) { return this._valid ? (t = e instanceof Ne ? e.bbox() : e, !(this._bbox[0] > t[2] || this._bbox[2] < t[0] || this._bbox[3] < t[1] || this._bbox[1] > t[3])) : null; var t }, Ne.prototype._fastContains = function () { if (!this._valid) return new Function("return null;"); var e = "return " + this._bbox[0] + "<= ll[0] &&" + this._bbox[1] + "<= ll[1] &&" + this._bbox[2] + ">= ll[0] &&" + this._bbox[3] + ">= ll[1]"; return new Function("ll", e) }, Ne.prototype.polygon = function () { return this._valid ? { type: "Polygon", coordinates: [[[this._bbox[0], this._bbox[1]], [this._bbox[2], this._bbox[1]], [this._bbox[2], this._bbox[3]], [this._bbox[0], this._bbox[3]], [this._bbox[0], this._bbox[1]]]] } : null }; var Ge = { features: ["FeatureCollection"], coordinates: ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], geometry: ["Feature"], geometries: ["GeometryCollection"] }, Ve = Object.keys(Ge), qe = function (e) { return We(e).bbox() }, je = function (e) { return We(e).polygon() }, Xe = function (e) { return ze(e).map((function (e) { e && Ve.some((function (t) { return !!e[t] && -1 !== Ge[t].indexOf(e.type) })) && (e.bbox = We(e).bbox(), this.update(e)) })) }; function We(e) { for (var t = Ue(), r = Oe(e), n = 0; n < r.length; n++)t.include(r[n]); return t } qe.polygon = je, qe.bboxify = Xe; var Ze = y, He = x, Qe = v, $e = b, Je = w, Ke = T; function Ye(e, t) { var r = Ze, n = He, i = Ze, o = He, s = Ke, a = Je; e.forEach((function (e) { var t = qe(e), c = t[1], l = t[3], u = t[0], h = t[2]; c > r && (r = c), l < n && (n = l), l > i && (i = l), c < o && (o = c), u < s && (s = u), h > a && (a = h) })); var c = t; return r + c.lat > $e && (c.lat = $e - r), i + c.lat > He && (c.lat = He - i), n + c.lat < Qe && (c.lat = Qe - n), o + c.lat < Ze && (c.lat = Ze - o), s + c.lng <= Je && (c.lng += 360 * Math.ceil(Math.abs(c.lng) / 360)), a + c.lng >= Ke && (c.lng -= 360 * Math.ceil(Math.abs(c.lng) / 360)), c } function et(e, t) { var r = Ye(e.map((function (e) { return e.toGeoJSON() })), t); e.forEach((function (e) { var t, n = e.getCoordinates(), i = function (e) { var t = { lng: e[0] + r.lng, lat: e[1] + r.lat }; return [t.lng, t.lat] }, o = function (e) { return e.map((function (e) { return i(e) })) }, s = function (e) { return e.map((function (e) { return o(e) })) }; e.type === h.POINT ? t = i(n) : e.type === h.LINE_STRING || e.type === h.MULTI_POINT ? t = n.map(i) : e.type === h.POLYGON || e.type === h.MULTI_LINE_STRING ? t = n.map(o) : e.type === h.MULTI_POLYGON && (t = n.map(s)), e.incomingCoords(t) })) } var tt = { onSetup: function (e) { var t = this, r = { dragMoveLocation: null, boxSelectStartLocation: null, boxSelectElement: void 0, boxSelecting: !1, canBoxSelect: !1, dragMoving: !1, canDragMove: !1, initiallySelectedFeatureIds: e.featureIds || [] }; return this.setSelected(r.initiallySelectedFeatureIds.filter((function (e) { return void 0 !== t.getFeature(e) }))), this.fireActionable(), this.setActionableState({ combineFeatures: !0, uncombineFeatures: !0, trash: !0 }), r }, fireUpdate: function () { this.map.fire(p.UPDATE, { action: f.MOVE, features: this.getSelected().map((function (e) { return e.toGeoJSON() })) }) }, fireActionable: function () { var e = this, t = this.getSelected(), r = t.filter((function (t) { return e.isInstanceOf("MultiFeature", t) })), n = !1; if (t.length > 1) { n = !0; var i = t[0].type.replace("Multi", ""); t.forEach((function (e) { e.type.replace("Multi", "") !== i && (n = !1) })) } var o = r.length > 0, s = t.length > 0; this.setActionableState({ combineFeatures: n, uncombineFeatures: o, trash: s }) }, getUniqueIds: function (e) { return e.length ? e.map((function (e) { return e.properties.id })).filter((function (e) { return void 0 !== e })).reduce((function (e, t) { return e.add(t), e }), new P).values() : [] }, stopExtendedInteractions: function (e) { e.boxSelectElement && (e.boxSelectElement.parentNode && e.boxSelectElement.parentNode.removeChild(e.boxSelectElement), e.boxSelectElement = null), this.map.dragPan.enable(), e.boxSelecting = !1, e.canBoxSelect = !1, e.dragMoving = !1, e.canDragMove = !1 }, onStop: function () { Le.enable(this) }, onMouseMove: function (e) { return this.stopExtendedInteractions(e), !0 }, onMouseOut: function (e) { return !e.dragMoving || this.fireUpdate() } }; tt.onTap = tt.onClick = function (e, t) { return ve(t) ? this.clickAnywhere(e, t) : fe(m.VERTEX)(t) ? this.clickOnVertex(e, t) : xe(t) ? this.clickOnFeature(e, t) : void 0 }, tt.clickAnywhere = function (e) { var t = this, r = this.getSelectedIds(); r.length && (this.clearSelectedFeatures(), r.forEach((function (e) { return t.doRender(e) }))), Le.enable(this), this.stopExtendedInteractions(e) }, tt.clickOnVertex = function (e, t) { this.changeMode(d.DIRECT_SELECT, { featureId: t.featureTarget.properties.parent, coordPath: t.featureTarget.properties.coord_path, startPos: t.lngLat }), this.updateUIClasses({ mouse: l.MOVE }) }, tt.startOnActiveFeature = function (e, t) { this.stopExtendedInteractions(e), this.map.dragPan.disable(), this.doRender(t.featureTarget.properties.id), e.canDragMove = !0, e.dragMoveLocation = t.lngLat }, tt.clickOnFeature = function (e, t) { var r = this; Le.disable(this), this.stopExtendedInteractions(e); var n = we(t), i = this.getSelectedIds(), o = t.featureTarget.properties.id, s = this.isSelected(o); if (!n && s && this.getFeature(o).type !== h.POINT) return this.changeMode(d.DIRECT_SELECT, { featureId: o }); s && n ? (this.deselect(o), this.updateUIClasses({ mouse: l.POINTER }), 1 === i.length && Le.enable(this)) : !s && n ? (this.select(o), this.updateUIClasses({ mouse: l.MOVE })) : s || n || (i.forEach((function (e) { return r.doRender(e) })), this.setSelected(o), this.updateUIClasses({ mouse: l.MOVE })), this.doRender(o) }, tt.onMouseDown = function (e, t) { return ge(t) ? this.startOnActiveFeature(e, t) : this.drawConfig.boxSelect && me(t) ? this.startBoxSelect(e, t) : void 0 }, tt.startBoxSelect = function (e, t) { this.stopExtendedInteractions(e), this.map.dragPan.disable(), e.boxSelectStartLocation = Se(t.originalEvent, this.map.getContainer()), e.canBoxSelect = !0 }, tt.onTouchStart = function (e, t) { if (ge(t)) return this.startOnActiveFeature(e, t) }, tt.onDrag = function (e, t) { return e.canDragMove ? this.dragMove(e, t) : this.drawConfig.boxSelect && e.canBoxSelect ? this.whileBoxSelect(e, t) : void 0 }, tt.whileBoxSelect = function (e, t) { e.boxSelecting = !0, this.updateUIClasses({ mouse: l.ADD }), e.boxSelectElement || (e.boxSelectElement = document.createElement("div"), e.boxSelectElement.classList.add(a.BOX_SELECT), this.map.getContainer().appendChild(e.boxSelectElement)); var r = Se(t.originalEvent, this.map.getContainer()), n = Math.min(e.boxSelectStartLocation.x, r.x), i = Math.max(e.boxSelectStartLocation.x, r.x), o = Math.min(e.boxSelectStartLocation.y, r.y), s = Math.max(e.boxSelectStartLocation.y, r.y), c = "translate(" + n + "px, " + o + "px)"; e.boxSelectElement.style.transform = c, e.boxSelectElement.style.WebkitTransform = c, e.boxSelectElement.style.width = i - n + "px", e.boxSelectElement.style.height = s - o + "px" }, tt.dragMove = function (e, t) { e.dragMoving = !0, t.originalEvent.stopPropagation(); var r = { lng: t.lngLat.lng - e.dragMoveLocation.lng, lat: t.lngLat.lat - e.dragMoveLocation.lat }; et(this.getSelected(), r), e.dragMoveLocation = t.lngLat }, tt.onTouchEnd = tt.onMouseUp = function (e, t) { var r = this; if (e.dragMoving) this.fireUpdate(); else if (e.boxSelecting) { var n = [e.boxSelectStartLocation, Se(t.originalEvent, this.map.getContainer())], i = this.featuresAt(null, n, "click"), o = this.getUniqueIds(i).filter((function (e) { return !r.isSelected(e) })); o.length && (this.select(o), o.forEach((function (e) { return r.doRender(e) })), this.updateUIClasses({ mouse: l.MOVE })) } this.stopExtendedInteractions(e) }, tt.toDisplayFeatures = function (e, t, r) { t.properties.active = this.isSelected(t.properties.id) ? g.ACTIVE : g.INACTIVE, r(t), this.fireActionable(), t.properties.active === g.ACTIVE && t.geometry.type !== h.POINT && Ae(t).forEach(r) }, tt.onTrash = function () { this.deleteFeature(this.getSelectedIds()), this.fireActionable() }, tt.onCombineFeatures = function () { var e = this.getSelected(); if (!(0 === e.length || e.length < 2)) { for (var t = [], r = [], n = e[0].type.replace("Multi", ""), i = 0; i < e.length; i++) { var o = e[i]; if (o.type.replace("Multi", "") !== n) return; o.type.includes("Multi") ? o.getCoordinates().forEach((function (e) { t.push(e) })) : t.push(o.getCoordinates()), r.push(o.toGeoJSON()) } if (r.length > 1) { var s = this.newFeature({ type: h.FEATURE, properties: r[0].properties, geometry: { type: "Multi" + n, coordinates: t } }); this.addFeature(s), this.deleteFeature(this.getSelectedIds(), { silent: !0 }), this.setSelected([s.id]), this.map.fire(p.COMBINE_FEATURES, { createdFeatures: [s.toGeoJSON()], deletedFeatures: r }) } this.fireActionable() } }, tt.onUncombineFeatures = function () { var e = this, t = this.getSelected(); if (0 !== t.length) { for (var r = [], n = [], i = function (i) { var o = t[i]; e.isInstanceOf("MultiFeature", o) && (o.getFeatures().forEach((function (t) { e.addFeature(t), t.properties = o.properties, r.push(t.toGeoJSON()), e.select([t.id]) })), e.deleteFeature(o.id, { silent: !0 }), n.push(o.toGeoJSON())) }, o = 0; o < t.length; o++)i(o); r.length > 1 && this.map.fire(p.UNCOMBINE_FEATURES, { createdFeatures: r, deletedFeatures: n }), this.fireActionable() } }; var rt = fe(m.VERTEX), nt = fe(m.MIDPOINT), it = { fireUpdate: function () { this.map.fire(p.UPDATE, { action: f.CHANGE_COORDINATES, features: this.getSelected().map((function (e) { return e.toGeoJSON() })) }) }, fireActionable: function (e) { this.setActionableState({ combineFeatures: !1, uncombineFeatures: !1, trash: e.selectedCoordPaths.length > 0 }) }, startDragging: function (e, t) { this.map.dragPan.disable(), e.canDragMove = !0, e.dragMoveLocation = t.lngLat }, stopDragging: function (e) { this.map.dragPan.enable(), e.dragMoving = !1, e.canDragMove = !1, e.dragMoveLocation = null }, onVertex: function (e, t) { this.startDragging(e, t); var r = t.featureTarget.properties, n = e.selectedCoordPaths.indexOf(r.coord_path); we(t) || -1 !== n ? we(t) && -1 === n && e.selectedCoordPaths.push(r.coord_path) : e.selectedCoordPaths = [r.coord_path]; var i = this.pathsToCoordinates(e.featureId, e.selectedCoordPaths); this.setSelectedCoordinates(i) }, onMidpoint: function (e, t) { this.startDragging(e, t); var r = t.featureTarget.properties; e.feature.addCoordinate(r.coord_path, r.lng, r.lat), this.fireUpdate(), e.selectedCoordPaths = [r.coord_path] }, pathsToCoordinates: function (e, t) { return t.map((function (t) { return { feature_id: e, coord_path: t } })) }, onFeature: function (e, t) { 0 === e.selectedCoordPaths.length ? this.startDragging(e, t) : this.stopDragging(e) }, dragFeature: function (e, t, r) { et(this.getSelected(), r), e.dragMoveLocation = t.lngLat }, dragVertex: function (e, t, r) { for (var n = e.selectedCoordPaths.map((function (t) { return e.feature.getCoordinate(t) })), i = Ye(n.map((function (e) { return { type: h.FEATURE, properties: {}, geometry: { type: h.POINT, coordinates: e } } })), r), o = 0; o < n.length; o++) { var s = n[o]; e.feature.updateCoordinate(e.selectedCoordPaths[o], s[0] + i.lng, s[1] + i.lat) } }, clickNoTarget: function () { this.changeMode(d.SIMPLE_SELECT) }, clickInactive: function () { this.changeMode(d.SIMPLE_SELECT) }, clickActiveFeature: function (e) { e.selectedCoordPaths = [], this.clearSelectedCoordinates(), e.feature.changed() }, onSetup: function (e) { var t = e.featureId, r = this.getFeature(t); if (!r) throw new Error("You must provide a featureId to enter direct_select mode"); if (r.type === h.POINT) throw new TypeError("direct_select mode doesn't handle point features"); var n = { featureId: t, feature: r, dragMoveLocation: e.startPos || null, dragMoving: !1, canDragMove: !1, selectedCoordPaths: e.coordPath ? [e.coordPath] : [] }; return this.setSelectedCoordinates(this.pathsToCoordinates(t, n.selectedCoordPaths)), this.setSelected(t), Le.disable(this), this.setActionableState({ trash: !0 }), n }, onStop: function () { Le.enable(this), this.clearSelectedCoordinates() }, toDisplayFeatures: function (e, t, r) { e.featureId === t.properties.id ? (t.properties.active = g.ACTIVE, r(t), Ae(t, { map: this.map, midpoints: !0, selectedPaths: e.selectedCoordPaths }).forEach(r)) : (t.properties.active = g.INACTIVE, r(t)), this.fireActionable(e) }, onTrash: function (e) { e.selectedCoordPaths.sort((function (e, t) { return t.localeCompare(e, "en", { numeric: !0 }) })).forEach((function (t) { return e.feature.removeCoordinate(t) })), this.fireUpdate(), e.selectedCoordPaths = [], this.clearSelectedCoordinates(), this.fireActionable(e), !1 === e.feature.isValid() && (this.deleteFeature([e.featureId]), this.changeMode(d.SIMPLE_SELECT, {})) }, onMouseMove: function (e, t) { var r = ge(t), n = rt(t), i = 0 === e.selectedCoordPaths.length; return r && i || n && !i ? this.updateUIClasses({ mouse: l.MOVE }) : this.updateUIClasses({ mouse: l.NONE }), this.stopDragging(e), !0 }, onMouseOut: function (e) { return e.dragMoving && this.fireUpdate(), !0 } }; it.onTouchStart = it.onMouseDown = function (e, t) { return rt(t) ? this.onVertex(e, t) : ge(t) ? this.onFeature(e, t) : nt(t) ? this.onMidpoint(e, t) : void 0 }, it.onDrag = function (e, t) { if (!0 === e.canDragMove) { e.dragMoving = !0, t.originalEvent.stopPropagation(); var r = { lng: t.lngLat.lng - e.dragMoveLocation.lng, lat: t.lngLat.lat - e.dragMoveLocation.lat }; e.selectedCoordPaths.length > 0 ? this.dragVertex(e, t, r) : this.dragFeature(e, t, r), e.dragMoveLocation = t.lngLat } }, it.onClick = function (e, t) { return ve(t) ? this.clickNoTarget(e, t) : ge(t) ? this.clickActiveFeature(e, t) : _e(t) ? this.clickInactive(e, t) : void this.stopDragging(e) }, it.onTap = function (e, t) { return ve(t) ? this.clickNoTarget(e, t) : ge(t) ? this.clickActiveFeature(e, t) : _e(t) ? this.clickInactive(e, t) : void 0 }, it.onTouchEnd = it.onMouseUp = function (e) { e.dragMoving && this.fireUpdate(), this.stopDragging(e) }; var ot = {}; function st(e, t) { return !!e.lngLat && e.lngLat.lng === t[0] && e.lngLat.lat === t[1] } ot.onSetup = function () { var e = this.newFeature({ type: h.FEATURE, properties: {}, geometry: { type: h.POINT, coordinates: [] } }); return this.addFeature(e), this.clearSelectedFeatures(), this.updateUIClasses({ mouse: l.ADD }), this.activateUIButton(u.POINT), this.setActionableState({ trash: !0 }), { point: e } }, ot.stopDrawingAndRemove = function (e) { this.deleteFeature([e.point.id], { silent: !0 }), this.changeMode(d.SIMPLE_SELECT) }, ot.onTap = ot.onClick = function (e, t) { this.updateUIClasses({ mouse: l.MOVE }), e.point.updateCoordinate("", t.lngLat.lng, t.lngLat.lat), this.map.fire(p.CREATE, { features: [e.point.toGeoJSON()] }), this.changeMode(d.SIMPLE_SELECT, { featureIds: [e.point.id] }) }, ot.onStop = function (e) { this.activateUIButton(), e.point.getCoordinate().length || this.deleteFeature([e.point.id], { silent: !0 }) }, ot.toDisplayFeatures = function (e, t, r) { var n = t.properties.id === e.point.id; if (t.properties.active = n ? g.ACTIVE : g.INACTIVE, !n) return r(t) }, ot.onTrash = ot.stopDrawingAndRemove, ot.onKeyUp = function (e, t) { if (Te(t) || ke(t)) return this.stopDrawingAndRemove(e, t) }; var at = { onSetup: function () { var e = this.newFeature({ type: h.FEATURE, properties: {}, geometry: { type: h.POLYGON, coordinates: [[]] } }); return this.addFeature(e), this.clearSelectedFeatures(), Le.disable(this), this.updateUIClasses({ mouse: l.ADD }), this.activateUIButton(u.POLYGON), this.setActionableState({ trash: !0 }), { polygon: e, currentVertexPosition: 0 } }, clickAnywhere: function (e, t) { if (e.currentVertexPosition > 0 && st(t, e.polygon.coordinates[0][e.currentVertexPosition - 1])) return this.changeMode(d.SIMPLE_SELECT, { featureIds: [e.polygon.id] }); this.updateUIClasses({ mouse: l.ADD }), e.polygon.updateCoordinate("0." + e.currentVertexPosition, t.lngLat.lng, t.lngLat.lat), e.currentVertexPosition++, e.polygon.updateCoordinate("0." + e.currentVertexPosition, t.lngLat.lng, t.lngLat.lat) }, clickOnVertex: function (e) { return this.changeMode(d.SIMPLE_SELECT, { featureIds: [e.polygon.id] }) }, onMouseMove: function (e, t) { e.polygon.updateCoordinate("0." + e.currentVertexPosition, t.lngLat.lng, t.lngLat.lat), be(t) && this.updateUIClasses({ mouse: l.POINTER }) } }; at.onTap = at.onClick = function (e, t) { return be(t) ? this.clickOnVertex(e, t) : this.clickAnywhere(e, t) }, at.onKeyUp = function (e, t) { Te(t) ? (this.deleteFeature([e.polygon.id], { silent: !0 }), this.changeMode(d.SIMPLE_SELECT)) : ke(t) && this.changeMode(d.SIMPLE_SELECT, { featureIds: [e.polygon.id] }) }, at.onStop = function (e) { this.updateUIClasses({ mouse: l.NONE }), Le.enable(this), this.activateUIButton(), void 0 !== this.getFeature(e.polygon.id) && (e.polygon.removeCoordinate("0." + e.currentVertexPosition), e.polygon.isValid() ? this.map.fire(p.CREATE, { features: [e.polygon.toGeoJSON()] }) : (this.deleteFeature([e.polygon.id], { silent: !0 }), this.changeMode(d.SIMPLE_SELECT, {}, { silent: !0 }))) }, at.toDisplayFeatures = function (e, t, r) { var n = t.properties.id === e.polygon.id; if (t.properties.active = n ? g.ACTIVE : g.INACTIVE, !n) return r(t); if (0 !== t.geometry.coordinates.length) { var i = t.geometry.coordinates[0].length; if (!(i < 3)) { if (t.properties.meta = m.FEATURE, r(Pe(e.polygon.id, t.geometry.coordinates[0][0], "0.0", !1)), i > 3) { var o = t.geometry.coordinates[0].length - 3; r(Pe(e.polygon.id, t.geometry.coordinates[0][o], "0." + o, !1)) } if (i <= 4) { var s = [[t.geometry.coordinates[0][0][0], t.geometry.coordinates[0][0][1]], [t.geometry.coordinates[0][1][0], t.geometry.coordinates[0][1][1]]]; if (r({ type: h.FEATURE, properties: t.properties, geometry: { coordinates: s, type: h.LINE_STRING } }), 3 === i) return } return r(t) } } }, at.onTrash = function (e) { this.deleteFeature([e.polygon.id], { silent: !0 }), this.changeMode(d.SIMPLE_SELECT) }; var ct = { onSetup: function (e) { var t, r, n = (e = e || {}).featureId, i = "forward"; if (n) { if (!(t = this.getFeature(n))) throw new Error("Could not find a feature with the provided featureId"); var o = e.from; if (o && "Feature" === o.type && o.geometry && "Point" === o.geometry.type && (o = o.geometry), o && "Point" === o.type && o.coordinates && 2 === o.coordinates.length && (o = o.coordinates), !o || !Array.isArray(o)) throw new Error("Please use the `from` property to indicate which point to continue the line from"); var s = t.coordinates.length - 1; if (t.coordinates[s][0] === o[0] && t.coordinates[s][1] === o[1]) r = s + 1, t.addCoordinate.apply(t, [r].concat(t.coordinates[s])); else { if (t.coordinates[0][0] !== o[0] || t.coordinates[0][1] !== o[1]) throw new Error("`from` should match the point at either the start or the end of the provided LineString"); i = "backwards", r = 0, t.addCoordinate.apply(t, [r].concat(t.coordinates[0])) } } else t = this.newFeature({ type: h.FEATURE, properties: {}, geometry: { type: h.LINE_STRING, coordinates: [] } }), r = 0, this.addFeature(t); return this.clearSelectedFeatures(), Le.disable(this), this.updateUIClasses({ mouse: l.ADD }), this.activateUIButton(u.LINE), this.setActionableState({ trash: !0 }), { line: t, currentVertexPosition: r, direction: i } }, clickAnywhere: function (e, t) { if (e.currentVertexPosition > 0 && st(t, e.line.coordinates[e.currentVertexPosition - 1]) || "backwards" === e.direction && st(t, e.line.coordinates[e.currentVertexPosition + 1])) return this.changeMode(d.SIMPLE_SELECT, { featureIds: [e.line.id] }); this.updateUIClasses({ mouse: l.ADD }), e.line.updateCoordinate(e.currentVertexPosition, t.lngLat.lng, t.lngLat.lat), "forward" === e.direction ? (e.currentVertexPosition++, e.line.updateCoordinate(e.currentVertexPosition, t.lngLat.lng, t.lngLat.lat)) : e.line.addCoordinate(0, t.lngLat.lng, t.lngLat.lat) }, clickOnVertex: function (e) { return this.changeMode(d.SIMPLE_SELECT, { featureIds: [e.line.id] }) }, onMouseMove: function (e, t) { e.line.updateCoordinate(e.currentVertexPosition, t.lngLat.lng, t.lngLat.lat), be(t) && this.updateUIClasses({ mouse: l.POINTER }) } }; ct.onTap = ct.onClick = function (e, t) { if (be(t)) return this.clickOnVertex(e, t); this.clickAnywhere(e, t) }, ct.onKeyUp = function (e, t) { ke(t) ? this.changeMode(d.SIMPLE_SELECT, { featureIds: [e.line.id] }) : Te(t) && (this.deleteFeature([e.line.id], { silent: !0 }), this.changeMode(d.SIMPLE_SELECT)) }, ct.onStop = function (e) { Le.enable(this), this.activateUIButton(), void 0 !== this.getFeature(e.line.id) && (e.line.removeCoordinate("" + e.currentVertexPosition), e.line.isValid() ? this.map.fire(p.CREATE, { features: [e.line.toGeoJSON()] }) : (this.deleteFeature([e.line.id], { silent: !0 }), this.changeMode(d.SIMPLE_SELECT, {}, { silent: !0 }))) }, ct.onTrash = function (e) { this.deleteFeature([e.line.id], { silent: !0 }), this.changeMode(d.SIMPLE_SELECT) }, ct.toDisplayFeatures = function (e, t, r) { var n = t.properties.id === e.line.id; if (t.properties.active = n ? g.ACTIVE : g.INACTIVE, !n) return r(t); t.geometry.coordinates.length < 2 || (t.properties.meta = m.FEATURE, r(Pe(e.line.id, t.geometry.coordinates["forward" === e.direction ? t.geometry.coordinates.length - 2 : 1], "" + ("forward" === e.direction ? t.geometry.coordinates.length - 2 : 1), !1)), r(t)) }; var lt = { simple_select: tt, direct_select: it, draw_point: ot, draw_polygon: at, draw_line_string: ct }, ut = { defaultMode: d.SIMPLE_SELECT, keybindings: !0, touchEnabled: !0, clickBuffer: 2, touchBuffer: 25, boxSelect: !0, displayControlsDefault: !0, styles: pe, modes: lt, controls: {}, userProperties: !1 }, ht = { point: !0, line_string: !0, polygon: !0, trash: !0, combine_features: !0, uncombine_features: !0 }, dt = { point: !1, line_string: !1, polygon: !1, trash: !1, combine_features: !1, uncombine_features: !1 }; function pt(e, t) { return e.map((function (e) { return e.source ? e : ae(e, { id: e.id + "." + t, source: "hot" === t ? c.HOT : c.COLD }) })) } function ft(e) { void 0 === e && (e = {}); var t = ae(e); return e.controls || (t.controls = {}), !1 === e.displayControlsDefault ? t.controls = ae(dt, e.controls) : t.controls = ae(ht, e.controls), (t = ae(ut, t)).styles = pt(t.styles, "cold").concat(pt(t.styles, "hot")), t } var mt = q((function (e, t) { var r = 200, n = "__lodash_hash_undefined__", i = 1, o = 2, s = 9007199254740991, a = "[object Arguments]", c = "[object Array]", l = "[object AsyncFunction]", u = "[object Boolean]", h = "[object Date]", d = "[object Error]", p = "[object Function]", f = "[object GeneratorFunction]", m = "[object Map]", g = "[object Number]", _ = "[object Null]", y = "[object Object]", v = "[object Promise]", x = "[object Proxy]", b = "[object RegExp]", w = "[object Set]", T = "[object String]", k = "[object Symbol]", C = "[object Undefined]", E = "[object WeakMap]", S = "[object ArrayBuffer]", P = "[object DataView]", I = "[object Float64Array]", A = "[object Int8Array]", L = "[object Int16Array]", M = "[object Int32Array]", B = "[object Uint8Array]", R = "[object Uint8ClampedArray]", D = "[object Uint16Array]", F = "[object Uint32Array]", O = /[\\^$.*+?()[\]{}|]/g, z = /^\[object .+?Constructor\]$/, U = /^(?:0|[1-9]\d*)$/, N = {}; N["[object Float32Array]"] = N[I] = N[A] = N[L] = N[M] = N[B] = N[R] = N[D] = N[F] = !0, N[a] = N[c] = N[S] = N[u] = N[P] = N[h] = N[d] = N[p] = N[m] = N[g] = N[y] = N[b] = N[w] = N[T] = N[E] = !1; var G = "object" == typeof ye && ye && ye.Object === Object && ye, V = "object" == typeof self && self && self.Object === Object && self, q = G || V || Function("return this")(), j = t && !t.nodeType && t, X = j && e && !e.nodeType && e, W = X && X.exports === j, Z = W && G.process, H = function () { try { return Z && Z.binding && Z.binding("util") } catch (e) { } }(), Q = H && H.isTypedArray; function $(e, t) { for (var r = -1, n = null == e ? 0 : e.length, i = 0, o = []; ++r < n;) { var s = e[r]; t(s, r, e) && (o[i++] = s) } return o } function J(e, t) { for (var r = -1, n = t.length, i = e.length; ++r < n;)e[i + r] = t[r]; return e } function K(e, t) { for (var r = -1, n = null == e ? 0 : e.length; ++r < n;)if (t(e[r], r, e)) return !0; return !1 } function Y(e, t) { for (var r = -1, n = Array(e); ++r < e;)n[r] = t(r); return n } function ee(e) { return function (t) { return e(t) } } function te(e, t) { return e.has(t) } function re(e, t) { return null == e ? void 0 : e[t] } function ne(e) { var t = -1, r = Array(e.size); return e.forEach((function (e, n) { r[++t] = [n, e] })), r } function ie(e, t) { return function (r) { return e(t(r)) } } function oe(e) { var t = -1, r = Array(e.size); return e.forEach((function (e) { r[++t] = e })), r } var se, ae = Array.prototype, ce = Function.prototype, le = Object.prototype, ue = q["__core-js_shared__"], he = ce.toString, de = le.hasOwnProperty, pe = (se = /[^.]+$/.exec(ue && ue.keys && ue.keys.IE_PROTO || "")) ? "Symbol(src)_1." + se : "", fe = le.toString, me = RegExp("^" + he.call(de).replace(O, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), ge = W ? q.Buffer : void 0, _e = q.Symbol, ve = q.Uint8Array, xe = le.propertyIsEnumerable, be = ae.splice, we = _e ? _e.toStringTag : void 0, Te = Object.getOwnPropertySymbols, ke = ge ? ge.isBuffer : void 0, Ce = ie(Object.keys, Object), Ee = St(q, "DataView"), Se = St(q, "Map"), Pe = St(q, "Promise"), Ie = St(q, "Set"), Ae = St(q, "WeakMap"), Le = St(Object, "create"), Me = Ft(Ee), Be = Ft(Se), Re = Ft(Pe), De = Ft(Ie), Fe = Ft(Ae), Oe = _e ? _e.prototype : void 0, ze = Oe ? Oe.valueOf : void 0; function Ue(e) { var t = -1, r = null == e ? 0 : e.length; for (this.clear(); ++t < r;) { var n = e[t]; this.set(n[0], n[1]) } } function Ne() { this.__data__ = Le ? Le(null) : {}, this.size = 0 } function Ge(e) { var t = this.has(e) && delete this.__data__[e]; return this.size -= t ? 1 : 0, t } function Ve(e) { var t = this.__data__; if (Le) { var r = t[e]; return r === n ? void 0 : r } return de.call(t, e) ? t[e] : void 0 } function qe(e) { var t = this.__data__; return Le ? void 0 !== t[e] : de.call(t, e) } function je(e, t) { var r = this.__data__; return this.size += this.has(e) ? 0 : 1, r[e] = Le && void 0 === t ? n : t, this } function Xe(e) { var t = -1, r = null == e ? 0 : e.length; for (this.clear(); ++t < r;) { var n = e[t]; this.set(n[0], n[1]) } } function We() { this.__data__ = [], this.size = 0 } function Ze(e) { var t = this.__data__, r = pt(t, e); return !(r < 0 || (r == t.length - 1 ? t.pop() : be.call(t, r, 1), --this.size, 0)) } function He(e) { var t = this.__data__, r = pt(t, e); return r < 0 ? void 0 : t[r][1] } function Qe(e) { return pt(this.__data__, e) > -1 } function $e(e, t) { var r = this.__data__, n = pt(r, e); return n < 0 ? (++this.size, r.push([e, t])) : r[n][1] = t, this } function Je(e) { var t = -1, r = null == e ? 0 : e.length; for (this.clear(); ++t < r;) { var n = e[t]; this.set(n[0], n[1]) } } function Ke() { this.size = 0, this.__data__ = { hash: new Ue, map: new (Se || Xe), string: new Ue } } function Ye(e) { var t = Et(this, e).delete(e); return this.size -= t ? 1 : 0, t } function et(e) { return Et(this, e).get(e) } function tt(e) { return Et(this, e).has(e) } function rt(e, t) { var r = Et(this, e), n = r.size; return r.set(e, t), this.size += r.size == n ? 0 : 1, this } function nt(e) { var t = -1, r = null == e ? 0 : e.length; for (this.__data__ = new Je; ++t < r;)this.add(e[t]) } function it(e) { return this.__data__.set(e, n), this } function ot(e) { return this.__data__.has(e) } function st(e) { var t = this.__data__ = new Xe(e); this.size = t.size } function at() { this.__data__ = new Xe, this.size = 0 } function ct(e) { var t = this.__data__, r = t.delete(e); return this.size = t.size, r } function lt(e) { return this.__data__.get(e) } function ut(e) { return this.__data__.has(e) } function ht(e, t) { var n = this.__data__; if (n instanceof Xe) { var i = n.__data__; if (!Se || i.length < r - 1) return i.push([e, t]), this.size = ++n.size, this; n = this.__data__ = new Je(i) } return n.set(e, t), this.size = n.size, this } function dt(e, t) { var r = Ut(e), n = !r && zt(e), i = !r && !n && Gt(e), o = !r && !n && !i && Zt(e), s = r || n || i || o, a = s ? Y(e.length, String) : [], c = a.length; for (var l in e) !t && !de.call(e, l) || s && ("length" == l || i && ("offset" == l || "parent" == l) || o && ("buffer" == l || "byteLength" == l || "byteOffset" == l) || Lt(l, c)) || a.push(l); return a } function pt(e, t) { for (var r = e.length; r--;)if (Ot(e[r][0], t)) return r; return -1 } function ft(e, t, r) { var n = t(e); return Ut(e) ? n : J(n, r(e)) } function mt(e) { return null == e ? void 0 === e ? C : _ : we && we in Object(e) ? Pt(e) : Dt(e) } function gt(e) { return Wt(e) && mt(e) == a } function _t(e, t, r, n, i) { return e === t || (null == e || null == t || !Wt(e) && !Wt(t) ? e != e && t != t : yt(e, t, r, n, _t, i)) } function yt(e, t, r, n, o, s) { var l = Ut(e), u = Ut(t), h = l ? c : At(e), d = u ? c : At(t), p = (h = h == a ? y : h) == y, f = (d = d == a ? y : d) == y, m = h == d; if (m && Gt(e)) { if (!Gt(t)) return !1; l = !0, p = !1 } if (m && !p) return s || (s = new st), l || Zt(e) ? wt(e, t, r, n, o, s) : Tt(e, t, h, r, n, o, s); if (!(r & i)) { var g = p && de.call(e, "__wrapped__"), _ = f && de.call(t, "__wrapped__"); if (g || _) { var v = g ? e.value() : e, x = _ ? t.value() : t; return s || (s = new st), o(v, x, r, n, s) } } return !!m && (s || (s = new st), kt(e, t, r, n, o, s)) } function vt(e) { return !(!Xt(e) || Bt(e)) && (qt(e) ? me : z).test(Ft(e)) } function xt(e) { return Wt(e) && jt(e.length) && !!N[mt(e)] } function bt(e) { if (!Rt(e)) return Ce(e); var t = []; for (var r in Object(e)) de.call(e, r) && "constructor" != r && t.push(r); return t } function wt(e, t, r, n, s, a) { var c = r & i, l = e.length, u = t.length; if (l != u && !(c && u > l)) return !1; var h = a.get(e); if (h && a.get(t)) return h == t; var d = -1, p = !0, f = r & o ? new nt : void 0; for (a.set(e, t), a.set(t, e); ++d < l;) { var m = e[d], g = t[d]; if (n) var _ = c ? n(g, m, d, t, e, a) : n(m, g, d, e, t, a); if (void 0 !== _) { if (_) continue; p = !1; break } if (f) { if (!K(t, (function (e, t) { if (!te(f, t) && (m === e || s(m, e, r, n, a))) return f.push(t) }))) { p = !1; break } } else if (m !== g && !s(m, g, r, n, a)) { p = !1; break } } return a.delete(e), a.delete(t), p } function Tt(e, t, r, n, s, a, c) { switch (r) { case P: if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1; e = e.buffer, t = t.buffer; case S: return !(e.byteLength != t.byteLength || !a(new ve(e), new ve(t))); case u: case h: case g: return Ot(+e, +t); case d: return e.name == t.name && e.message == t.message; case b: case T: return e == t + ""; case m: var l = ne; case w: var p = n & i; if (l || (l = oe), e.size != t.size && !p) return !1; var f = c.get(e); if (f) return f == t; n |= o, c.set(e, t); var _ = wt(l(e), l(t), n, s, a, c); return c.delete(e), _; case k: if (ze) return ze.call(e) == ze.call(t) }return !1 } function kt(e, t, r, n, o, s) { var a = r & i, c = Ct(e), l = c.length; if (l != Ct(t).length && !a) return !1; for (var u = l; u--;) { var h = c[u]; if (!(a ? h in t : de.call(t, h))) return !1 } var d = s.get(e); if (d && s.get(t)) return d == t; var p = !0; s.set(e, t), s.set(t, e); for (var f = a; ++u < l;) { var m = e[h = c[u]], g = t[h]; if (n) var _ = a ? n(g, m, h, t, e, s) : n(m, g, h, e, t, s); if (!(void 0 === _ ? m === g || o(m, g, r, n, s) : _)) { p = !1; break } f || (f = "constructor" == h) } if (p && !f) { var y = e.constructor, v = t.constructor; y == v || !("constructor" in e) || !("constructor" in t) || "function" == typeof y && y instanceof y && "function" == typeof v && v instanceof v || (p = !1) } return s.delete(e), s.delete(t), p } function Ct(e) { return ft(e, Ht, It) } function Et(e, t) { var r = e.__data__; return Mt(t) ? r["string" == typeof t ? "string" : "hash"] : r.map } function St(e, t) { var r = re(e, t); return vt(r) ? r : void 0 } function Pt(e) { var t = de.call(e, we), r = e[we]; try { e[we] = void 0; var n = !0 } catch (e) { } var i = fe.call(e); return n && (t ? e[we] = r : delete e[we]), i } Ue.prototype.clear = Ne, Ue.prototype.delete = Ge, Ue.prototype.get = Ve, Ue.prototype.has = qe, Ue.prototype.set = je, Xe.prototype.clear = We, Xe.prototype.delete = Ze, Xe.prototype.get = He, Xe.prototype.has = Qe, Xe.prototype.set = $e, Je.prototype.clear = Ke, Je.prototype.delete = Ye, Je.prototype.get = et, Je.prototype.has = tt, Je.prototype.set = rt, nt.prototype.add = nt.prototype.push = it, nt.prototype.has = ot, st.prototype.clear = at, st.prototype.delete = ct, st.prototype.get = lt, st.prototype.has = ut, st.prototype.set = ht; var It = Te ? function (e) { return null == e ? [] : (e = Object(e), $(Te(e), (function (t) { return xe.call(e, t) }))) } : Qt, At = mt; function Lt(e, t) { return !!(t = null == t ? s : t) && ("number" == typeof e || U.test(e)) && e > -1 && e % 1 == 0 && e < t } function Mt(e) { var t = typeof e; return "string" == t || "number" == t || "symbol" == t || "boolean" == t ? "__proto__" !== e : null === e } function Bt(e) { return !!pe && pe in e } function Rt(e) { var t = e && e.constructor; return e === ("function" == typeof t && t.prototype || le) } function Dt(e) { return fe.call(e) } function Ft(e) { if (null != e) { try { return he.call(e) } catch (e) { } try { return e + "" } catch (e) { } } return "" } function Ot(e, t) { return e === t || e != e && t != t } (Ee && At(new Ee(new ArrayBuffer(1))) != P || Se && At(new Se) != m || Pe && At(Pe.resolve()) != v || Ie && At(new Ie) != w || Ae && At(new Ae) != E) && (At = function (e) { var t = mt(e), r = t == y ? e.constructor : void 0, n = r ? Ft(r) : ""; if (n) switch (n) { case Me: return P; case Be: return m; case Re: return v; case De: return w; case Fe: return E }return t }); var zt = gt(function () { return arguments }()) ? gt : function (e) { return Wt(e) && de.call(e, "callee") && !xe.call(e, "callee") }, Ut = Array.isArray; function Nt(e) { return null != e && jt(e.length) && !qt(e) } var Gt = ke || $t; function Vt(e, t) { return _t(e, t) } function qt(e) { if (!Xt(e)) return !1; var t = mt(e); return t == p || t == f || t == l || t == x } function jt(e) { return "number" == typeof e && e > -1 && e % 1 == 0 && e <= s } function Xt(e) { var t = typeof e; return null != e && ("object" == t || "function" == t) } function Wt(e) { return null != e && "object" == typeof e } var Zt = Q ? ee(Q) : xt; function Ht(e) { return Nt(e) ? dt(e) : bt(e) } function Qt() { return [] } function $t() { return !1 } e.exports = Vt })); function gt(e, t) { return e.length === t.length && JSON.stringify(e.map((function (e) { return e })).sort()) === JSON.stringify(t.map((function (e) { return e })).sort()) } var _t = { Polygon: H, LineString: Z, Point: W, MultiPolygon: J, MultiLineString: J, MultiPoint: J }; function yt(e, t) { return t.modes = d, t.getFeatureIdsAt = function (t) { return A.click({ point: t }, null, e).map((function (e) { return e.properties.id })) }, t.getSelectedIds = function () { return e.store.getSelectedIds() }, t.getSelected = function () { return { type: h.FEATURE_COLLECTION, features: e.store.getSelectedIds().map((function (t) { return e.store.get(t) })).map((function (e) { return e.toGeoJSON() })) } }, t.getSelectedPoints = function () { return { type: h.FEATURE_COLLECTION, features: e.store.getSelectedCoordinates().map((function (e) { return { type: h.FEATURE, properties: {}, geometry: { type: h.POINT, coordinates: e.coordinates } } })) } }, t.set = function (r) { if (void 0 === r.type || r.type !== h.FEATURE_COLLECTION || !Array.isArray(r.features)) throw new Error("Invalid FeatureCollection"); var n = e.store.createRenderBatch(), i = e.store.getAllIds().slice(), o = t.add(r), s = new P(o); return (i = i.filter((function (e) { return !s.has(e) }))).length && t.delete(i), n(), o }, t.add = function (t) { var r = JSON.parse(JSON.stringify(Me(t))).features.map((function (t) { if (t.id = t.id || j(), null === t.geometry) throw new Error("Invalid geometry: null"); if (void 0 === e.store.get(t.id) || e.store.get(t.id).type !== t.geometry.type) { var r = _t[t.geometry.type]; if (void 0 === r) throw new Error("Invalid geometry type: " + t.geometry.type + "."); var n = new r(e, t); e.store.add(n) } else { var i = e.store.get(t.id); i.properties = t.properties, mt(i.getCoordinates(), t.geometry.coordinates) || i.incomingCoords(t.geometry.coordinates) } return t.id })); return e.store.render(), r }, t.get = function (t) { var r = e.store.get(t); if (r) return r.toGeoJSON() }, t.getAll = function () { return { type: h.FEATURE_COLLECTION, features: e.store.getAll().map((function (e) { return e.toGeoJSON() })) } }, t.delete = function (r) { return e.store.delete(r, { silent: !0 }), t.getMode() !== d.DIRECT_SELECT || e.store.getSelectedIds().length ? e.store.render() : e.events.changeMode(d.SIMPLE_SELECT, void 0, { silent: !0 }), t }, t.deleteAll = function () { return e.store.delete(e.store.getAllIds(), { silent: !0 }), t.getMode() === d.DIRECT_SELECT ? e.events.changeMode(d.SIMPLE_SELECT, void 0, { silent: !0 }) : e.store.render(), t }, t.changeMode = function (r, n) { return void 0 === n && (n = {}), r === d.SIMPLE_SELECT && t.getMode() === d.SIMPLE_SELECT ? (gt(n.featureIds || [], e.store.getSelectedIds()) || (e.store.setSelected(n.featureIds, { silent: !0 }), e.store.render()), t) : (r === d.DIRECT_SELECT && t.getMode() === d.DIRECT_SELECT && n.featureId === e.store.getSelectedIds()[0] || e.events.changeMode(r, n, { silent: !0 }), t) }, t.getMode = function () { return e.events.getMode() }, t.trash = function () { return e.events.trash({ silent: !0 }), t }, t.combineFeatures = function () { return e.events.combineFeatures({ silent: !0 }), t }, t.uncombineFeatures = function () { return e.events.uncombineFeatures({ silent: !0 }), t }, t.setFeatureProperty = function (r, n, i) { return e.store.setFeatureProperty(r, n, i), t }, t } var vt = function (e, t) { var r = { options: e = ft(e) }; t = yt(r, t), r.api = t; var n = de(r); return t.onAdd = n.onAdd, t.onRemove = n.onRemove, t.types = u, t.options = e, t }; function xt(e) { vt(e, this) } return xt.modes = lt, xt }() })); Fe('\r\n/* Override default control style */\r\n.mapbox-gl-draw_ctrl-bottom-left,\r\n.mapbox-gl-draw_ctrl-top-left {\r\n  margin-left:0;\r\n  border-radius:0 4px 4px 0;\r\n}\r\n.mapbox-gl-draw_ctrl-top-right,\r\n.mapbox-gl-draw_ctrl-bottom-right {\r\n  margin-right:0;\r\n  border-radius:4px 0 0 4px;\r\n}\r\n.mapbox-gl-draw_ctrl-draw {\r\n  background-color:rgba(0,0,0,0.75);\r\n  border-color:rgba(0,0,0,0.9);\r\n}\r\n.mapbox-gl-draw_ctrl-draw > button {\r\n  border-color:rgba(0,0,0,0.9);\r\n  color:rgba(255,255,255,0.5);\r\n  width:30px;\r\n  height:30px;\r\n}\r\n.mapbox-gl-draw_ctrl-draw > button:hover {\r\n  background-color:rgba(0,0,0,0.85);\r\n  color:rgba(255,255,255,0.75);\r\n}\r\n.mapbox-gl-draw_ctrl-draw > button.active,\r\n.mapbox-gl-draw_ctrl-draw > button.active:hover {\r\n  background-color:rgba(0,0,0,0.95);\r\n  color:#fff;\r\n}\r\n.mapbox-gl-draw_ctrl-draw-btn {\r\n  background-repeat: no-repeat;\r\n  background-position: center;\r\n}\r\n\r\n.mapbox-gl-draw_point {\r\n  background-image: url(\'data:image/svg+xml;utf8,%3Csvg xmlns="http://www.w3.org/2000/svg" width="20" height="20">%3Cpath d="m10 2c-3.3 0-6 2.7-6 6s6 9 6 9 6-5.7 6-9-2.7-6-6-6zm0 2c2.1 0 3.8 1.7 3.8 3.8 0 1.5-1.8 3.9-2.9 5.2h-1.7c-1.1-1.4-2.9-3.8-2.9-5.2-.1-2.1 1.6-3.8 3.7-3.8z"/>%3C/svg>\');\r\n}\r\n.mapbox-gl-draw_polygon {\r\n  background-image: url(\'data:image/svg+xml;utf8,%3Csvg xmlns="http://www.w3.org/2000/svg" width="20" height="20">%3Cpath d="m15 12.3v-4.6c.6-.3 1-1 1-1.7 0-1.1-.9-2-2-2-.7 0-1.4.4-1.7 1h-4.6c-.3-.6-1-1-1.7-1-1.1 0-2 .9-2 2 0 .7.4 1.4 1 1.7v4.6c-.6.3-1 1-1 1.7 0 1.1.9 2 2 2 .7 0 1.4-.4 1.7-1h4.6c.3.6 1 1 1.7 1 1.1 0 2-.9 2-2 0-.7-.4-1.4-1-1.7zm-8-.3v-4l1-1h4l1 1v4l-1 1h-4z"/>%3C/svg>\');\r\n}\r\n.mapbox-gl-draw_line {\r\n  background-image: url(\'data:image/svg+xml;utf8,%3Csvg xmlns="http://www.w3.org/2000/svg" width="20" height="20">%3Cpath d="m13.5 3.5c-1.4 0-2.5 1.1-2.5 2.5 0 .3 0 .6.2.9l-3.8 3.8c-.3-.1-.6-.2-.9-.2-1.4 0-2.5 1.1-2.5 2.5s1.1 2.5 2.5 2.5 2.5-1.1 2.5-2.5c0-.3 0-.6-.2-.9l3.8-3.8c.3.1.6.2.9.2 1.4 0 2.5-1.1 2.5-2.5s-1.1-2.5-2.5-2.5z"/>%3C/svg>\');\r\n}\r\n.mapbox-gl-draw_trash {\r\n  background-image: url(\'data:image/svg+xml;utf8,%3Csvg xmlns="http://www.w3.org/2000/svg" width="20" height="20">%3Cpath d="M10,3.4 c-0.8,0-1.5,0.5-1.8,1.2H5l-1,1v1h12v-1l-1-1h-3.2C11.5,3.9,10.8,3.4,10,3.4z M5,8v7c0,1,1,2,2,2h6c1,0,2-1,2-2V8h-2v5.5h-1.5V8h-3 v5.5H7V8H5z"/>%3C/svg>\');\r\n}\r\n.mapbox-gl-draw_uncombine {\r\n  background-image: url(\'data:image/svg+xml;utf8,%3Csvg xmlns="http://www.w3.org/2000/svg" width="20" height="20">%3Cpath d="m12 2c-.3 0-.5.1-.7.3l-1 1c-.4.4-.4 1 0 1.4l1 1c.4.4 1 .4 1.4 0l1-1c.4-.4.4-1 0-1.4l-1-1c-.2-.2-.4-.3-.7-.3zm4 4c-.3 0-.5.1-.7.3l-1 1c-.4.4-.4 1 0 1.4l1 1c.4.4 1 .4 1.4 0l1-1c.4-.4.4-1 0-1.4l-1-1c-.2-.2-.4-.3-.7-.3zm-7 1c-1 0-1 1-.5 1.5.3.3 1 1 1 1l-1 1s-.5.5 0 1 1 0 1 0l1-1 1 1c.5.5 1.5.5 1.5-.5v-4zm-5 3c-.3 0-.5.1-.7.3l-1 1c-.4.4-.4 1 0 1.4l4.9 4.9c.4.4 1 .4 1.4 0l1-1c.4-.4.4-1 0-1.4l-4.9-4.9c-.1-.2-.4-.3-.7-.3z"/>%3C/svg>\');\r\n}\r\n.mapbox-gl-draw_combine {\r\n  background-image: url(\'data:image/svg+xml;utf8,%3Csvg xmlns="http://www.w3.org/2000/svg" width="20" height="20">%3Cpath d="M12.1,2c-0.3,0-0.5,0.1-0.7,0.3l-1,1c-0.4,0.4-0.4,1,0,1.4l4.9,4.9c0.4,0.4,1,0.4,1.4,0l1-1 c0.4-0.4,0.4-1,0-1.4l-4.9-4.9C12.6,2.1,12.3,2,12.1,2z M8,8C7,8,7,9,7.5,9.5c0.3,0.3,1,1,1,1l-1,1c0,0-0.5,0.5,0,1s1,0,1,0l1-1l1,1 C11,13,12,13,12,12V8H8z M4,10c-0.3,0-0.5,0.1-0.7,0.3l-1,1c-0.4,0.4-0.4,1,0,1.4l1,1c0.4,0.4,1,0.4,1.4,0l1-1c0.4-0.4,0.4-1,0-1.4 l-1-1C4.5,10.1,4.3,10,4,10z M8,14c-0.3,0-0.5,0.1-0.7,0.3l-1,1c-0.4,0.4-0.4,1,0,1.4l1,1c0.4,0.4,1,0.4,1.4,0l1-1 c0.4-0.4,0.4-1,0-1.4l-1-1C8.5,14.1,8.3,14,8,14z"/>%3C/svg>\');\r\n}\r\n\r\n.mapboxgl-map.mouse-pointer .mapboxgl-canvas-container.mapboxgl-interactive {\r\n  cursor: pointer;\r\n}\r\n.mapboxgl-map.mouse-move .mapboxgl-canvas-container.mapboxgl-interactive {\r\n  cursor: move;\r\n}\r\n.mapboxgl-map.mouse-add .mapboxgl-canvas-container.mapboxgl-interactive {\r\n  cursor: crosshair;\r\n}\r\n.mapboxgl-map.mouse-move.mode-direct_select .mapboxgl-canvas-container.mapboxgl-interactive {\r\n  cursor: grab;\r\n  cursor: -moz-grab;\r\n  cursor: -webkit-grab;\r\n}\r\n.mapboxgl-map.mode-direct_select.feature-vertex.mouse-move .mapboxgl-canvas-container.mapboxgl-interactive {\r\n  cursor: move;\r\n}\r\n.mapboxgl-map.mode-direct_select.feature-midpoint.mouse-pointer .mapboxgl-canvas-container.mapboxgl-interactive {\r\n  cursor: cell;\r\n}\r\n.mapboxgl-map.mode-direct_select.feature-feature.mouse-move .mapboxgl-canvas-container.mapboxgl-interactive {\r\n  cursor: move;\r\n}\r\n.mapboxgl-map.mode-static.mouse-pointer  .mapboxgl-canvas-container.mapboxgl-interactive {\r\n  cursor: grab;\r\n  cursor: -moz-grab;\r\n  cursor: -webkit-grab;\r\n}\r\n\r\n.mapbox-gl-draw_boxselect {\r\n    pointer-events: none;\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 0;\r\n    height: 0;\r\n    background: rgba(0,0,0,.1);\r\n    border: 2px dotted #fff;\r\n    opacity: 0.5;\r\n}\r\n'); const ze = [{ id: "gl-draw-polygon-fill-inactive", type: "fill", filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]], paint: { "fill-color": ["case", ["==", ["get", "user_regionType"], "12"], "#e6e4d7", ["==", ["get", "user_regionType"], "1"], "#990033", "#3bb2d0"], "fill-outline-color": "#3bb2d0", "fill-opacity": ["case", ["==", ["get", "user_regionType"], "12"], 1, .1] } }, { id: "gl-draw-polygon-fill-active", type: "fill", filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]], paint: { "fill-color": "#fbb03b", "fill-outline-color": "#fbb03b", "fill-opacity": .1 } }, { id: "gl-draw-polygon-midpoint", type: "circle", filter: ["all", ["==", "$type", "Point"], ["==", "meta", "midpoint"]], paint: { "circle-radius": 3, "circle-color": "#fbb03b" } }, { id: "gl-draw-polygon-stroke-inactive", type: "line", filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": ["case", ["==", ["get", "user_regionType"], "12"], "#e6e4d7", "#3bb2d0"], "line-width": 2 } }, { id: "gl-draw-polygon-stroke-active", type: "line", filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#fbb03b", "line-dasharray": [.2, 2], "line-width": 2 } }, { id: "gl-draw-line-inactive", type: "line", filter: ["all", ["==", "active", "false"], ["==", "$type", "LineString"], ["!=", "mode", "static"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": ["case", ["==", ["get", "user_lineType"], "2"], "#2a7c80", ["all", ["!=", ["get", "user_color"], ""], ["!=", ["get", "user_color"], null]], ["get", "user_color"], "#d5d5d5"], "line-width": ["case", ["all", ["!=", ["get", "user_width"], ""], ["!=", ["get", "user_width"], null]], ["get", "user_width"], 3] } }, { id: "gl-draw-line-active", type: "line", filter: ["all", ["==", "$type", "LineString"], ["==", "active", "true"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#fbb03b", "line-dasharray": [.2, 2], "line-width": 2 } }, { id: "gl-draw-polygon-and-line-vertex-stroke-inactive", type: "circle", filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]], paint: { "circle-radius": 5, "circle-color": "#fff" } }, { id: "gl-draw-polygon-and-line-vertex-inactive", type: "circle", filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]], paint: { "circle-radius": 3, "circle-color": "#fbb03b" } }, { id: "gl-draw-point-point-stroke-inactive", type: "circle", filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]], paint: { "circle-radius": 5, "circle-opacity": 1, "circle-color": "#fff" } }, { id: "gl-draw-point-inactive", type: "circle", filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]], paint: { "circle-radius": ["case", ["all", ["!=", ["get", "user_radius"], ""], ["!=", ["get", "user_radius"], null]], ["get", "user_radius"], 3], "circle-color": ["case", ["==", ["get", "user_type"], "9"], "red", ["==", ["get", "user_type"], "25"], "blue", ["==", ["get", "user_type"], "26"], "#00ff00", ["all", ["!=", ["get", "user_color"], ""], ["!=", ["get", "user_color"], null]], ["get", "user_color"], "#3bb2d0"] } }, { id: "gl-draw-point-stroke-active", type: "circle", filter: ["all", ["==", "$type", "Point"], ["==", "active", "true"], ["!=", "meta", "midpoint"]], paint: { "circle-radius": ["case", ["all", ["!=", ["get", "user_radius"], ""], ["!=", ["get", "user_radius"], null]], ["get", "user_radius"], 7], "circle-color": "#fff" } }, { id: "gl-draw-point-active", type: "circle", filter: ["all", ["==", "$type", "Point"], ["!=", "meta", "midpoint"], ["==", "active", "true"]], paint: { "circle-radius": 5, "circle-color": "#fbb03b" } }, { id: "gl-draw-polygon-fill-static", type: "fill", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]], paint: { "fill-color": "#404040", "fill-outline-color": "#404040", "fill-opacity": .1 } }, { id: "gl-draw-polygon-stroke-static", type: "line", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#404040", "line-width": 2 } }, { id: "gl-draw-line-static", type: "line", filter: ["all", ["==", "mode", "static"], ["==", "$type", "LineString"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#404040", "line-width": 2 } }, { id: "gl-draw-point-static", type: "circle", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Point"]], paint: { "circle-radius": 5, "circle-color": "#404040" } }]; class Ue { constructor(e) { this._map = e, this._initDraw() } async initFeatures(e) { await this._draw.add(e) } updateFeature(e) { this._draw.add(e) } clearFeature() { this._draw.deleteAll() } addFeature(e) { this.updateFeature(e) } currentFeature() { const e = this._draw.getSelected(); return 1 === e.features.length ? e.features[0] : null } getAll() { return this._draw.getAll() } getFeature(e) { return this._draw.get(e) } delFeature(e) { e ? this._draw.delete(e) : this._draw.delete(this._draw.getSelectedIds()) } _initDraw() { const e = this._map, t = Oe.modes; this.setClickIntercept(t); const r = new Oe({ displayControlsDefault: !1, controls: { point: !0, line_string: !0, polygon: !0, trash: !0 }, modes: t, userProperties: !0, styles: ze }); e.addControl(r, "top-left"), this._draw = r, e.on("draw.update", (e => { this.setMapSymbol() })) } setMapSymbol() { const e = this._draw.getAll(), t = this._map.getSource("map-tag"); t ? t.setData(e) : (this._map.addSource("map-tag", { type: "geojson", data: e }), this._createMapTagLayer()) } _createMapTagLayer() { this._map.addLayer({ id: "map-tag-point", type: "symbol", source: "map-tag", filter: ["==", "$type", "Point"], layout: { "text-field": "{name}", "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"], "text-offset": [0, .5], "text-anchor": "top", "text-size": 14 }, paint: { "text-color": "#fff", "text-halo-color": "#000", "text-halo-width": 1 } }), this._map.addLayer({ id: "map-tag-line-plogy", type: "symbol", source: "map-tag", filter: ["!=", "$type", "Point"], layout: { "text-field": "{desc}", "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"], "text-offset": [0, .5], "text-anchor": "top", "text-size": 12 }, paint: { "text-color": ["case", ["==", ["get", "lineType"], "1"], "#21ba45", ["==", ["get", "lineType"], "2"], "#c10015", "#1976d2"] } }) } setClickIntercept(e) { e.simple_select.onClick = function (e, t) { if (t.preventDefault(), t && t.featureTarget) { let r = t.featureTarget; if ("Polygon" === r.properties["meta:type"]) return; if ("LineString" === r.properties["meta:type"]) return; if ("Point" === r.properties["meta:type"] && (!r.properties.user_enableSelect || "false" === r.properties.user_enableSelect)) return; this.clickOnFeature(e, t) } else this.clickAnywhere(e, t) }, e.simple_select.onTap = function (e, t) { if (t.preventDefault(), t && t.featureTarget) { let e = t.featureTarget; if ("Polygon" === e.properties["meta:type"]) return; if ("LineString" === e.properties["meta:type"]) return; if ("Point" === e.properties["meta:type"] && (!e.properties.user_enableSelect || "false" === e.properties.user_enableSelect)) return } this.onClick(e, t) } } changeMode(e) { e ? this._draw.changeMode(e) : this._draw.changeMode("simple_select") } changeFeatureColor(e, t, r) { this._draw.setFeatureProperty(e, t, r) } getSelectedFeatures() { const e = this._draw.getSelected(); return e.features.length > 0 ? e.features : null } setSelectedFeatures(e) { this._draw.changeMode(this._draw.modes.SIMPLE_SELECT, { featureIds: e }) } } let Ne, Ge; function Ve() { Ne.getLayer("axis") || Ne.addLayer({ id: "axis", type: "line", layout: { "line-join": "round", "line-cap": "round" }, paint: { "line-color": "#ff0000", "line-width": 1 }, source: { type: "geojson", data: { type: "Feature", properties: {}, geometry: { type: "MultiLineString", coordinates: [] } } } }) } async function qe(e) { await Xe(e) } function je() { Ne.getLayer("map-tag-line-plogy") && Ne.removeLayer("map-tag-line-plogy"), Ne.getLayer("map-tag-point") && Ne.removeLayer("map-tag-point"), Ne.getSource("map-tag") && Ne.removeSource("map-tag") } async function Xe(e) { e || (e = Ge.getAll()); const t = Ne.getSource("map-tag"); t ? t.setData(e) : (Ne.addSource("map-tag", { type: "geojson", data: e }), Ne.addLayer({ id: "map-tag-point", type: "symbol", source: "map-tag", filter: ["==", "$type", "Point"], layout: { "text-field": "{name}", "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"], "text-offset": [0, .5], "text-anchor": "top", "text-size": 14 }, paint: { "text-color": "#fff", "text-halo-color": "#000", "text-halo-width": 1 } }), Ne.addLayer({ id: "map-tag-line-plogy", type: "symbol", source: "map-tag", filter: ["!=", "$type", "Point"], layout: { "text-field": "{desc}", "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"], "text-offset": [0, .5], "text-anchor": "top", "text-size": 12 }, paint: { "text-color": ["case", ["==", ["get", "lineType"], "1"], "#21ba45", ["==", ["get", "lineType"], "2"], "#c10015", "#1976d2"] } })) } De.accessToken = ke.mapboxToken; var We = { initMap: function (e, t, r, n, i) { return t || (t = "#cdccb5"), r || (r = 17), n || (n = [0, 0]), i || (i = "mapbox://fonts/mapbox/{fontstack}/{range}.pbf"), Ne = new De.Map({ container: e, center: n, zoom: r, doubleClickZoom: !1, style: { version: 8, sources: {}, glyphs: i, layers: [{ id: "background", type: "background", paint: { "background-color": t } }] } }), Ne.dragRotate.disable(), Ne.touchZoomRotate.disableRotation(), new Promise(((e, t) => { Ne.on("load", (() => { Ve(), Ge = new Ue(Ne), e(Ne) })) })) }, setBaseMap: async function (e, t) { Ve(); let r = null; r = "string" == typeof e ? e : URL.createObjectURL(new Blob([e], { type: "image/png" })); const n = await async function (e) { const { originX: t, originY: r, resolution: n, pixelWidth: i, pixelHeight: o } = e, s = i * n + t, a = o * n + r; return [[1e-4 * t, 1e-4 * a], [1e-4 * s, 1e-4 * a], [1e-4 * s, 1e-4 * r], [1e-4 * t, 1e-4 * r]] }(t), i = Ne.getSource("basemap"); i ? i.updateImage({ url: r, coordinates: n }) : (Ne.addSource("basemap", { type: "image", url: r, coordinates: n }), Ne.addLayer({ id: "basemap", type: "raster", source: "basemap", paint: { "raster-fade-duration": 0 } }, "axis")), URL.revokeObjectURL(r) }, initFeatures: async function (e) { await Ge.initFeatures(e), await qe(e) }, getCurrentFeature: function () { return Ge.currentFeature() }, removeBaseMapImage: function () { Ne.getSource("basemap") && (Ge.clearFeature(), Ne.removeLayer("basemap"), Ne.removeSource("basemap")) }, setSelectedFeatures: function (e) { Ge.setSelectedFeatures(e) }, setClickMapCallback: function (e) { Ne.on("click", (function (t) { const r = Ne.queryRenderedFeatures(t.point); if (r.length > 0) { const t = Ge.getFeature(r[0].properties.id); return t.properties && t.properties.poiId && (t.id = t.properties.poiId, delete t.properties.poiId), t.properties && t.properties.yaw || (t.properties.yaw = 0), t.geometry.coordinates = [1e4 * t.geometry.coordinates[0], 1e4 * t.geometry.coordinates[1]], void e({ type: "LayerPoint", data: t }) } const n = { type: "MapPoint", data: { id: "", type: "Feature", properties: { yaw: 0 }, geometry: { type: "Point", coordinates: [1e4 * t.lngLat.lng, 1e4 * t.lngLat.lat] } } }; e(n) })), Ne.on("touchstart", (function (t) { const r = Ne.queryRenderedFeatures(t.point); if (r.length > 0) { const t = Ge.getFeature(r[0].properties.id); return t.properties && t.properties.poiId && (t.id = t.properties.poiId, delete t.properties.poiId), t.properties && t.properties.yaw || (t.properties.yaw = 0), t.geometry.coordinates = [1e4 * t.geometry.coordinates[0], 1e4 * t.geometry.coordinates[1]], void e({ type: "LayerPoint", data: t }) } const n = { type: "MapPoint", data: { id: "", type: "Feature", properties: { yaw: 0 }, geometry: { type: "Point", coordinates: [1e4 * t.lngLat.lng, 1e4 * t.lngLat.lat] } } }; e(n) })) }, addFeature: function (e) { Ge.addFeature(e), qe() }, delFeature: function (e) { Ge.delFeature(e), qe() }, getFeature: function (e) { return Ge.getFeature(e) }, updateFeature: function (e) { Ge.updateFeature(e), qe() }, clearFeature: function () { Ge.clearFeature(), je() }, fly: function (e) { Ne.flyTo({ center: e }) }, markerElMap: function (e, t, r, n) { return new De.Marker({ draggable: r, element: e, rotation: n }).setLngLat(t).addTo(Ne) }, getLayer: function (e) { return Ne.getLayer(e) }, getSource: function (e) { return Ne.getSource(e) }, getIsSourceLoad: function (e) { return Ne.isSourceLoaded(e) }, addMapEvent: function (e, t) { Ne.on(e, t) }, removeMapEvent: function (e, t) { Ne.off(e, t) }, project: function (e) { return Ne.project(e) }, getAll: function () { return Ge.getAll() }, setZoom: function (e) { Ne.zoomTo(e) }, setMapCenter: function (e) { Ne.setCenter(e) }, setMapTag: qe, removeMapSymbol: je, setMapSymbol: Xe, removeMap: function () { Ne && Ne.remove() }, isStyleLoaded: function () { return Ne.isStyleLoaded() }, renderPointCloud: function (e) { } }, Ze = function () { function e(e) { this.requestRetryTime = 1e3, this.features = null, this.requestMapIndex = 0, this.mapArray = [], this.loadMapInterval = null, this.mBaseListener = e, e.getMode() !== X.WAN_APP ? this.requestRetryTime = 1e3 : this.requestRetryTime = 5e3, this.aXSearchEngin = new Pe(e) } return e.prototype.createMap = function (e, t, r, n, i) { return c(this, void 0, void 0, (function () { return l(this, (function (o) { switch (o.label) { case 0: return [4, We.initMap(e, t, r, n, i)]; case 1: return o.sent(), [2] } })) })) }, e.prototype.setAreaMap = function (e, t) { return c(this, void 0, void 0, (function () { var r = this; return l(this, (function (n) { switch (n.label) { case 0: return this.loadMapInterval && (clearInterval(this.loadMapInterval), this.loadMapInterval = null), We.isStyleLoaded() ? [4, this.loadMap(e, t)] : [3, 2]; case 1: return n.sent(), [3, 3]; case 2: this.loadMapInterval = setInterval((function () { return c(r, void 0, void 0, (function () { return l(this, (function (r) { switch (r.label) { case 0: return We.isStyleLoaded() ? (clearInterval(this.loadMapInterval), this.loadMapInterval = null, [4, this.loadMap(e, t)]) : [3, 2]; case 1: r.sent(), r.label = 2; case 2: return [2] } })) })) }), 1e3), n.label = 3; case 3: return [2] } })) })) }, e.prototype.loadMap = function (e, t) { return c(this, void 0, void 0, (function () { var r, n, i, o; return l(this, (function (s) { switch (s.label) { case 0: return r = null, -1 !== t ? [3, 2] : [4, this.aXSearchEngin.getAreaMediumThumbnail(e)]; case 1: return r = s.sent(), [3, 6]; case 2: return "number" != typeof t ? [3, 4] : (this.requestMapIndex = 0, [4, this.requestBaseMap(e, t)]); case 3: return r = s.sent(), [3, 6]; case 4: return [4, this.requestCloudBaseMap(e)]; case 5: r = s.sent(), s.label = 6; case 6: return [4, this.requestCloudMapMeta(e)]; case 7: return n = s.sent(), [4, this.requestCloudFeatures(e)]; case 8: return i = s.sent(), this.features = i.data, [4, this.beautifyMapImg(r, { r: 42, g: 124, b: 128, a: 255 }, { r: 230, g: 228, b: 215, a: 255 }, { r: 255, g: 255, b: 255, a: .7 })]; case 9: return o = s.sent(), We.removeBaseMapImage(), [4, We.setBaseMap(o, n.data)]; case 10: return s.sent(), [4, We.initFeatures(i.data)]; case 11: return s.sent(), [2] } })) })) }, e.prototype.getNowMapFeatures = function () { return this.features }, e.prototype.reLoadFeatures = function (e) { return c(this, void 0, void 0, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, We.initFeatures(e)]; case 1: return t.sent(), [2] } })) })) }, e.prototype.requestBaseMap = function (e, t, r) { return c(this, void 0, Promise, (function () { var n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return r || (this.mapArray = []), n = 40 * this.requestMapIndex * 1024, i = 40960 * (this.requestMapIndex + 1), [4, this.requestBaseMapItem(e, n, i, t)]; case 1: return (o = u.sent()).data && this.mapArray.push(o.data), o.continue ? [2, new Promise((function (r, n) { setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return this.requestMapIndex = this.requestMapIndex + 1, [4, this.requestBaseMap(e, t, !0)]; case 1: return n = i.sent(), r(n), [2] } })) })) })) }))] : [3, 2]; case 2: return [4, this.mergeArrayBuffers(this.mapArray)]; case 3: return s = u.sent(), [2, new Promise((function (e) { e(s) }))] } })) })) }, e.prototype.requestBaseMapItem = function (e, t, r, n, i) { return void 0 === i && (i = 15), c(this, void 0, Promise, (function () { var o, s, a, u, h, d, p, f, m, g, _ = this; return l(this, (function (y) { switch (y.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!y.sent()) return [2, new Promise((function (e, t) { t($.Get_Cloud_Base_Map_Fail) }))]; o = null, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXMapEngin", {}, "request-cloud-base-map-" + n + " start：" + t + " end：" + r), s = 0, a = 0, y.label = 2; case 2: return y.trys.push([2, 5, , 14]), [4, this.mBaseListener.getBaseHeader()]; case 3: return (u = y.sent())["X-Range"] = "bytes=" + t + "-" + r, [4, de.get("".concat(this.mBaseListener.getServerUrl(), "geo/area/").concat(e, "/base-map/").concat(n), { responseType: "arraybuffer", headers: u })]; case 4: return o = y.sent(), (h = o.headers) || (h = o.header), d = h["content-range"], p = h["content-length"], d ? (s = Number(d.split("/")[1]), a = Number(d.split("/")[0].split("-")[1])) : p && (s = Number(p), a = -1), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXMapEngin", {}, "response-cloud-base-map-end start：" + t + " end：" + r), [3, 14]; case 5: return f = y.sent(), m = { error: f }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXMapEngin", m, "request-cloud-base-map-error start：" + t + " end：" + r), g = null, f.response && 416 === f.response.status ? (g = new Promise((function (e) { o.continue = -1 === a ? !(s < 40960) : s - 1 !== a, e(o) })), [3, 13]) : [3, 6]; case 6: return f.response && 404 === f.response.status ? (g = new Promise((function (e, t) { t($.Map_Not_Exist) })), [3, 13]) : [3, 7]; case 7: return f.response && 401 === f.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 12]; case 8: if (y.sent()) return [2, g = new Promise((function (e, t) { t(Q.Token_401) }))]; y.label = 9; case 9: return y.trys.push([9, 11, , 12]), [4, this.mBaseListener.requestAuth()]; case 10: return y.sent(), [3, 12]; case 11: return y.sent(), [2, g = new Promise((function (e, t) { t($.Get_Cloud_Base_Map_Fail) }))]; case 12: if (i > 0) return i--, [2, new Promise((function (t, r) { _.retryTimer = setTimeout((function () { return c(_, void 0, void 0, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.requestCloudBaseMap(e, i)]; case 1: return r = n.sent(), t(r), [2] } })) })) }), _.requestRetryTime) }))]; g = new Promise((function (e, t) { t($.Get_Cloud_Base_Map_Fail) })), y.label = 13; case 13: return [2, g]; case 14: return [2, new Promise((function (e) { o.continue = -1 === a ? !(s < 40960) : s - 1 !== a, e(o) }))] } })) })) }, e.prototype.mergeArrayBuffers = function (e) { return c(this, void 0, void 0, (function () { var t, r, n, i, o, s, a, c, u, h; return l(this, (function (l) { for (t = 0, r = 0, n = e; r < n.length; r++)u = n[r], t += u.byteLength; for (i = new ArrayBuffer(t), o = new Uint8Array(i), s = 0, a = 0, c = e; a < c.length; a++)u = c[a], h = new Uint8Array(u), o.set(h, s), s += h.length; return [2, i] })) })) }, e.prototype.requestCloudBaseMap = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Cloud_Base_Map_Fail) }))]; r = null, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXMapEngin", {}, "request-cloud-base-map"), u.label = 2; case 2: return u.trys.push([2, 5, , 13]), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "map/v2.0/area/").concat(e, "/base-map?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), { responseType: "arraybuffer", headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXMapEngin", {}, "response-cloud-base-map-end"), [3, 13]; case 5: return i = u.sent(), console.log(i, "res========="), o = { error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXMapEngin", o, "request-cloud-base-map-error"), s = null, i.response && 404 === i.response.status ? (s = new Promise((function (e, t) { t($.Map_Not_Exist) })), [3, 12]) : [3, 6]; case 6: return i.response && 401 === i.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (u.sent()) return [2, s = new Promise((function (e, t) { t(Q.Token_401) }))]; u.label = 8; case 8: return u.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return u.sent(), [3, 11]; case 10: return u.sent(), [2, s = new Promise((function (e, t) { t($.Get_Cloud_Base_Map_Fail) }))]; case 11: if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.requestCloudBaseMap(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Cloud_Base_Map_Fail) })), u.label = 12; case 12: return [2, s]; case 13: return [2, new Promise((function (e) { e(r.data) }))] } })) })) }, e.prototype.requestCloudMapMeta = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Cloud_Map_Meta_Fail) }))]; r = null, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXMapEngin", {}, "request-cloud-map-meta"), u.label = 2; case 2: return u.trys.push([2, 5, , 13]), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "map/v1.1/area/").concat(e, "/map-meta?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXMapEngin", { resData: r ? r.data : null }, "response-cloud-map-meta-end"), [3, 13]; case 5: return i = u.sent(), o = { error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXMapEngin", o, "request-cloud-map-meta-error"), s = null, i.response && 404 === i.response.status ? (s = new Promise((function (e, t) { t($.Get_Cloud_Map_Meta_Fail_404) })), [3, 12]) : [3, 6]; case 6: return i.response && 401 === i.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (u.sent()) return [2, s = new Promise((function (e, t) { t(Q.Token_401) }))]; u.label = 8; case 8: return u.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return u.sent(), [3, 11]; case 10: return u.sent(), [2, s = new Promise((function (e, t) { t($.Get_Cloud_Map_Meta_Fail) }))]; case 11: if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.requestCloudMapMeta(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Cloud_Map_Meta_Fail) })), u.label = 12; case 12: return [2, s]; case 13: return [2, new Promise((function (e) { e(r.data) }))] } })) })) }, e.prototype.requestCloudFeatures = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: return [4, this.mBaseListener.checkChassisNetWork()]; case 1: if (!u.sent()) return [2, new Promise((function (e, t) { t($.Get_Cloud_Features_Fail) }))]; r = null, this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXMapEngin", {}, "request-cloud-features"), u.label = 2; case 2: return u.trys.push([2, 5, , 13]), [4, this.mBaseListener.getHeader()]; case 3: return n = u.sent(), [4, de.get("".concat(this.mBaseListener.getServerUrl(), "map/v1.1/area/").concat(e, "/features?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), { headers: n })]; case 4: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXMapEngin", { resData: r ? r.data : null }, "response-cloud-features-end"), [3, 13]; case 5: return i = u.sent(), o = { error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXMapEngin", o, "request-cloud-features-error"), s = null, i.response && 404 === i.response.status ? (s = new Promise((function (e, t) { t($.Get_Cloud_Features_Fail_404) })), [3, 12]) : [3, 6]; case 6: return i.response && 401 === i.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 11]; case 7: if (u.sent()) return [2, s = new Promise((function (e, t) { t(Q.Token_401) }))]; u.label = 8; case 8: return u.trys.push([8, 10, , 11]), [4, this.mBaseListener.requestAuth()]; case 9: return u.sent(), [3, 11]; case 10: return u.sent(), [2, s = new Promise((function (e, t) { t($.Get_Cloud_Features_Fail) }))]; case 11: if (t > 0) return t--, [2, new Promise((function (r, n) { a.retryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.requestCloudFeatures(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Cloud_Features_Fail) })), u.label = 12; case 12: return [2, s]; case 13: return [2, new Promise((function (e) { e(r.data) }))] } })) })) }, e.prototype.setSelectedFeatures = function (e) { var t = this, r = e.split(","), n = []; r.length > 0 ? r.forEach((function (e) { n.push(t.getFeatureId(e)) })) : n.push(this.getFeatureId(e)), We.setSelectedFeatures(n) }, e.prototype.getCurrentPointPosition = function (e) { var t, r, n, i, o = 0; return r ? (e = this.getFeatureId(e), t = We.getFeature(e)) : t = We.getCurrentFeature(), t && "Point" === t.geometry.type ? (r = t.properties && t.properties.poiId ? t.properties.poiId : t.id, n = t.geometry.coordinates[0], i = t.geometry.coordinates[1], t.properties && t.properties.yaw && (o = Number(t.properties.yaw)), { id: r, x: 1e4 * n, y: 1e4 * i, yaw: o }) : null }, e.prototype.setClickMapCallback = function (e) { We.setClickMapCallback(e) }, e.prototype.getMapLoadSucc = function () { return !!We && !!We.isStyleLoaded() }, e.prototype.addPoint = function (e, t) { var r = this, n = this.guid(); return this.getMapLoadSucc() ? (this.addMapPoint(n, e, t), n) : (setTimeout((function () { r.addMapPoint(n, e, t) }), 1e3), n) }, e.prototype.addMapPoint = function (e, t, r) { t = [Number(1e-4 * t[0]), Number(1e-4 * t[1])], r ? r.yaw || (r.yaw = 0) : r = { yaw: 0 }; var n = { id: e, geometry: { type: "Point", coordinates: t }, properties: r, type: "Feature" }; We.addFeature(n) }, e.prototype.addLine = function (e, t, r) { var n = this, i = null; if (i = r || this.guid(), !this.getMapLoadSucc()) return setTimeout((function () { n.addLine(e, t, i) }), 1e3), i; var o = e.map((function (e) { return e.map((function (e) { return 1e-4 * e })) })); t || (t = { lineType: "1" }); var s = { id: i, geometry: { type: "LineString", coordinates: o }, properties: t, type: "Feature" }; return We.addFeature(s), i }, e.prototype.trackLine = function (e, t, r) { return this.addLine(t, r, e) }, e.prototype.deleteFeature = function (e) { var t; e && (t = this.getFeatureId(e)), We.delFeature(t) }, e.prototype.clearFeature = function () { We.clearFeature() }, e.prototype.getFeature = function (e) { var t = this.getFeatureId(e), r = We.getFeature(t); return "Point" === r.geometry.type && (r.properties && r.properties.poiId && (r.id = r.properties.poiId, delete r.properties.poiId), !r.properties || r.properties.yaw ? r.properties.yaw = 0 : r.properties.yaw = Number(r.properties.yaw)), r }, e.prototype.clearAreaMap = function () { We.removeBaseMapImage() }, e.prototype.project = function (e) { return e = [Number(1e-4 * e[0]), Number(1e-4 * e[1])], We.project(e) }, e.prototype.setPointPosition = function (e, t, r) { var n = this; if (void 0 === r && (r = 3), !this.getMapLoadSucc() && r > 0) setTimeout((function () { r--, n.setPointPosition(e, t, r) }), 1e3); else { var i, o = this.getFeatureId(e); if (o ? (i = We.getFeature(o), this.setSelectedFeatures(o)) : i = We.getCurrentFeature(), i && "Point" === i.geometry.type) { var s = i.geometry.coordinates; We.fly(s), this.currentPotiosnFeature = i, this.rotationAngle(t) } } }, e.prototype.cancleSetPointPosition = function () { if (this.currentPotiosnFeature = null, this.angleMarker) { this.setSelectedFeatures(""); var e = this.angleMarker.getLngLat(), t = this.angleMarker.getRotation(), r = this.getRotate(t); return this.angleMarker.remove(), this.angleMarker = null, { x: 1e4 * e.lng, y: 1e4 * e.lat, yaw: r } } return null }, e.prototype.getPlaceList = function () { if (!We) return J.Un_Init_Error; var e = We.getAll(); return e.features = e.features.filter((function (e) { return "Point" === e.geometry.type })), e.features.forEach((function (e) { e.geometry.coordinates = [1e4 * e.geometry.coordinates[0], 1e4 * e.geometry.coordinates[1]], "Point" === e.geometry.type && (e.properties && e.properties.poiId && (e.id = e.properties.poiId, delete e.properties.poiId), e.properties && e.properties.yaw ? e.properties.yaw = Number(e.properties.yaw) : e.properties.yaw = 0, e.properties && e.properties.mapOverlay && delete e.properties.mapOverlay) })), e.features.sort((function (e, t) { var r, n; return r = e.properties && e.properties.name ? e.properties.name : "", n = t.properties && t.properties.name ? t.properties.name : "", r.localeCompare(n, "zh-CN", { numeric: !0 }) })), e }, e.prototype.setMarker = function (e, t, r, n, i) { t = [Number(1e-4 * t[0]), Number(1e-4 * t[1])]; var o = (n %= 360) < 0 ? 360 + n : n, s = We.markerElMap(e, t, r, 360 - o); return i && s.on("drag", (function (e) { i(e) })), s }, e.prototype.setMarkerProperties = function (e, t, r) { if (e) { t = [Number(1e-4 * t[0]), Number(1e-4 * t[1])], e.setLngLat(t); var n = (r %= 360) < 0 ? 360 + r : r; e.setRotation(360 - n) } }, e.prototype.removeMarker = function (e) { e.remove(), e = null }, e.prototype.fly = function (e) { e = [Number(1e-4 * e[0]), Number(1e-4 * e[1])], We.fly(e) }, e.prototype.zoomTo = function (e) { We.setZoom(e) }, e.prototype.setMapCenter = function (e) { e = [Number(1e-4 * e[0]), Number(1e-4 * e[1])], We.setMapCenter(e) }, e.prototype.beautifyMapImg = function (e, t, r, n) { return c(this, void 0, Promise, (function () { return l(this, (function (i) { switch (i.label) { case 0: return [4, this.beautifyMap(e, t, r, n)]; case 1: return [2, i.sent()] } })) })) }, e.prototype.destroy = function () { if (this.loadMapInterval && (clearInterval(this.loadMapInterval), this.loadMapInterval = null), null !== this.retryTimer && (clearTimeout(this.retryTimer), this.retryTimer = null), this.angleMarker && (this.angleMarker.remove(), this.angleMarker = null), "object" == typeof window) { var e = document.getElementsByTagName("canvas"); if (e && e.length > 0) for (var t = 0; t < e.length; t++)e[t] && e[t].getContext("webgl") && e[t].getContext("webgl").getExtension("WEBGL_lose_context") && e[t].getContext("webgl").getExtension("WEBGL_lose_context").loseContext(); var r = document.getElementsByClassName("mapboxgl-control-container"); if (r && r.length > 0) for (t = 0; t < r.length; t++)null != r[t] && r[t].parentNode.removeChild(r[t]); var n = document.getElementsByClassName("mapboxgl-interactive"); if (n && n.length > 0) for (t = 0; t < n.length; t++)null != n[t] && n[t].parentNode.removeChild(n[t]); var i = document.getElementsByClassName("mapboxgl-canary"); if (i && i.length > 0) for (t = 0; t < i.length; t++)null != i[t] && i[t].parentNode.removeChild(i[t]) } }, e.prototype.getFeatureId = function (e) { var t = We.getAll().features.filter((function (t) { return "Point" === t.geometry.type && t.properties.poiId === e })); return t.length > 0 ? t[0].id : e }, e.prototype.beautifyMap = function (e, t, r, n) { return c(this, void 0, Promise, (function () { var i, o, s, a, c, u, h, d, p, f, m, g, _, y, v, x, b, w, T, k, C, E, S, P, I, A, L; return l(this, (function (l) { switch (l.label) { case 0: return i = null, e ? (i = "string" == typeof e ? e : URL.createObjectURL(new Blob([e], { type: "image/png" })), [4, this.getImgSize(i)]) : [2, null]; case 1: for (o = l.sent(), s = o.width, a = o.height, c = document.createElement("canvas"), u = document.createElement("canvas"), c.width = s, c.height = a, u.width = s, u.height = a, (h = c.getContext("2d")).drawImage(o, 0, 0, s, a), d = u.getContext("2d"), p = h.getImageData(0, 0, s, a), f = p.data, m = d.getImageData(0, 0, s, a), g = m.data, _ = [], y = Math.ceil(4.8), v = 0; v <= y; v++) { for (x = [], b = 0; b <= y; b++)x.push(.05 * Math.sqrt(b * b + v * v)); _.push(x) } for (w = function (e, t) { return e >= 0 && e < s && t >= 0 && t < a && f[t * s + e << 2] <= 89 }, T = 0; T < s * a; T++)k = T % s, C = Math.floor(T / s), L = f[E = T << 2], w(k, C) ? (S = t.r, P = t.g, I = t.b, A = t.a) : L >= 180 ? (S = r.r, P = r.g, I = r.b, A = r.a) : (S = n.r, P = n.g, I = n.b, A = n.a), g[E] = S, g[E + 1] = P, g[E + 2] = I, g[E + 3] = A; return d.putImageData(m, 0, 0), [2, u.toDataURL()] } })) })) }, e.prototype.getImgSize = function (e) { return new Promise((function (t, r) { var n = new Image; n.src = e, n.onload = function () { t(n) } })) }, e.prototype.guid = function () { return this.padStart(((new Date).getTime() / 1e3 | 0).toString(16), 8, "0") + this.padStart(Math.floor(16777215 * Math.random()).toString(16), 6, "0") + this.padStart(Math.floor(65535 * Math.random()).toString(16), 4, "0") + this.padStart((16777215 * Math.random()).toString(16), 6, "0") }, e.prototype.padStart = function (e, t, r) { for (e = String(e), r = String(r); e.length < t;)e = r + e; return e }, e.prototype.rotationAngle = function (e) { this.angleMarker && (this.angleMarker.remove(), this.angleMarker = null); var t = e; this.currentPotiosnFeature.properties && this.currentPotiosnFeature.properties.yaw && (t = this.currentPotiosnFeature.properties.yaw), t = 360 - Number(t) + 90, this.angleMarker = We.markerElMap(this.createAngleEl(), this.currentPotiosnFeature.geometry.coordinates, !0, t); var r = this; this.angleMarker.on("drag", (function (e) { r.marketDrag(e) })); var n = document.getElementById("rotateImg"); n.addEventListener("mousedown", (function (e) { e.cancelBubble = !0, e.preventDefault(), e.stopPropagation(), We.addMapEvent("mousemove", r.turnAngleFunc = function (e) { r.turnAngle(e) }), We.addMapEvent("mouseup", r.rotateMouseMoveFunc = function (e) { r.rotateMouseMove(e) }) })), n.addEventListener("touchstart", (function (e) { e.cancelBubble = !0, e.preventDefault(), e.stopPropagation(), We.addMapEvent("touchmove", r.turnAngleFunc = function (e) { r.turnAngle(e) }), We.addMapEvent("touchend", r.rotateMouseMoveFunc = function (e) { r.rotateMouseMove(e) }) })) }, e.prototype.marketDrag = function (e) { var t = this.angleMarker.getLngLat(); this.currentPotiosnFeature.geometry.coordinates = [t.lng, t.lat], We.updateFeature(this.currentPotiosnFeature) }, e.prototype.turnAngle = function (e, t) { e.cancelBubble = !0, e.preventDefault(), e.originalEvent.stopPropagation(); var r = We.project(this.currentPotiosnFeature.geometry.coordinates), n = this.calculateDegree(e.point.x, e.point.y, r.x, r.y); this.angleMarker.setRotation(n); var i = this.getRotate(n); t && t(i), this.currentPotiosnFeature.properties.yaw = String(i) }, e.prototype.calculateDegree = function (e, t, r, n) { return Math.atan2(e - r, t - n) * (180 / Math.PI) * -1 + 180 }, e.prototype.rotateMouseMove = function (e) { We.updateFeature(this.currentPotiosnFeature), We.removeMapEvent("mousemove", this.turnAngleFunc), We.removeMapEvent("mouseup", this.rotateMouseMoveFunc), We.removeMapEvent("touchmove", this.turnAngleFunc), We.removeMapEvent("touchend", this.rotateMouseMoveFunc) }, e.prototype.getRotate = function (e) { var t = e - 90; return t < 0 && (t = 360 + t), Math.round(360 - t) }, e.prototype.createAngleEl = function () { var e = document.createElement("div"); e.className = "marker"; var t = document.createElement("div"); t.id = "rotateImg", t.style.width = "80px", t.style.height = "25px", t.style.position = "absolute", t.style.bottom = "75px", t.style.textAlign = "center"; var r = document.createElement("img"); r.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAAAXNSR0IArs4c6QAAC8xJREFUeF7tnWusXGUVhp91WmIQbIlGxVsEjRQx0XgBqT1zWiOiiVZNvIDgDeolMQaINJo2XmIUodIgBJP+wHi0JMWiv1qihng5nJkDlqrxj7TeChE1Gi8gmGBLO5/5vu40hXA6a9rZM3tmvTuZzLms/X37fdY82TN79p4xtIiACCxKwMRGBERgcQISRI8OETgGAQlS88MjtXg2cCbGmcAZJJ4FPKPcjGWk8vOy8ntiGVZ+fxrwCPAoxiMkHi0/H/23bvn9QRL3k9jH3dxv0K05TrjhJcgAWp6meQnGKysRzij33SNSnDKAKbxDPFCEgX0Y+8rPS9ljc/zaO4DqnkhAghzHIyJN8yqmmCbRAlYBLzyOYYa5St4bzZebsYvH2W338NgwN2Bc55Igjs6l1ayky/nAyurWdCF6pdqPFWHuJbGbLrttgb/2Wini/yXIIl1P06zBWAu8HTgrwINjB8YOEjuszT8C5HVFlCBHYUqrOZduESLfXuMiOHlF/4bDovA8dtj3ODR5Ef2JwguSZng56YgUM350ISr/UGSh7FXuCpH4SSHDCpJavBP4aLW3iNj7fjPn1yvf4RCzkV7ghxMkTfNerIhxYb+PENUDib0Y32IJszbHPyedSRhB0gyXkooYaya9qUPK9yAwW4nywJDmHPo0Ey9ImuYyjHXV+xVDBxxgwofKHiU/9VrgN5OWd2IFSTOsI/EJ4NxJa1pD8xwgMcsUN9k8exq6jX1v1sQJUr1/sR54W980tMIgCDwEbOZfbLb7ODCIAUc5xsQIkmZ4EbCexBWjBKq5KwLGL7IoNs/2cWYyEYKkaa7AyHuNLImWZhHYTpfNtlCEGbtlrAVJrfI0KosxLkemDmLsJfEX4GGM/5B4GKr7qeo+kc+VOg04rdx3WX7k9/w3eA6wAlg+Jo+4/FRrM4nN1iE/BRubZSwFKU+nunyxOjrVRNj5/YG95Wb8li57WcpemyO/Mz2wJb2J5/I4K0jlXLEV2FE/D2yWgQ60h8R11mHrQEetcbCxEyTN8D4SXwFeViOXfoY+CPyK/Jy7S4fEgi3wp34GqKM2reJ8psoZyK+Hcp+vU2nK8g2WsMHm+G9TNmix7RgbQdKFnMJjRYyrRgw1PyX6SZEilVsWIl/d1+glTXMWU+WQ93mkIsx5I91g4+d02WAd5ka6HT0mHwtB0irezFSRY1RNzZey7gTu4AA7bRd/b3JTPduWVtOiy1oSazHO9qxTQ00+U3iDtbm+hrEHMmTjBUktvgB8aSBp+x3E+Bld7mCKnTbP7/tdfVzqy8GOw6Lk61+eP4LtzifVb7C7+eMI5j7mlI0VJK3idUzxZeCtQ4aWr+W+Ne8xrMMvhzz3SKdLaziVg0WUi6Cc7TzMJZ/Plfcm3x3mpL3maqQgaZpLMLZUn/bRK8Og/n8vxlYOsXUcXlMMKvRi46TVvJEulwEfrHuuJ4xvXGPzfG6ocx5jssYJklrljNtbhgjoB1mMcX/Hty5eZU9ufAQrsjy9rnmeNO4Wa/PJIc01Pk+x0gxXkrhxKGDy3iKx1drliJSWHgTKUbAsCkWU04cAbDtL+IDNkQ+jj2xpzB4ktdgIXFM7CWMniU3WZqH2uSZwguqct6tJXDmEeD8GLhnlh0g0QpDU4qv5BVrNwPMRkizGMJ++1RxpdMOnFqsxsij5yFedS36v6f3W4Xd1TrLY2CMXJLW4GfhUzeFvZAmbbI6/1TxPuOGrC9KuBl5RY/j8iZEXW4ddNc7xlEOPVJDU4tvAh2sMfSfGJpvnpzXOEX7odAHL+R/ryx4FTq4JSP6M4ousw49qGr9ZgqQW7wFuB+qQdD+JjdbhhmHCjD5XmuHVJK4F3lILi8Tt1inv0QxtqePB6d741OJdlSQnuVfqXdgp5/gs0Oldqoo6CKQZriPx2YGObWyzeS4d6JiOwUYqSN6+6pqOvCcZxDH2GziVjfZD9juyq6RGAqnFxcDXBnQR263W5kM1bu6iQ49ckEqSvEvOkuTvyTieJX/c/0a92Xc86OpbJ63kbJayCXjHCcwya20uP4H1T2jVRghSJJnmAqxcv/zMPhNtr15v7OtzPZUPiUBqlZNN80mn/S63WJuP97vSIOsbI0glSf5E9SxJvqS092J83ubLafBaGk4gtXg38M1yGbFvacTpJo0SpEiyihZLuI3EC47JMXGVdbjJx1pVTSCQZpghFUl6XQ16s7Wb8ek0jROkSHL4C2tuA178lI1NXG4dZpvQdG1DfwRSi3Oqk1HfsMiaX7c2n+5v1PqqGylIJUn+ro4syUuPip+/Smydtfl+fUg0ct0E0hpO51C5nCEf5j96ud7afKbu+fsZv7GCFEla5UtstlUfcfPn/CkmNs+d/QRUbTMJpNdyEiez5ahPprnW2uWE1UYtjRakkiR/e+w2pviY3cU9jaKnjTlhAqlVDgPvt/ZxHeU64fl7DdB4QSpJzrE29/UKo/+LwKAJjIUggw6t8UTAS0CCeEmpLiQBCRKy7QrtJSBBvKRUF5KABAnZdoX2EpAgXlKqC0lAgoRsu0J7CUgQLynVhSQgQUK2XaG9BCSIl5TqQhKQICHbrtBeAhLES0p1IQlIkJBtV2gvAQniJaW6kAQkSMi2K7SXgATxklJdSAISJGTbFdpLQIJ4SakuJAEJErLtCu0lIEG8pFQXkoAECdl2hfYSkCBeUqoLSUCChGy7QnsJSBAvKdWFJCBBQrZdob0EJIiXlOpCEpAgIduu0F4CEsRLSnUhCUiQkG1XaC8BCeIlpbqQBCRIyLYrtJeABPGSUl1IAhIkZNsV2ktAgnhJqS4kAQkSsu0K7SUgQbykVBeSgAQJ2XaF9hKQIF5SqgtJQIKEbLtCewlIEC8p1YUkIEFCtl2hvQQkiJeU6kISkCAh267QXgISxEtKdSEJSJCQbVdoLwEJ4iWlupAEJEjItiu0l4AE8ZJSXUgCEiRk2xXaS0CCeEmpLiQBCRKy7QrtJSBBvKRUF5KABAnZdoX2EpAgXlKqC0lAgoRsu0J7CUgQLynVhSQgQUK2XaG9BCSIl5TqQhKQICHbrtBeAhLES0p1IQlIkJBtV2gvAQniJaW6kAQkSMi2K7SXgATxklJdSAISJGTbFdpLQIJ4SakuJAEJErLtCu0lIEG8pFQXkoAECdl2hfYSkCBeUqoLSUCChGy7QnsJSBAvKdWFJCBBQrZdob0EJIiXlOpCEpAgIduu0F4CEsRLSnUhCUiQkG1XaC8BCeIlpbqQBCRIyLYrtJeABPGSUl1IAhIkZNsV2ktAgnhJqS4kAQkSsu0K7SUgQbykVBeSgAQJ2XaF9hKQIF5SqgtJQIKEbLtCewlIEC8p1YUkIEFCtl2hvQQkiJeU6kISkCAh267QXgISxEtKdSEJSJCQbVdoLwEJ4iWlupAEJEjItiu0l4AE8ZJSXUgCEiRk2xXaS0CCeEmpLiQBCRKy7QrtJSBBvKRUF5KABAnZdoX2EpAgXlKqC0lAgoRsu0J7CUgQLynVhSQgQUK2XaG9BCSIl5TqQhKQICHbrtBeAhLES0p1IQlIkJBtV2gvAQniJaW6kAQkSMi2K7SXgATxklJdSAISJGTbFdpLQIJ4SakuJAEJErLtCu0lIEG8pFQXkoAECdl2hfYSkCBeUqoLSUCChGy7QnsJSBAvKdWFJCBBQrZdob0EJIiXlOpCEpAgIduu0F4CEsRLSnUhCUiQkG1XaC8BCeIlpbqQBCRIyLYrtJeABPGSUl1IAhIkZNsV2ktAgnhJqS4kAQkSsu0K7SUgQbykVBeSgAQJ2XaF9hKQIF5SqgtJQIKEbLtCewlIEC8p1YUkIEFCtl2hvQQkiJeU6kISkCAh267QXgISxEtKdSEJSJCQbVdoLwEJ4iWlupAEJEjItiu0l4AE8ZJSXUgCEiRk2xXaS0CCeEmpLiQBCRKy7QrtJSBBvKRUF5KABAnZdoX2EpAgXlKqC0lAgoRsu0J7CUgQLynVhSQgQUK2XaG9BCSIl5TqQhKQICHbrtBeAhLES0p1IQn8H9levtjxmrGQAAAAAElFTkSuQmCC", r.style.width = "50px", r.style.height = "25px", t.appendChild(r), e.appendChild(t); var n = document.createElement("div"); return n.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAgAElEQVR4Xu19C5gcVZn2+1UPyXTNAAH8VRB/QFRwBQFRrtMhLAJJ1wyXFRBBIWR6BtgFBVaQOwERBV1vwQVmqkNQUeQiJDPVCbBKSE9ARIVlBXURAQUFf5WQpKsnyXR9/1M9M5hMZrqr65xTXT19zvPkyQP93c57zpuqOpfvI+imEdAITIkAaWw0AhqBqRHQBNGzQyNQAQFNED09NAKaIHoOaATCIaCfIOFw01pNgoAmSJMMtO5mOAQ0QcLhprWaBAFNkCYZaN3NcAhogoTDTWs1CQKaIE0y0Lqb4RDQBAmHm9ZqEgQ0QWI00PxPmOGHQ89hY4zCaupQNEFiNPycwnllguRxc4zCaupQNEFiNPycwjNjBPlQjMJq6lA0QWIy/HwEjoaHh8rhGDiGHsXDMQmtqcPQBInJ8HMK9wA4aSyceymPk2MSWlOHoQkSg+Hnw7AbEnhpi1BK2J0ew8sxCK+pQ9AEicHwcwpfBHD5hFBuoDyuiEF4TR2CJkgMhp9T+H8A3jYhlL9SHv8nBuE1dQiaIHUefu7AGSDcMWkYjDNpCN+pc4hN7V4TpM7DzykMATh8ijBWUx4ddQ6xqd1rgtRx+LkDB4Pw04ohMA6hITxRxzCb2rUmSB2Hn2cjC8aCiiEQFtMqdNcxzKZ2rQlSp+Hng7EdZuDNQO43Ynt6AmsDyWohqQhogkiFM7gxTuESADcG1Pg85XFTQFktJhEBTRCJYGaWb/gQe95BWStpVzPLKfwOwJ7V5MZ+f4HyeG812Z5coadU4p8t7mr/72qy+vdgCGiCBMNpUqnuAfegRMI4yPM8/2P7IADvJ/Bt/VbbOZXMcgonALi/RtcnUh4PVNLpybmLmHEeA88T8CSAJ0rAE7dbpv7IrxHscXFNkBqB80lhGHwCM50Iwt4T1Y0ZtFvf0ck/VCRIB3IgzKvJNWM5DSFdSeecB9e9fWQk8fpWMozfEPH9nkcPZLvMn9Xkt8mFNUECTIBzBtx3jRjGCWDPJ8VRU6kQ8ES/ZR5SkRyHYy8Y+E0At1uLeNibVuO3lXQzTuFhgD42pQzjxyDj/hbPe+DWLvPVUHE0kZImSIXB7s0NH+Mxnwrmk0DYtvq84BNsq21plderrwO4oLqtSSW+QXlcWEl3wXL3UMPDY1XtM9aB6F6D6K6+dOvoMXvdtkJAE2QCJN13v7kjtc/8BHxigGfXMGf+altm1bNTnEIBgFmD3c1FXcqjrZpuJuf+AYx3V5P7x++0CkR38foNP8yesv3fg+tNf0lNkLEx7l1R+HCpRKcT41QQdql96GmhbSWvrfL08D/eb6nd9hYa51Iet1ay0eOsn88wbq/ZD+NPTLgrkeA7++a2/bJm/Wmo0PQEmb+8uHvC4/OJ6HwwbxN2jN8sJGfecwpVTLbAKfiT7oCwPsb0nqI8PlzJxsJHuOUVt7gptB+iTcy8qGTQoiXzklveUwlttDEVm5Ygp+f+tl3SM88H8fkA3iEyfAzcl7XM8duAk5riDswB4RERP2/pMo6kIaysZCvjFL8E8KWC/l4H06Ki4S66M71TU+7kNyVBMoOFc0E4H6APCE6gsnoJOKTaXgOn8AMAp8rwB+AuyuOTlWz1Dqzd2zNafi3HH/8ajEV2Z5vo66GccCK00lQE6XHW7w8Y1zDKG3Wy2k9tyzy0yreH//H+F1kOx+y8nfLli1ZTth7HvV9mXwn+RqV3bb/V/rTkvsTWXNMQJDPoXgDCNQBmyRwNhnFO1mq9rQpB/I/3q2X6BXAd5cv9mbJ1DxYsIhqU7HcNGNfaneY3JNuNpblpTxBFT43xwXzFtsyqy6mcwp8BvFPyDHiN8ti5ms2MU3wOYCmvkpv7apanybQmSLdTzBD4K7KfGuMThRk3ZjvNih/C3IHTQLiz2kQO9TvjdBrC9yvpZhz3MwC+Gcp+daU1DLo4yOHM6qbiKTFtCdLjuDcyykfKVTU2ZtDuVc9dpcqrTUcoCuJRymNOJdtj57Ne8zOaKorBN3xTv2V+XpX9etpVBlq9OjV6bgrfAvAvamOg79lW8tNVvj38FKKqj57vR/nRlKVTtYzj+k8Q/0misv2oxcNnptv5rmlFkMzAujlIJL4JhvLctgxjXtZqXVGRILNxGxi9KmclCH20CmdX8hH4fJZooIRnUCp91u7atuIejaibKPWnDUG6B92TaTR9TlI5gIyVdqd5ZEVynIwEXsOI8lh8B+9EC93jb8dM3Xqc4iCDrQjiKTLo7KyV/G4EvpS7mBYEGSPH3crRGnPA4J6s1Vbx1iB34CIQ/iOSmBj/TkP4WsXXrMHip0Ac2aRl4KKsZfonlxu6NTxBoiYHgZ5fU2jdJ8C5K//Ox14RzY7fUn7ry1ub+x49nzX8PwBvdclLXYzVD3Cq8y3HckMTJOMUzwJ4sRwoglqpPujcgbkgLA9qUYocYx4NoeI3UcYpXgPwQin+AhupjldgU3UQbFiCRD3YDFpSQumyJVa7v2RasXEHloHQVU1O6u+MARrCcdVs9g6sfZtntFwVwarWZqE0LkkakiA9jnsRI5r3e2Z2yKDr7bRZOQPi+PfJHOyKEv5YbaIq+T2Bd9NKvBLEtp+BBaXSxSB8Koi8sIyHk+0u815hOxEbaDiCdDuFDIH6I8ApT8DN/ZZZ08c/p+Dv3H8ugvgmc/FVyuPiWnz35ArzAOMCZj6mFr1QskRH2enkT0Lp1kmpoQjS47inMPBDxVi95nl89eKutlAk5FQ5W+J2imOcyvxaymP7ML4zg8VuEF+v4MzYFuF4Hg5b3GU+HibGeug0DEG6c+7hBmOAgR3UAcUrDPAlfVb7/4TxwR04C4SIFw0mRMpYQEOo/botgF5n/b4e6CaA5obpfyAdwp+IPatRjsw3BEHKx0cSyKncISfQl/qt5MQqT4HGfFyIU/BzTn20JiX5wk9SvpzELnTrcYo3MPiy0AaqKvIzGOFj7OPbt87hVVU3WoGGIEjGce9TeLbqZQIuqfVbY+Iwcao8KeOSwfBgypfJGrqNvc76+YB3C22kgiKBvttvJc9QYVumzdgTRPGp3KUE45J+q/V/RUHlFPxd6mhWhKoH+z3Ko+JByuomgB5n+P0MzyfJ8UHka5VhxsXZTvOrtepFKR9rgozd5wj1sVwdRHlr83wgTJjlfFfxaS7a6BdwZQSkcs/J87xjF3e1xzZxXWwJUj6ZayRyKg4fyj4nxB24AgR/BSg+jXElDZWr50pp6kgS7++RWBLk5Ls5uX2buxog0RxSW00OIuruTyelrjRxqrwxuKuUmSjPyCuUryW7YnXH6khCt9tWsnKlrerhKZGIJUEyueJVYL5Oeo8V7OZyqvx+XrEsgfR+BDd4AuVRMVdwcFOjkqpIwoxPZjvNu2qNR7V87Agy31m/bwsbq4Mli64FHuMY22p9uBaNILKcwn8BU2d8D2JDocyPKY+pM72HdJzJDZ8L9v4zpPoUavQrLmw8Im65gWNHkIxTuAMguct/XulIFbfceA7eixKelztRJFtL4H20slzNSmrrcdyPMyD1bBUDX8ta5r9LDVTQWKwI0pvbcILHpVorL1WGwGPL7mrzP/alN+7AzSD8m3TDMg0yvk1DOE+myXFbo+UhvAdl2jbIODZO5RhiRZCM43+Y4zBpgBP12elkxfvaIr44BT9BdIuIjQh0RyiP0Em5q8WXyRWuApPE70VaZVtJVVlgqnVnq99jQ5CenHs+czkbiaz2lG2ZFbOgizjiFM4FIPk9XCSiirr/SnnhsgtTOsg47gCATlnRE+Ez/WlzkSx7InZiQZDuFbwjjRSfAFWv5BqkswRe28Kbdr+lc9YbQeTDyHAKvwLwwTC6ddB5lvLYR5XfTz/4WtvM0na/B+PtUnwwfsctyYOzc6nuxXxiQRDpS4dEZ9rp5HekDNYkRvgIpOBhlSr7SuwamE2PIq/Etr/8O1hMgVgiJvJOOoj0ue4E6V4x/F4qlZ4AaEeRjozrEtF1/elkxaTOon64A/eBVCemE41ygj7jRzSEj0u2uoW5Hsf9LAOSklrz3zmRODg7t1X6ClwtGNSdIJlB91ujtTokNMaddqep9MAgH4od0YK/SYg2ehMj2Ikeh9LXlm7H/Q5B/KBkGZxyTRJTdUbIiuNQV4J0D67bhygR6nLSJL16A1w63O7cVlLRmMlx4xT8FRs/6UEjti9QXnoZhi1wyAyu+wAo4a9GSrnYxlzaN9u5rf+9V5dWV4JkcoXrwXSFlJ4TXWGnkzdIsVXBCKfKTw8pr4OqY53E/t8pj51U+83kipeDWc5BSeIv2um2K1XHPJX9uhHk5Lv/mNy+bSf/6bGnhM7/IknJwxelaYMEW1Oa4Nn4BBixOy9UU58Jp9Iqtff6z8/xzCIX/afIgTXFNrnwC28W/rbvPae8uyjBVs0m6kaQjLP+LMCQcqqWDHyyf576g26cwmMAKpZbq3kE/qGwFAnML/9nCUtUXVIC8DjlJW7GTtHhnuXuqeyV6zJKaN4C22oPdc9e1HndCNLtFB4kkHCqGSLc0582TxEFopo+H44Pwijvfchu68A4k4awxREb7sCJGE3Gva1sh/CwD63Gs9LtTjDYk3PvZsbJon4Y/FDWajtW1E4Y/boQpNtZN5uQeDRMwBN0SpzAYdm5ptD96yBxcAr+zcZMENkaZG6mfOUVPE7B31GWfZbKpjx6aogzlGj3CvcgKpWfuolQBjZTYpSOyFrbStxnCRZRXQgia2k3SAm0YDBUl+IUuLpUYIln4WE+rcbPg2jw4fgIjPJrl7Sde8qrqzi1eZ+6B90vE0G8+lSdlnzrRZDnRY+VEKjIJXzQPi75YpBJJiLDKVwAQFYq/0soX86+WHPjVDlrop9EQUa7kPKyNvWmDiezrLgHJfAsg8XqtjB+Z3ea75PR8VpsRE4QP9UlM4kfP49gU3AcSE7BJ+HutQC7layf7X0E59JjeFnEDh+G3dCCW8CYJ2IHwEuUxx6CNgKpZwbd74FweiDhCkJEnO5Pt0WaNT9ygsh6vSIP/9LfZcq9OzLJ4PDhOBoGRLJubADhTNlLq2NLzv5H/MzQE8/DMbQa0m9ZToynZ8A9kQ38KHScb/1LFf3Oej0IIvx6BeZn7c42ZadTNx9ITsEBkA41uIw+mLiIHlKTEoiPQRtcfA0Uug5ijvKIoiwbMoOFX4FI7BuqDq9ZkRJE1utVFAcSfUJwCjsD+FMIcvjXcM+lPH4cQrdmFU6V78TfAiDMO/oulMefa3Zao0JPrngtM19do9rWb6oRv2ZFSpCM4/ofmDWl558MUM/z9l/c1a66vLJPkBtRa611yfmoaplQIfNz3UR5CatMVQJdMLB+P8Mwnq6lP5PJEuGr/WlTeA4FjSNaguSKDpjDva6M9YgIy/rTppJUmBNB4xT84w2tAcH8MUaLaSonbqV4uAP7jRUP9Z8qQdow5SOoDAygJ+cuZa5eBatS0ET0UH86GdmmYcQEcV8FY5cgozaVDLM3P9vZ7n+cKm3cgTPGdrKr+WEQzqVVuK2aYJS/82ycDS6/dlUf49GdfGUXzMb73T24/kwiw9/PEWmv25b5ThEDtehWB68WaxVke3Nr9vR4hvDll1IL/u/tx5rKS5xxCr8EUC2z4xIkcFXQsmeSoAxshkfLwX0BGDvjNbXmU5SHsvv7bxHEKe5G4JcCd2AKQcLIXv3WdsIJx4PEERlBegYLxzGRaJa/J23LFKp9EQQUTpUnyy8qyPp7GZ+jvNy8UEFiCyPDKZwEwM+iXqmUwYGUL/+joLR1DxaeJqL9RJww45Rsp3mPiI2gupERRMq9c8IiO63+hlnFUgaM/0ALrqSVGA4KchzkeA5aMYLrQZgqMZuUkgnV+ppxiv0Ai51pi/COSHQEybnLwGKlkYnoU/3p5J3VBkHkd56HmVg/6eRfjdEVqpUi9uutyx2YM5aJ/vCtYmlHKy2H0js1meXDvfA80e+1QdsyIymzHR1BHPcFAO8RmSCcMN6n+hI/z8bnwfjyFnESLqNVE/6fSEdioMuzcSkYX5rQz0tpVXlpW1kbu5L7nKCD39uWKeOiXdUwIiFI7228jbdrcWPVaCoLvGxbpth5qAABcKq8aTa+SuJfYvJfp1TcAwkQjVoRnoN9UCrXNRlfNn+N8uXNUaUt47jC5SKMV5Iz+s4mP7Ol0hYJQboHN+xDVBJNzvAD2zJPU4kGd6AThAEwXgfhSsrDVukvLrY5hQy4/H3yDv81mIYwqDK2bse9lyCWgog5sW+2c6byf7giIYicTODGebbV+m2VA1cuZcB4CYSrojh+obIvtdouH6thfAGE3VWUTNg8nozj+ql8vllrjJvLE3BSv2X6xV2VtkgIkhksXAEioRJlhkGpvnnJIVVo8BzsjhEcMPHqqyp/cbVbvurbgqdoJYT3K6bqY+/yYofnsViWR+Yr7c42OZlTKgxGJASRkkxsxNvPPr79GVUTiw/ENvSLcrb2pm+qscgsXf8htBhCR3IY+G7WMuXWkZlk5CMhSGbQXQVCSmTmMWj3rJUUumwk4l/rykOgW8aOOiNvd5qz5UU1uaVoCOK4TwL4iEhnRszkDkuOpDUiNrRuPBCY/wjPanGLopn3f25b5kdV9ygaguSKvwKz0GWZXZ9MJhYuJE81INq+egQWLmTjlY8WS0KeiJ6100nll+aiIYjj/h4Quf9M62wruZ0QoFo5VghknOJagEVyfr1oW6bQxnMQQKIiyOabb0Himijzqm2ZcatDHqYfWmcMgYzjvgLgXQKAvGZbpvJNzUgI0u0U3iRQ6CcAgZ7rt5JCr2gCA6FVFSDQ4xT9VED/FNY0g9dmrbbtw+oH1YuEIJmcuxEsUkiSf2pbbapy4gbFSstJRCDjFB4H6JDQJgmb7LQ5I7R+QMVoCOK4tVxdnSz0x2zL3Pr0acBOarH4ISChovGwbZliyegCwBIVQfzMICLvi0/bllntdl+A7mqRuCCQcdynAOwvEM+fbcsUur4dxHdEBCk8B9AHggQ0mQwDz2ct8/1h9bVe/BDodtz/pXBpisY6w7+2rbbQ3zBBEYmIIK5fTOWwoEFNlCPg1X69ihUWvljq9TjuKyy2ihXJa3c0BBksOiChdD9rbMuUUvMulrOlCYPKOK6/kz4rdNeZcnZnUnlWyGgIkit+D8wiyYs32Zb6FYvQg6UVa0Yg47j+BbptalYcVyC6004nlVY09l1FQxDHvRnAv4UGA4DLG3f8fucs0fM7IiFoXUkInDa4ZgeTZoiWo/62bZmyCwtt1cNoCDJYuB4kVs3WKPGBfce1KU9LI2kOaDMVEOhdVviwl6BKaZWq48f8RbtTffXbSAjSkyv0MFNf9V5PLRHVDTKRGLVuMARk3DAl4t7+dJtfFk9pi4QgmVzxn8EslOmcCBf3p00/+ZluDY5AT879HHO4KltvdZ3oKDud/IlqKCIhiJwLMnyL3dn2r6oB0fbVI5AZLPwniM4V8RTVBbpICOIDkXFc/zprS3hQeIVttYmWHQvvXmtKQyDjFJYDNFfA4IhtmeFXwGpwHCFBir8GeO8aYttClEBr+62k8tObYePTesERyAy660BoD64xUZJ+Y1vJ0CczavEbGUF6nOIgg8U2dgiH2mnzp7V0UMvGC4HMwLo5MBKPiERFIKffSnaK2AiqGxlBMo7r50Hy8yEJNO8y22rfMi2ogDWtGj0CGcf1051eKuj5W7ZlflbQRiD1yAiywFk/34Bxe6CophTih22r7RgxG1q7ngjIyHBDoDP6reR3o+hHdAQZHH6PQZ6fwFqklUbg7brEan9NxIjWrQ8C5wy47xoh/AEEQyQCI5HcpW8uKS886scYGUF8Z92O+yIBQgmoGXRGNqJ/PUQGUetujUC3U/w0gUVLvUV6NyhighRvJ/B8kcnDwH1Zy/QrJunWYAjISFoNwjfstHlhVF2PmCCFswl0q2DnNnls7L24s9VPJaRbgyCwYPQV+zdCJ3jLrzxGV7/VqjT7/OaQRkuQ3MYDiEeEDxwycFHWMr/eIHNDhzn6en0hAV8TBGPNiJncecmRFFn5u0gJ4oOTcYovAVypmGR1DAkr7bR5ZHVBLREXBDI59xEw5ojEQ8AD/ZZ5ooiNWnWjJ8hgYQmIzqw10Iny7OHgbJf5M1E7Wl89At0D7kFk4AlRT0w4P5s2/btFkbXICdLjFDoZNCDcQ6I+O508W9iONqAcgUyueBuYe8Uc0TADe0ed4T9ygoy+ZhV+CZB4Gh/mj9idbWIXb8RGTWtXQSAzWDgQRD8XBYoI9/SnzVNE7dSqXx+CDBYuB5F4dSD9FKl1vCOXl/P0ABjeGVmrPZLd881BqgtBepzh9zO8Z8WOv491Qz9FIp/0QR3KenoAeN2Ykdyr72h6M6hvWXJ1IYgffE/O/QEzThXuiH6KCEOoyoCspwfAtm219aiKs5LduhEkM+CeBAP3SOm0x5bd1ZaTYksbkYJAZqCQhkGODGNMxnHZdKv4wk6IYOpGkNGPdeH8rONdXr1rOjl7IekKVCHmgHSVhczGK7niKgAyEo5HevZqIhj1JcigewEIcnbEia6208kvSB9tbbBmBDK54lVgvq5mxckUGBfaneY3pNgKYaSuBJl//xuzEjNmPiV6wrfcb6JhLvERevMwxCyQqFLeFEzQo2BuFTXLwEuljRsOWHLiDnUr3lpXgoy+ZhWvAXihKJhj+kttyzxBki1tJgQCGcd9AMDxIVQnUaGFtpW8Vo6tcFbqTpD5y4u7t3js14oIn8h4874TXWGnkzeEg0NriSCQyRUvB7P4/tZoEGtGDDpgybzkSyIxierWnSDlp0jO/ToYF4h2ZlzfIOPYvnTrQ7LsaTvVEejNDR/jsfdgdcmAEhHf+5gqqlgQpMdZvz/D8J8ikho/xQnzY9m5JJogWVI809tM9wrekUruf0k5PjQGFcE7oN9qf7reyMWCID4IPY57IwOXSANEbyBKg7KaIXkbgqOeCLip3zI/X81vFL/HhiC9A2vf5hktQwD2ktZx/T0iDcqpDGVkLtWPOvmt4Y109HVt91flwQdwEBuC+LF254oLiDkbIO7gIoQL7XT91tGDB9p4kt25wgnEdL/MyJmoO5tOLpZpU8RWrAjid0TuMuEYNAZb9jx9FEVkokzUlf/dWPYQu2X62BGkO+ceTgz/VUtqM4Z5l76Pt0WSS0lq4DE05m/wtsyYKb3aFxM6smnTL/gamxY7gvjISP9gH4N7ZOOGHeq5KxubURcIpPe+ws5eK/l176W2OH2Yb96xWBKkd4BNzyguBzBb6iiUV0jisXwou19R2MssL6ThyTmhOyHeVYaXnNfXRW4U/ajFRywJ4nfgrGWFDycS5JPk7bV0KIgsE5+YTbf5RyJ0C4hAJudeAJZ0sHRLn38plXje7TGtPxlbgvgYdjvrTyMYdwYcw9rE6nxKtLZg6yst+QjJFp1heKdnrfbv17eHU3uPNUHK3yO54rXMfLUSAIn62Gi9TO+4T45ueYfcG/6SeEaSye0T0XX96eQ1SsZWktHYE8TvZ8ZxfwhAUUYLfsqgxKX67NaWM2r0bFXpyzKPj0yYs3fblvkJSfNYmZmGIMiCpYVdjJby98iH1CGhTwGPY6vylWrMxzPeCM9bfHyb9NUw2fOjIQjid3rBcvdQKmGACDvJBmEze0vZww3NeulqLAPi5fLuc2w9Ugz8kRMtXYvnzvhvheMozXTDEKRMEsf9uAHcK633kxmicmLkG3ad1/rFZrnjXr5Dvnz4CgD+fQ7hm4CVxsdAyyF91gzhNKRK58BmxhuKIOWPdqc4n8GCpdwCwbsaHt8w3bOljGUf8Z8aMhIsVAbWKx1pd227MhD6MRFqOIKUSTLons+Eb0WCIVEfPK9vuqU4LSd1M4xeVStUE8eG4c3LWu0rIhkziU4akiBjT5LLGBzd1dppQpSoieGPVT2yssviSMMSxAegO+eeR4xFssAIZMffOylxttE+5MeyjXRH9cQYx5JAl/dbSb/0c0O2hiZImSTO+rkEw18CjrYRVjJjGbOxNK7l4PyyZ0Te8UQ4TrR4TRhwifGZ/k4z2n/AwgRaQafhCeL3LTOwbg6MxCOSsQlqbhMDywBauo3HP7m1y3w1qKIKufnO+ncmkDga4OMJOE60JmDYGAl0Vr+VXBJWPy5604IgPpi9zsaDSxi5h4B31w1chgdgNQir4ZUejGrFJpNzDwF7cwD659E/SNQLA2b8jQlnL7bM++oVg0y/04YgPigLVmzczyiN+HW41e2414I+Yz2Ih8B4kQz6ffnvEr+43tj04vc7Z9V04ei0wTU7tHvb7MEJ2gOEPdjj9/h/E4zDGLxdLWEplH3GM3DO4nnm4wp9RGp6WhGkTJLRYyl+vl9FZ7ekjc8mAAUCCh7g+n8DGL8PYTLQZgDlvzH6ZxtpntUYutsb4Qsb4fhILd2fdgQZ77zSU8C1INwEso1wKjfsMExbgviAjN0n8Z8m0i9dhQV8mun9heFdGOf7HKJ4T2uC+OCM3Uz0SSL9+q4o+A2uv6pU4gvjehNQFrbTniDlFa4BNtkoXiM1c6OsEWhAO36CBfKS18bxDrlsOJuCIOOgjaUUuljlcW7ZAxQze0uZ8JW4peZRiVFTEeQfRClncPTzAMtLc6pylOpv+7dMdFOcMh5GBUlTEmT0tWvt29houVi/dlWeaqOvUyNfiUuu3KiIMe6naQny1nKwX3qBjDPBmC+tiE/Uoyjf3xoQlhB7d8ShBIH87gW32PQEGYdqtNIVzmTwfCk1E4OPQWwk/ZqABFoyYuCOeld2igsomiATRqKcd3abmfNBOBPA/nEZKMVxPA3GHSObNizRqVm3RFoTpMLM684NdxGXjgOoC8A7FE/SqM2/DvAAU2JZNt06ELXzRvGnCRJgpHof5u1LGwvHGWR0MftkUZvYIEBIIUVomIgHPPYGEjPalvUdTW+GNNQ0apogNcTGYecAAAGsSURBVA51t1PcDcRdBuMoBubE/8Oe/06gRzzCSjANZK3kyzV2uanFNUEEhn/+I9y6jbvhY0zeUWM39mLxzULAEwxazgaGTG4dWpSmDQLdbGpVTRCJw9+7gnfm0vDHGPwRAu3JwJ4AvxdAi0Q3m5saAeh3BLzA4BeI6GeJROvDtx5Lf1Hkr+nMaoJEMOT+axkR9iR4e7KH3UA0q/zHww4gngXwDgDNArDDWDhvALwGoDfAtAYG3gDzGv8PGXiZYbzAjBf065L6wdMEUY+x9tDACGiCNPDg6dDVI6AJoh5j7aGBEdAEaeDB06GrR0ATRD3G2kMDI6AJ0sCDp0NXj4AmiHqMtYcGRkATpIEHT4euHgFNEPUYaw8NjIAmSAMPng5dPQKaIOox1h4aGAFNkAYePB26egQ0QdRjrD00MAKaIA08eDp09QhogqjHWHtoYAQ0QRp48HTo6hHQBFGPsfbQwAhogjTw4OnQ1SOgCaIeY+2hgRHQBGngwdOhq0dAE0Q9xtpDAyOgCdLAg6dDV4+AJoh6jLWHBkZAE6SBB0+Hrh4BTRD1GGsPDYzA/weAb11feK80wgAAAABJRU5ErkJggg==)", n.style.width = "80px", n.style.height = "80px", n.style.backgroundSize = "100%", e.appendChild(n), e }, e.prototype.addMapEvent = function (e, t) { We.addMapEvent(e, t) }, e.prototype.removeMapEvent = function (e, t) { We.removeMapEvent(e, t) }, e.prototype.renderPointCloud = function (e) { }, e.prototype.getCurrentFeature = function () { return We.getCurrentFeature() }, e.prototype.checkMapIsExit = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return r.trys.push([0, 7, , 8]), -1 !== t ? [3, 2] : [4, this.aXSearchEngin.getAreaMediumThumbnail(e)]; case 1: return r.sent(), [3, 6]; case 2: return "number" != typeof t ? [3, 4] : (this.requestMapIndex = 0, [4, this.requestBaseMapItem(e, 0, 10, t)]); case 3: return r.sent(), [3, 6]; case 4: return [4, this.requestCloudBaseMap(e)]; case 5: r.sent(), r.label = 6; case 6: return [2, !0]; case 7: return [2, r.sent()]; case 8: return [2] } })) })) }, e }(), He = function () { function e(e) { this.axMapEngin = new Ze(e) } return e.prototype.createMap = function (e, t, r, n, i) { return c(this, void 0, Promise, (function () { return l(this, (function (o) { switch (o.label) { case 0: return [4, this.axMapEngin.createMap(e, t, r, n, i)]; case 1: return o.sent(), [2] } })) })) }, e.prototype.setAreaMap = function (e, t) { this.axMapEngin.setAreaMap(e, t) }, e.prototype.getCurrentPointPosition = function (e) { return this.axMapEngin.getCurrentPointPosition(e) }, e.prototype.setSelectedFeatures = function (e) { this.axMapEngin.setSelectedFeatures(e) }, e.prototype.editPose = function (e, t) { this.curEditPoseId && (this.deleteFeature(this.curEditPoseId), this.curEditPoseId = null), this.curEditPoseId = this.addPoint(e, t); var r = 0; t && "number" == typeof t.angle && (r = t.angle), this.axMapEngin.setPointPosition(this.curEditPoseId, r) }, e.prototype.endEditPose = function () { return this.curEditPoseId && (this.curEditPoseId = null, this.deleteFeature(this.curEditPoseId)), this.axMapEngin.cancleSetPointPosition() }, e.prototype.setClickMapCallback = function (e) { this.axMapEngin.setClickMapCallback(e) }, e.prototype.addPoint = function (e, t) { return this.axMapEngin.addPoint(e, t) }, e.prototype.addLine = function (e, t) { return this.axMapEngin.addLine(e, t) }, e.prototype.trackLine = function (e, t, r) { return this.axMapEngin.trackLine(e, t, r) }, e.prototype.deleteFeature = function (e) { this.axMapEngin.deleteFeature(e) }, e.prototype.getFeature = function (e) { return this.axMapEngin.getFeature(e) }, e.prototype.clearFeature = function () { this.axMapEngin.clearFeature() }, e.prototype.getPlaceList = function () { return this.axMapEngin.getPlaceList() }, e.prototype.clearAreaMap = function () { this.axMapEngin.clearAreaMap() }, e.prototype.project = function (e) { return this.axMapEngin.project(e) }, e.prototype.addMarker = function (e, t, r) { var n = document.createElement("div"); return n.className = "marker", n.style.backgroundImage = "url(" + e + ")", n.style.width = "28px", n.style.height = "28px", n.style.backgroundSize = "100%", n.style.backgroundRepeat = "no-repeat", this.axMapEngin.setMarker(n, t, !1, r) }, e.prototype.addStrMarker = function (e, t, r) { var n = document.createElement("div"); return e && (n.innerHTML = e, n.style.width = "100px", n.style.paddingTop = "40px", n.style.textAlign = "center", n.style.color = "#2794F2"), r || (r = 0), this.axMapEngin.setMarker(n, t, !1, r) }, e.prototype.addBubble = function (e, t, r, n) { var i = document.createElement("div"); return i.className = "marker", i.style.backgroundImage = "url(" + e + ")", i.style.width = "100px", i.style.height = "110px", i.style.backgroundSize = "100%", i.style.backgroundRepeat = "no-repeat", i.addEventListener("touchstart", (function (e) { e.preventDefault(), e.stopPropagation(), n && n() }), !1), i.addEventListener("mousedown", (function (e) { e.preventDefault(), e.stopPropagation(), n && n() }), !1), this.axMapEngin.setMarker(i, t, !1, r, n) }, e.prototype.updateMarker = function (e, t, r) { this.axMapEngin.setMarkerProperties(e, t, r) }, e.prototype.setMarkerProperties = function (e, t, r) { this.axMapEngin.setMarkerProperties(e, t, r) }, e.prototype.removeMarker = function (e) { this.axMapEngin.removeMarker(e) }, e.prototype.fly = function (e) { this.axMapEngin.fly(e) }, e.prototype.zoomTo = function (e) { this.axMapEngin.zoomTo(e) }, e.prototype.setMapCenter = function (e) { this.axMapEngin.setMapCenter(e) }, e.prototype.beautifyMapImg = function (e, t, r, n) { return c(this, void 0, Promise, (function () { return l(this, (function (i) { switch (i.label) { case 0: return [4, this.axMapEngin.beautifyMapImg(e, t, r, n)]; case 1: return [2, i.sent()] } })) })) }, e.prototype.destroy = function () { this.axMapEngin.destroy() }, e.prototype.addMapEvent = function (e, t) { this.axMapEngin.addMapEvent(e, t) }, e.prototype.removeMapEvent = function (e, t) { this.axMapEngin.removeMapEvent(e, t) }, e.prototype.getCurrentFeature = function () { return this.axMapEngin.getCurrentFeature() }, e.prototype.showLayerChoosed = function (e) { return c(this, void 0, void 0, (function () { var t, r, n, i, o, s, a; return l(this, (function (c) { switch (c.label) { case 0: return [4, this.axMapEngin.getNowMapFeatures()]; case 1: if (t = c.sent(), r = JSON.parse(JSON.stringify(t)), this.clearFeature(), !(r && r.features && e && e.length > 0)) return [3, 3]; for (n = r.features, i = [], o = 1; o < n.length; o++)s = n[o], a = s.geometry.type, e.indexOf(a) >= 0 && i.push(s); return r.features = i, [4, this.axMapEngin.reLoadFeatures(r)]; case 2: c.sent(), c.label = 3; case 3: return [2] } })) })) }, e.prototype.checkMapIsExit = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axMapEngin.checkMapIsExit(e, t)]; case 1: return [2, r.sent()] } })) })) }, e }(), Qe = ve((function (e, t) { function r(e, t) { var r = [], n = []; return null == t && (t = function (e, t) { return r[0] === t ? "[Circular ~]" : "[Circular ~." + n.slice(0, r.indexOf(t)).join(".") + "]" }), function (i, o) { if (r.length > 0) { var s = r.indexOf(this); ~s ? r.splice(s + 1) : r.push(this), ~s ? n.splice(s, 1 / 0, i) : n.push(i), ~r.indexOf(o) && (o = t.call(this, i, o)) } else r.push(o); return null == e ? o : e.call(this, i, o) } } (e.exports = function (e, t, n, i) { return JSON.stringify(e, r(t, i), n) }).getSerialize = r })); Qe.getSerialize; var $e = function () { function e(e, t, r, n, i, o) { this.androidWorkerConnected = !1, this.TaskType = { Disinfect: 0, Gohome: 1, Restaurant: 2, Hotel: 3, Transport: 4 }, this.mBaseListener = n, this.mCurrentMode = e, this.isPrivataDeploy = i, this.lanLoggerUrl = "", e === X.LOCAL_APP ? (this.loggerUrl = o ? o + "logstores" : "http://192.168.25.25:9001/logstores", this.loggerHeader = {}) : e === X.WAN_APP ? (this.loggerUrl = t, this.isPrivataDeploy || this.loggerUrl.indexOf("apieu") > -1 || this.loggerUrl.indexOf("apilocal") > -1 || this.loggerUrl.indexOf("apidev") > -1 ? this.loggerHeader = { "Content-Type": "text/plain" } : this.loggerHeader = { "x-log-bodyrawsize": "1234", "x-log-apiversion": "0.6.0" }) : e === X.LAN_APP && (this.loggerUrl = "http://192.168.12.1:9001/logstores", this.loggerHeader = {}), this.sdkVersion = r } return e.prototype.destroy = function () { this.androidWorker && (this.androidWorker.postMessage({ type: "stopWS" }), this.androidWorker.terminate(), this.androidWorker = null) }, e.prototype.enableAndroidLog = function (e) { var t = this; if ("undefined" != typeof Worker) { console.log("start android worker"); var r = new Blob(["onmessage = (event) => {\n\n    let data = event.data\n    if (data.type === 'initWS') {\n      initWS(data.wsUrl)\n    } else if (data.type === 'sendWS') {\n      sendWS(data.cmd, data.sendType)\n    } else if (data.type === 'stopWS') {\n      stopWS()\n    } else if (data.type === 'closeWS') {\n      closeWS()\n    }\n  }\n\n\n  var _ws = null\n  var _uri = null\n  var _protocol = null\n  var _isStarted = false\n  var _heartTimer = null\n  var _isKeepAlive = true\n  var _retryTimeout = 1000\n  var _heartBeatTime = null\n  var wsMap = new Map()\n\n  // // var _workerMsgTime = new Date().getTime()\n  // var _wsMsgTime = null\n\n  function generateUUID() {\n    var d = new Date().getTime()\n    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = (d + Math.random() * 16) % 16 | 0\n      d = Math.floor(d / 16)\n      return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16)\n    })\n    return uuid\n  }\n\n  function keepAlive(ws) {\n    if (_isKeepAlive === false) return\n    if (_heartTimer !== null) {\n      clearTimeout(_heartTimer)\n      _heartTimer = null\n    }\n    if (!ws) return\n    var timeout = 1000\n    if (ws.readyState === ws.OPEN) {\n      ws.send('{\"reqType\":\"onHeartBeat\"}')\n    }\n    // console.log(_heartBeatTime - new Date().getTime())\n    if(new Date().getTime() - _heartBeatTime > 5000){\n      console.log(\"---worker ws发送心跳检测，5s没有收到反馈，关闭ws，重新连接---\")\n      postMessage({ type: 1 })\n      ws.close()\n    }else{\n      _heartTimer = setTimeout(function () {\n        keepAlive(ws)\n      }, timeout)\n    }\n  }\n\n  function sendWS(cmd, sendType) {\n    if (_ws) {\n      if(sendType !== \"logger\"){\n        if(cmd.timestamp && new Date().getTime() - cmd.timestamp > 10000){\n          console.log(\"send ws cmd ---\" + cmd.cmd + \"---current time less than 10s\")\n          return\n        }\n      }\n      _ws.send(JSON.stringify(cmd))\n    }\n  }\n\n  function stopWS() {\n    if (!_ws) {\n      return\n    }\n    _isStarted = false\n    _ws.close()\n    _ws = null\n  }\n\n  function closeWS() {\n    console.log(\"----------外部调用发起ws关闭操作。-----------\")\n    _ws.close()\n  }\n\n  function initWS(wsUrl, protocol) {\n    _uri = wsUrl\n    _protocol = protocol\n    // console.log(\"init ----- ws\")\n    // 创建 WebSocket 连接\n    if (protocol) {\n      _ws = new WebSocket(wsUrl, protocol)\n    } else {\n      _ws = new WebSocket(wsUrl)\n    }\n    _isStarted = true\n    _ws.binaryType = 'arraybuffer'\n    _heartBeatTime = new Date().getTime()\n    keepAlive(_ws)\n    // 收到消息\n    _ws.onmessage = (evt) => {\n      // console.log(evt)\n      if (typeof (evt.data) === 'string') {\n        let data = JSON.parse(evt.data)\n        if (data.reqType === 'onHeartBeat') {\n          _heartBeatTime = new Date().getTime()\n        }\n        postMessage({ type: 0, data: data })\n      } else {\n        postMessage({ type: 0, data: evt.data })\n      }\n    }\n    // 断开连接\n    _ws.onclose = (evt) => {\n      console.log(evt, 'close')\n      // console.log(new Date().getTime(), 'close')\n      // console.log('------worker ws close------')\n      postMessage({ type: 1 })\n\n      if (_isStarted === false) {\n        return\n      }\n\n      if (_heartTimer !== null) {\n        clearTimeout(_heartTimer)\n        _heartTimer = null\n      }\n\n      setTimeout(() => {\n        // console.log(Date.parse(new Date()), 'retry-start')\n        // console.log('------worker ws retry-start------retryTime: -- ' + _retryTimeout)\n        initWS(_uri, _protocol)\n      }, _retryTimeout)\n    }\n\n    // 打开连接\n    _ws.onopen = (evt) => {\n      // console.log(evt, 'open')\n      // console.log('------worker ws open------')\n      postMessage({ type: 2 })\n    }\n\n    _ws.onerror = (evt) => {\n      console.log(evt, 'onerror')\n      console.log('------worker ws onerror------')\n      postMessage({ type: 3 })\n    }\n  }"]), n = URL.createObjectURL(r); this.androidWorker = new Worker(n), this.androidWorker.onmessage = function (e) { var r = e.data; 0 === r.type || (1 === r.type ? t.androidWorkerConnected = !1 : 2 === r.type && (t.androidWorkerConnected = !0)) }; var i = "ws://127.0.0.1:9004"; null !== e && "" !== e && void 0 !== e && (i = e), this.androidWorker.postMessage({ type: "initWS", wsUrl: i }) } }, e.prototype.sendAndroidLog = function (e, t, r, n) { return c(this, void 0, void 0, (function () { var i; return l(this, (function (o) { return r.error && "AxiosError" === r.error.name && (r.error = { code: r.error.code, name: r.error.name, message: r.error.message }), i = { reqType: "onWriteLog", data: { source: "sdk", tag: t, level: e, logType: "sdk-operation", message: n, extData: r }, timestamp: (new Date).getTime() }, this.androidWorker && this.androidWorkerConnected && i && this.androidWorker.postMessage({ type: "sendWS", cmd: i, sendType: "logger" }), [2] })) })) }, e.prototype.setLoggerExportUrl = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { return this.lanLoggerUrl = e, [2] })) })) }, e.prototype.exportLogger = function (e) { return c(this, void 0, Promise, (function () { var t, r, n, i; return l(this, (function (o) { switch (o.label) { case 0: this.lanLoggerUrl && "" !== this.lanLoggerUrl && (this.loggerUrl = this.lanLoggerUrl + "logstores"), o.label = 1; case 1: return o.trys.push([1, 5, , 6]), t = e, !0 === this.isPrivataDeploy || this.loggerUrl.indexOf("apieu") > -1 || this.loggerUrl.indexOf("apilocal") > -1 || this.loggerUrl.indexOf("apidev") > -1 ? (r = {}, r = e && e.__logs__ && e.__logs__.length > 0 ? { message: Qe(e.__logs__[0]) } : { message: Qe(e) }, [4, this.mBaseListener.getToken(X.WAN_APP)]) : [3, 3]; case 2: n = o.sent(), this.loggerHeader["X-Token"] = n, t = Qe(r) + " \n ", o.label = 3; case 3: return [4, de.post(this.loggerUrl, t, { headers: this.loggerHeader, timeout: 1e3 })]; case 4: return (i = o.sent()) && 200 === i.status ? [2, !0] : [3, 6]; case 5: return o.sent(), [2, !1]; case 6: return [2, !1] } })) })) }, e.prototype.exportOperationLogger = function (e, t, r, n, i, o, s) { return c(this, void 0, Promise, (function () { var a, c, u; return l(this, (function (l) { switch (l.label) { case 0: return this.sendAndroidLog(e, r, n, i), a = "sdk-operation", o && "" !== o && (a = o), n.error && "AxiosError" === n.error.name && (n.error = { code: n.error.code, name: n.error.name, message: n.error.message }), c = { logType: a, robotId: t, timestamp: (new Date).getTime().toString(), tag: r, level: e, message: i, data: Qe(n), time: this.formatDate(new Date), totalAxiosrequestTime_ms: s }, "string" == typeof s && "" !== s && s && (c = { logType: a, robotId: t, timestamp: (new Date).getTime().toString(), tag: r, level: e, message: i, data: Qe(n), time: this.formatDate(new Date), totalAxiosrequestTime_ms: s }), u = {}, u = this.mCurrentMode === X.WAN_APP ? { __topic__: "logs", __source__: "SDK_" + this.sdkVersion, __logs__: [c], __tags__: { timestamp: (new Date).getTime.toString } } : c, [4, this.exportLogger(u)]; case 1: return [2, l.sent()] } })) })) }, e.prototype.exportTaskLogger = function (e, t, r, n) { return c(this, void 0, Promise, (function () { var i; return l(this, (function (o) { switch (o.label) { case 0: switch (i = {}, i = this.mCurrentMode === X.WAN_APP ? { __topic__: "logs", __source__: "SDK_" + this.sdkVersion, __logs__: r, __tags__: { timestamp: (new Date).getTime.toString } } : r, e) { case 1: return [3, 1]; case 2: return [3, 3]; case 3: return [3, 5] }return [3, 7]; case 1: return [4, this.exportEventLogger(t, i, n)]; case 2: case 4: case 6: return [2, o.sent()]; case 3: return [4, this.exportAlarmLogger(t, i, n)]; case 5: return [4, this.exportStateLogger(t, i, n)]; case 7: return [2] } })) })) }, e.prototype.decycle = function (e) { var t = [], r = Qe(e, (function (e, r) { if ("object" == typeof r && null !== r) { if (-1 !== t.indexOf(r)) return; t.push(r) } return r })); return t = null, r }, e.prototype.exportEventLogger = function (e, t, r) { return c(this, void 0, Promise, (function () { var n, i; return l(this, (function (o) { switch (o.label) { case 0: return n = this.getTaskTypeName(e), t.error && "AxiosError" === t.error.name && (t.error = { code: t.error.code, name: t.error.name, message: t.error.message }), i = { taskType: n, topic: n + "-task", source: "sdk", logData: Qe(t), event: r }, [4, this.exportLogger(i)]; case 1: return [2, o.sent()] } })) })) }, e.prototype.exportAlarmLogger = function (e, t, r) { return c(this, void 0, Promise, (function () { var n, i; return l(this, (function (o) { switch (o.label) { case 0: return n = this.getTaskTypeName(e), t.error && "AxiosError" === t.error.name && (t.error = { code: t.error.code, name: t.error.name, message: t.error.message }), i = { taskType: n, topic: n + "-task", source: "sdk", logData: Qe(t), alarm: r }, [4, this.exportLogger(i)]; case 1: return [2, o.sent()] } })) })) }, e.prototype.exportStateLogger = function (e, t, r) { return c(this, void 0, Promise, (function () { var n, i; return l(this, (function (o) { switch (o.label) { case 0: return n = this.getTaskTypeName(e), t.error && "AxiosError" === t.error.name && (t.error = { code: t.error.code, name: t.error.name, message: t.error.message }), i = { taskType: n, topic: n + "-task", source: "sdk", logData: Qe(t), state: r }, [4, this.exportLogger(i)]; case 1: return [2, o.sent()] } })) })) }, e.prototype.getTaskTypeName = function (e) { switch (e) { case this.TaskType.Disinfect: return "disinfect"; case this.TaskType.Restaurant: return "restaurant"; case this.TaskType.Hotel: return "hotel"; case this.TaskType.Transport: return "transport"; default: return null } }, e.prototype.formatDate = function (e, t) { if (e) { switch (t || (t = "yyyy-MM-dd HH:mm:ss"), typeof e) { case "string": e = new Date(e.replace(/-/, "/")); break; case "number": e = new Date(e) }if (e instanceof Date) { var r = { yyyy: e.getFullYear(), M: e.getMonth() + 1, d: e.getDate(), H: e.getHours(), m: e.getMinutes(), s: e.getSeconds(), MM: ("" + (e.getMonth() + 101)).substr(1), dd: ("" + (e.getDate() + 100)).substr(1), HH: ("" + (e.getHours() + 100)).substr(1), mm: ("" + (e.getMinutes() + 100)).substr(1), ss: ("" + (e.getSeconds() + 100)).substr(1) }; return t.replace(/(yyyy|MM?|dd?|HH?|mm?|ss?)/g, (function () { return r[arguments[0]] })) } } }, e }(), Je = function () { function e(e) { this.requestRetryTime = 5e3, this.mBaseListener = e, e.getMode() !== X.WAN_APP ? (this.requestRetryTime = 1e3, this.destroy()) : this.requestRetryTime = 5e3 } return e.prototype.destroy = function () { null !== this.totalRetryTimer && (clearTimeout(this.totalRetryTimer), this.totalRetryTimer = null) }, e.prototype.requestTotal = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXStatis", { params: e }, "request-total"), r = null, u.label = 1; case 1: return u.trys.push([1, 4, , 12]), [4, this.mBaseListener.getHeader()]; case 2: return n = u.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "statis/v1.1/total?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), e, { headers: n })]; case 3: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXStatis", { resData: r ? r.data : null }, "response-total-end"), [3, 12]; case 4: return i = u.sent(), o = { error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXStatis", o, "request-total-error"), s = null, i.response && 404 === i.response.status ? (s = new Promise((function (e, t) { t($.Get_Statis_Total_Fail_404) })), [3, 11]) : [3, 5]; case 5: return i.response && 401 === i.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 10]; case 6: if (u.sent()) return [2, s = new Promise((function (e, t) { t(Q.Token_401) }))]; u.label = 7; case 7: return u.trys.push([7, 9, , 10]), [4, this.mBaseListener.requestAuth()]; case 8: return u.sent(), [3, 10]; case 9: return u.sent(), [2, s = new Promise((function (e, t) { t($.Get_Statis_Total_Fail) }))]; case 10: if (t > 0) return t--, [2, new Promise((function (r, n) { a.totalRetryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.requestTotal(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Statis_Total_Fail) })), u.label = 11; case 11: return [2, s]; case 12: return r && 200 === r.status && r.data ? [2, r.data.data] : [2, s = new Promise((function (e, t) { t($.Get_Statis_Total_Fail) }))] } })) })) }, e.prototype.getSingleTaskStatistics = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXStatis", { params: e }, "request-single-task-statis"), r = null, u.label = 1; case 1: return u.trys.push([1, 4, , 12]), [4, this.mBaseListener.getHeader()]; case 2: return n = u.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "statis/v1.1/task/").concat(e.taskId, "?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), { fields: e.fields }, { headers: n })]; case 3: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXStatis", { resData: r ? r.data : null }, "response-single-task-statis-end"), [3, 12]; case 4: return i = u.sent(), o = { error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXStatis", o, "request-single-task-statis-error"), s = null, i.response && 404 === i.response.status ? (s = new Promise((function (e, t) { t($.Get_Single_Task_Statis_Fail_404) })), [3, 11]) : [3, 5]; case 5: return i.response && 401 === i.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 10]; case 6: if (u.sent()) return [2, s = new Promise((function (e, t) { t(Q.Token_401) }))]; u.label = 7; case 7: return u.trys.push([7, 9, , 10]), [4, this.mBaseListener.requestAuth()]; case 8: return u.sent(), [3, 10]; case 9: return u.sent(), [2, s = new Promise((function (e, t) { t($.Get_Single_Task_Statis_Fail) }))]; case 10: if (t > 0) return t--, [2, new Promise((function (r, n) { a.totalRetryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getSingleTaskStatistics(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Single_Task_Statis_Fail) })), u.label = 11; case 11: return [2, s]; case 12: return r && 200 === r.status && r.data ? [2, r.data.data] : [2, s = new Promise((function (e, t) { t($.Get_Single_Task_Statis_Fail) }))] } })) })) }, e.prototype.getTaskStatistics = function (e, t) { return void 0 === t && (t = 15), c(this, void 0, Promise, (function () { var r, n, i, o, s, a = this; return l(this, (function (u) { switch (u.label) { case 0: this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXStatis", { params: e }, "request-task-statis"), r = null, u.label = 1; case 1: return u.trys.push([1, 4, , 12]), [4, this.mBaseListener.getHeader()]; case 2: return n = u.sent(), [4, de.post("".concat(this.mBaseListener.getServerUrl(), "statis/v1.1/task?robotSn=").concat(this.mBaseListener.getCurrentRobotSn()), e, { headers: n })]; case 3: return r = u.sent(), this.mBaseListener.exportOperationLogger(V, this.mBaseListener.getCurrentRobotSn(), "AXStatis", { resData: r ? r.data : null }, "response-task-statis-end"), [3, 12]; case 4: return i = u.sent(), o = { error: i }, this.mBaseListener.exportOperationLogger(N, this.mBaseListener.getCurrentRobotSn(), "AXStatis", o, "request-task-statis-error"), s = null, i.response && 404 === i.response.status ? (s = new Promise((function (e, t) { t($.Get_Task_Statis_Fail_404) })), [3, 11]) : [3, 5]; case 5: return i.response && 401 === i.response.status ? [4, this.mBaseListener.getIsTokenParamsInit()] : [3, 10]; case 6: if (u.sent()) return [2, s = new Promise((function (e, t) { t(Q.Token_401) }))]; u.label = 7; case 7: return u.trys.push([7, 9, , 10]), [4, this.mBaseListener.requestAuth()]; case 8: return u.sent(), [3, 10]; case 9: return u.sent(), [2, s = new Promise((function (e, t) { t($.Get_Task_Statis_Fail) }))]; case 10: if (t > 0) return t--, [2, new Promise((function (r, n) { a.totalRetryTimer = setTimeout((function () { return c(a, void 0, void 0, (function () { var n; return l(this, (function (i) { switch (i.label) { case 0: return [4, this.getTaskStatistics(e, t)]; case 1: return n = i.sent(), r(n), [2] } })) })) }), a.requestRetryTime) }))]; s = new Promise((function (e, t) { t($.Get_Task_Statis_Fail) })), u.label = 11; case 11: return [2, s]; case 12: return r && 200 === r.status && r.data ? [2, r.data.data] : [2, s = new Promise((function (e, t) { t($.Get_Task_Statis_Fail) }))] } })) })) }, e }(), Ke = function () { function e(e, t, r, n, i, o, s) { void 0 === s && (s = {}); var a = this; if (this.isFinishInit = !1, this.sdkVersion = "1.1.225", this.viewLanguage = "en", this.isTokenParamsInit = !1, this.initParams = s, this.axMode = r, this.viewLanguage = s.viewLanguage || "en", new ue(this.viewLanguage), this.axMode !== X.LAN_APP && this.axMode !== X.LOCAL_APP && this.axMode !== X.WAN_APP) throw new Error("Invalid app mode."); if (r === X.LOCAL_APP) ke.serverUrl = s.chassisUrl && n ? n : "http://192.168.25.25:9002/", ke.wsUrl = s.chassisUrl && i ? i : "ws://192.168.25.25:9000/", ke.chassisUrl = s.chassisUrl ? s.chassisUrl : "http://192.168.25.25:9001/", ke.outlineStatisUrl = s.outlineStatisUrl ? s.outlineStatisUrl : "http://192.168.25.25:9004/"; else if (r === X.WAN_APP) if (n && "" !== n && null !== n ? ("/" !== n.charAt(n.length - 1) && (n += "/"), ke.serverUrl = n, !0 === this.initParams.isPrivateDeploy ? this.loggerUrl = n + "log-track" : -1 !== n.indexOf("apieu") ? this.loggerUrl = "https://apieu.autoxing.com/log-track" : -1 !== n.indexOf("apilocal") ? this.loggerUrl = n + "log-track" : -1 !== n.indexOf("apiglobal") ? this.loggerUrl = "https://apiglobal.autoxing.com/log-tracking/sdk-log-entry" : -1 === n.indexOf("devapi.autoxing.com") && -1 === n.indexOf("apidev.autoxing.com") && -1 === n.indexOf("api.autoxing.com") ? this.loggerUrl = n + "logstores" : "dev" === ke.server ? this.loggerUrl = "https://apidev.autoxing.com/log-track" : this.loggerUrl = "https://csp-prod.cn-beijing.log.aliyuncs.com/logstores/sdk-log-entry/track") : "dev" === ke.server ? (ke.serverUrl = "https://apidev.autoxing.com/", this.loggerUrl = "https://apidev.autoxing.com/log-track") : (ke.serverUrl = "https://api.autoxing.com/", this.loggerUrl = "https://csp-prod.cn-beijing.log.aliyuncs.com/logstores/sdk-log-entry/track"), i && "" !== i && null !== i) "/" !== i.charAt(i.length - 1) && (i += "/"), ke.wsUrl = i; else if (n && "" !== n && null !== n) if (-1 !== n.indexOf("https")) { var c = n.split("https"); ke.wsUrl = "wss" + c[1] } else c = n.split("http"), ke.wsUrl = "ws" + c[1]; else "dev" === ke.server ? ke.wsUrl = "wss://servicedev.autoxing.com/" : ke.wsUrl = "wss://service.autoxing.com/"; else r === X.LAN_APP && (ke.serverUrl = "http://192.168.12.1:9002/", ke.wsUrl = "ws://192.168.12.1:9000/", ke.chassisUrl = "http://192.168.12.1:9001/", ke.outlineStatisUrl = "http://192.168.12.1:9004/"); o && "" !== o && null !== o && (ke.baseHeader = { Authorization: o }), n && "" !== n && null !== n ? this.wanServerUrl = n : "dev" === ke.server ? this.wanServerUrl = "https://apidev.autoxing.com/" : this.wanServerUrl = "https://api.autoxing.com/"; var l = { requestAuth: function () { return a.requestAuth() }, getToken: function (e) { return a.getToken(e) }, getTokenKey: function () { return a.getTokenKey() }, getServerUrl: function () { return a.getServerUrl() }, getBaseHeader: function () { return a.getBaseHeader() }, getWsUrl: function () { return ke.wsUrl }, getChassisUrl: function () { return ke.chassisUrl }, getMode: function () { return a.getMode() }, sendCmd: function (e) { a.sendCmd(e) }, getCurrentRobotSn: function () { return a.aXRobotEngin.getCurrentRobotSn() }, getState: function (e) { return a.getState(e) }, checkCmd: function (e, t) { return a.checkCmd(e, t) }, trackLine: function (e, t, r) { a.axMap.trackLine(e, t, r) }, deleteFeature: function (e) { a.axMap.deleteFeature(e) }, onStateChanged: function (e) { a.onStateChanged(e) }, onStateError: function (e) { a.onStateError(e) }, onTaskChanged: function (e) { a.onTaskChanged(e) }, onTaskError: function (e) { a.onTaskError(e) }, onRobotListStatusChanged: function (e) { a.onRobotListStatusChanged(e) }, onRobotListStatusError: function (e) { a.onRobotListStatusError(e) }, onEdgeAiChanged: function (e) { a.onEdgeAiChanged(e) }, onEdgeAiError: function (e) { a.onEdgeAiError(e) }, getActionMode: function (e) { return a.getActionMode() }, performRestartTask: function () { return a.aXTaskEngin.performRestartTask() }, getHeader: function () { return a.getHeader() }, receiveTaskState: function (e) { return a.receiveTaskState(e) }, getWANServerUrl: function () { return a.wanServerUrl }, setCurrentTaskProperty: function (e, t) { return a.setCurrentTaskProperty(e, t) }, getCurrentTaskProperty: function () { return a.getCurrentTaskProperty() }, exportTaskLogger: function (e, t, r, n) { return a.exportTaskLogger(e, t, r, n) }, exportOperationLogger: function (e, t, r, n, i, o) { return a.exportOperationLogger(e, t, r, n, i, o) }, finishTask: function (e) { return a.finishTask(e) }, restartTask: function (e) { return a.restartTask(e) }, goRestartTask: function (e) { return a.goRestartTask(e) }, cancelTask: function (e, t) { return a.cancelTask(e, t) }, motionFor: function (e) { return a.motionFor(e) }, getRobotOwnCharges: function (e) { return a.getRobotOwnCharges(e) }, startTask: function (e, t) { return a.startTask(e, t) }, setLoggerExportUrl: function (e) { return a.setLoggerExportUrl(e) }, onSerialChanged: function (e) { return a.onSerialChanged(e) }, onDownloadMapStateChanged: function (e) { return a.onDownloadMapStateChanged(e) }, onLaserDataChanged: function (e) { return a.onLaserDataChanged(e) }, checkChassisNetWork: function () { return a.checkChassisNetWork() }, onPointCloudDataChanged: function (e) { return a.onPointCloudDataChanged(e) }, onChassisStartProgressChanged: function (e) { return a.onChassisStartProgressChanged(e) }, checkCloudNetWork: function () { return a.checkCloudNetWork() }, onRobotSettingsStateChanged: function (e) { a.onRobotSettingsStateChanged(e) }, onRobotSettingsStateError: function (e) { a.onRobotSettingsStateError(e) }, getIsTokenParamsInit: function () { return a.getIsTokenParamsInit() } }, u = !1; s.isPrivateDeploy && (u = s.isPrivateDeploy), this.axLogger = new $e(r, this.loggerUrl, this.sdkVersion, l, u, ke.chassisUrl), this.aXAuth = new Ee(s.tokenData, e, t, l), this.aXRobotEngin = new Ce(l), this.aXMotionEngin = new Se(l), this.aXSearchEngin = new Pe(l), this.aXTaskEngin = new Ae(l), this.aXRobotsEngin = new Le(l), this.aXTaskQueueEngin = new Me(l), this.aXOutlineStatisEngin = new Re(l), this.aXCustomTaskEngin = new Be(l), this.axMap = new He(l), this.aXStatis = new Je(l), s.tokenData && s.tokenData.token ? this.isTokenParamsInit = !0 : this.isTokenParamsInit = !1 } return e.prototype.getSdkVersion = function () { return this.sdkVersion }, e.prototype.requestAuth = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXAuth.requestAuth()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.onStateChanged = function (e) { this.mOnRobotListener && "function" == typeof this.mOnRobotListener.onStateChanged && this.mOnRobotListener.onStateChanged(e) }, e.prototype.onStateError = function (e) { this.mOnRobotListener && "function" == typeof this.mOnRobotListener.onStateError && this.mOnRobotListener.onStateError(e) }, e.prototype.onRobotSettingsStateError = function (e) { this.mOnRobotSettingsListener && "function" == typeof this.mOnRobotSettingsListener.onRobotSettingsStateError && this.mOnRobotSettingsListener.onRobotSettingsStateError(e) }, e.prototype.onRobotSettingsStateChanged = function (e) { this.mOnRobotSettingsListener && "function" == typeof this.mOnRobotSettingsListener.onRobotSettingsStateChanged && this.mOnRobotSettingsListener.onRobotSettingsStateChanged(e) }, e.prototype.onEdgeAiChanged = function (e) { this.mOnEdgeAiListener && "function" == typeof this.mOnEdgeAiListener.onEdgeAiChanged && this.mOnEdgeAiListener.onEdgeAiChanged(e) }, e.prototype.onEdgeAiError = function (e) { this.mOnEdgeAiListener && "function" == typeof this.mOnEdgeAiListener.onEdgeAiError && this.mOnEdgeAiListener.onEdgeAiError(e) }, e.prototype.receiveTaskState = function (e) { this.aXTaskEngin.dealTaskState(e) }, e.prototype.setCurrentTaskProperty = function (e, t) { this.aXTaskEngin.setCurrentTaskProperty(e, t) }, e.prototype.getCurrentTaskProperty = function () { return this.aXTaskEngin.getCurrentTaskProperty() }, e.prototype.onTaskChanged = function (e) { this.mOnTaskListener && "function" == typeof this.mOnTaskListener.onTaskChanged && this.mOnTaskListener.onTaskChanged(e) }, e.prototype.onTaskError = function (e) { this.mOnTaskListener && "function" == typeof this.mOnTaskListener.onTaskError && this.mOnTaskListener.onTaskError(e) }, e.prototype.onRobotListStatusChanged = function (e) { this.mOnBusinessListener && "function" == typeof this.mOnBusinessListener.onRobotListStatusChanged && this.mOnBusinessListener.onRobotListStatusChanged(e) }, e.prototype.onRobotListStatusError = function (e) { this.mOnBusinessListener && "function" == typeof this.mOnBusinessListener.onRobotListStatusError && this.mOnBusinessListener.onRobotListStatusError(e) }, e.prototype.getHeader = function () { return c(this, void 0, Promise, (function () { var e; return l(this, (function (t) { switch (t.label) { case 0: return this.axMode !== X.WAN_APP ? [3, 2] : [4, this.getToken()]; case 1: if ("string" == typeof (e = t.sent())) return [2, { "X-Token": e }]; t.label = 2; case 2: return [2, {}] } })) })) }, e.prototype.checkCmd = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.checkCmd(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.init = function () { return c(this, void 0, Promise, (function () { var e, t, r; return l(this, (function (n) { switch (n.label) { case 0: if (this.axMode !== X.WAN_APP) return [3, 9]; n.label = 1; case 1: return n.trys.push([1, 7, , 8]), this.initParams && this.initParams.tokenData && this.initParams.tokenData.token ? (e = !0, this.initParams.isPrivate ? [3, 3] : [4, this.aXAuth.verifyApplication()]) : [3, 4]; case 2: e = n.sent(), n.label = 3; case 3: return e && (this.isFinishInit = !0), [2, e]; case 4: return [4, this.aXAuth.requestAuth()]; case 5: return !0 === (t = n.sent()) && (this.isFinishInit = !0), [2, t]; case 6: return [3, 8]; case 7: return r = n.sent(), [2, new Promise((function (e, t) { t(r) }))]; case 8: return [3, 10]; case 9: return this.isFinishInit = !0, [2, !0]; case 10: return [2] } })) })) }, e.prototype.createMap = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return !0 !== this.isFinishInit ? [3, 2] : [4, this.axMap.createMap(e, t, null, null, r)]; case 1: return n.sent(), [2, this.axMap]; case 2: return [2, null] } })) })) }, e.prototype.connectRobot = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return !0 !== this.isFinishInit ? [3, 2] : [4, this.aXRobotEngin.connectRobot(e)]; case 1: return [2, t.sent()]; case 2: return [2, null] } })) })) }, e.prototype.setEmergency = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.setEmergency(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.beginControl = function () { this.aXMotionEngin.beginControl() }, e.prototype.endControl = function () { this.aXMotionEngin.endControl() }, e.prototype.motionFor = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXMotionEngin.motionFor(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.motionForToRobot = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXRobotsEngin.motionFor(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.motionControl = function (e, t) { this.aXMotionEngin.motionControl(e, t) }, e.prototype.moveTo = function (e, t) { this.aXMotionEngin.moveTo(e, t) }, e.prototype.resetPose = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXRobotEngin.resetPose(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.resetMap = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXRobotEngin.resetPose({ x: 0, y: 0, yaw: 0, areaId: e }, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.updateMap = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXRobotEngin.updateMap(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.updateMapUpgrade = function (e, t) { return c(this, void 0, void 0, (function () { return l(this, (function (r) { return this.mOnUpdateMapListener = e, this.aXRobotEngin.updateMapUpgrade(e, t), [2] })) })) }, e.prototype.updateMapByRobotId = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXRobotsEngin.updateMapByRobotId(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.restartRobot = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.restartRobot(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.setEnableTrack = function (e) { this.aXRobotEngin.setEnableTrack(e) }, e.prototype.createTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskEngin.createTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.executeTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskEngin.executeTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.startTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskEngin.startTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.pauseTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskEngin.pauseTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.resumeTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskEngin.resumeTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.continueTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskEngin.continueTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.cancelTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskEngin.cancelTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.cancelElevatorTask = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXTaskEngin.cancelElevator()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.getCurrentTask = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { return [2, this.aXTaskEngin.getCurrentTask()] })) })) }, e.prototype.updateTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskEngin.updateTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.restartTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskEngin.restartTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.goRestartTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskEngin.goRestartTask(e)]; case 1: return t.sent(), [2] } })) })) }, e.prototype.finishTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskEngin.finishTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getRobotId = function () { return this.aXRobotEngin.getCurrentRobotSn() }, e.prototype.goHome = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.goHome(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.openSprayer = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.openSprayer(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.closeSprayer = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.closeSprayer(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.openBoxDoor = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXRobotEngin.openBoxDoor(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.closeBoxDoor = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXRobotEngin.closeBoxDoor(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.openLightBelt = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.openLightBelt(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.closeLightBelt = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.closeLightBelt(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.setVolume = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXRobotEngin.setVolume(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.setSpeed = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.setSpeed(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.stopPlayAudio = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.stopPlayAudio(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.setLanguage = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.setLanguage(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.setWifi = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXRobotEngin.setWifi(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.switchUpdateMap = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.switchUpdateMap(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.switchAutoCharge = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.switchAutoCharge(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.setGlobalPosition = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.setGlobalPosition(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.removeWheelOverload = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.removeWheelOverload(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getMode = function () { return this.axMode }, e.prototype.getToken = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXAuth.getToken(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getTokenKey = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXAuth.getTokenKey()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.getServerUrl = function () { return ke.serverUrl }, e.prototype.getBaseHeader = function () { return ke.baseHeader }, e.prototype.sendCmd = function (e) { this.aXRobotEngin.sendCmd(e) }, e.prototype.isRobotEstimate = function () { return this.aXRobotEngin.isRobotEstimate() }, e.prototype.getPlaceList = function () { return this.axMap.getPlaceList() }, e.prototype.getPoiList = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXSearchEngin.searchPoi(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getPoiListExtend = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXSearchEngin.searchPoiExtend(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getPoiById = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXSearchEngin.searchPoiById(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getRobotOwnCharges = function (e) { return c(this, void 0, Promise, (function () { var t; return l(this, (function (r) { switch (r.label) { case 0: return t = {}, e ? (t.robotId = e, t.type = 9, t.properties = { deviceIds: e }) : (t.robotId = this.aXRobotEngin.getCurrentRobotSn(), t.type = 9, t.properties = { deviceIds: this.aXRobotEngin.getCurrentRobotSn() }), [4, this.aXSearchEngin.searchPoi(t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getBusinessList = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXSearchEngin.searchBusiness()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.getAreaList = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXSearchEngin.searchArea()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.getAreaListByBus = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXSearchEngin.searchAreaByBus(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getAreaById = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXSearchEngin.getAreaById(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getEffectiveAreaList = function (e) { return c(this, void 0, Promise, (function () { var t; return l(this, (function (r) { switch (r.label) { case 0: return t = !0, "boolean" == typeof e && (t = e), [4, this.aXSearchEngin.searchArea(t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getAreaPic = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXSearchEngin.getAreaPic(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getState = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { return !0 === this.isFinishInit ? [2, this.aXRobotEngin.getState(e)] : [2, null] })) })) }, e.prototype.subscribeRealState = function (e) { this.mOnRobotListener = e, this.aXRobotEngin.getStateToStateChanged() }, e.prototype.subscribeTaskState = function (e) { this.mOnTaskListener = e, this.axMode === X.WAN_APP && this.aXTaskEngin.start() }, e.prototype.connectBusiness = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return this.axMode !== X.WAN_APP ? [3, 2] : [4, this.aXRobotsEngin.startChannel(e, t)]; case 1: return [2, r.sent()]; case 2: return [2, !1] } })) })) }, e.prototype.subscribeRobotsStateByBus = function (e) { this.mOnBusinessListener = e }, e.prototype.pauseTaskToRobot = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotsEngin.pauseTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.resumeTaskToRobot = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotsEngin.resumeTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.continueTaskToRobot = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotsEngin.continueTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getRobotList = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return !0 !== this.isFinishInit ? [3, 4] : this.axMode !== X.WAN_APP ? [3, 2] : [4, this.aXRobotEngin.getRobotList(e, t)]; case 1: return [2, r.sent()]; case 2: case 4: return [2, null]; case 3: return [3, 5]; case 5: return [2] } })) })) }, e.prototype.getBusinessId = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return void 0 === e && (e = this.axMode), e !== X.WAN_APP ? [3, 2] : [4, this.aXRobotEngin.requestRobotDeploy()]; case 1: return [2, t.sent()]; case 2: return [2, null] } })) })) }, e.prototype.getActionMode = function (e) { var t = this.aXRobotEngin.getCurrentRobotSn(); return t ? 0 === t.indexOf("7") || 0 === t.indexOf("A") || 0 === t.indexOf("1") || 0 === t.indexOf("B7") || 0 === t.indexOf("S6") || 0 === t.indexOf("S3") ? 2 : 1 : 3 }, e.prototype.destroy = function () { this.aXRobotEngin.destroy(), this.aXMotionEngin.destroy(), this.aXTaskEngin.destroy(), this.aXRobotsEngin.destroy(), this.axMap.destroy(), this.aXAuth.destroy(), this.aXSearchEngin.destroy(), this.aXStatis.destroy(), this.axLogger.destroy() }, e.prototype.robotListSubDestroy = function () { this.aXRobotsEngin.destroy() }, e.prototype.exportTaskLogger = function (e, t, r, n) { return c(this, void 0, Promise, (function () { return l(this, (function (i) { switch (i.label) { case 0: return [4, this.axLogger.exportTaskLogger(e, t, r, n)]; case 1: return [2, i.sent()] } })) })) }, e.prototype.exportOperationLogger = function (e, t, r, n, i, o, s) { return c(this, void 0, Promise, (function () { return l(this, (function (a) { return "object" == typeof n && (n.sourceType = n.sourceType ? n.sourceType : this.initParams.sourceType ? this.initParams.sourceType : 6), [2, this.axLogger.exportOperationLogger(e, t, r, n, i, o, s)] })) })) }, e.prototype.setLoggerExportUrl = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axLogger.setLoggerExportUrl(e)]; case 1: return t.sent(), [2] } })) })) }, e.prototype.saveCruise = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskEngin.saveCruise(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getCruises = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskEngin.getCruises(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.deleteCruise = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskEngin.deleteCruise(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.syncCruiseCloud = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskEngin.syncCruiseCloud(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.syncCruiseLocal = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXTaskEngin.syncCruiseLocal()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.setServerInfo = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXRobotEngin.setServerInfo(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.setServerInfos = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.setServerInfos(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.setPlayAudio = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.setPlayAudio(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.setRouteMode = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.setRouteMode(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getRouteMode = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXRobotEngin.getRouteMode()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.subscribeSerialData = function (e) { this.mOnSerialListener = e, this.axMode !== X.WAN_APP && this.aXRobotEngin.startSerialDataChannel() }, e.prototype.onSerialChanged = function (e) { this.mOnSerialListener && "function" == typeof this.mOnSerialListener.onSerialChanged && this.mOnSerialListener.onSerialChanged(e) }, e.prototype.onSerialError = function (e) { this.mOnSerialListener && "function" == typeof this.mOnSerialListener.onSerialError && this.mOnSerialListener.onSerialError(e) }, e.prototype.subscribeDownloadMapState = function (e) { this.mOnDownloadMapStateListener = e }, e.prototype.onDownloadMapStateChanged = function (e) { this.mOnDownloadMapStateListener && "function" == typeof this.mOnDownloadMapStateListener.onDownloadMapStateChanged && this.mOnDownloadMapStateListener.onDownloadMapStateChanged(e) }, e.prototype.getStatisticsTotal = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXStatis.requestTotal(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getSingleTaskStatistics = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXStatis.getSingleTaskStatistics(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getTaskStatistics = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXStatis.getTaskStatistics(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.clearSystemDownAlert = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.clearSystemDownAlert(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getRouteInfo = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXRobotEngin.getRouteInfo()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.subscribeLaserData = function (e) { this.mOnLaserDataListener = e }, e.prototype.onLaserDataChanged = function (e) { this.mOnLaserDataListener && "function" == typeof this.mOnLaserDataListener.onLaserDataChanged && this.mOnLaserDataListener.onLaserDataChanged(e) }, e.prototype.sendLaserData = function (e) { this.aXRobotEngin.sendInfo(e) }, e.prototype.enableAndroidLog = function (e) { this.axLogger.enableAndroidLog(e) }, e.prototype.checkChassisNetWork = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXRobotEngin.checkChassisNetWork()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.checkCloudNetWork = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXRobotEngin.checkCloudNetWork()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.getAreaCompareList = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXRobotEngin.getAreaCompareList()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.sendSyncMapData = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.sendSyncMapData(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.shutdownRobot = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.shutdownRobot(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.recordBag = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.recordBag(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getAreaFeatures = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXSearchEngin.getAreaFeatures(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.setJackAction = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.setJackAction(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getAreaThumbnail = function (e) { return c(this, void 0, Promise, (function () { var t; return l(this, (function (r) { switch (r.label) { case 0: return t = null, this.axMode !== X.WAN_APP ? [3, 2] : [4, this.aXSearchEngin.getCloudAreaThumbnail(e)]; case 1: return t = r.sent(), [3, 4]; case 2: return [4, this.aXSearchEngin.getAreaThumbnail(e)]; case 3: t = r.sent(), r.label = 4; case 4: return [2, t] } })) })) }, e.prototype.getAreaMediumThumbnail = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXSearchEngin.getAreaMediumThumbnail(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.addTimeTask = function (e) { return c(this, void 0, Promise, (function () { var t; return l(this, (function (r) { switch (r.label) { case 0: return t = null, this.axMode !== X.WAN_APP ? [3, 2] : [4, this.aXRobotEngin.addTimerTask(e)]; case 1: return t = r.sent(), [3, 4]; case 2: return [4, this.aXSearchEngin.addTimeTask(e)]; case 3: t = r.sent(), r.label = 4; case 4: return [2, t] } })) })) }, e.prototype.getTimeTaskList = function (e) { return c(this, void 0, Promise, (function () { var t; return l(this, (function (r) { switch (r.label) { case 0: return t = null, this.axMode !== X.WAN_APP ? [3, 2] : [4, this.aXRobotEngin.getTimerTaskList(e)]; case 1: return t = r.sent(), [3, 4]; case 2: return [4, this.aXSearchEngin.getTimeTaskList(e)]; case 3: t = r.sent(), r.label = 4; case 4: return [2, t] } })) })) }, e.prototype.deleteTimeTask = function (e) { return c(this, void 0, Promise, (function () { var t; return l(this, (function (r) { switch (r.label) { case 0: return t = null, this.axMode !== X.WAN_APP ? [3, 2] : [4, this.aXRobotEngin.delTimerTask(e)]; case 1: return t = r.sent(), [3, 4]; case 2: return [4, this.aXSearchEngin.deleteTimeTask(e)]; case 3: t = r.sent(), r.label = 4; case 4: return [2, t] } })) })) }, e.prototype.getPointCloudData = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXSearchEngin.getPointCloudData()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.subscribePointCloudData = function (e) { this.mnPointCloudDataListener = e }, e.prototype.onPointCloudDataChanged = function (e) { this.mnPointCloudDataListener && "function" == typeof this.mnPointCloudDataListener.onPointCloudDataChanged && this.mnPointCloudDataListener.onPointCloudDataChanged(e) }, e.prototype.subscribeChassisStartProgress = function (e) { this.mOnChassisStartProgressListener = e }, e.prototype.onChassisStartProgressChanged = function (e) { this.mOnChassisStartProgressListener && "function" == typeof this.mOnChassisStartProgressListener.onChassisStartProgressChanged && this.mOnChassisStartProgressListener.onChassisStartProgressChanged(e) }, e.prototype.getChassisStartProgress = function () { return this.aXRobotEngin.getChassisStartProgress() }, e.prototype.setSmoothLevel = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.setSmoothLevel(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.setBumpTolerance = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.setBumpTolerance(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.saveRobotSetting = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.saveRobotSetting(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getRobotSetting = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXRobotEngin.getRobotSetting()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.setPlayObstacle = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.setPlayObstacle(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.sendCommand = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.sendCommand(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getRobotFootprint = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXRobotEngin.getRobotFootprint()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.saveRobotFootprint = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.saveRobotFootprint(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.setFootprintDefault = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXRobotEngin.setFootprintDefault()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.getTaskList = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskEngin.getTaskList(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getTaskDetail = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskEngin.getTaskDetail(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.fixIMU = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXRobotEngin.fixIMU()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.getCustomizeTaskList = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXTaskEngin.getCustomizeTaskList()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.saveCustomizeTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskEngin.saveCustomizeTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.delCustomizeTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskEngin.delCustomizeTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getShelvesAreaList = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.getShelvesAreaList(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.clearWheelControlErrors = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.clearWheelControlErrors(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getRobotService = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.getRobotService(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.addQueueTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskQueueEngin.addQueueTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getQueueTaskList = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskQueueEngin.getQueueTaskList(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getQueueTaskDetail = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskQueueEngin.getQueueTaskDetail(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getTaskQueue = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskQueueEngin.getTaskQueue(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getTaskQueueAssigned = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskQueueEngin.getTaskQueueAssigned(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getTaskQueueRobot = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskQueueEngin.getTaskQueueRobot(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getTaskQueueIssued = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskQueueEngin.getTaskQueueIssued(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.setTaskOrder = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXTaskQueueEngin.setTaskOrder(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.pauseQueue = function (e) { return c(this, void 0, Promise, (function () { var t; return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskQueueEngin.pauseQueue(e)]; case 1: return (t = r.sent()) && this.getMode() === X.WAN_APP ? [4, this.aXRobotEngin.pauseChassisQueue(e)] : [3, 3]; case 2: t = r.sent(), r.label = 3; case 3: return [2, t] } })) })) }, e.prototype.continueQueue = function (e) { return c(this, void 0, Promise, (function () { var t; return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskQueueEngin.continueQueue(e)]; case 1: return (t = r.sent()) && this.getMode() === X.WAN_APP ? [4, this.aXRobotEngin.continueChassisQueue(e)] : [3, 3]; case 2: t = r.sent(), r.label = 3; case 3: return [2, t] } })) })) }, e.prototype.setQueueOrder = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskQueueEngin.setQueueOrder(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.deleteQueueTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskQueueEngin.deleteQueueTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getRobotSettingById = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.getRobotSettingById(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.setJackActionToRobot = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXRobotsEngin.setJackActionToRobot(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.saveCustomTask = function (e, t) { return c(this, void 0, Promise, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return r = !1, t ? [4, this.aXCustomTaskEngin.editCustomTask(e, t)] : [3, 2]; case 1: return r = n.sent(), [3, 4]; case 2: return [4, this.aXCustomTaskEngin.createCustomTask(e)]; case 3: r = n.sent(), n.label = 4; case 4: return [2, r] } })) })) }, e.prototype.getCustomTaskInfo = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXCustomTaskEngin.getCustomTaskInfo(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getCustomTaskList = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXCustomTaskEngin.getCustomTaskList(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.deleteCustomTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXCustomTaskEngin.deleteCustomTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.verifyApplication = function () { return c(this, void 0, Promise, (function () { var e; return l(this, (function (t) { switch (t.label) { case 0: return e = !0, this.initParams.isPrivate ? [3, 2] : [4, this.aXAuth.verifyApplication()]; case 1: e = t.sent(), t.label = 2; case 2: return [2, e] } })) })) }, e.prototype.destroyRobotConnect = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXRobotEngin.destroyRobotConnect()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.getDeviceInfo = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.aXRobotEngin.getDeviceInfo()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.setWeightSpeedLimit = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.setWeightSpeedLimit(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getTaskDetailsById = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskEngin.getTaskDetailsById(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.detectRackSize = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.detectRackSize(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getRackSize = function () { return c(this, void 0, Promise, (function () { var e; return l(this, (function (t) { switch (t.label) { case 0: return e = null, this.axMode !== X.WAN_APP ? [3, 2] : [4, this.sendPyCommand("getDetectedRack", {})]; case 1: return e = t.sent(), [3, 4]; case 2: return [4, this.aXRobotEngin.getRackSize()]; case 3: e = t.sent(), t.label = 4; case 4: return [2, e] } })) })) }, e.prototype.setRackSize = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.setRackSize(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.setSerialPortLight = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.setSerialPortLight(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getBatteryLife = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXRobotEngin.getBatteryLife(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.startRollerAction = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.startRollerAction(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.sendPyCommand = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXRobotEngin.sendPyCommand(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.oneKeyPrivateConfig = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXRobotEngin.oneKeyPrivateConfig(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.getCustomSetting = function () { return c(this, void 0, Promise, (function () { var e; return l(this, (function (t) { switch (t.label) { case 0: return e = null, this.axMode !== X.WAN_APP ? [3, 2] : [4, this.sendPyCommand("getCustomSettings", {})]; case 1: return e = t.sent(), [3, 4]; case 2: return [4, this.aXRobotEngin.getCustomSetting()]; case 3: e = t.sent(), t.label = 4; case 4: return [2, e] } })) })) }, e.prototype.getRobotCustomSettings = function (e, t, r, n) { return c(this, void 0, Promise, (function () { return l(this, (function (i) { switch (i.label) { case 0: return this.mOnRobotSettingsListener = r, [4, this.aXRobotEngin.getRobotCustomSettings(e, t, n)]; case 1: return [2, i.sent()] } })) })) }, e.prototype.getRobotCustomSettingsInBus = function (e, t, r, n) { return c(this, void 0, Promise, (function () { return l(this, (function (i) { switch (i.label) { case 0: return r && (this.mOnRobotSettingsListener = r), [4, this.aXRobotsEngin.getRobotCustomSettingsInBus(e, t, n)]; case 1: return [2, i.sent()] } })) })) }, e.prototype.getBindEdgeIntelligence = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXSearchEngin.getBindEdgeIntelligence(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.subscribeEdgeAiState = function (e, t) { this.mOnEdgeAiListener = e, this.aXSearchEngin.startEdgeAiWebSocket(t) }, e.prototype.stopSubscribeEdgeAiState = function () { this.aXSearchEngin.stopEdgeAiWebSocket() }, e.prototype.getTokenByOpenId = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXAuth.getTokenByOpenId(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.addTaskSimple = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskEngin.addTaskSimple(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getTaskSimpleTemplate = function (e, t) { return c(this, void 0, Promise, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXSearchEngin.searchPoiById(e, t)]; case 1: return r = n.sent(), [4, this.aXTaskEngin.getTaskSimpleTemplate(r)]; case 2: return [2, n.sent()] } })) })) }, e.prototype.getTaskComplexTemplate = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { return [2, this.aXTaskEngin.getTaskComplexTemplate(e, t, r)] })) })) }, e.prototype.getTaskAreaTemplate = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { return [2, this.aXTaskEngin.getTaskAreaTemplate(e, t, r)] })) })) }, e.prototype.requestMapService = function (e, t, r, n) { return c(this, void 0, Promise, (function () { return l(this, (function (i) { switch (i.label) { case 0: return [4, this.aXRobotEngin.requestMapService(e, t, r, n)]; case 1: return [2, i.sent()] } })) })) }, e.prototype.requestTaskScheduling = function (e, t, r, n) { return c(this, void 0, Promise, (function () { return l(this, (function (i) { switch (i.label) { case 0: return [4, this.aXRobotEngin.requestTaskScheduling(e, t, r, n)]; case 1: return [2, i.sent()] } })) })) }, e.prototype.setRCSActive = function (e, t, r, n) { return c(this, void 0, Promise, (function () { return l(this, (function (i) { switch (i.label) { case 0: return [4, this.aXRobotEngin.setRCSActive(e, t, r, n)]; case 1: return [2, i.sent()] } })) })) }, e.prototype.getRCSPathList = function (e, t, r, n) { return c(this, void 0, Promise, (function () { return l(this, (function (i) { switch (i.label) { case 0: return [4, this.aXRobotEngin.getRCSPathList(e, t, r, n)]; case 1: return [2, i.sent()] } })) })) }, e.prototype.addRCSAreaTask = function (e, t, r, n) { return c(this, void 0, Promise, (function () { return l(this, (function (i) { switch (i.label) { case 0: return [4, this.aXTaskEngin.addRCSAreaTask(e, t, r, n)]; case 1: return [2, i.sent()] } })) })) }, e.prototype.addTimerTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.addTimerTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.delTimerTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.delTimerTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.editTimerTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.editTimerTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getTimerTaskList = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.getTimerTaskList(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.cancelChassisAllQueueTasks = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.cancelChassisAllQueueTasks(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.cancelCloudAllQueueTasks = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskQueueEngin.cancelCloudAllQueueTasks(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.callBackRobot = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { return console.log(e), [2] })) })) }, e.prototype.checkMapIsExit = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axMap.checkMapIsExit(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getGroupList = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskEngin.getGroupList(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.addGroup = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskEngin.addGroup(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.editGroup = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXTaskEngin.editGroup(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.delGroup = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskEngin.delGroup(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getGroupDetail = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskEngin.getGroupDetail(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getGroupTaskList = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskEngin.getGroupTaskList(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.addGroupTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskEngin.addGroupTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.editGroupTask = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXTaskEngin.editGroupTask(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.delGroupTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskEngin.delGroupTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getGroupTaskDetail = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXTaskEngin.getGroupTaskDetail(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getChassisTaskQueueRobot = function (e, t, r) { return c(this, void 0, void 0, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXRobotEngin.getChassisTaskQueueRobot(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.setChassisQueueOrder = function (e, t, r) { return c(this, void 0, void 0, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXRobotEngin.setChassisQueueOrder(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.deleteChassisQueueTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.deleteChassisQueueTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.cancelChassisQueueTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.aXRobotEngin.cancelChassisQueueTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.cancelRobotQueueTask = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.aXRobotsEngin.cancelRobotQueueTask(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.createDB = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return this.indexedDB = new Ie, [4, this.indexedDB.createDB(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.addDBData = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.indexedDB.addData(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.updateDBData = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.indexedDB.updateData(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.deleteDBData = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.indexedDB.deleteData(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getDBData = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.indexedDB.getData(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getAllDBData = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.indexedDB.getAllData(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getRobotLanguageList = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { return [2, he] })) })) }, e.prototype.getOverviewStatis = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXOutlineStatisEngin.getOverviewStatis(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.offlineGetTasksStatis = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXOutlineStatisEngin.getTasksStatis(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getHourlyRobotStatis = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXOutlineStatisEngin.getHourlyRobotStatis(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getHourlyTasksStatis = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXOutlineStatisEngin.getHourlyTasksStatis(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getTaskCountByDayStatis = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXOutlineStatisEngin.getTaskCountByDayStatis(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.cruiseRouteSort = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXSearchEngin.cruiseRouteSort(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getIsTokenParamsInit = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { return [2, this.isTokenParamsInit] })) })) }, e.prototype.cancelTaskV3 = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.aXTaskEngin.cancelTaskV3(e)]; case 1: return [2, t.sent()] } })) })) }, e }(), Ye = function () { function e(e, t, r, n, i, o) { "object" == typeof e ? (e.server && (ke.server = e.server || ke.server, ke.baseHeader.Authorization = "dev" === ke.server ? "APPCODE 9f7297c52bbd42f082331ed620d50653" : "APPCODE 667a51a4d948433081a272c78d10a8a4"), this.axDispatch = new Ke(e.appId, e.secret, e.mode, e.serverUrl, e.wsUrl, e.appCode, e)) : this.axDispatch = new Ke(e, t, r, n, i, o) } return e.prototype.init = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.axDispatch.init()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.connectRobot = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.connectRobot(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.destroy = function () { this.axDispatch.destroy() }, e.prototype.robotListSubDestroy = function () { this.axDispatch.robotListSubDestroy() }, e.prototype.beginControl = function () { this.axDispatch.beginControl() }, e.prototype.endControl = function () { this.axDispatch.endControl() }, e.prototype.motionFor = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.motionFor(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.setEmergency = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.setEmergency(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.motionControl = function (e, t) { this.axDispatch.motionControl(e, t) }, e.prototype.moveTo = function (e, t) { this.axDispatch.moveTo(e, t) }, e.prototype.resetPose = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.resetPose(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.resetMap = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.resetMap(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.updateMap = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.updateMap(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.updateMapUpgrade = function (e, t) { return c(this, void 0, void 0, (function () { return l(this, (function (r) { return this.axDispatch.updateMapUpgrade(e, t), [2] })) })) }, e.prototype.goHome = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.goHome(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.openSprayer = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.openSprayer(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.closeSprayer = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.closeSprayer(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.openBoxDoor = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.openBoxDoor(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.closeBoxDoor = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.closeBoxDoor(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.openLightBelt = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.openLightBelt(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.closeLightBelt = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.closeLightBelt(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.setVolume = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.setVolume(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.setSpeed = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.setSpeed(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.fixIMU = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.axDispatch.fixIMU()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.getToken = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getToken(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getVersion = function () { return this.axDispatch.getSdkVersion() }, e.prototype.getRobotList = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.getRobotList(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getPlaceList = function () { return this.axDispatch.getPlaceList() }, e.prototype.getPoiList = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getPoiList(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getPoiById = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getPoiById(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getRobotOwnCharges = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getRobotOwnCharges(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getAreaList = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.axDispatch.getAreaList()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.getAreaById = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getAreaById(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getEffectiveAreaList = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getEffectiveAreaList(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getAreaPic = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getAreaPic(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getState = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { return [2, this.axDispatch.getState(e)] })) })) }, e.prototype.subscribeRealState = function (e) { this.axDispatch.subscribeRealState(e) }, e.prototype.subscribeTaskState = function (e) { this.axDispatch.subscribeTaskState(e) }, e.prototype.setEnableTrack = function (e) { this.axDispatch.setEnableTrack(e) }, e.prototype.createTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.createTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.executeTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.executeTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.startTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.startTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.pauseTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.pauseTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.resumeTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.resumeTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.continueTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.continueTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.cancelTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.cancelTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.cancelElevatorTask = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.axDispatch.cancelElevatorTask()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.getCurrentTask = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { return [2, this.axDispatch.getCurrentTask()] })) })) }, e.prototype.updateTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.updateTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.restartTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.restartTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getRobotId = function () { return this.axDispatch.getRobotId() }, e.prototype.isRobotEstimate = function () { return this.axDispatch.isRobotEstimate() }, e.prototype.createMap = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.createMap(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.stopPlayAudio = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.stopPlayAudio(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.setLanguage = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.setLanguage(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getBusinessId = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getBusinessId(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.removeWheelOverload = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.removeWheelOverload(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.exportOpreationLogger = function (e, t, r, n, i, o, s) { return c(this, void 0, Promise, (function () { return l(this, (function (a) { switch (a.label) { case 0: return [4, this.axDispatch.exportOperationLogger(e, t, r, n, i, o, s)]; case 1: return [2, a.sent()] } })) })) }, e.prototype.setWifi = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.setWifi(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.switchAutoCharge = function (e) { return void 0 === e && (e = !0), c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.switchAutoCharge(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.restartRobot = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.restartRobot(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.setGlobalPosition = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.setGlobalPosition(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.saveCruise = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.saveCruise(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getCruises = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getCruises(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.deleteCruise = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.deleteCruise(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.syncCruiseCloud = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.syncCruiseCloud(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.syncCruiseLocal = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.axDispatch.syncCruiseLocal()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.setServerInfo = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.setServerInfo(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.setServerInfos = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.setServerInfos(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.setPlayAudio = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.setPlayAudio(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.setRouteMode = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.setRouteMode(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.subscribeSerialData = function (e) { this.axDispatch.subscribeSerialData(e) }, e.prototype.getRouteMode = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.axDispatch.getRouteMode()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.subscribeDownloadMapState = function (e) { this.axDispatch.subscribeDownloadMapState(e) }, e.prototype.getStatisticsTotal = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getStatisticsTotal(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getSingleTaskStatistics = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getSingleTaskStatistics(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getTaskStatistics = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getTaskStatistics(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.clearSystemDownAlert = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.clearSystemDownAlert(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getRouteInfo = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.axDispatch.getRouteInfo()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.subscribeLaserData = function (e) { this.axDispatch.subscribeLaserData(e) }, e.prototype.sendLaserData = function (e) { this.axDispatch.sendLaserData(e) }, e.prototype.enableAndroidLog = function (e) { this.axDispatch.enableAndroidLog(e) }, e.prototype.getAreaCompareList = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.axDispatch.getAreaCompareList()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.sendSyncMapData = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.sendSyncMapData(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.shutdownRobot = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.shutdownRobot(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.recordBag = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.recordBag(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getAreaFeatures = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getAreaFeatures(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.setJackAction = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.setJackAction(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getAreaThumbnail = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getAreaThumbnail(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getAreaMediumThumbnail = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getAreaMediumThumbnail(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.addTimeTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.addTimeTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getTimeTaskList = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getTimeTaskList(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.deleteTimeTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.deleteTimeTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getPointCloudData = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.axDispatch.getPointCloudData()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.subscribeChassisStartProgress = function (e) { this.axDispatch.subscribeChassisStartProgress(e) }, e.prototype.getChassisStartProgress = function () { return this.axDispatch.getChassisStartProgress() }, e.prototype.setSmoothLevel = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.setSmoothLevel(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.setBumpTolerance = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.setBumpTolerance(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.saveRobotSetting = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.saveRobotSetting(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getRobotSetting = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.axDispatch.getRobotSetting()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.getRobotService = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getRobotService(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.setPlayObstacle = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.setPlayObstacle(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.sendCommand = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.sendCommand(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getRobotFootprint = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.axDispatch.getRobotFootprint()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.saveRobotFootprint = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.saveRobotFootprint(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.setFootprintDefault = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.axDispatch.setFootprintDefault()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.getCustomizeTaskList = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.axDispatch.getCustomizeTaskList()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.saveCustomizeTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.saveCustomizeTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.delCustomizeTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.delCustomizeTask(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getShelvesAreaList = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getShelvesAreaList(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.clearWheelControlErrors = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.clearWheelControlErrors(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getDeviceInfo = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.axDispatch.getDeviceInfo()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.setWeightSpeedLimit = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.setWeightSpeedLimit(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getTaskDetailsById = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getTaskDetailsById(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.detectRackSize = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.detectRackSize(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getRackSize = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.axDispatch.getRackSize()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.setRackSize = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.setRackSize(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.setSerialPortLight = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.setSerialPortLight(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.getBatteryLife = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getBatteryLife(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.startRollerAction = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.startRollerAction(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.sendPyCommand = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.sendPyCommand(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.oneKeyPrivateConfig = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.oneKeyPrivateConfig(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.getCustomSetting = function () { return c(this, void 0, void 0, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.axDispatch.getCustomSetting()]; case 1: return [2, e.sent()] } })) })) }, e.prototype.getRobotCustomSettings = function (e, t, r, n) { return c(this, void 0, Promise, (function () { return l(this, (function (i) { switch (i.label) { case 0: return [4, this.axDispatch.getRobotCustomSettings(e, t, r, n)]; case 1: return [2, i.sent()] } })) })) }, e.prototype.getTokenByOpenId = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getTokenByOpenId(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.addTaskSimple = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.addTaskSimple(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getTaskSimpleTemplate = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.getTaskSimpleTemplate(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getTaskComplexTemplate = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.getTaskComplexTemplate(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.getTaskAreaTemplate = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.getTaskAreaTemplate(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.requestMapService = function (e, t, r, n) { return c(this, void 0, Promise, (function () { return l(this, (function (i) { switch (i.label) { case 0: return [4, this.axDispatch.requestMapService(e, t, r, n)]; case 1: return [2, i.sent()] } })) })) }, e.prototype.requestTaskScheduling = function (e, t, r, n) { return c(this, void 0, Promise, (function () { return l(this, (function (i) { switch (i.label) { case 0: return [4, this.axDispatch.requestTaskScheduling(e, t, r, n)]; case 1: return [2, i.sent()] } })) })) }, e.prototype.setRCSActive = function (e, t, r, n) { return c(this, void 0, Promise, (function () { return l(this, (function (i) { switch (i.label) { case 0: return [4, this.axDispatch.setRCSActive(e, t, r, n)]; case 1: return [2, i.sent()] } })) })) }, e.prototype.getRCSPathList = function (e, t, r, n) { return c(this, void 0, Promise, (function () { return l(this, (function (i) { switch (i.label) { case 0: return [4, this.axDispatch.getRCSPathList(e, t, r, n)]; case 1: return [2, i.sent()] } })) })) }, e.prototype.addRCSAreaTask = function (e, t, r, n) { return c(this, void 0, Promise, (function () { return l(this, (function (i) { switch (i.label) { case 0: return [4, this.axDispatch.addRCSAreaTask(e, t, r, n)]; case 1: return [2, i.sent()] } })) })) }, e.prototype.addTimerTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.addTimerTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.delTimerTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.delTimerTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.editTimerTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.editTimerTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getTimerTaskList = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.getTimerTaskList(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.cancelChassisAllQueueTasks = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.cancelChassisAllQueueTasks(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.cancelCloudAllQueueTasks = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.cancelCloudAllQueueTasks(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.getChassisTaskQueueRobot = function (e, t, r) { return c(this, void 0, void 0, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.getChassisTaskQueueRobot(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.getChassisTaskQueueRobotOutLine = function (e, t, r) { return c(this, void 0, void 0, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.getChassisTaskQueueRobot(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.setChassisQueueOrder = function (e, t, r) { return c(this, void 0, void 0, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.setChassisQueueOrder(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, e.prototype.deleteChassisQueueTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.deleteChassisQueueTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.cancelChassisQueueTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.cancelChassisQueueTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.checkMapIsExit = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.checkMapIsExit(e, t)]; case 1: return [2, r.sent()] } })) })) }, e.prototype.offlineGetOverviewStatis = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getOverviewStatis(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.offlineGetTasksStatis = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.offlineGetTasksStatis(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.offlineGetHourlyRobotStatis = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getHourlyRobotStatis(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.offlineGetHourlyTasksStatis = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getHourlyTasksStatis(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.offlineGetTaskCountByDayStatis = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getTaskCountByDayStatis(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.cancelTaskV3 = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.cancelTaskV3(e)]; case 1: return [2, t.sent()] } })) })) }, e.prototype.cruiseRouteSort = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.cruiseRouteSort(e)]; case 1: return [2, t.sent()] } })) })) }, e }(), et = function (e) { function t(t) { var r = e.call(this, t, "", t.mode, "", "", "") || this; return r.axDispatchManage = r.axDispatch, r } return function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function r() { this.constructor = e } s(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r) }(t, e), t.prototype.getTaskList = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatchManage.getTaskList(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.getTaskDetail = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatchManage.getTaskDetail(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.getBusinessList = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return [4, this.axDispatchManage.getBusinessList()]; case 1: return [2, e.sent()] } })) })) }, t.prototype.getAreaListByBus = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatchManage.getAreaListByBus(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.connectBusiness = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatchManage.connectBusiness(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.subscribeRobotsStateByBus = function (e) { this.axDispatchManage.subscribeRobotsStateByBus(e) }, t.prototype.pauseTaskToRobot = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatchManage.pauseTaskToRobot(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.resumeTaskToRobot = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatchManage.resumeTaskToRobot(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.continueTaskToRobot = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatchManage.continueTaskToRobot(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.motionForToRobot = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatchManage.motionForToRobot(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, t.prototype.getPoiListExtend = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatchManage.getPoiListExtend(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.addQueueTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatchManage.addQueueTask(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.getQueueTaskList = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatchManage.getQueueTaskList(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.getQueueTaskDetail = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatchManage.getQueueTaskDetail(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.getTaskQueue = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatchManage.getTaskQueue(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.getTaskQueueAssigned = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatchManage.getTaskQueueAssigned(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.getTaskQueueRobot = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatchManage.getTaskQueueRobot(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.getTaskQueueIssued = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatchManage.getTaskQueueIssued(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.setTaskOrder = function (e, t, r) { return void 0 === r && (r = !1), c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatchManage.setTaskOrder(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, t.prototype.pauseQueue = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatchManage.pauseQueue(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.continueQueue = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatchManage.continueQueue(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.setQueueOrder = function (e, t) { return c(this, void 0, Promise, (function () { var r; return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatchManage.setQueueOrder(e, t)]; case 1: return (r = n.sent()) && this.continueQueue(e), [2, r] } })) })) }, t.prototype.deleteQueueTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatchManage.deleteQueueTask(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.getRobotSettingById = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatchManage.getRobotSettingById(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.setJackActionToRobot = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.setJackActionToRobot(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, t.prototype.saveCustomTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatchManage.saveCustomTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.getCustomTaskInfo = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatchManage.getCustomTaskInfo(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.getCustomTaskList = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatchManage.getCustomTaskList(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.deleteCustomTask = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatchManage.deleteCustomTask(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.getRobotCustomSettingsInBus = function (e, t, r, n) { return c(this, void 0, Promise, (function () { return l(this, (function (i) { switch (i.label) { case 0: return [4, this.axDispatch.getRobotCustomSettingsInBus(e, t, r, n)]; case 1: return [2, i.sent()] } })) })) }, t.prototype.destroyConnect = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { switch (e.label) { case 0: return this.axDispatch.destroy(), [4, this.axDispatchManage.destroyRobotConnect()]; case 1: return [2, e.sent()] } })) })) }, t.prototype.getBindEdgeIntelligence = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatchManage.getBindEdgeIntelligence(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.subscribeEdgeAiState = function (e, t) { this.axDispatch.subscribeEdgeAiState(e, t) }, t.prototype.stopSubscribeEdgeAiState = function () { this.axDispatch.stopSubscribeEdgeAiState() }, t.prototype.updateMapByRobotId = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.updateMapByRobotId(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, t.prototype.getGroupList = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.getGroupList(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.addGroup = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.addGroup(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.editGroup = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.editGroup(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, t.prototype.delGroup = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.delGroup(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.getGroupDetail = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.getGroupDetail(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.getGroupTaskList = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.getGroupTaskList(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.addGroupTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.addGroupTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.editGroupTask = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.editGroupTask(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, t.prototype.delGroupTask = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.delGroupTask(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.getGroupTaskDetail = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.getGroupTaskDetail(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.cancelRobotQueueTask = function (e, t, r) { return c(this, void 0, Promise, (function () { return l(this, (function (n) { switch (n.label) { case 0: return [4, this.axDispatch.cancelRobotQueueTask(e, t, r)]; case 1: return [2, n.sent()] } })) })) }, t.prototype.conncetDB = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.createDB(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.addDBData = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.addDBData(e, t)]; case 1: return r.sent(), [2] } })) })) }, t.prototype.updateDBData = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.updateDBData(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.deleteDBData = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.deleteDBData(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.getDBData = function (e, t) { return c(this, void 0, Promise, (function () { return l(this, (function (r) { switch (r.label) { case 0: return [4, this.axDispatch.getDBData(e, t)]; case 1: return [2, r.sent()] } })) })) }, t.prototype.getAllDBData = function (e) { return c(this, void 0, Promise, (function () { return l(this, (function (t) { switch (t.label) { case 0: return [4, this.axDispatch.getAllDBData(e)]; case 1: return [2, t.sent()] } })) })) }, t.prototype.getRobotLanguageList = function () { return c(this, void 0, Promise, (function () { return l(this, (function (e) { return [2, this.axDispatch.getRobotLanguageList()] })) })) }, t }(Ye); if ("undefined" != typeof window) { var tt = window; tt.AXRobot = Ye, tt.AppMode = X, tt.MotionType = q, tt.ActionType = ae, tt.EmergencyType = j, tt.LightColor = ce, tt.ChassisErrors = le, tt.AXRobotManage = et } e.AXRobot = Ye, e.AXRobotManage = et, e.ActionType = ae, e.AppMode = X, e.ChassisErrors = le, e.EmergencyType = j, e.LightColor = ce, e.MotionType = q, Object.defineProperty(e, "__esModule", { value: !0 }) }(i.exports, r()) } } }));
